// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DesignObjects.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_DesignObjects_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_DesignObjects_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommonTypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_DesignObjects_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_DesignObjects_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_DesignObjects_2eproto;
namespace DesignObjects {
class DesignObjectClass;
struct DesignObjectClassDefaultTypeInternal;
extern DesignObjectClassDefaultTypeInternal _DesignObjectClass_default_instance_;
class DesignObjectSyn;
struct DesignObjectSynDefaultTypeInternal;
extern DesignObjectSynDefaultTypeInternal _DesignObjectSyn_default_instance_;
class InstanceClass;
struct InstanceClassDefaultTypeInternal;
extern InstanceClassDefaultTypeInternal _InstanceClass_default_instance_;
class NetClass;
struct NetClassDefaultTypeInternal;
extern NetClassDefaultTypeInternal _NetClass_default_instance_;
class NetListClass;
struct NetListClassDefaultTypeInternal;
extern NetListClassDefaultTypeInternal _NetListClass_default_instance_;
class PinBusClass;
struct PinBusClassDefaultTypeInternal;
extern PinBusClassDefaultTypeInternal _PinBusClass_default_instance_;
class PinClass;
struct PinClassDefaultTypeInternal;
extern PinClassDefaultTypeInternal _PinClass_default_instance_;
class PortBusClass;
struct PortBusClassDefaultTypeInternal;
extern PortBusClassDefaultTypeInternal _PortBusClass_default_instance_;
class PortClass;
struct PortClassDefaultTypeInternal;
extern PortClassDefaultTypeInternal _PortClass_default_instance_;
class PortDirEnum;
struct PortDirEnumDefaultTypeInternal;
extern PortDirEnumDefaultTypeInternal _PortDirEnum_default_instance_;
}  // namespace DesignObjects
PROTOBUF_NAMESPACE_OPEN
template<> ::DesignObjects::DesignObjectClass* Arena::CreateMaybeMessage<::DesignObjects::DesignObjectClass>(Arena*);
template<> ::DesignObjects::DesignObjectSyn* Arena::CreateMaybeMessage<::DesignObjects::DesignObjectSyn>(Arena*);
template<> ::DesignObjects::InstanceClass* Arena::CreateMaybeMessage<::DesignObjects::InstanceClass>(Arena*);
template<> ::DesignObjects::NetClass* Arena::CreateMaybeMessage<::DesignObjects::NetClass>(Arena*);
template<> ::DesignObjects::NetListClass* Arena::CreateMaybeMessage<::DesignObjects::NetListClass>(Arena*);
template<> ::DesignObjects::PinBusClass* Arena::CreateMaybeMessage<::DesignObjects::PinBusClass>(Arena*);
template<> ::DesignObjects::PinClass* Arena::CreateMaybeMessage<::DesignObjects::PinClass>(Arena*);
template<> ::DesignObjects::PortBusClass* Arena::CreateMaybeMessage<::DesignObjects::PortBusClass>(Arena*);
template<> ::DesignObjects::PortClass* Arena::CreateMaybeMessage<::DesignObjects::PortClass>(Arena*);
template<> ::DesignObjects::PortDirEnum* Arena::CreateMaybeMessage<::DesignObjects::PortDirEnum>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace DesignObjects {

enum PortDirEnum_PortDir : int {
  PortDirEnum_PortDir_kIn = 0,
  PortDirEnum_PortDir_kOut = 1,
  PortDirEnum_PortDir_kInOut = 2,
  PortDirEnum_PortDir_kOther = 3
};
bool PortDirEnum_PortDir_IsValid(int value);
constexpr PortDirEnum_PortDir PortDirEnum_PortDir_PortDir_MIN = PortDirEnum_PortDir_kIn;
constexpr PortDirEnum_PortDir PortDirEnum_PortDir_PortDir_MAX = PortDirEnum_PortDir_kOther;
constexpr int PortDirEnum_PortDir_PortDir_ARRAYSIZE = PortDirEnum_PortDir_PortDir_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortDirEnum_PortDir_descriptor();
template<typename T>
inline const std::string& PortDirEnum_PortDir_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortDirEnum_PortDir>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortDirEnum_PortDir_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortDirEnum_PortDir_descriptor(), enum_t_value);
}
inline bool PortDirEnum_PortDir_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortDirEnum_PortDir* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortDirEnum_PortDir>(
    PortDirEnum_PortDir_descriptor(), name, value);
}
// ===================================================================

class DesignObjectClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.DesignObjectClass) */ {
 public:
  inline DesignObjectClass() : DesignObjectClass(nullptr) {}
  ~DesignObjectClass() override;
  explicit PROTOBUF_CONSTEXPR DesignObjectClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesignObjectClass(const DesignObjectClass& from);
  DesignObjectClass(DesignObjectClass&& from) noexcept
    : DesignObjectClass() {
    *this = ::std::move(from);
  }

  inline DesignObjectClass& operator=(const DesignObjectClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesignObjectClass& operator=(DesignObjectClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DesignObjectClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const DesignObjectClass* internal_default_instance() {
    return reinterpret_cast<const DesignObjectClass*>(
               &_DesignObjectClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DesignObjectClass& a, DesignObjectClass& b) {
    a.Swap(&b);
  }
  inline void Swap(DesignObjectClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesignObjectClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesignObjectClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesignObjectClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DesignObjectClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DesignObjectClass& from) {
    DesignObjectClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DesignObjectClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.DesignObjectClass";
  }
  protected:
  explicit DesignObjectClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string _name = 1;
  bool has__name() const;
  private:
  bool _internal_has__name() const;
  public:
  void clear__name();
  const std::string& _name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__name();
  PROTOBUF_NODISCARD std::string* release__name();
  void set_allocated__name(std::string* _name);
  private:
  const std::string& _internal__name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__name(const std::string& value);
  std::string* _internal_mutable__name();
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.DesignObjectClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class NetClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.NetClass) */ {
 public:
  inline NetClass() : NetClass(nullptr) {}
  ~NetClass() override;
  explicit PROTOBUF_CONSTEXPR NetClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetClass(const NetClass& from);
  NetClass(NetClass&& from) noexcept
    : NetClass() {
    *this = ::std::move(from);
  }

  inline NetClass& operator=(const NetClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetClass& operator=(NetClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetClass* internal_default_instance() {
    return reinterpret_cast<const NetClass*>(
               &_NetClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NetClass& a, NetClass& b) {
    a.Swap(&b);
  }
  inline void Swap(NetClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetClass& from) {
    NetClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.NetClass";
  }
  protected:
  explicit NetClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPinPortsFieldNumber = 2,
    kIsClockNetFieldNumber = 1,
  };
  // repeated uint64 _pin_ports = 2;
  int _pin_ports_size() const;
  private:
  int _internal__pin_ports_size() const;
  public:
  void clear__pin_ports();
  private:
  uint64_t _internal__pin_ports(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__pin_ports() const;
  void _internal_add__pin_ports(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__pin_ports();
  public:
  uint64_t _pin_ports(int index) const;
  void set__pin_ports(int index, uint64_t value);
  void add__pin_ports(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _pin_ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__pin_ports();

  // required bool _is_clock_net = 1;
  bool has__is_clock_net() const;
  private:
  bool _internal_has__is_clock_net() const;
  public:
  void clear__is_clock_net();
  bool _is_clock_net() const;
  void set__is_clock_net(bool value);
  private:
  bool _internal__is_clock_net() const;
  void _internal_set__is_clock_net(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.NetClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _pin_ports_;
    bool _is_clock_net_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class PinBusClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.PinBusClass) */ {
 public:
  inline PinBusClass() : PinBusClass(nullptr) {}
  ~PinBusClass() override;
  explicit PROTOBUF_CONSTEXPR PinBusClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PinBusClass(const PinBusClass& from);
  PinBusClass(PinBusClass&& from) noexcept
    : PinBusClass() {
    *this = ::std::move(from);
  }

  inline PinBusClass& operator=(const PinBusClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline PinBusClass& operator=(PinBusClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PinBusClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const PinBusClass* internal_default_instance() {
    return reinterpret_cast<const PinBusClass*>(
               &_PinBusClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PinBusClass& a, PinBusClass& b) {
    a.Swap(&b);
  }
  inline void Swap(PinBusClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PinBusClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PinBusClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PinBusClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PinBusClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PinBusClass& from) {
    PinBusClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PinBusClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.PinBusClass";
  }
  protected:
  explicit PinBusClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPinsFieldNumber = 3,
    kIndexesFieldNumber = 4,
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kSizeFieldNumber = 5,
  };
  // repeated uint64 _pins = 3;
  int _pins_size() const;
  private:
  int _internal__pins_size() const;
  public:
  void clear__pins();
  private:
  uint64_t _internal__pins(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__pins() const;
  void _internal_add__pins(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__pins();
  public:
  uint64_t _pins(int index) const;
  void set__pins(int index, uint64_t value);
  void add__pins(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _pins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__pins();

  // repeated uint32 indexes = 4;
  int indexes_size() const;
  private:
  int _internal_indexes_size() const;
  public:
  void clear_indexes();
  private:
  uint32_t _internal_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_indexes() const;
  void _internal_add_indexes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_indexes();
  public:
  uint32_t indexes(int index) const;
  void set_indexes(int index, uint32_t value);
  void add_indexes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_indexes();

  // required uint32 _left = 1;
  bool has__left() const;
  private:
  bool _internal_has__left() const;
  public:
  void clear__left();
  uint32_t _left() const;
  void set__left(uint32_t value);
  private:
  uint32_t _internal__left() const;
  void _internal_set__left(uint32_t value);
  public:

  // required uint32 _right = 2;
  bool has__right() const;
  private:
  bool _internal_has__right() const;
  public:
  void clear__right();
  uint32_t _right() const;
  void set__right(uint32_t value);
  private:
  uint32_t _internal__right() const;
  void _internal_set__right(uint32_t value);
  public:

  // required uint32 _size = 5;
  bool has__size() const;
  private:
  bool _internal_has__size() const;
  public:
  void clear__size();
  uint32_t _size() const;
  void set__size(uint32_t value);
  private:
  uint32_t _internal__size() const;
  void _internal_set__size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.PinBusClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _pins_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > indexes_;
    uint32_t _left_;
    uint32_t _right_;
    uint32_t _size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class PinClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.PinClass) */ {
 public:
  inline PinClass() : PinClass(nullptr) {}
  ~PinClass() override;
  explicit PROTOBUF_CONSTEXPR PinClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PinClass(const PinClass& from);
  PinClass(PinClass&& from) noexcept
    : PinClass() {
    *this = ::std::move(from);
  }

  inline PinClass& operator=(const PinClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline PinClass& operator=(PinClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PinClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const PinClass* internal_default_instance() {
    return reinterpret_cast<const PinClass*>(
               &_PinClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PinClass& a, PinClass& b) {
    a.Swap(&b);
  }
  inline void Swap(PinClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PinClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PinClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PinClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PinClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PinClass& from) {
    PinClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PinClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.PinClass";
  }
  protected:
  explicit PinClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
    kCellPortFieldNumber = 2,
    kOwnInstanceFieldNumber = 3,
    kPinBusFieldNumber = 4,
  };
  // required uint64 _net = 1;
  bool has__net() const;
  private:
  bool _internal_has__net() const;
  public:
  void clear__net();
  uint64_t _net() const;
  void set__net(uint64_t value);
  private:
  uint64_t _internal__net() const;
  void _internal_set__net(uint64_t value);
  public:

  // required uint64 _cell_port = 2;
  bool has__cell_port() const;
  private:
  bool _internal_has__cell_port() const;
  public:
  void clear__cell_port();
  uint64_t _cell_port() const;
  void set__cell_port(uint64_t value);
  private:
  uint64_t _internal__cell_port() const;
  void _internal_set__cell_port(uint64_t value);
  public:

  // required uint64 _own_instance = 3;
  bool has__own_instance() const;
  private:
  bool _internal_has__own_instance() const;
  public:
  void clear__own_instance();
  uint64_t _own_instance() const;
  void set__own_instance(uint64_t value);
  private:
  uint64_t _internal__own_instance() const;
  void _internal_set__own_instance(uint64_t value);
  public:

  // required uint64 _pin_bus = 4;
  bool has__pin_bus() const;
  private:
  bool _internal_has__pin_bus() const;
  public:
  void clear__pin_bus();
  uint64_t _pin_bus() const;
  void set__pin_bus(uint64_t value);
  private:
  uint64_t _internal__pin_bus() const;
  void _internal_set__pin_bus(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.PinClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t _net_;
    uint64_t _cell_port_;
    uint64_t _own_instance_;
    uint64_t _pin_bus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class PortDirEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.PortDirEnum) */ {
 public:
  inline PortDirEnum() : PortDirEnum(nullptr) {}
  ~PortDirEnum() override;
  explicit PROTOBUF_CONSTEXPR PortDirEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortDirEnum(const PortDirEnum& from);
  PortDirEnum(PortDirEnum&& from) noexcept
    : PortDirEnum() {
    *this = ::std::move(from);
  }

  inline PortDirEnum& operator=(const PortDirEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortDirEnum& operator=(PortDirEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortDirEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortDirEnum* internal_default_instance() {
    return reinterpret_cast<const PortDirEnum*>(
               &_PortDirEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PortDirEnum& a, PortDirEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(PortDirEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortDirEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortDirEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortDirEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortDirEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortDirEnum& from) {
    PortDirEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortDirEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.PortDirEnum";
  }
  protected:
  explicit PortDirEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PortDirEnum_PortDir PortDir;
  static constexpr PortDir kIn =
    PortDirEnum_PortDir_kIn;
  static constexpr PortDir kOut =
    PortDirEnum_PortDir_kOut;
  static constexpr PortDir kInOut =
    PortDirEnum_PortDir_kInOut;
  static constexpr PortDir kOther =
    PortDirEnum_PortDir_kOther;
  static inline bool PortDir_IsValid(int value) {
    return PortDirEnum_PortDir_IsValid(value);
  }
  static constexpr PortDir PortDir_MIN =
    PortDirEnum_PortDir_PortDir_MIN;
  static constexpr PortDir PortDir_MAX =
    PortDirEnum_PortDir_PortDir_MAX;
  static constexpr int PortDir_ARRAYSIZE =
    PortDirEnum_PortDir_PortDir_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PortDir_descriptor() {
    return PortDirEnum_PortDir_descriptor();
  }
  template<typename T>
  static inline const std::string& PortDir_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PortDir>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PortDir_Name.");
    return PortDirEnum_PortDir_Name(enum_t_value);
  }
  static inline bool PortDir_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PortDir* value) {
    return PortDirEnum_PortDir_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPdFieldNumber = 1,
  };
  // required .DesignObjects.PortDirEnum.PortDir pd = 1;
  bool has_pd() const;
  private:
  bool _internal_has_pd() const;
  public:
  void clear_pd();
  ::DesignObjects::PortDirEnum_PortDir pd() const;
  void set_pd(::DesignObjects::PortDirEnum_PortDir value);
  private:
  ::DesignObjects::PortDirEnum_PortDir _internal_pd() const;
  void _internal_set_pd(::DesignObjects::PortDirEnum_PortDir value);
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.PortDirEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int pd_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class PortClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.PortClass) */ {
 public:
  inline PortClass() : PortClass(nullptr) {}
  ~PortClass() override;
  explicit PROTOBUF_CONSTEXPR PortClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortClass(const PortClass& from);
  PortClass(PortClass&& from) noexcept
    : PortClass() {
    *this = ::std::move(from);
  }

  inline PortClass& operator=(const PortClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortClass& operator=(PortClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortClass* internal_default_instance() {
    return reinterpret_cast<const PortClass*>(
               &_PortClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PortClass& a, PortClass& b) {
    a.Swap(&b);
  }
  inline void Swap(PortClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortClass& from) {
    PortClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.PortClass";
  }
  protected:
  explicit PortClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapsFieldNumber = 1,
    kPortDirFieldNumber = 2,
    kNetFieldNumber = 3,
    kPortBusFieldNumber = 4,
  };
  // repeated .Common.Types.ModeTransPairMapDouble _caps = 1;
  int _caps_size() const;
  private:
  int _internal__caps_size() const;
  public:
  void clear__caps();
  ::Common::Types::ModeTransPairMapDouble* mutable__caps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ModeTransPairMapDouble >*
      mutable__caps();
  private:
  const ::Common::Types::ModeTransPairMapDouble& _internal__caps(int index) const;
  ::Common::Types::ModeTransPairMapDouble* _internal_add__caps();
  public:
  const ::Common::Types::ModeTransPairMapDouble& _caps(int index) const;
  ::Common::Types::ModeTransPairMapDouble* add__caps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ModeTransPairMapDouble >&
      _caps() const;

  // required .DesignObjects.PortDirEnum _port_dir = 2;
  bool has__port_dir() const;
  private:
  bool _internal_has__port_dir() const;
  public:
  void clear__port_dir();
  const ::DesignObjects::PortDirEnum& _port_dir() const;
  PROTOBUF_NODISCARD ::DesignObjects::PortDirEnum* release__port_dir();
  ::DesignObjects::PortDirEnum* mutable__port_dir();
  void set_allocated__port_dir(::DesignObjects::PortDirEnum* _port_dir);
  private:
  const ::DesignObjects::PortDirEnum& _internal__port_dir() const;
  ::DesignObjects::PortDirEnum* _internal_mutable__port_dir();
  public:
  void unsafe_arena_set_allocated__port_dir(
      ::DesignObjects::PortDirEnum* _port_dir);
  ::DesignObjects::PortDirEnum* unsafe_arena_release__port_dir();

  // optional uint64 _net = 3;
  bool has__net() const;
  private:
  bool _internal_has__net() const;
  public:
  void clear__net();
  uint64_t _net() const;
  void set__net(uint64_t value);
  private:
  uint64_t _internal__net() const;
  void _internal_set__net(uint64_t value);
  public:

  // required uint64 _port_bus = 4;
  bool has__port_bus() const;
  private:
  bool _internal_has__port_bus() const;
  public:
  void clear__port_bus();
  uint64_t _port_bus() const;
  void set__port_bus(uint64_t value);
  private:
  uint64_t _internal__port_bus() const;
  void _internal_set__port_bus(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.PortClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ModeTransPairMapDouble > _caps_;
    ::DesignObjects::PortDirEnum* _port_dir_;
    uint64_t _net_;
    uint64_t _port_bus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class PortBusClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.PortBusClass) */ {
 public:
  inline PortBusClass() : PortBusClass(nullptr) {}
  ~PortBusClass() override;
  explicit PROTOBUF_CONSTEXPR PortBusClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortBusClass(const PortBusClass& from);
  PortBusClass(PortBusClass&& from) noexcept
    : PortBusClass() {
    *this = ::std::move(from);
  }

  inline PortBusClass& operator=(const PortBusClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortBusClass& operator=(PortBusClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortBusClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortBusClass* internal_default_instance() {
    return reinterpret_cast<const PortBusClass*>(
               &_PortBusClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PortBusClass& a, PortBusClass& b) {
    a.Swap(&b);
  }
  inline void Swap(PortBusClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortBusClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortBusClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortBusClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortBusClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortBusClass& from) {
    PortBusClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortBusClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.PortBusClass";
  }
  protected:
  explicit PortBusClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 4,
    kIndexesFieldNumber = 5,
    kPortDirFieldNumber = 3,
    kRightFieldNumber = 2,
    kLeftFieldNumber = 1,
    kSizeFieldNumber = 6,
  };
  // repeated uint64 _ports = 4;
  int _ports_size() const;
  private:
  int _internal__ports_size() const;
  public:
  void clear__ports();
  private:
  uint64_t _internal__ports(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__ports() const;
  void _internal_add__ports(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__ports();
  public:
  uint64_t _ports(int index) const;
  void set__ports(int index, uint64_t value);
  void add__ports(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__ports();

  // repeated uint32 indexes = 5;
  int indexes_size() const;
  private:
  int _internal_indexes_size() const;
  public:
  void clear_indexes();
  private:
  uint32_t _internal_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_indexes() const;
  void _internal_add_indexes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_indexes();
  public:
  uint32_t indexes(int index) const;
  void set_indexes(int index, uint32_t value);
  void add_indexes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_indexes();

  // required .DesignObjects.PortDirEnum _port_dir = 3;
  bool has__port_dir() const;
  private:
  bool _internal_has__port_dir() const;
  public:
  void clear__port_dir();
  const ::DesignObjects::PortDirEnum& _port_dir() const;
  PROTOBUF_NODISCARD ::DesignObjects::PortDirEnum* release__port_dir();
  ::DesignObjects::PortDirEnum* mutable__port_dir();
  void set_allocated__port_dir(::DesignObjects::PortDirEnum* _port_dir);
  private:
  const ::DesignObjects::PortDirEnum& _internal__port_dir() const;
  ::DesignObjects::PortDirEnum* _internal_mutable__port_dir();
  public:
  void unsafe_arena_set_allocated__port_dir(
      ::DesignObjects::PortDirEnum* _port_dir);
  ::DesignObjects::PortDirEnum* unsafe_arena_release__port_dir();

  // required uint64 _right = 2;
  bool has__right() const;
  private:
  bool _internal_has__right() const;
  public:
  void clear__right();
  uint64_t _right() const;
  void set__right(uint64_t value);
  private:
  uint64_t _internal__right() const;
  void _internal_set__right(uint64_t value);
  public:

  // required uint32 _left = 1;
  bool has__left() const;
  private:
  bool _internal_has__left() const;
  public:
  void clear__left();
  uint32_t _left() const;
  void set__left(uint32_t value);
  private:
  uint32_t _internal__left() const;
  void _internal_set__left(uint32_t value);
  public:

  // required uint32 _size = 6;
  bool has__size() const;
  private:
  bool _internal_has__size() const;
  public:
  void clear__size();
  uint32_t _size() const;
  void set__size(uint32_t value);
  private:
  uint32_t _internal__size() const;
  void _internal_set__size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.PortBusClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _ports_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > indexes_;
    ::DesignObjects::PortDirEnum* _port_dir_;
    uint64_t _right_;
    uint32_t _left_;
    uint32_t _size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class InstanceClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.InstanceClass) */ {
 public:
  inline InstanceClass() : InstanceClass(nullptr) {}
  ~InstanceClass() override;
  explicit PROTOBUF_CONSTEXPR InstanceClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceClass(const InstanceClass& from);
  InstanceClass(InstanceClass&& from) noexcept
    : InstanceClass() {
    *this = ::std::move(from);
  }

  inline InstanceClass& operator=(const InstanceClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceClass& operator=(InstanceClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceClass* internal_default_instance() {
    return reinterpret_cast<const InstanceClass*>(
               &_InstanceClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InstanceClass& a, InstanceClass& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstanceClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstanceClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstanceClass& from) {
    InstanceClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.InstanceClass";
  }
  protected:
  explicit InstanceClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPinsFieldNumber = 2,
    kPinsBusFieldNumber = 3,
    kInstCellFieldNumber = 1,
  };
  // repeated uint64 _pins = 2;
  int _pins_size() const;
  private:
  int _internal__pins_size() const;
  public:
  void clear__pins();
  private:
  uint64_t _internal__pins(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__pins() const;
  void _internal_add__pins(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__pins();
  public:
  uint64_t _pins(int index) const;
  void set__pins(int index, uint64_t value);
  void add__pins(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _pins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__pins();

  // repeated uint64 _pins_bus = 3;
  int _pins_bus_size() const;
  private:
  int _internal__pins_bus_size() const;
  public:
  void clear__pins_bus();
  private:
  uint64_t _internal__pins_bus(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__pins_bus() const;
  void _internal_add__pins_bus(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__pins_bus();
  public:
  uint64_t _pins_bus(int index) const;
  void set__pins_bus(int index, uint64_t value);
  void add__pins_bus(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _pins_bus() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__pins_bus();

  // required uint64 _inst_cell = 1;
  bool has__inst_cell() const;
  private:
  bool _internal_has__inst_cell() const;
  public:
  void clear__inst_cell();
  uint64_t _inst_cell() const;
  void set__inst_cell(uint64_t value);
  private:
  uint64_t _internal__inst_cell() const;
  void _internal_set__inst_cell(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:DesignObjects.InstanceClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _pins_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _pins_bus_;
    uint64_t _inst_cell_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class NetListClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.NetListClass) */ {
 public:
  inline NetListClass() : NetListClass(nullptr) {}
  ~NetListClass() override;
  explicit PROTOBUF_CONSTEXPR NetListClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetListClass(const NetListClass& from);
  NetListClass(NetListClass&& from) noexcept
    : NetListClass() {
    *this = ::std::move(from);
  }

  inline NetListClass& operator=(const NetListClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetListClass& operator=(NetListClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetListClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetListClass* internal_default_instance() {
    return reinterpret_cast<const NetListClass*>(
               &_NetListClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NetListClass& a, NetListClass& b) {
    a.Swap(&b);
  }
  inline void Swap(NetListClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetListClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetListClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetListClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetListClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetListClass& from) {
    NetListClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetListClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.NetListClass";
  }
  protected:
  explicit NetListClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 1,
    kPortBusesFieldNumber = 2,
    kNetsFieldNumber = 3,
    kInstancesFieldNumber = 4,
  };
  // repeated uint64 _ports = 1;
  int _ports_size() const;
  private:
  int _internal__ports_size() const;
  public:
  void clear__ports();
  private:
  uint64_t _internal__ports(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__ports() const;
  void _internal_add__ports(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__ports();
  public:
  uint64_t _ports(int index) const;
  void set__ports(int index, uint64_t value);
  void add__ports(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__ports();

  // repeated uint64 _port_buses = 2;
  int _port_buses_size() const;
  private:
  int _internal__port_buses_size() const;
  public:
  void clear__port_buses();
  private:
  uint64_t _internal__port_buses(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__port_buses() const;
  void _internal_add__port_buses(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__port_buses();
  public:
  uint64_t _port_buses(int index) const;
  void set__port_buses(int index, uint64_t value);
  void add__port_buses(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _port_buses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__port_buses();

  // repeated uint64 _nets = 3;
  int _nets_size() const;
  private:
  int _internal__nets_size() const;
  public:
  void clear__nets();
  private:
  uint64_t _internal__nets(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__nets() const;
  void _internal_add__nets(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__nets();
  public:
  uint64_t _nets(int index) const;
  void set__nets(int index, uint64_t value);
  void add__nets(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _nets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__nets();

  // repeated uint64 _instances = 4;
  int _instances_size() const;
  private:
  int _internal__instances_size() const;
  public:
  void clear__instances();
  private:
  uint64_t _internal__instances(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__instances() const;
  void _internal_add__instances(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__instances();
  public:
  uint64_t _instances(int index) const;
  void set__instances(int index, uint64_t value);
  void add__instances(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _instances() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__instances();

  // @@protoc_insertion_point(class_scope:DesignObjects.NetListClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _ports_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _port_buses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _nets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _instances_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// -------------------------------------------------------------------

class DesignObjectSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DesignObjects.DesignObjectSyn) */ {
 public:
  inline DesignObjectSyn() : DesignObjectSyn(nullptr) {}
  ~DesignObjectSyn() override;
  explicit PROTOBUF_CONSTEXPR DesignObjectSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DesignObjectSyn(const DesignObjectSyn& from);
  DesignObjectSyn(DesignObjectSyn&& from) noexcept
    : DesignObjectSyn() {
    *this = ::std::move(from);
  }

  inline DesignObjectSyn& operator=(const DesignObjectSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DesignObjectSyn& operator=(DesignObjectSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DesignObjectSyn& default_instance() {
    return *internal_default_instance();
  }
  enum DosCase {
    kN = 4,
    kPib = 5,
    kPi = 6,
    kPo = 7,
    kPob = 8,
    kI = 9,
    kNl = 10,
    DOS_NOT_SET = 0,
  };

  static inline const DesignObjectSyn* internal_default_instance() {
    return reinterpret_cast<const DesignObjectSyn*>(
               &_DesignObjectSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DesignObjectSyn& a, DesignObjectSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(DesignObjectSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DesignObjectSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DesignObjectSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DesignObjectSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DesignObjectSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DesignObjectSyn& from) {
    DesignObjectSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DesignObjectSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DesignObjects.DesignObjectSyn";
  }
  protected:
  explicit DesignObjectSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kNFieldNumber = 4,
    kPibFieldNumber = 5,
    kPiFieldNumber = 6,
    kPoFieldNumber = 7,
    kPobFieldNumber = 8,
    kIFieldNumber = 9,
    kNlFieldNumber = 10,
  };
  // required .DesignObjects.DesignObjectClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::DesignObjects::DesignObjectClass& parent() const;
  PROTOBUF_NODISCARD ::DesignObjects::DesignObjectClass* release_parent();
  ::DesignObjects::DesignObjectClass* mutable_parent();
  void set_allocated_parent(::DesignObjects::DesignObjectClass* parent);
  private:
  const ::DesignObjects::DesignObjectClass& _internal_parent() const;
  ::DesignObjects::DesignObjectClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::DesignObjects::DesignObjectClass* parent);
  ::DesignObjects::DesignObjectClass* unsafe_arena_release_parent();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .DesignObjects.NetClass n = 4;
  bool has_n() const;
  private:
  bool _internal_has_n() const;
  public:
  void clear_n();
  const ::DesignObjects::NetClass& n() const;
  PROTOBUF_NODISCARD ::DesignObjects::NetClass* release_n();
  ::DesignObjects::NetClass* mutable_n();
  void set_allocated_n(::DesignObjects::NetClass* n);
  private:
  const ::DesignObjects::NetClass& _internal_n() const;
  ::DesignObjects::NetClass* _internal_mutable_n();
  public:
  void unsafe_arena_set_allocated_n(
      ::DesignObjects::NetClass* n);
  ::DesignObjects::NetClass* unsafe_arena_release_n();

  // .DesignObjects.PinBusClass pib = 5;
  bool has_pib() const;
  private:
  bool _internal_has_pib() const;
  public:
  void clear_pib();
  const ::DesignObjects::PinBusClass& pib() const;
  PROTOBUF_NODISCARD ::DesignObjects::PinBusClass* release_pib();
  ::DesignObjects::PinBusClass* mutable_pib();
  void set_allocated_pib(::DesignObjects::PinBusClass* pib);
  private:
  const ::DesignObjects::PinBusClass& _internal_pib() const;
  ::DesignObjects::PinBusClass* _internal_mutable_pib();
  public:
  void unsafe_arena_set_allocated_pib(
      ::DesignObjects::PinBusClass* pib);
  ::DesignObjects::PinBusClass* unsafe_arena_release_pib();

  // .DesignObjects.PinClass pi = 6;
  bool has_pi() const;
  private:
  bool _internal_has_pi() const;
  public:
  void clear_pi();
  const ::DesignObjects::PinClass& pi() const;
  PROTOBUF_NODISCARD ::DesignObjects::PinClass* release_pi();
  ::DesignObjects::PinClass* mutable_pi();
  void set_allocated_pi(::DesignObjects::PinClass* pi);
  private:
  const ::DesignObjects::PinClass& _internal_pi() const;
  ::DesignObjects::PinClass* _internal_mutable_pi();
  public:
  void unsafe_arena_set_allocated_pi(
      ::DesignObjects::PinClass* pi);
  ::DesignObjects::PinClass* unsafe_arena_release_pi();

  // .DesignObjects.PortClass po = 7;
  bool has_po() const;
  private:
  bool _internal_has_po() const;
  public:
  void clear_po();
  const ::DesignObjects::PortClass& po() const;
  PROTOBUF_NODISCARD ::DesignObjects::PortClass* release_po();
  ::DesignObjects::PortClass* mutable_po();
  void set_allocated_po(::DesignObjects::PortClass* po);
  private:
  const ::DesignObjects::PortClass& _internal_po() const;
  ::DesignObjects::PortClass* _internal_mutable_po();
  public:
  void unsafe_arena_set_allocated_po(
      ::DesignObjects::PortClass* po);
  ::DesignObjects::PortClass* unsafe_arena_release_po();

  // .DesignObjects.PortBusClass pob = 8;
  bool has_pob() const;
  private:
  bool _internal_has_pob() const;
  public:
  void clear_pob();
  const ::DesignObjects::PortBusClass& pob() const;
  PROTOBUF_NODISCARD ::DesignObjects::PortBusClass* release_pob();
  ::DesignObjects::PortBusClass* mutable_pob();
  void set_allocated_pob(::DesignObjects::PortBusClass* pob);
  private:
  const ::DesignObjects::PortBusClass& _internal_pob() const;
  ::DesignObjects::PortBusClass* _internal_mutable_pob();
  public:
  void unsafe_arena_set_allocated_pob(
      ::DesignObjects::PortBusClass* pob);
  ::DesignObjects::PortBusClass* unsafe_arena_release_pob();

  // .DesignObjects.InstanceClass i = 9;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  const ::DesignObjects::InstanceClass& i() const;
  PROTOBUF_NODISCARD ::DesignObjects::InstanceClass* release_i();
  ::DesignObjects::InstanceClass* mutable_i();
  void set_allocated_i(::DesignObjects::InstanceClass* i);
  private:
  const ::DesignObjects::InstanceClass& _internal_i() const;
  ::DesignObjects::InstanceClass* _internal_mutable_i();
  public:
  void unsafe_arena_set_allocated_i(
      ::DesignObjects::InstanceClass* i);
  ::DesignObjects::InstanceClass* unsafe_arena_release_i();

  // .DesignObjects.NetListClass nl = 10;
  bool has_nl() const;
  private:
  bool _internal_has_nl() const;
  public:
  void clear_nl();
  const ::DesignObjects::NetListClass& nl() const;
  PROTOBUF_NODISCARD ::DesignObjects::NetListClass* release_nl();
  ::DesignObjects::NetListClass* mutable_nl();
  void set_allocated_nl(::DesignObjects::NetListClass* nl);
  private:
  const ::DesignObjects::NetListClass& _internal_nl() const;
  ::DesignObjects::NetListClass* _internal_mutable_nl();
  public:
  void unsafe_arena_set_allocated_nl(
      ::DesignObjects::NetListClass* nl);
  ::DesignObjects::NetListClass* unsafe_arena_release_nl();

  void clear_dos();
  DosCase dos_case() const;
  // @@protoc_insertion_point(class_scope:DesignObjects.DesignObjectSyn)
 private:
  class _Internal;
  void set_has_n();
  void set_has_pib();
  void set_has_pi();
  void set_has_po();
  void set_has_pob();
  void set_has_i();
  void set_has_nl();

  inline bool has_dos() const;
  inline void clear_has_dos();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DesignObjects::DesignObjectClass* parent_;
    uint64_t id_;
    uint32_t type_;
    union DosUnion {
      constexpr DosUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::DesignObjects::NetClass* n_;
      ::DesignObjects::PinBusClass* pib_;
      ::DesignObjects::PinClass* pi_;
      ::DesignObjects::PortClass* po_;
      ::DesignObjects::PortBusClass* pob_;
      ::DesignObjects::InstanceClass* i_;
      ::DesignObjects::NetListClass* nl_;
    } dos_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DesignObjects_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DesignObjectClass

// required string _name = 1;
inline bool DesignObjectClass::_internal_has__name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DesignObjectClass::has__name() const {
  return _internal_has__name();
}
inline void DesignObjectClass::clear__name() {
  _impl_._name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DesignObjectClass::_name() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectClass._name)
  return _internal__name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DesignObjectClass::set__name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DesignObjects.DesignObjectClass._name)
}
inline std::string* DesignObjectClass::mutable__name() {
  std::string* _s = _internal_mutable__name();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectClass._name)
  return _s;
}
inline const std::string& DesignObjectClass::_internal__name() const {
  return _impl_._name_.Get();
}
inline void DesignObjectClass::_internal_set__name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._name_.Set(value, GetArenaForAllocation());
}
inline std::string* DesignObjectClass::_internal_mutable__name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._name_.Mutable(GetArenaForAllocation());
}
inline std::string* DesignObjectClass::release__name() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectClass._name)
  if (!_internal_has__name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._name_.IsDefault()) {
    _impl_._name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DesignObjectClass::set_allocated__name(std::string* _name) {
  if (_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._name_.SetAllocated(_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._name_.IsDefault()) {
    _impl_._name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectClass._name)
}

// -------------------------------------------------------------------

// NetClass

// required bool _is_clock_net = 1;
inline bool NetClass::_internal_has__is_clock_net() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetClass::has__is_clock_net() const {
  return _internal_has__is_clock_net();
}
inline void NetClass::clear__is_clock_net() {
  _impl_._is_clock_net_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool NetClass::_internal__is_clock_net() const {
  return _impl_._is_clock_net_;
}
inline bool NetClass::_is_clock_net() const {
  // @@protoc_insertion_point(field_get:DesignObjects.NetClass._is_clock_net)
  return _internal__is_clock_net();
}
inline void NetClass::_internal_set__is_clock_net(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._is_clock_net_ = value;
}
inline void NetClass::set__is_clock_net(bool value) {
  _internal_set__is_clock_net(value);
  // @@protoc_insertion_point(field_set:DesignObjects.NetClass._is_clock_net)
}

// repeated uint64 _pin_ports = 2;
inline int NetClass::_internal__pin_ports_size() const {
  return _impl_._pin_ports_.size();
}
inline int NetClass::_pin_ports_size() const {
  return _internal__pin_ports_size();
}
inline void NetClass::clear__pin_ports() {
  _impl_._pin_ports_.Clear();
}
inline uint64_t NetClass::_internal__pin_ports(int index) const {
  return _impl_._pin_ports_.Get(index);
}
inline uint64_t NetClass::_pin_ports(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.NetClass._pin_ports)
  return _internal__pin_ports(index);
}
inline void NetClass::set__pin_ports(int index, uint64_t value) {
  _impl_._pin_ports_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.NetClass._pin_ports)
}
inline void NetClass::_internal_add__pin_ports(uint64_t value) {
  _impl_._pin_ports_.Add(value);
}
inline void NetClass::add__pin_ports(uint64_t value) {
  _internal_add__pin_ports(value);
  // @@protoc_insertion_point(field_add:DesignObjects.NetClass._pin_ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetClass::_internal__pin_ports() const {
  return _impl_._pin_ports_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetClass::_pin_ports() const {
  // @@protoc_insertion_point(field_list:DesignObjects.NetClass._pin_ports)
  return _internal__pin_ports();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetClass::_internal_mutable__pin_ports() {
  return &_impl_._pin_ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetClass::mutable__pin_ports() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.NetClass._pin_ports)
  return _internal_mutable__pin_ports();
}

// -------------------------------------------------------------------

// PinBusClass

// required uint32 _left = 1;
inline bool PinBusClass::_internal_has__left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PinBusClass::has__left() const {
  return _internal_has__left();
}
inline void PinBusClass::clear__left() {
  _impl_._left_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PinBusClass::_internal__left() const {
  return _impl_._left_;
}
inline uint32_t PinBusClass::_left() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinBusClass._left)
  return _internal__left();
}
inline void PinBusClass::_internal_set__left(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._left_ = value;
}
inline void PinBusClass::set__left(uint32_t value) {
  _internal_set__left(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinBusClass._left)
}

// required uint32 _right = 2;
inline bool PinBusClass::_internal_has__right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PinBusClass::has__right() const {
  return _internal_has__right();
}
inline void PinBusClass::clear__right() {
  _impl_._right_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PinBusClass::_internal__right() const {
  return _impl_._right_;
}
inline uint32_t PinBusClass::_right() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinBusClass._right)
  return _internal__right();
}
inline void PinBusClass::_internal_set__right(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._right_ = value;
}
inline void PinBusClass::set__right(uint32_t value) {
  _internal_set__right(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinBusClass._right)
}

// repeated uint64 _pins = 3;
inline int PinBusClass::_internal__pins_size() const {
  return _impl_._pins_.size();
}
inline int PinBusClass::_pins_size() const {
  return _internal__pins_size();
}
inline void PinBusClass::clear__pins() {
  _impl_._pins_.Clear();
}
inline uint64_t PinBusClass::_internal__pins(int index) const {
  return _impl_._pins_.Get(index);
}
inline uint64_t PinBusClass::_pins(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinBusClass._pins)
  return _internal__pins(index);
}
inline void PinBusClass::set__pins(int index, uint64_t value) {
  _impl_._pins_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinBusClass._pins)
}
inline void PinBusClass::_internal_add__pins(uint64_t value) {
  _impl_._pins_.Add(value);
}
inline void PinBusClass::add__pins(uint64_t value) {
  _internal_add__pins(value);
  // @@protoc_insertion_point(field_add:DesignObjects.PinBusClass._pins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PinBusClass::_internal__pins() const {
  return _impl_._pins_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PinBusClass::_pins() const {
  // @@protoc_insertion_point(field_list:DesignObjects.PinBusClass._pins)
  return _internal__pins();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PinBusClass::_internal_mutable__pins() {
  return &_impl_._pins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PinBusClass::mutable__pins() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.PinBusClass._pins)
  return _internal_mutable__pins();
}

// repeated uint32 indexes = 4;
inline int PinBusClass::_internal_indexes_size() const {
  return _impl_.indexes_.size();
}
inline int PinBusClass::indexes_size() const {
  return _internal_indexes_size();
}
inline void PinBusClass::clear_indexes() {
  _impl_.indexes_.Clear();
}
inline uint32_t PinBusClass::_internal_indexes(int index) const {
  return _impl_.indexes_.Get(index);
}
inline uint32_t PinBusClass::indexes(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinBusClass.indexes)
  return _internal_indexes(index);
}
inline void PinBusClass::set_indexes(int index, uint32_t value) {
  _impl_.indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinBusClass.indexes)
}
inline void PinBusClass::_internal_add_indexes(uint32_t value) {
  _impl_.indexes_.Add(value);
}
inline void PinBusClass::add_indexes(uint32_t value) {
  _internal_add_indexes(value);
  // @@protoc_insertion_point(field_add:DesignObjects.PinBusClass.indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PinBusClass::_internal_indexes() const {
  return _impl_.indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PinBusClass::indexes() const {
  // @@protoc_insertion_point(field_list:DesignObjects.PinBusClass.indexes)
  return _internal_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PinBusClass::_internal_mutable_indexes() {
  return &_impl_.indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PinBusClass::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.PinBusClass.indexes)
  return _internal_mutable_indexes();
}

// required uint32 _size = 5;
inline bool PinBusClass::_internal_has__size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PinBusClass::has__size() const {
  return _internal_has__size();
}
inline void PinBusClass::clear__size() {
  _impl_._size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PinBusClass::_internal__size() const {
  return _impl_._size_;
}
inline uint32_t PinBusClass::_size() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinBusClass._size)
  return _internal__size();
}
inline void PinBusClass::_internal_set__size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._size_ = value;
}
inline void PinBusClass::set__size(uint32_t value) {
  _internal_set__size(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinBusClass._size)
}

// -------------------------------------------------------------------

// PinClass

// required uint64 _net = 1;
inline bool PinClass::_internal_has__net() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PinClass::has__net() const {
  return _internal_has__net();
}
inline void PinClass::clear__net() {
  _impl_._net_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PinClass::_internal__net() const {
  return _impl_._net_;
}
inline uint64_t PinClass::_net() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinClass._net)
  return _internal__net();
}
inline void PinClass::_internal_set__net(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._net_ = value;
}
inline void PinClass::set__net(uint64_t value) {
  _internal_set__net(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinClass._net)
}

// required uint64 _cell_port = 2;
inline bool PinClass::_internal_has__cell_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PinClass::has__cell_port() const {
  return _internal_has__cell_port();
}
inline void PinClass::clear__cell_port() {
  _impl_._cell_port_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PinClass::_internal__cell_port() const {
  return _impl_._cell_port_;
}
inline uint64_t PinClass::_cell_port() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinClass._cell_port)
  return _internal__cell_port();
}
inline void PinClass::_internal_set__cell_port(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._cell_port_ = value;
}
inline void PinClass::set__cell_port(uint64_t value) {
  _internal_set__cell_port(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinClass._cell_port)
}

// required uint64 _own_instance = 3;
inline bool PinClass::_internal_has__own_instance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PinClass::has__own_instance() const {
  return _internal_has__own_instance();
}
inline void PinClass::clear__own_instance() {
  _impl_._own_instance_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PinClass::_internal__own_instance() const {
  return _impl_._own_instance_;
}
inline uint64_t PinClass::_own_instance() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinClass._own_instance)
  return _internal__own_instance();
}
inline void PinClass::_internal_set__own_instance(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._own_instance_ = value;
}
inline void PinClass::set__own_instance(uint64_t value) {
  _internal_set__own_instance(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinClass._own_instance)
}

// required uint64 _pin_bus = 4;
inline bool PinClass::_internal_has__pin_bus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PinClass::has__pin_bus() const {
  return _internal_has__pin_bus();
}
inline void PinClass::clear__pin_bus() {
  _impl_._pin_bus_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t PinClass::_internal__pin_bus() const {
  return _impl_._pin_bus_;
}
inline uint64_t PinClass::_pin_bus() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PinClass._pin_bus)
  return _internal__pin_bus();
}
inline void PinClass::_internal_set__pin_bus(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._pin_bus_ = value;
}
inline void PinClass::set__pin_bus(uint64_t value) {
  _internal_set__pin_bus(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PinClass._pin_bus)
}

// -------------------------------------------------------------------

// PortDirEnum

// required .DesignObjects.PortDirEnum.PortDir pd = 1;
inline bool PortDirEnum::_internal_has_pd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PortDirEnum::has_pd() const {
  return _internal_has_pd();
}
inline void PortDirEnum::clear_pd() {
  _impl_.pd_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::DesignObjects::PortDirEnum_PortDir PortDirEnum::_internal_pd() const {
  return static_cast< ::DesignObjects::PortDirEnum_PortDir >(_impl_.pd_);
}
inline ::DesignObjects::PortDirEnum_PortDir PortDirEnum::pd() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortDirEnum.pd)
  return _internal_pd();
}
inline void PortDirEnum::_internal_set_pd(::DesignObjects::PortDirEnum_PortDir value) {
  assert(::DesignObjects::PortDirEnum_PortDir_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pd_ = value;
}
inline void PortDirEnum::set_pd(::DesignObjects::PortDirEnum_PortDir value) {
  _internal_set_pd(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortDirEnum.pd)
}

// -------------------------------------------------------------------

// PortClass

// repeated .Common.Types.ModeTransPairMapDouble _caps = 1;
inline int PortClass::_internal__caps_size() const {
  return _impl_._caps_.size();
}
inline int PortClass::_caps_size() const {
  return _internal__caps_size();
}
inline ::Common::Types::ModeTransPairMapDouble* PortClass::mutable__caps(int index) {
  // @@protoc_insertion_point(field_mutable:DesignObjects.PortClass._caps)
  return _impl_._caps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ModeTransPairMapDouble >*
PortClass::mutable__caps() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.PortClass._caps)
  return &_impl_._caps_;
}
inline const ::Common::Types::ModeTransPairMapDouble& PortClass::_internal__caps(int index) const {
  return _impl_._caps_.Get(index);
}
inline const ::Common::Types::ModeTransPairMapDouble& PortClass::_caps(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortClass._caps)
  return _internal__caps(index);
}
inline ::Common::Types::ModeTransPairMapDouble* PortClass::_internal_add__caps() {
  return _impl_._caps_.Add();
}
inline ::Common::Types::ModeTransPairMapDouble* PortClass::add__caps() {
  ::Common::Types::ModeTransPairMapDouble* _add = _internal_add__caps();
  // @@protoc_insertion_point(field_add:DesignObjects.PortClass._caps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ModeTransPairMapDouble >&
PortClass::_caps() const {
  // @@protoc_insertion_point(field_list:DesignObjects.PortClass._caps)
  return _impl_._caps_;
}

// required .DesignObjects.PortDirEnum _port_dir = 2;
inline bool PortClass::_internal_has__port_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._port_dir_ != nullptr);
  return value;
}
inline bool PortClass::has__port_dir() const {
  return _internal_has__port_dir();
}
inline void PortClass::clear__port_dir() {
  if (_impl_._port_dir_ != nullptr) _impl_._port_dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DesignObjects::PortDirEnum& PortClass::_internal__port_dir() const {
  const ::DesignObjects::PortDirEnum* p = _impl_._port_dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::DesignObjects::PortDirEnum&>(
      ::DesignObjects::_PortDirEnum_default_instance_);
}
inline const ::DesignObjects::PortDirEnum& PortClass::_port_dir() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortClass._port_dir)
  return _internal__port_dir();
}
inline void PortClass::unsafe_arena_set_allocated__port_dir(
    ::DesignObjects::PortDirEnum* _port_dir) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._port_dir_);
  }
  _impl_._port_dir_ = _port_dir;
  if (_port_dir) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.PortClass._port_dir)
}
inline ::DesignObjects::PortDirEnum* PortClass::release__port_dir() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DesignObjects::PortDirEnum* temp = _impl_._port_dir_;
  _impl_._port_dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DesignObjects::PortDirEnum* PortClass::unsafe_arena_release__port_dir() {
  // @@protoc_insertion_point(field_release:DesignObjects.PortClass._port_dir)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DesignObjects::PortDirEnum* temp = _impl_._port_dir_;
  _impl_._port_dir_ = nullptr;
  return temp;
}
inline ::DesignObjects::PortDirEnum* PortClass::_internal_mutable__port_dir() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_._port_dir_ == nullptr) {
    auto* p = CreateMaybeMessage<::DesignObjects::PortDirEnum>(GetArenaForAllocation());
    _impl_._port_dir_ = p;
  }
  return _impl_._port_dir_;
}
inline ::DesignObjects::PortDirEnum* PortClass::mutable__port_dir() {
  ::DesignObjects::PortDirEnum* _msg = _internal_mutable__port_dir();
  // @@protoc_insertion_point(field_mutable:DesignObjects.PortClass._port_dir)
  return _msg;
}
inline void PortClass::set_allocated__port_dir(::DesignObjects::PortDirEnum* _port_dir) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._port_dir_;
  }
  if (_port_dir) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_port_dir);
    if (message_arena != submessage_arena) {
      _port_dir = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _port_dir, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._port_dir_ = _port_dir;
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.PortClass._port_dir)
}

// optional uint64 _net = 3;
inline bool PortClass::_internal_has__net() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PortClass::has__net() const {
  return _internal_has__net();
}
inline void PortClass::clear__net() {
  _impl_._net_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PortClass::_internal__net() const {
  return _impl_._net_;
}
inline uint64_t PortClass::_net() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortClass._net)
  return _internal__net();
}
inline void PortClass::_internal_set__net(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._net_ = value;
}
inline void PortClass::set__net(uint64_t value) {
  _internal_set__net(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortClass._net)
}

// required uint64 _port_bus = 4;
inline bool PortClass::_internal_has__port_bus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PortClass::has__port_bus() const {
  return _internal_has__port_bus();
}
inline void PortClass::clear__port_bus() {
  _impl_._port_bus_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PortClass::_internal__port_bus() const {
  return _impl_._port_bus_;
}
inline uint64_t PortClass::_port_bus() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortClass._port_bus)
  return _internal__port_bus();
}
inline void PortClass::_internal_set__port_bus(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._port_bus_ = value;
}
inline void PortClass::set__port_bus(uint64_t value) {
  _internal_set__port_bus(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortClass._port_bus)
}

// -------------------------------------------------------------------

// PortBusClass

// required uint32 _left = 1;
inline bool PortBusClass::_internal_has__left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PortBusClass::has__left() const {
  return _internal_has__left();
}
inline void PortBusClass::clear__left() {
  _impl_._left_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PortBusClass::_internal__left() const {
  return _impl_._left_;
}
inline uint32_t PortBusClass::_left() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortBusClass._left)
  return _internal__left();
}
inline void PortBusClass::_internal_set__left(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._left_ = value;
}
inline void PortBusClass::set__left(uint32_t value) {
  _internal_set__left(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortBusClass._left)
}

// required uint64 _right = 2;
inline bool PortBusClass::_internal_has__right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PortBusClass::has__right() const {
  return _internal_has__right();
}
inline void PortBusClass::clear__right() {
  _impl_._right_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PortBusClass::_internal__right() const {
  return _impl_._right_;
}
inline uint64_t PortBusClass::_right() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortBusClass._right)
  return _internal__right();
}
inline void PortBusClass::_internal_set__right(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._right_ = value;
}
inline void PortBusClass::set__right(uint64_t value) {
  _internal_set__right(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortBusClass._right)
}

// required .DesignObjects.PortDirEnum _port_dir = 3;
inline bool PortBusClass::_internal_has__port_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._port_dir_ != nullptr);
  return value;
}
inline bool PortBusClass::has__port_dir() const {
  return _internal_has__port_dir();
}
inline void PortBusClass::clear__port_dir() {
  if (_impl_._port_dir_ != nullptr) _impl_._port_dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DesignObjects::PortDirEnum& PortBusClass::_internal__port_dir() const {
  const ::DesignObjects::PortDirEnum* p = _impl_._port_dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::DesignObjects::PortDirEnum&>(
      ::DesignObjects::_PortDirEnum_default_instance_);
}
inline const ::DesignObjects::PortDirEnum& PortBusClass::_port_dir() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortBusClass._port_dir)
  return _internal__port_dir();
}
inline void PortBusClass::unsafe_arena_set_allocated__port_dir(
    ::DesignObjects::PortDirEnum* _port_dir) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._port_dir_);
  }
  _impl_._port_dir_ = _port_dir;
  if (_port_dir) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.PortBusClass._port_dir)
}
inline ::DesignObjects::PortDirEnum* PortBusClass::release__port_dir() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DesignObjects::PortDirEnum* temp = _impl_._port_dir_;
  _impl_._port_dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DesignObjects::PortDirEnum* PortBusClass::unsafe_arena_release__port_dir() {
  // @@protoc_insertion_point(field_release:DesignObjects.PortBusClass._port_dir)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DesignObjects::PortDirEnum* temp = _impl_._port_dir_;
  _impl_._port_dir_ = nullptr;
  return temp;
}
inline ::DesignObjects::PortDirEnum* PortBusClass::_internal_mutable__port_dir() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_._port_dir_ == nullptr) {
    auto* p = CreateMaybeMessage<::DesignObjects::PortDirEnum>(GetArenaForAllocation());
    _impl_._port_dir_ = p;
  }
  return _impl_._port_dir_;
}
inline ::DesignObjects::PortDirEnum* PortBusClass::mutable__port_dir() {
  ::DesignObjects::PortDirEnum* _msg = _internal_mutable__port_dir();
  // @@protoc_insertion_point(field_mutable:DesignObjects.PortBusClass._port_dir)
  return _msg;
}
inline void PortBusClass::set_allocated__port_dir(::DesignObjects::PortDirEnum* _port_dir) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._port_dir_;
  }
  if (_port_dir) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_port_dir);
    if (message_arena != submessage_arena) {
      _port_dir = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _port_dir, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._port_dir_ = _port_dir;
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.PortBusClass._port_dir)
}

// repeated uint64 _ports = 4;
inline int PortBusClass::_internal__ports_size() const {
  return _impl_._ports_.size();
}
inline int PortBusClass::_ports_size() const {
  return _internal__ports_size();
}
inline void PortBusClass::clear__ports() {
  _impl_._ports_.Clear();
}
inline uint64_t PortBusClass::_internal__ports(int index) const {
  return _impl_._ports_.Get(index);
}
inline uint64_t PortBusClass::_ports(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortBusClass._ports)
  return _internal__ports(index);
}
inline void PortBusClass::set__ports(int index, uint64_t value) {
  _impl_._ports_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortBusClass._ports)
}
inline void PortBusClass::_internal_add__ports(uint64_t value) {
  _impl_._ports_.Add(value);
}
inline void PortBusClass::add__ports(uint64_t value) {
  _internal_add__ports(value);
  // @@protoc_insertion_point(field_add:DesignObjects.PortBusClass._ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PortBusClass::_internal__ports() const {
  return _impl_._ports_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PortBusClass::_ports() const {
  // @@protoc_insertion_point(field_list:DesignObjects.PortBusClass._ports)
  return _internal__ports();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PortBusClass::_internal_mutable__ports() {
  return &_impl_._ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PortBusClass::mutable__ports() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.PortBusClass._ports)
  return _internal_mutable__ports();
}

// repeated uint32 indexes = 5;
inline int PortBusClass::_internal_indexes_size() const {
  return _impl_.indexes_.size();
}
inline int PortBusClass::indexes_size() const {
  return _internal_indexes_size();
}
inline void PortBusClass::clear_indexes() {
  _impl_.indexes_.Clear();
}
inline uint32_t PortBusClass::_internal_indexes(int index) const {
  return _impl_.indexes_.Get(index);
}
inline uint32_t PortBusClass::indexes(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortBusClass.indexes)
  return _internal_indexes(index);
}
inline void PortBusClass::set_indexes(int index, uint32_t value) {
  _impl_.indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortBusClass.indexes)
}
inline void PortBusClass::_internal_add_indexes(uint32_t value) {
  _impl_.indexes_.Add(value);
}
inline void PortBusClass::add_indexes(uint32_t value) {
  _internal_add_indexes(value);
  // @@protoc_insertion_point(field_add:DesignObjects.PortBusClass.indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PortBusClass::_internal_indexes() const {
  return _impl_.indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PortBusClass::indexes() const {
  // @@protoc_insertion_point(field_list:DesignObjects.PortBusClass.indexes)
  return _internal_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PortBusClass::_internal_mutable_indexes() {
  return &_impl_.indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PortBusClass::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.PortBusClass.indexes)
  return _internal_mutable_indexes();
}

// required uint32 _size = 6;
inline bool PortBusClass::_internal_has__size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PortBusClass::has__size() const {
  return _internal_has__size();
}
inline void PortBusClass::clear__size() {
  _impl_._size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PortBusClass::_internal__size() const {
  return _impl_._size_;
}
inline uint32_t PortBusClass::_size() const {
  // @@protoc_insertion_point(field_get:DesignObjects.PortBusClass._size)
  return _internal__size();
}
inline void PortBusClass::_internal_set__size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._size_ = value;
}
inline void PortBusClass::set__size(uint32_t value) {
  _internal_set__size(value);
  // @@protoc_insertion_point(field_set:DesignObjects.PortBusClass._size)
}

// -------------------------------------------------------------------

// InstanceClass

// required uint64 _inst_cell = 1;
inline bool InstanceClass::_internal_has__inst_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstanceClass::has__inst_cell() const {
  return _internal_has__inst_cell();
}
inline void InstanceClass::clear__inst_cell() {
  _impl_._inst_cell_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t InstanceClass::_internal__inst_cell() const {
  return _impl_._inst_cell_;
}
inline uint64_t InstanceClass::_inst_cell() const {
  // @@protoc_insertion_point(field_get:DesignObjects.InstanceClass._inst_cell)
  return _internal__inst_cell();
}
inline void InstanceClass::_internal_set__inst_cell(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._inst_cell_ = value;
}
inline void InstanceClass::set__inst_cell(uint64_t value) {
  _internal_set__inst_cell(value);
  // @@protoc_insertion_point(field_set:DesignObjects.InstanceClass._inst_cell)
}

// repeated uint64 _pins = 2;
inline int InstanceClass::_internal__pins_size() const {
  return _impl_._pins_.size();
}
inline int InstanceClass::_pins_size() const {
  return _internal__pins_size();
}
inline void InstanceClass::clear__pins() {
  _impl_._pins_.Clear();
}
inline uint64_t InstanceClass::_internal__pins(int index) const {
  return _impl_._pins_.Get(index);
}
inline uint64_t InstanceClass::_pins(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.InstanceClass._pins)
  return _internal__pins(index);
}
inline void InstanceClass::set__pins(int index, uint64_t value) {
  _impl_._pins_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.InstanceClass._pins)
}
inline void InstanceClass::_internal_add__pins(uint64_t value) {
  _impl_._pins_.Add(value);
}
inline void InstanceClass::add__pins(uint64_t value) {
  _internal_add__pins(value);
  // @@protoc_insertion_point(field_add:DesignObjects.InstanceClass._pins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
InstanceClass::_internal__pins() const {
  return _impl_._pins_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
InstanceClass::_pins() const {
  // @@protoc_insertion_point(field_list:DesignObjects.InstanceClass._pins)
  return _internal__pins();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
InstanceClass::_internal_mutable__pins() {
  return &_impl_._pins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
InstanceClass::mutable__pins() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.InstanceClass._pins)
  return _internal_mutable__pins();
}

// repeated uint64 _pins_bus = 3;
inline int InstanceClass::_internal__pins_bus_size() const {
  return _impl_._pins_bus_.size();
}
inline int InstanceClass::_pins_bus_size() const {
  return _internal__pins_bus_size();
}
inline void InstanceClass::clear__pins_bus() {
  _impl_._pins_bus_.Clear();
}
inline uint64_t InstanceClass::_internal__pins_bus(int index) const {
  return _impl_._pins_bus_.Get(index);
}
inline uint64_t InstanceClass::_pins_bus(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.InstanceClass._pins_bus)
  return _internal__pins_bus(index);
}
inline void InstanceClass::set__pins_bus(int index, uint64_t value) {
  _impl_._pins_bus_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.InstanceClass._pins_bus)
}
inline void InstanceClass::_internal_add__pins_bus(uint64_t value) {
  _impl_._pins_bus_.Add(value);
}
inline void InstanceClass::add__pins_bus(uint64_t value) {
  _internal_add__pins_bus(value);
  // @@protoc_insertion_point(field_add:DesignObjects.InstanceClass._pins_bus)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
InstanceClass::_internal__pins_bus() const {
  return _impl_._pins_bus_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
InstanceClass::_pins_bus() const {
  // @@protoc_insertion_point(field_list:DesignObjects.InstanceClass._pins_bus)
  return _internal__pins_bus();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
InstanceClass::_internal_mutable__pins_bus() {
  return &_impl_._pins_bus_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
InstanceClass::mutable__pins_bus() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.InstanceClass._pins_bus)
  return _internal_mutable__pins_bus();
}

// -------------------------------------------------------------------

// NetListClass

// repeated uint64 _ports = 1;
inline int NetListClass::_internal__ports_size() const {
  return _impl_._ports_.size();
}
inline int NetListClass::_ports_size() const {
  return _internal__ports_size();
}
inline void NetListClass::clear__ports() {
  _impl_._ports_.Clear();
}
inline uint64_t NetListClass::_internal__ports(int index) const {
  return _impl_._ports_.Get(index);
}
inline uint64_t NetListClass::_ports(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.NetListClass._ports)
  return _internal__ports(index);
}
inline void NetListClass::set__ports(int index, uint64_t value) {
  _impl_._ports_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.NetListClass._ports)
}
inline void NetListClass::_internal_add__ports(uint64_t value) {
  _impl_._ports_.Add(value);
}
inline void NetListClass::add__ports(uint64_t value) {
  _internal_add__ports(value);
  // @@protoc_insertion_point(field_add:DesignObjects.NetListClass._ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_internal__ports() const {
  return _impl_._ports_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_ports() const {
  // @@protoc_insertion_point(field_list:DesignObjects.NetListClass._ports)
  return _internal__ports();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::_internal_mutable__ports() {
  return &_impl_._ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::mutable__ports() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.NetListClass._ports)
  return _internal_mutable__ports();
}

// repeated uint64 _port_buses = 2;
inline int NetListClass::_internal__port_buses_size() const {
  return _impl_._port_buses_.size();
}
inline int NetListClass::_port_buses_size() const {
  return _internal__port_buses_size();
}
inline void NetListClass::clear__port_buses() {
  _impl_._port_buses_.Clear();
}
inline uint64_t NetListClass::_internal__port_buses(int index) const {
  return _impl_._port_buses_.Get(index);
}
inline uint64_t NetListClass::_port_buses(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.NetListClass._port_buses)
  return _internal__port_buses(index);
}
inline void NetListClass::set__port_buses(int index, uint64_t value) {
  _impl_._port_buses_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.NetListClass._port_buses)
}
inline void NetListClass::_internal_add__port_buses(uint64_t value) {
  _impl_._port_buses_.Add(value);
}
inline void NetListClass::add__port_buses(uint64_t value) {
  _internal_add__port_buses(value);
  // @@protoc_insertion_point(field_add:DesignObjects.NetListClass._port_buses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_internal__port_buses() const {
  return _impl_._port_buses_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_port_buses() const {
  // @@protoc_insertion_point(field_list:DesignObjects.NetListClass._port_buses)
  return _internal__port_buses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::_internal_mutable__port_buses() {
  return &_impl_._port_buses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::mutable__port_buses() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.NetListClass._port_buses)
  return _internal_mutable__port_buses();
}

// repeated uint64 _nets = 3;
inline int NetListClass::_internal__nets_size() const {
  return _impl_._nets_.size();
}
inline int NetListClass::_nets_size() const {
  return _internal__nets_size();
}
inline void NetListClass::clear__nets() {
  _impl_._nets_.Clear();
}
inline uint64_t NetListClass::_internal__nets(int index) const {
  return _impl_._nets_.Get(index);
}
inline uint64_t NetListClass::_nets(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.NetListClass._nets)
  return _internal__nets(index);
}
inline void NetListClass::set__nets(int index, uint64_t value) {
  _impl_._nets_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.NetListClass._nets)
}
inline void NetListClass::_internal_add__nets(uint64_t value) {
  _impl_._nets_.Add(value);
}
inline void NetListClass::add__nets(uint64_t value) {
  _internal_add__nets(value);
  // @@protoc_insertion_point(field_add:DesignObjects.NetListClass._nets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_internal__nets() const {
  return _impl_._nets_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_nets() const {
  // @@protoc_insertion_point(field_list:DesignObjects.NetListClass._nets)
  return _internal__nets();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::_internal_mutable__nets() {
  return &_impl_._nets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::mutable__nets() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.NetListClass._nets)
  return _internal_mutable__nets();
}

// repeated uint64 _instances = 4;
inline int NetListClass::_internal__instances_size() const {
  return _impl_._instances_.size();
}
inline int NetListClass::_instances_size() const {
  return _internal__instances_size();
}
inline void NetListClass::clear__instances() {
  _impl_._instances_.Clear();
}
inline uint64_t NetListClass::_internal__instances(int index) const {
  return _impl_._instances_.Get(index);
}
inline uint64_t NetListClass::_instances(int index) const {
  // @@protoc_insertion_point(field_get:DesignObjects.NetListClass._instances)
  return _internal__instances(index);
}
inline void NetListClass::set__instances(int index, uint64_t value) {
  _impl_._instances_.Set(index, value);
  // @@protoc_insertion_point(field_set:DesignObjects.NetListClass._instances)
}
inline void NetListClass::_internal_add__instances(uint64_t value) {
  _impl_._instances_.Add(value);
}
inline void NetListClass::add__instances(uint64_t value) {
  _internal_add__instances(value);
  // @@protoc_insertion_point(field_add:DesignObjects.NetListClass._instances)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_internal__instances() const {
  return _impl_._instances_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
NetListClass::_instances() const {
  // @@protoc_insertion_point(field_list:DesignObjects.NetListClass._instances)
  return _internal__instances();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::_internal_mutable__instances() {
  return &_impl_._instances_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
NetListClass::mutable__instances() {
  // @@protoc_insertion_point(field_mutable_list:DesignObjects.NetListClass._instances)
  return _internal_mutable__instances();
}

// -------------------------------------------------------------------

// DesignObjectSyn

// required uint64 id = 1;
inline bool DesignObjectSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DesignObjectSyn::has_id() const {
  return _internal_has_id();
}
inline void DesignObjectSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t DesignObjectSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t DesignObjectSyn::id() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.id)
  return _internal_id();
}
inline void DesignObjectSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void DesignObjectSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DesignObjects.DesignObjectSyn.id)
}

// required uint32 type = 2;
inline bool DesignObjectSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DesignObjectSyn::has_type() const {
  return _internal_has_type();
}
inline void DesignObjectSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DesignObjectSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t DesignObjectSyn::type() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.type)
  return _internal_type();
}
inline void DesignObjectSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void DesignObjectSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:DesignObjects.DesignObjectSyn.type)
}

// required .DesignObjects.DesignObjectClass parent = 3;
inline bool DesignObjectSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool DesignObjectSyn::has_parent() const {
  return _internal_has_parent();
}
inline void DesignObjectSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DesignObjects::DesignObjectClass& DesignObjectSyn::_internal_parent() const {
  const ::DesignObjects::DesignObjectClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::DesignObjects::DesignObjectClass&>(
      ::DesignObjects::_DesignObjectClass_default_instance_);
}
inline const ::DesignObjects::DesignObjectClass& DesignObjectSyn::parent() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.parent)
  return _internal_parent();
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_parent(
    ::DesignObjects::DesignObjectClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.parent)
}
inline ::DesignObjects::DesignObjectClass* DesignObjectSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DesignObjects::DesignObjectClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DesignObjects::DesignObjectClass* DesignObjectSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DesignObjects::DesignObjectClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::DesignObjects::DesignObjectClass* DesignObjectSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::DesignObjects::DesignObjectClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::DesignObjects::DesignObjectClass* DesignObjectSyn::mutable_parent() {
  ::DesignObjects::DesignObjectClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.parent)
  return _msg;
}
inline void DesignObjectSyn::set_allocated_parent(::DesignObjects::DesignObjectClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.parent)
}

// .DesignObjects.NetClass n = 4;
inline bool DesignObjectSyn::_internal_has_n() const {
  return dos_case() == kN;
}
inline bool DesignObjectSyn::has_n() const {
  return _internal_has_n();
}
inline void DesignObjectSyn::set_has_n() {
  _impl_._oneof_case_[0] = kN;
}
inline void DesignObjectSyn::clear_n() {
  if (_internal_has_n()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dos_.n_;
    }
    clear_has_dos();
  }
}
inline ::DesignObjects::NetClass* DesignObjectSyn::release_n() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.n)
  if (_internal_has_n()) {
    clear_has_dos();
    ::DesignObjects::NetClass* temp = _impl_.dos_.n_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dos_.n_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DesignObjects::NetClass& DesignObjectSyn::_internal_n() const {
  return _internal_has_n()
      ? *_impl_.dos_.n_
      : reinterpret_cast< ::DesignObjects::NetClass&>(::DesignObjects::_NetClass_default_instance_);
}
inline const ::DesignObjects::NetClass& DesignObjectSyn::n() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.n)
  return _internal_n();
}
inline ::DesignObjects::NetClass* DesignObjectSyn::unsafe_arena_release_n() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DesignObjects.DesignObjectSyn.n)
  if (_internal_has_n()) {
    clear_has_dos();
    ::DesignObjects::NetClass* temp = _impl_.dos_.n_;
    _impl_.dos_.n_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_n(::DesignObjects::NetClass* n) {
  clear_dos();
  if (n) {
    set_has_n();
    _impl_.dos_.n_ = n;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.n)
}
inline ::DesignObjects::NetClass* DesignObjectSyn::_internal_mutable_n() {
  if (!_internal_has_n()) {
    clear_dos();
    set_has_n();
    _impl_.dos_.n_ = CreateMaybeMessage< ::DesignObjects::NetClass >(GetArenaForAllocation());
  }
  return _impl_.dos_.n_;
}
inline ::DesignObjects::NetClass* DesignObjectSyn::mutable_n() {
  ::DesignObjects::NetClass* _msg = _internal_mutable_n();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.n)
  return _msg;
}

// .DesignObjects.PinBusClass pib = 5;
inline bool DesignObjectSyn::_internal_has_pib() const {
  return dos_case() == kPib;
}
inline bool DesignObjectSyn::has_pib() const {
  return _internal_has_pib();
}
inline void DesignObjectSyn::set_has_pib() {
  _impl_._oneof_case_[0] = kPib;
}
inline void DesignObjectSyn::clear_pib() {
  if (_internal_has_pib()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dos_.pib_;
    }
    clear_has_dos();
  }
}
inline ::DesignObjects::PinBusClass* DesignObjectSyn::release_pib() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.pib)
  if (_internal_has_pib()) {
    clear_has_dos();
    ::DesignObjects::PinBusClass* temp = _impl_.dos_.pib_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dos_.pib_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DesignObjects::PinBusClass& DesignObjectSyn::_internal_pib() const {
  return _internal_has_pib()
      ? *_impl_.dos_.pib_
      : reinterpret_cast< ::DesignObjects::PinBusClass&>(::DesignObjects::_PinBusClass_default_instance_);
}
inline const ::DesignObjects::PinBusClass& DesignObjectSyn::pib() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.pib)
  return _internal_pib();
}
inline ::DesignObjects::PinBusClass* DesignObjectSyn::unsafe_arena_release_pib() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DesignObjects.DesignObjectSyn.pib)
  if (_internal_has_pib()) {
    clear_has_dos();
    ::DesignObjects::PinBusClass* temp = _impl_.dos_.pib_;
    _impl_.dos_.pib_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_pib(::DesignObjects::PinBusClass* pib) {
  clear_dos();
  if (pib) {
    set_has_pib();
    _impl_.dos_.pib_ = pib;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.pib)
}
inline ::DesignObjects::PinBusClass* DesignObjectSyn::_internal_mutable_pib() {
  if (!_internal_has_pib()) {
    clear_dos();
    set_has_pib();
    _impl_.dos_.pib_ = CreateMaybeMessage< ::DesignObjects::PinBusClass >(GetArenaForAllocation());
  }
  return _impl_.dos_.pib_;
}
inline ::DesignObjects::PinBusClass* DesignObjectSyn::mutable_pib() {
  ::DesignObjects::PinBusClass* _msg = _internal_mutable_pib();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.pib)
  return _msg;
}

// .DesignObjects.PinClass pi = 6;
inline bool DesignObjectSyn::_internal_has_pi() const {
  return dos_case() == kPi;
}
inline bool DesignObjectSyn::has_pi() const {
  return _internal_has_pi();
}
inline void DesignObjectSyn::set_has_pi() {
  _impl_._oneof_case_[0] = kPi;
}
inline void DesignObjectSyn::clear_pi() {
  if (_internal_has_pi()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dos_.pi_;
    }
    clear_has_dos();
  }
}
inline ::DesignObjects::PinClass* DesignObjectSyn::release_pi() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.pi)
  if (_internal_has_pi()) {
    clear_has_dos();
    ::DesignObjects::PinClass* temp = _impl_.dos_.pi_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dos_.pi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DesignObjects::PinClass& DesignObjectSyn::_internal_pi() const {
  return _internal_has_pi()
      ? *_impl_.dos_.pi_
      : reinterpret_cast< ::DesignObjects::PinClass&>(::DesignObjects::_PinClass_default_instance_);
}
inline const ::DesignObjects::PinClass& DesignObjectSyn::pi() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.pi)
  return _internal_pi();
}
inline ::DesignObjects::PinClass* DesignObjectSyn::unsafe_arena_release_pi() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DesignObjects.DesignObjectSyn.pi)
  if (_internal_has_pi()) {
    clear_has_dos();
    ::DesignObjects::PinClass* temp = _impl_.dos_.pi_;
    _impl_.dos_.pi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_pi(::DesignObjects::PinClass* pi) {
  clear_dos();
  if (pi) {
    set_has_pi();
    _impl_.dos_.pi_ = pi;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.pi)
}
inline ::DesignObjects::PinClass* DesignObjectSyn::_internal_mutable_pi() {
  if (!_internal_has_pi()) {
    clear_dos();
    set_has_pi();
    _impl_.dos_.pi_ = CreateMaybeMessage< ::DesignObjects::PinClass >(GetArenaForAllocation());
  }
  return _impl_.dos_.pi_;
}
inline ::DesignObjects::PinClass* DesignObjectSyn::mutable_pi() {
  ::DesignObjects::PinClass* _msg = _internal_mutable_pi();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.pi)
  return _msg;
}

// .DesignObjects.PortClass po = 7;
inline bool DesignObjectSyn::_internal_has_po() const {
  return dos_case() == kPo;
}
inline bool DesignObjectSyn::has_po() const {
  return _internal_has_po();
}
inline void DesignObjectSyn::set_has_po() {
  _impl_._oneof_case_[0] = kPo;
}
inline void DesignObjectSyn::clear_po() {
  if (_internal_has_po()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dos_.po_;
    }
    clear_has_dos();
  }
}
inline ::DesignObjects::PortClass* DesignObjectSyn::release_po() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.po)
  if (_internal_has_po()) {
    clear_has_dos();
    ::DesignObjects::PortClass* temp = _impl_.dos_.po_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dos_.po_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DesignObjects::PortClass& DesignObjectSyn::_internal_po() const {
  return _internal_has_po()
      ? *_impl_.dos_.po_
      : reinterpret_cast< ::DesignObjects::PortClass&>(::DesignObjects::_PortClass_default_instance_);
}
inline const ::DesignObjects::PortClass& DesignObjectSyn::po() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.po)
  return _internal_po();
}
inline ::DesignObjects::PortClass* DesignObjectSyn::unsafe_arena_release_po() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DesignObjects.DesignObjectSyn.po)
  if (_internal_has_po()) {
    clear_has_dos();
    ::DesignObjects::PortClass* temp = _impl_.dos_.po_;
    _impl_.dos_.po_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_po(::DesignObjects::PortClass* po) {
  clear_dos();
  if (po) {
    set_has_po();
    _impl_.dos_.po_ = po;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.po)
}
inline ::DesignObjects::PortClass* DesignObjectSyn::_internal_mutable_po() {
  if (!_internal_has_po()) {
    clear_dos();
    set_has_po();
    _impl_.dos_.po_ = CreateMaybeMessage< ::DesignObjects::PortClass >(GetArenaForAllocation());
  }
  return _impl_.dos_.po_;
}
inline ::DesignObjects::PortClass* DesignObjectSyn::mutable_po() {
  ::DesignObjects::PortClass* _msg = _internal_mutable_po();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.po)
  return _msg;
}

// .DesignObjects.PortBusClass pob = 8;
inline bool DesignObjectSyn::_internal_has_pob() const {
  return dos_case() == kPob;
}
inline bool DesignObjectSyn::has_pob() const {
  return _internal_has_pob();
}
inline void DesignObjectSyn::set_has_pob() {
  _impl_._oneof_case_[0] = kPob;
}
inline void DesignObjectSyn::clear_pob() {
  if (_internal_has_pob()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dos_.pob_;
    }
    clear_has_dos();
  }
}
inline ::DesignObjects::PortBusClass* DesignObjectSyn::release_pob() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.pob)
  if (_internal_has_pob()) {
    clear_has_dos();
    ::DesignObjects::PortBusClass* temp = _impl_.dos_.pob_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dos_.pob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DesignObjects::PortBusClass& DesignObjectSyn::_internal_pob() const {
  return _internal_has_pob()
      ? *_impl_.dos_.pob_
      : reinterpret_cast< ::DesignObjects::PortBusClass&>(::DesignObjects::_PortBusClass_default_instance_);
}
inline const ::DesignObjects::PortBusClass& DesignObjectSyn::pob() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.pob)
  return _internal_pob();
}
inline ::DesignObjects::PortBusClass* DesignObjectSyn::unsafe_arena_release_pob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DesignObjects.DesignObjectSyn.pob)
  if (_internal_has_pob()) {
    clear_has_dos();
    ::DesignObjects::PortBusClass* temp = _impl_.dos_.pob_;
    _impl_.dos_.pob_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_pob(::DesignObjects::PortBusClass* pob) {
  clear_dos();
  if (pob) {
    set_has_pob();
    _impl_.dos_.pob_ = pob;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.pob)
}
inline ::DesignObjects::PortBusClass* DesignObjectSyn::_internal_mutable_pob() {
  if (!_internal_has_pob()) {
    clear_dos();
    set_has_pob();
    _impl_.dos_.pob_ = CreateMaybeMessage< ::DesignObjects::PortBusClass >(GetArenaForAllocation());
  }
  return _impl_.dos_.pob_;
}
inline ::DesignObjects::PortBusClass* DesignObjectSyn::mutable_pob() {
  ::DesignObjects::PortBusClass* _msg = _internal_mutable_pob();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.pob)
  return _msg;
}

// .DesignObjects.InstanceClass i = 9;
inline bool DesignObjectSyn::_internal_has_i() const {
  return dos_case() == kI;
}
inline bool DesignObjectSyn::has_i() const {
  return _internal_has_i();
}
inline void DesignObjectSyn::set_has_i() {
  _impl_._oneof_case_[0] = kI;
}
inline void DesignObjectSyn::clear_i() {
  if (_internal_has_i()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dos_.i_;
    }
    clear_has_dos();
  }
}
inline ::DesignObjects::InstanceClass* DesignObjectSyn::release_i() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.i)
  if (_internal_has_i()) {
    clear_has_dos();
    ::DesignObjects::InstanceClass* temp = _impl_.dos_.i_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dos_.i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DesignObjects::InstanceClass& DesignObjectSyn::_internal_i() const {
  return _internal_has_i()
      ? *_impl_.dos_.i_
      : reinterpret_cast< ::DesignObjects::InstanceClass&>(::DesignObjects::_InstanceClass_default_instance_);
}
inline const ::DesignObjects::InstanceClass& DesignObjectSyn::i() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.i)
  return _internal_i();
}
inline ::DesignObjects::InstanceClass* DesignObjectSyn::unsafe_arena_release_i() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DesignObjects.DesignObjectSyn.i)
  if (_internal_has_i()) {
    clear_has_dos();
    ::DesignObjects::InstanceClass* temp = _impl_.dos_.i_;
    _impl_.dos_.i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_i(::DesignObjects::InstanceClass* i) {
  clear_dos();
  if (i) {
    set_has_i();
    _impl_.dos_.i_ = i;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.i)
}
inline ::DesignObjects::InstanceClass* DesignObjectSyn::_internal_mutable_i() {
  if (!_internal_has_i()) {
    clear_dos();
    set_has_i();
    _impl_.dos_.i_ = CreateMaybeMessage< ::DesignObjects::InstanceClass >(GetArenaForAllocation());
  }
  return _impl_.dos_.i_;
}
inline ::DesignObjects::InstanceClass* DesignObjectSyn::mutable_i() {
  ::DesignObjects::InstanceClass* _msg = _internal_mutable_i();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.i)
  return _msg;
}

// .DesignObjects.NetListClass nl = 10;
inline bool DesignObjectSyn::_internal_has_nl() const {
  return dos_case() == kNl;
}
inline bool DesignObjectSyn::has_nl() const {
  return _internal_has_nl();
}
inline void DesignObjectSyn::set_has_nl() {
  _impl_._oneof_case_[0] = kNl;
}
inline void DesignObjectSyn::clear_nl() {
  if (_internal_has_nl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dos_.nl_;
    }
    clear_has_dos();
  }
}
inline ::DesignObjects::NetListClass* DesignObjectSyn::release_nl() {
  // @@protoc_insertion_point(field_release:DesignObjects.DesignObjectSyn.nl)
  if (_internal_has_nl()) {
    clear_has_dos();
    ::DesignObjects::NetListClass* temp = _impl_.dos_.nl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dos_.nl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DesignObjects::NetListClass& DesignObjectSyn::_internal_nl() const {
  return _internal_has_nl()
      ? *_impl_.dos_.nl_
      : reinterpret_cast< ::DesignObjects::NetListClass&>(::DesignObjects::_NetListClass_default_instance_);
}
inline const ::DesignObjects::NetListClass& DesignObjectSyn::nl() const {
  // @@protoc_insertion_point(field_get:DesignObjects.DesignObjectSyn.nl)
  return _internal_nl();
}
inline ::DesignObjects::NetListClass* DesignObjectSyn::unsafe_arena_release_nl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DesignObjects.DesignObjectSyn.nl)
  if (_internal_has_nl()) {
    clear_has_dos();
    ::DesignObjects::NetListClass* temp = _impl_.dos_.nl_;
    _impl_.dos_.nl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DesignObjectSyn::unsafe_arena_set_allocated_nl(::DesignObjects::NetListClass* nl) {
  clear_dos();
  if (nl) {
    set_has_nl();
    _impl_.dos_.nl_ = nl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DesignObjects.DesignObjectSyn.nl)
}
inline ::DesignObjects::NetListClass* DesignObjectSyn::_internal_mutable_nl() {
  if (!_internal_has_nl()) {
    clear_dos();
    set_has_nl();
    _impl_.dos_.nl_ = CreateMaybeMessage< ::DesignObjects::NetListClass >(GetArenaForAllocation());
  }
  return _impl_.dos_.nl_;
}
inline ::DesignObjects::NetListClass* DesignObjectSyn::mutable_nl() {
  ::DesignObjects::NetListClass* _msg = _internal_mutable_nl();
  // @@protoc_insertion_point(field_mutable:DesignObjects.DesignObjectSyn.nl)
  return _msg;
}

inline bool DesignObjectSyn::has_dos() const {
  return dos_case() != DOS_NOT_SET;
}
inline void DesignObjectSyn::clear_has_dos() {
  _impl_._oneof_case_[0] = DOS_NOT_SET;
}
inline DesignObjectSyn::DosCase DesignObjectSyn::dos_case() const {
  return DesignObjectSyn::DosCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DesignObjects

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DesignObjects::PortDirEnum_PortDir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DesignObjects::PortDirEnum_PortDir>() {
  return ::DesignObjects::PortDirEnum_PortDir_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_DesignObjects_2eproto
