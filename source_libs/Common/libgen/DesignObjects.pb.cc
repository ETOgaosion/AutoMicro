// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DesignObjects.proto

#include "DesignObjects.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace DesignObjects {
PROTOBUF_CONSTEXPR DesignObjectClass::DesignObjectClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DesignObjectClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DesignObjectClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DesignObjectClassDefaultTypeInternal() {}
  union {
    DesignObjectClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DesignObjectClassDefaultTypeInternal _DesignObjectClass_default_instance_;
PROTOBUF_CONSTEXPR NetClass::NetClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._pin_ports_)*/{}
  , /*decltype(_impl_._is_clock_net_)*/false} {}
struct NetClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetClassDefaultTypeInternal() {}
  union {
    NetClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetClassDefaultTypeInternal _NetClass_default_instance_;
PROTOBUF_CONSTEXPR PinBusClass::PinBusClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._pins_)*/{}
  , /*decltype(_impl_.indexes_)*/{}
  , /*decltype(_impl_._left_)*/0u
  , /*decltype(_impl_._right_)*/0u
  , /*decltype(_impl_._size_)*/0u} {}
struct PinBusClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PinBusClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PinBusClassDefaultTypeInternal() {}
  union {
    PinBusClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PinBusClassDefaultTypeInternal _PinBusClass_default_instance_;
PROTOBUF_CONSTEXPR PinClass::PinClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._net_)*/uint64_t{0u}
  , /*decltype(_impl_._cell_port_)*/uint64_t{0u}
  , /*decltype(_impl_._own_instance_)*/uint64_t{0u}
  , /*decltype(_impl_._pin_bus_)*/uint64_t{0u}} {}
struct PinClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PinClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PinClassDefaultTypeInternal() {}
  union {
    PinClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PinClassDefaultTypeInternal _PinClass_default_instance_;
PROTOBUF_CONSTEXPR PortDirEnum::PortDirEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pd_)*/0} {}
struct PortDirEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortDirEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortDirEnumDefaultTypeInternal() {}
  union {
    PortDirEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortDirEnumDefaultTypeInternal _PortDirEnum_default_instance_;
PROTOBUF_CONSTEXPR PortClass::PortClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._caps_)*/{}
  , /*decltype(_impl_._port_dir_)*/nullptr
  , /*decltype(_impl_._net_)*/uint64_t{0u}
  , /*decltype(_impl_._port_bus_)*/uint64_t{0u}} {}
struct PortClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortClassDefaultTypeInternal() {}
  union {
    PortClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortClassDefaultTypeInternal _PortClass_default_instance_;
PROTOBUF_CONSTEXPR PortBusClass::PortBusClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._ports_)*/{}
  , /*decltype(_impl_.indexes_)*/{}
  , /*decltype(_impl_._port_dir_)*/nullptr
  , /*decltype(_impl_._right_)*/uint64_t{0u}
  , /*decltype(_impl_._left_)*/0u
  , /*decltype(_impl_._size_)*/0u} {}
struct PortBusClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortBusClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortBusClassDefaultTypeInternal() {}
  union {
    PortBusClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortBusClassDefaultTypeInternal _PortBusClass_default_instance_;
PROTOBUF_CONSTEXPR InstanceClass::InstanceClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._pins_)*/{}
  , /*decltype(_impl_._pins_bus_)*/{}
  , /*decltype(_impl_._inst_cell_)*/uint64_t{0u}} {}
struct InstanceClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstanceClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstanceClassDefaultTypeInternal() {}
  union {
    InstanceClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstanceClassDefaultTypeInternal _InstanceClass_default_instance_;
PROTOBUF_CONSTEXPR NetListClass::NetListClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._ports_)*/{}
  , /*decltype(_impl_._port_buses_)*/{}
  , /*decltype(_impl_._nets_)*/{}
  , /*decltype(_impl_._instances_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetListClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetListClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetListClassDefaultTypeInternal() {}
  union {
    NetListClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetListClassDefaultTypeInternal _NetListClass_default_instance_;
PROTOBUF_CONSTEXPR DesignObjectSyn::DesignObjectSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.dos_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DesignObjectSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DesignObjectSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DesignObjectSynDefaultTypeInternal() {}
  union {
    DesignObjectSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DesignObjectSynDefaultTypeInternal _DesignObjectSyn_default_instance_;
}  // namespace DesignObjects
static ::_pb::Metadata file_level_metadata_DesignObjects_2eproto[10];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_DesignObjects_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_DesignObjects_2eproto = nullptr;

const uint32_t TableStruct_DesignObjects_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectClass, _impl_._name_),
  0,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetClass, _impl_._is_clock_net_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetClass, _impl_._pin_ports_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinBusClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinBusClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinBusClass, _impl_._left_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinBusClass, _impl_._right_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinBusClass, _impl_._pins_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinBusClass, _impl_.indexes_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinBusClass, _impl_._size_),
  0,
  1,
  ~0u,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinClass, _impl_._net_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinClass, _impl_._cell_port_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinClass, _impl_._own_instance_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PinClass, _impl_._pin_bus_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortDirEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortDirEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortDirEnum, _impl_.pd_),
  0,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortClass, _impl_._caps_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortClass, _impl_._port_dir_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortClass, _impl_._net_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortClass, _impl_._port_bus_),
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _impl_._left_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _impl_._right_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _impl_._port_dir_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _impl_._ports_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _impl_.indexes_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::PortBusClass, _impl_._size_),
  2,
  1,
  0,
  ~0u,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::InstanceClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::InstanceClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::InstanceClass, _impl_._inst_cell_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::InstanceClass, _impl_._pins_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::InstanceClass, _impl_._pins_bus_),
  0,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetListClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetListClass, _impl_._ports_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetListClass, _impl_._port_buses_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetListClass, _impl_._nets_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::NetListClass, _impl_._instances_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::DesignObjects::DesignObjectSyn, _impl_.dos_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::DesignObjects::DesignObjectClass)},
  { 8, 16, -1, sizeof(::DesignObjects::NetClass)},
  { 18, 29, -1, sizeof(::DesignObjects::PinBusClass)},
  { 34, 44, -1, sizeof(::DesignObjects::PinClass)},
  { 48, 55, -1, sizeof(::DesignObjects::PortDirEnum)},
  { 56, 66, -1, sizeof(::DesignObjects::PortClass)},
  { 70, 82, -1, sizeof(::DesignObjects::PortBusClass)},
  { 88, 97, -1, sizeof(::DesignObjects::InstanceClass)},
  { 100, -1, -1, sizeof(::DesignObjects::NetListClass)},
  { 110, 127, -1, sizeof(::DesignObjects::DesignObjectSyn)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::DesignObjects::_DesignObjectClass_default_instance_._instance,
  &::DesignObjects::_NetClass_default_instance_._instance,
  &::DesignObjects::_PinBusClass_default_instance_._instance,
  &::DesignObjects::_PinClass_default_instance_._instance,
  &::DesignObjects::_PortDirEnum_default_instance_._instance,
  &::DesignObjects::_PortClass_default_instance_._instance,
  &::DesignObjects::_PortBusClass_default_instance_._instance,
  &::DesignObjects::_InstanceClass_default_instance_._instance,
  &::DesignObjects::_NetListClass_default_instance_._instance,
  &::DesignObjects::_DesignObjectSyn_default_instance_._instance,
};

const char descriptor_table_protodef_DesignObjects_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023DesignObjects.proto\022\rDesignObjects\032\021Co"
  "mmonTypes.proto\"\"\n\021DesignObjectClass\022\r\n\005"
  "_name\030\001 \002(\t\"5\n\010NetClass\022\025\n\r_is_clock_net"
  "\030\001 \002(\010\022\022\n\n_pin_ports\030\002 \003(\004\"[\n\013PinBusClas"
  "s\022\r\n\005_left\030\001 \002(\r\022\016\n\006_right\030\002 \002(\r\022\r\n\005_pin"
  "s\030\003 \003(\004\022\017\n\007indexes\030\004 \003(\r\022\r\n\005_size\030\005 \002(\r\""
  "U\n\010PinClass\022\014\n\004_net\030\001 \002(\004\022\022\n\n_cell_port\030"
  "\002 \002(\004\022\025\n\r_own_instance\030\003 \002(\004\022\020\n\010_pin_bus"
  "\030\004 \002(\004\"s\n\013PortDirEnum\022.\n\002pd\030\001 \002(\0162\".Desi"
  "gnObjects.PortDirEnum.PortDir\"4\n\007PortDir"
  "\022\007\n\003kIn\020\000\022\010\n\004kOut\020\001\022\n\n\006kInOut\020\002\022\n\n\006kOthe"
  "r\020\003\"\220\001\n\tPortClass\0223\n\005_caps\030\001 \003(\0132$.Commo"
  "n.Types.ModeTransPairMapDouble\022-\n\t_port_"
  "dir\030\002 \002(\0132\032.DesignObjects.PortDirEnum\022\014\n"
  "\004_net\030\003 \001(\004\022\021\n\t_port_bus\030\004 \002(\004\"\214\001\n\014PortB"
  "usClass\022\r\n\005_left\030\001 \002(\r\022\016\n\006_right\030\002 \002(\004\022-"
  "\n\t_port_dir\030\003 \002(\0132\032.DesignObjects.PortDi"
  "rEnum\022\016\n\006_ports\030\004 \003(\004\022\017\n\007indexes\030\005 \003(\r\022\r"
  "\n\005_size\030\006 \002(\r\"E\n\rInstanceClass\022\022\n\n_inst_"
  "cell\030\001 \002(\004\022\r\n\005_pins\030\002 \003(\004\022\021\n\t_pins_bus\030\003"
  " \003(\004\"V\n\014NetListClass\022\016\n\006_ports\030\001 \003(\004\022\023\n\013"
  "_port_buses\030\002 \003(\004\022\r\n\005_nets\030\003 \003(\004\022\022\n\n_ins"
  "tances\030\004 \003(\004\"\206\003\n\017DesignObjectSyn\022\n\n\002id\030\001"
  " \002(\004\022\014\n\004type\030\002 \002(\r\0220\n\006parent\030\003 \002(\0132 .Des"
  "ignObjects.DesignObjectClass\022$\n\001n\030\004 \001(\0132"
  "\027.DesignObjects.NetClassH\000\022)\n\003pib\030\005 \001(\0132"
  "\032.DesignObjects.PinBusClassH\000\022%\n\002pi\030\006 \001("
  "\0132\027.DesignObjects.PinClassH\000\022&\n\002po\030\007 \001(\013"
  "2\030.DesignObjects.PortClassH\000\022*\n\003pob\030\010 \001("
  "\0132\033.DesignObjects.PortBusClassH\000\022)\n\001i\030\t "
  "\001(\0132\034.DesignObjects.InstanceClassH\000\022)\n\002n"
  "l\030\n \001(\0132\033.DesignObjects.NetListClassH\000B\005"
  "\n\003dos2X\n\024DesignObjectsService\022@\n\nlinkDes"
  "ign\022\032.Common.Types.StrStrIntSet\032\026.Common"
  ".Types.ULongMsg"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_DesignObjects_2eproto_deps[1] = {
  &::descriptor_table_CommonTypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_DesignObjects_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_DesignObjects_2eproto = {
    false, false, 1375, descriptor_table_protodef_DesignObjects_2eproto,
    "DesignObjects.proto",
    &descriptor_table_DesignObjects_2eproto_once, descriptor_table_DesignObjects_2eproto_deps, 1, 10,
    schemas, file_default_instances, TableStruct_DesignObjects_2eproto::offsets,
    file_level_metadata_DesignObjects_2eproto, file_level_enum_descriptors_DesignObjects_2eproto,
    file_level_service_descriptors_DesignObjects_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_DesignObjects_2eproto_getter() {
  return &descriptor_table_DesignObjects_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_DesignObjects_2eproto(&descriptor_table_DesignObjects_2eproto);
namespace DesignObjects {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortDirEnum_PortDir_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_DesignObjects_2eproto);
  return file_level_enum_descriptors_DesignObjects_2eproto[0];
}
bool PortDirEnum_PortDir_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PortDirEnum_PortDir PortDirEnum::kIn;
constexpr PortDirEnum_PortDir PortDirEnum::kOut;
constexpr PortDirEnum_PortDir PortDirEnum::kInOut;
constexpr PortDirEnum_PortDir PortDirEnum::kOther;
constexpr PortDirEnum_PortDir PortDirEnum::PortDir_MIN;
constexpr PortDirEnum_PortDir PortDirEnum::PortDir_MAX;
constexpr int PortDirEnum::PortDir_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class DesignObjectClass::_Internal {
 public:
  using HasBits = decltype(std::declval<DesignObjectClass>()._impl_._has_bits_);
  static void set_has__name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DesignObjectClass::DesignObjectClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.DesignObjectClass)
}
DesignObjectClass::DesignObjectClass(const DesignObjectClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DesignObjectClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__name()) {
    _this->_impl_._name_.Set(from._internal__name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:DesignObjects.DesignObjectClass)
}

inline void DesignObjectClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._name_){}
  };
  _impl_._name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DesignObjectClass::~DesignObjectClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.DesignObjectClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DesignObjectClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._name_.Destroy();
}

void DesignObjectClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DesignObjectClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.DesignObjectClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DesignObjectClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "DesignObjects.DesignObjectClass._name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DesignObjectClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.DesignObjectClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__name().data(), static_cast<int>(this->_internal__name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "DesignObjects.DesignObjectClass._name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.DesignObjectClass)
  return target;
}

size_t DesignObjectClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.DesignObjectClass)
  size_t total_size = 0;

  // required string _name = 1;
  if (_internal_has__name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DesignObjectClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DesignObjectClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DesignObjectClass::GetClassData() const { return &_class_data_; }


void DesignObjectClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DesignObjectClass*>(&to_msg);
  auto& from = static_cast<const DesignObjectClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.DesignObjectClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__name()) {
    _this->_internal_set__name(from._internal__name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DesignObjectClass::CopyFrom(const DesignObjectClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.DesignObjectClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DesignObjectClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DesignObjectClass::InternalSwap(DesignObjectClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._name_, lhs_arena,
      &other->_impl_._name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DesignObjectClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[0]);
}

// ===================================================================

class NetClass::_Internal {
 public:
  using HasBits = decltype(std::declval<NetClass>()._impl_._has_bits_);
  static void set_has__is_clock_net(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

NetClass::NetClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.NetClass)
}
NetClass::NetClass(const NetClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NetClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._pin_ports_){from._impl_._pin_ports_}
    , decltype(_impl_._is_clock_net_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._is_clock_net_ = from._impl_._is_clock_net_;
  // @@protoc_insertion_point(copy_constructor:DesignObjects.NetClass)
}

inline void NetClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._pin_ports_){arena}
    , decltype(_impl_._is_clock_net_){false}
  };
}

NetClass::~NetClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.NetClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._pin_ports_.~RepeatedField();
}

void NetClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.NetClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._pin_ports_.Clear();
  _impl_._is_clock_net_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NetClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool _is_clock_net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__is_clock_net(&has_bits);
          _impl_._is_clock_net_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _pin_ports = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__pin_ports(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__pin_ports(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.NetClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool _is_clock_net = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal__is_clock_net(), target);
  }

  // repeated uint64 _pin_ports = 2;
  for (int i = 0, n = this->_internal__pin_ports_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__pin_ports(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.NetClass)
  return target;
}

size_t NetClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.NetClass)
  size_t total_size = 0;

  // required bool _is_clock_net = 1;
  if (_internal_has__is_clock_net()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _pin_ports = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._pin_ports_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__pin_ports_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NetClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NetClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NetClass::GetClassData() const { return &_class_data_; }


void NetClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NetClass*>(&to_msg);
  auto& from = static_cast<const NetClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.NetClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._pin_ports_.MergeFrom(from._impl_._pin_ports_);
  if (from._internal_has__is_clock_net()) {
    _this->_internal_set__is_clock_net(from._internal__is_clock_net());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NetClass::CopyFrom(const NetClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.NetClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void NetClass::InternalSwap(NetClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._pin_ports_.InternalSwap(&other->_impl_._pin_ports_);
  swap(_impl_._is_clock_net_, other->_impl_._is_clock_net_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NetClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[1]);
}

// ===================================================================

class PinBusClass::_Internal {
 public:
  using HasBits = decltype(std::declval<PinBusClass>()._impl_._has_bits_);
  static void set_has__left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

PinBusClass::PinBusClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.PinBusClass)
}
PinBusClass::PinBusClass(const PinBusClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PinBusClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._pins_){from._impl_._pins_}
    , decltype(_impl_.indexes_){from._impl_.indexes_}
    , decltype(_impl_._left_){}
    , decltype(_impl_._right_){}
    , decltype(_impl_._size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._left_, &from._impl_._left_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._size_) -
    reinterpret_cast<char*>(&_impl_._left_)) + sizeof(_impl_._size_));
  // @@protoc_insertion_point(copy_constructor:DesignObjects.PinBusClass)
}

inline void PinBusClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._pins_){arena}
    , decltype(_impl_.indexes_){arena}
    , decltype(_impl_._left_){0u}
    , decltype(_impl_._right_){0u}
    , decltype(_impl_._size_){0u}
  };
}

PinBusClass::~PinBusClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.PinBusClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PinBusClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._pins_.~RepeatedField();
  _impl_.indexes_.~RepeatedField();
}

void PinBusClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PinBusClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.PinBusClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._pins_.Clear();
  _impl_.indexes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_._left_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._size_) -
        reinterpret_cast<char*>(&_impl_._left_)) + sizeof(_impl_._size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PinBusClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 _left = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__left(&has_bits);
          _impl_._left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _right = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__right(&has_bits);
          _impl_._right_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _pins = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__pins(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__pins(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 indexes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_indexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_indexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__size(&has_bits);
          _impl_._size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PinBusClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.PinBusClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 _left = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal__left(), target);
  }

  // required uint32 _right = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal__right(), target);
  }

  // repeated uint64 _pins = 3;
  for (int i = 0, n = this->_internal__pins_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__pins(i), target);
  }

  // repeated uint32 indexes = 4;
  for (int i = 0, n = this->_internal_indexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_indexes(i), target);
  }

  // required uint32 _size = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal__size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.PinBusClass)
  return target;
}

size_t PinBusClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DesignObjects.PinBusClass)
  size_t total_size = 0;

  if (_internal_has__left()) {
    // required uint32 _left = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__left());
  }

  if (_internal_has__right()) {
    // required uint32 _right = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__right());
  }

  if (_internal_has__size()) {
    // required uint32 _size = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__size());
  }

  return total_size;
}
size_t PinBusClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.PinBusClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 _left = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__left());

    // required uint32 _right = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__right());

    // required uint32 _size = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _pins = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._pins_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__pins_size());
    total_size += data_size;
  }

  // repeated uint32 indexes = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.indexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_indexes_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PinBusClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PinBusClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PinBusClass::GetClassData() const { return &_class_data_; }


void PinBusClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PinBusClass*>(&to_msg);
  auto& from = static_cast<const PinBusClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.PinBusClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._pins_.MergeFrom(from._impl_._pins_);
  _this->_impl_.indexes_.MergeFrom(from._impl_.indexes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._left_ = from._impl_._left_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._right_ = from._impl_._right_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._size_ = from._impl_._size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PinBusClass::CopyFrom(const PinBusClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.PinBusClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinBusClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PinBusClass::InternalSwap(PinBusClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._pins_.InternalSwap(&other->_impl_._pins_);
  _impl_.indexes_.InternalSwap(&other->_impl_.indexes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PinBusClass, _impl_._size_)
      + sizeof(PinBusClass::_impl_._size_)
      - PROTOBUF_FIELD_OFFSET(PinBusClass, _impl_._left_)>(
          reinterpret_cast<char*>(&_impl_._left_),
          reinterpret_cast<char*>(&other->_impl_._left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PinBusClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[2]);
}

// ===================================================================

class PinClass::_Internal {
 public:
  using HasBits = decltype(std::declval<PinClass>()._impl_._has_bits_);
  static void set_has__net(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__cell_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__own_instance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__pin_bus(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

PinClass::PinClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.PinClass)
}
PinClass::PinClass(const PinClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PinClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._net_){}
    , decltype(_impl_._cell_port_){}
    , decltype(_impl_._own_instance_){}
    , decltype(_impl_._pin_bus_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._net_, &from._impl_._net_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._pin_bus_) -
    reinterpret_cast<char*>(&_impl_._net_)) + sizeof(_impl_._pin_bus_));
  // @@protoc_insertion_point(copy_constructor:DesignObjects.PinClass)
}

inline void PinClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._net_){uint64_t{0u}}
    , decltype(_impl_._cell_port_){uint64_t{0u}}
    , decltype(_impl_._own_instance_){uint64_t{0u}}
    , decltype(_impl_._pin_bus_){uint64_t{0u}}
  };
}

PinClass::~PinClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.PinClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PinClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PinClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PinClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.PinClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_._net_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._pin_bus_) -
        reinterpret_cast<char*>(&_impl_._net_)) + sizeof(_impl_._pin_bus_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PinClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 _net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__net(&has_bits);
          _impl_._net_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _cell_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__cell_port(&has_bits);
          _impl_._cell_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _own_instance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__own_instance(&has_bits);
          _impl_._own_instance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _pin_bus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__pin_bus(&has_bits);
          _impl_._pin_bus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PinClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.PinClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 _net = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__net(), target);
  }

  // required uint64 _cell_port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__cell_port(), target);
  }

  // required uint64 _own_instance = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__own_instance(), target);
  }

  // required uint64 _pin_bus = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__pin_bus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.PinClass)
  return target;
}

size_t PinClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DesignObjects.PinClass)
  size_t total_size = 0;

  if (_internal_has__net()) {
    // required uint64 _net = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__net());
  }

  if (_internal_has__cell_port()) {
    // required uint64 _cell_port = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__cell_port());
  }

  if (_internal_has__own_instance()) {
    // required uint64 _own_instance = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__own_instance());
  }

  if (_internal_has__pin_bus()) {
    // required uint64 _pin_bus = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__pin_bus());
  }

  return total_size;
}
size_t PinClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.PinClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint64 _net = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__net());

    // required uint64 _cell_port = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__cell_port());

    // required uint64 _own_instance = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__own_instance());

    // required uint64 _pin_bus = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__pin_bus());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PinClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PinClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PinClass::GetClassData() const { return &_class_data_; }


void PinClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PinClass*>(&to_msg);
  auto& from = static_cast<const PinClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.PinClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._net_ = from._impl_._net_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._cell_port_ = from._impl_._cell_port_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._own_instance_ = from._impl_._own_instance_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._pin_bus_ = from._impl_._pin_bus_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PinClass::CopyFrom(const PinClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.PinClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PinClass::InternalSwap(PinClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PinClass, _impl_._pin_bus_)
      + sizeof(PinClass::_impl_._pin_bus_)
      - PROTOBUF_FIELD_OFFSET(PinClass, _impl_._net_)>(
          reinterpret_cast<char*>(&_impl_._net_),
          reinterpret_cast<char*>(&other->_impl_._net_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PinClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[3]);
}

// ===================================================================

class PortDirEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<PortDirEnum>()._impl_._has_bits_);
  static void set_has_pd(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

PortDirEnum::PortDirEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.PortDirEnum)
}
PortDirEnum::PortDirEnum(const PortDirEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortDirEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pd_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.pd_ = from._impl_.pd_;
  // @@protoc_insertion_point(copy_constructor:DesignObjects.PortDirEnum)
}

inline void PortDirEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pd_){0}
  };
}

PortDirEnum::~PortDirEnum() {
  // @@protoc_insertion_point(destructor:DesignObjects.PortDirEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortDirEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PortDirEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortDirEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.PortDirEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pd_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortDirEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .DesignObjects.PortDirEnum.PortDir pd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DesignObjects::PortDirEnum_PortDir_IsValid(val))) {
            _internal_set_pd(static_cast<::DesignObjects::PortDirEnum_PortDir>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PortDirEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.PortDirEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .DesignObjects.PortDirEnum.PortDir pd = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.PortDirEnum)
  return target;
}

size_t PortDirEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.PortDirEnum)
  size_t total_size = 0;

  // required .DesignObjects.PortDirEnum.PortDir pd = 1;
  if (_internal_has_pd()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pd());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortDirEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortDirEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortDirEnum::GetClassData() const { return &_class_data_; }


void PortDirEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortDirEnum*>(&to_msg);
  auto& from = static_cast<const PortDirEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.PortDirEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pd()) {
    _this->_internal_set_pd(from._internal_pd());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortDirEnum::CopyFrom(const PortDirEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.PortDirEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortDirEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PortDirEnum::InternalSwap(PortDirEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.pd_, other->_impl_.pd_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortDirEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[4]);
}

// ===================================================================

class PortClass::_Internal {
 public:
  using HasBits = decltype(std::declval<PortClass>()._impl_._has_bits_);
  static const ::DesignObjects::PortDirEnum& _port_dir(const PortClass* msg);
  static void set_has__port_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__net(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__port_bus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::DesignObjects::PortDirEnum&
PortClass::_Internal::_port_dir(const PortClass* msg) {
  return *msg->_impl_._port_dir_;
}
void PortClass::clear__caps() {
  _impl_._caps_.Clear();
}
PortClass::PortClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.PortClass)
}
PortClass::PortClass(const PortClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._caps_){from._impl_._caps_}
    , decltype(_impl_._port_dir_){nullptr}
    , decltype(_impl_._net_){}
    , decltype(_impl_._port_bus_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has__port_dir()) {
    _this->_impl_._port_dir_ = new ::DesignObjects::PortDirEnum(*from._impl_._port_dir_);
  }
  ::memcpy(&_impl_._net_, &from._impl_._net_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._port_bus_) -
    reinterpret_cast<char*>(&_impl_._net_)) + sizeof(_impl_._port_bus_));
  // @@protoc_insertion_point(copy_constructor:DesignObjects.PortClass)
}

inline void PortClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._caps_){arena}
    , decltype(_impl_._port_dir_){nullptr}
    , decltype(_impl_._net_){uint64_t{0u}}
    , decltype(_impl_._port_bus_){uint64_t{0u}}
  };
}

PortClass::~PortClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.PortClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._caps_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_._port_dir_;
}

void PortClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.PortClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._caps_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_._port_dir_ != nullptr);
    _impl_._port_dir_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_._net_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._port_bus_) -
        reinterpret_cast<char*>(&_impl_._net_)) + sizeof(_impl_._port_bus_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Common.Types.ModeTransPairMapDouble _caps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__caps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .DesignObjects.PortDirEnum _port_dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable__port_dir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _net = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__net(&has_bits);
          _impl_._net_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _port_bus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__port_bus(&has_bits);
          _impl_._port_bus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PortClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.PortClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Common.Types.ModeTransPairMapDouble _caps = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__caps_size()); i < n; i++) {
    const auto& repfield = this->_internal__caps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required .DesignObjects.PortDirEnum _port_dir = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::_port_dir(this),
        _Internal::_port_dir(this).GetCachedSize(), target, stream);
  }

  // optional uint64 _net = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__net(), target);
  }

  // required uint64 _port_bus = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__port_bus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.PortClass)
  return target;
}

size_t PortClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DesignObjects.PortClass)
  size_t total_size = 0;

  if (_internal_has__port_dir()) {
    // required .DesignObjects.PortDirEnum _port_dir = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._port_dir_);
  }

  if (_internal_has__port_bus()) {
    // required uint64 _port_bus = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__port_bus());
  }

  return total_size;
}
size_t PortClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.PortClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .DesignObjects.PortDirEnum _port_dir = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._port_dir_);

    // required uint64 _port_bus = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__port_bus());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Common.Types.ModeTransPairMapDouble _caps = 1;
  total_size += 1UL * this->_internal__caps_size();
  for (const auto& msg : this->_impl_._caps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 _net = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__net());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortClass::GetClassData() const { return &_class_data_; }


void PortClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortClass*>(&to_msg);
  auto& from = static_cast<const PortClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.PortClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._caps_.MergeFrom(from._impl_._caps_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable__port_dir()->::DesignObjects::PortDirEnum::MergeFrom(
          from._internal__port_dir());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._net_ = from._impl_._net_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._port_bus_ = from._impl_._port_bus_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortClass::CopyFrom(const PortClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.PortClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_._caps_))
    return false;
  if (_internal_has__port_dir()) {
    if (!_impl_._port_dir_->IsInitialized()) return false;
  }
  return true;
}

void PortClass::InternalSwap(PortClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._caps_.InternalSwap(&other->_impl_._caps_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PortClass, _impl_._port_bus_)
      + sizeof(PortClass::_impl_._port_bus_)
      - PROTOBUF_FIELD_OFFSET(PortClass, _impl_._port_dir_)>(
          reinterpret_cast<char*>(&_impl_._port_dir_),
          reinterpret_cast<char*>(&other->_impl_._port_dir_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PortClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[5]);
}

// ===================================================================

class PortBusClass::_Internal {
 public:
  using HasBits = decltype(std::declval<PortBusClass>()._impl_._has_bits_);
  static void set_has__left(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::DesignObjects::PortDirEnum& _port_dir(const PortBusClass* msg);
  static void set_has__port_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::DesignObjects::PortDirEnum&
PortBusClass::_Internal::_port_dir(const PortBusClass* msg) {
  return *msg->_impl_._port_dir_;
}
PortBusClass::PortBusClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.PortBusClass)
}
PortBusClass::PortBusClass(const PortBusClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortBusClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._ports_){from._impl_._ports_}
    , decltype(_impl_.indexes_){from._impl_.indexes_}
    , decltype(_impl_._port_dir_){nullptr}
    , decltype(_impl_._right_){}
    , decltype(_impl_._left_){}
    , decltype(_impl_._size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has__port_dir()) {
    _this->_impl_._port_dir_ = new ::DesignObjects::PortDirEnum(*from._impl_._port_dir_);
  }
  ::memcpy(&_impl_._right_, &from._impl_._right_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._size_) -
    reinterpret_cast<char*>(&_impl_._right_)) + sizeof(_impl_._size_));
  // @@protoc_insertion_point(copy_constructor:DesignObjects.PortBusClass)
}

inline void PortBusClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._ports_){arena}
    , decltype(_impl_.indexes_){arena}
    , decltype(_impl_._port_dir_){nullptr}
    , decltype(_impl_._right_){uint64_t{0u}}
    , decltype(_impl_._left_){0u}
    , decltype(_impl_._size_){0u}
  };
}

PortBusClass::~PortBusClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.PortBusClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortBusClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._ports_.~RepeatedField();
  _impl_.indexes_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_._port_dir_;
}

void PortBusClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortBusClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.PortBusClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._ports_.Clear();
  _impl_.indexes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_._port_dir_ != nullptr);
    _impl_._port_dir_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_._right_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._size_) -
        reinterpret_cast<char*>(&_impl_._right_)) + sizeof(_impl_._size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortBusClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 _left = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__left(&has_bits);
          _impl_._left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _right = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__right(&has_bits);
          _impl_._right_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .DesignObjects.PortDirEnum _port_dir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable__port_dir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _ports = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__ports(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__ports(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 indexes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_indexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_indexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has__size(&has_bits);
          _impl_._size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PortBusClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.PortBusClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 _left = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal__left(), target);
  }

  // required uint64 _right = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__right(), target);
  }

  // required .DesignObjects.PortDirEnum _port_dir = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::_port_dir(this),
        _Internal::_port_dir(this).GetCachedSize(), target, stream);
  }

  // repeated uint64 _ports = 4;
  for (int i = 0, n = this->_internal__ports_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__ports(i), target);
  }

  // repeated uint32 indexes = 5;
  for (int i = 0, n = this->_internal_indexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_indexes(i), target);
  }

  // required uint32 _size = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal__size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.PortBusClass)
  return target;
}

size_t PortBusClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DesignObjects.PortBusClass)
  size_t total_size = 0;

  if (_internal_has__port_dir()) {
    // required .DesignObjects.PortDirEnum _port_dir = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._port_dir_);
  }

  if (_internal_has__right()) {
    // required uint64 _right = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__right());
  }

  if (_internal_has__left()) {
    // required uint32 _left = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__left());
  }

  if (_internal_has__size()) {
    // required uint32 _size = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__size());
  }

  return total_size;
}
size_t PortBusClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.PortBusClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .DesignObjects.PortDirEnum _port_dir = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._port_dir_);

    // required uint64 _right = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__right());

    // required uint32 _left = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__left());

    // required uint32 _size = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _ports = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._ports_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__ports_size());
    total_size += data_size;
  }

  // repeated uint32 indexes = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.indexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_indexes_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortBusClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortBusClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortBusClass::GetClassData() const { return &_class_data_; }


void PortBusClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortBusClass*>(&to_msg);
  auto& from = static_cast<const PortBusClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.PortBusClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._ports_.MergeFrom(from._impl_._ports_);
  _this->_impl_.indexes_.MergeFrom(from._impl_.indexes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable__port_dir()->::DesignObjects::PortDirEnum::MergeFrom(
          from._internal__port_dir());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._right_ = from._impl_._right_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._left_ = from._impl_._left_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._size_ = from._impl_._size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortBusClass::CopyFrom(const PortBusClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.PortBusClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortBusClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__port_dir()) {
    if (!_impl_._port_dir_->IsInitialized()) return false;
  }
  return true;
}

void PortBusClass::InternalSwap(PortBusClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._ports_.InternalSwap(&other->_impl_._ports_);
  _impl_.indexes_.InternalSwap(&other->_impl_.indexes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PortBusClass, _impl_._size_)
      + sizeof(PortBusClass::_impl_._size_)
      - PROTOBUF_FIELD_OFFSET(PortBusClass, _impl_._port_dir_)>(
          reinterpret_cast<char*>(&_impl_._port_dir_),
          reinterpret_cast<char*>(&other->_impl_._port_dir_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PortBusClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[6]);
}

// ===================================================================

class InstanceClass::_Internal {
 public:
  using HasBits = decltype(std::declval<InstanceClass>()._impl_._has_bits_);
  static void set_has__inst_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

InstanceClass::InstanceClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.InstanceClass)
}
InstanceClass::InstanceClass(const InstanceClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstanceClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._pins_){from._impl_._pins_}
    , decltype(_impl_._pins_bus_){from._impl_._pins_bus_}
    , decltype(_impl_._inst_cell_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._inst_cell_ = from._impl_._inst_cell_;
  // @@protoc_insertion_point(copy_constructor:DesignObjects.InstanceClass)
}

inline void InstanceClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._pins_){arena}
    , decltype(_impl_._pins_bus_){arena}
    , decltype(_impl_._inst_cell_){uint64_t{0u}}
  };
}

InstanceClass::~InstanceClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.InstanceClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstanceClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._pins_.~RepeatedField();
  _impl_._pins_bus_.~RepeatedField();
}

void InstanceClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstanceClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.InstanceClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._pins_.Clear();
  _impl_._pins_bus_.Clear();
  _impl_._inst_cell_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstanceClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 _inst_cell = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__inst_cell(&has_bits);
          _impl_._inst_cell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _pins = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__pins(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__pins(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _pins_bus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__pins_bus(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__pins_bus(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstanceClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.InstanceClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 _inst_cell = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__inst_cell(), target);
  }

  // repeated uint64 _pins = 2;
  for (int i = 0, n = this->_internal__pins_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__pins(i), target);
  }

  // repeated uint64 _pins_bus = 3;
  for (int i = 0, n = this->_internal__pins_bus_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__pins_bus(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.InstanceClass)
  return target;
}

size_t InstanceClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.InstanceClass)
  size_t total_size = 0;

  // required uint64 _inst_cell = 1;
  if (_internal_has__inst_cell()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__inst_cell());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _pins = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._pins_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__pins_size());
    total_size += data_size;
  }

  // repeated uint64 _pins_bus = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._pins_bus_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__pins_bus_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstanceClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstanceClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstanceClass::GetClassData() const { return &_class_data_; }


void InstanceClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstanceClass*>(&to_msg);
  auto& from = static_cast<const InstanceClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.InstanceClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._pins_.MergeFrom(from._impl_._pins_);
  _this->_impl_._pins_bus_.MergeFrom(from._impl_._pins_bus_);
  if (from._internal_has__inst_cell()) {
    _this->_internal_set__inst_cell(from._internal__inst_cell());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstanceClass::CopyFrom(const InstanceClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.InstanceClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstanceClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void InstanceClass::InternalSwap(InstanceClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._pins_.InternalSwap(&other->_impl_._pins_);
  _impl_._pins_bus_.InternalSwap(&other->_impl_._pins_bus_);
  swap(_impl_._inst_cell_, other->_impl_._inst_cell_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InstanceClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[7]);
}

// ===================================================================

class NetListClass::_Internal {
 public:
};

NetListClass::NetListClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.NetListClass)
}
NetListClass::NetListClass(const NetListClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NetListClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._ports_){from._impl_._ports_}
    , decltype(_impl_._port_buses_){from._impl_._port_buses_}
    , decltype(_impl_._nets_){from._impl_._nets_}
    , decltype(_impl_._instances_){from._impl_._instances_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DesignObjects.NetListClass)
}

inline void NetListClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._ports_){arena}
    , decltype(_impl_._port_buses_){arena}
    , decltype(_impl_._nets_){arena}
    , decltype(_impl_._instances_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NetListClass::~NetListClass() {
  // @@protoc_insertion_point(destructor:DesignObjects.NetListClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetListClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._ports_.~RepeatedField();
  _impl_._port_buses_.~RepeatedField();
  _impl_._nets_.~RepeatedField();
  _impl_._instances_.~RepeatedField();
}

void NetListClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetListClass::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.NetListClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._ports_.Clear();
  _impl_._port_buses_.Clear();
  _impl_._nets_.Clear();
  _impl_._instances_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NetListClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 _ports = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__ports(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__ports(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _port_buses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__port_buses(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__port_buses(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _nets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__nets(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__nets(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _instances = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__instances(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__instances(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetListClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.NetListClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 _ports = 1;
  for (int i = 0, n = this->_internal__ports_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__ports(i), target);
  }

  // repeated uint64 _port_buses = 2;
  for (int i = 0, n = this->_internal__port_buses_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__port_buses(i), target);
  }

  // repeated uint64 _nets = 3;
  for (int i = 0, n = this->_internal__nets_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__nets(i), target);
  }

  // repeated uint64 _instances = 4;
  for (int i = 0, n = this->_internal__instances_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__instances(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.NetListClass)
  return target;
}

size_t NetListClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.NetListClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _ports = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._ports_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__ports_size());
    total_size += data_size;
  }

  // repeated uint64 _port_buses = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._port_buses_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__port_buses_size());
    total_size += data_size;
  }

  // repeated uint64 _nets = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._nets_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__nets_size());
    total_size += data_size;
  }

  // repeated uint64 _instances = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._instances_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__instances_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NetListClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NetListClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NetListClass::GetClassData() const { return &_class_data_; }


void NetListClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NetListClass*>(&to_msg);
  auto& from = static_cast<const NetListClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.NetListClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._ports_.MergeFrom(from._impl_._ports_);
  _this->_impl_._port_buses_.MergeFrom(from._impl_._port_buses_);
  _this->_impl_._nets_.MergeFrom(from._impl_._nets_);
  _this->_impl_._instances_.MergeFrom(from._impl_._instances_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NetListClass::CopyFrom(const NetListClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.NetListClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetListClass::IsInitialized() const {
  return true;
}

void NetListClass::InternalSwap(NetListClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._ports_.InternalSwap(&other->_impl_._ports_);
  _impl_._port_buses_.InternalSwap(&other->_impl_._port_buses_);
  _impl_._nets_.InternalSwap(&other->_impl_._nets_);
  _impl_._instances_.InternalSwap(&other->_impl_._instances_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NetListClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[8]);
}

// ===================================================================

class DesignObjectSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<DesignObjectSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::DesignObjects::DesignObjectClass& parent(const DesignObjectSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::DesignObjects::NetClass& n(const DesignObjectSyn* msg);
  static const ::DesignObjects::PinBusClass& pib(const DesignObjectSyn* msg);
  static const ::DesignObjects::PinClass& pi(const DesignObjectSyn* msg);
  static const ::DesignObjects::PortClass& po(const DesignObjectSyn* msg);
  static const ::DesignObjects::PortBusClass& pob(const DesignObjectSyn* msg);
  static const ::DesignObjects::InstanceClass& i(const DesignObjectSyn* msg);
  static const ::DesignObjects::NetListClass& nl(const DesignObjectSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::DesignObjects::DesignObjectClass&
DesignObjectSyn::_Internal::parent(const DesignObjectSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::DesignObjects::NetClass&
DesignObjectSyn::_Internal::n(const DesignObjectSyn* msg) {
  return *msg->_impl_.dos_.n_;
}
const ::DesignObjects::PinBusClass&
DesignObjectSyn::_Internal::pib(const DesignObjectSyn* msg) {
  return *msg->_impl_.dos_.pib_;
}
const ::DesignObjects::PinClass&
DesignObjectSyn::_Internal::pi(const DesignObjectSyn* msg) {
  return *msg->_impl_.dos_.pi_;
}
const ::DesignObjects::PortClass&
DesignObjectSyn::_Internal::po(const DesignObjectSyn* msg) {
  return *msg->_impl_.dos_.po_;
}
const ::DesignObjects::PortBusClass&
DesignObjectSyn::_Internal::pob(const DesignObjectSyn* msg) {
  return *msg->_impl_.dos_.pob_;
}
const ::DesignObjects::InstanceClass&
DesignObjectSyn::_Internal::i(const DesignObjectSyn* msg) {
  return *msg->_impl_.dos_.i_;
}
const ::DesignObjects::NetListClass&
DesignObjectSyn::_Internal::nl(const DesignObjectSyn* msg) {
  return *msg->_impl_.dos_.nl_;
}
void DesignObjectSyn::set_allocated_n(::DesignObjects::NetClass* n) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dos();
  if (n) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(n);
    if (message_arena != submessage_arena) {
      n = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, n, submessage_arena);
    }
    set_has_n();
    _impl_.dos_.n_ = n;
  }
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.n)
}
void DesignObjectSyn::set_allocated_pib(::DesignObjects::PinBusClass* pib) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dos();
  if (pib) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pib);
    if (message_arena != submessage_arena) {
      pib = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pib, submessage_arena);
    }
    set_has_pib();
    _impl_.dos_.pib_ = pib;
  }
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.pib)
}
void DesignObjectSyn::set_allocated_pi(::DesignObjects::PinClass* pi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dos();
  if (pi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pi);
    if (message_arena != submessage_arena) {
      pi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pi, submessage_arena);
    }
    set_has_pi();
    _impl_.dos_.pi_ = pi;
  }
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.pi)
}
void DesignObjectSyn::set_allocated_po(::DesignObjects::PortClass* po) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dos();
  if (po) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(po);
    if (message_arena != submessage_arena) {
      po = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, po, submessage_arena);
    }
    set_has_po();
    _impl_.dos_.po_ = po;
  }
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.po)
}
void DesignObjectSyn::set_allocated_pob(::DesignObjects::PortBusClass* pob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dos();
  if (pob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pob);
    if (message_arena != submessage_arena) {
      pob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pob, submessage_arena);
    }
    set_has_pob();
    _impl_.dos_.pob_ = pob;
  }
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.pob)
}
void DesignObjectSyn::set_allocated_i(::DesignObjects::InstanceClass* i) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dos();
  if (i) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(i);
    if (message_arena != submessage_arena) {
      i = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, i, submessage_arena);
    }
    set_has_i();
    _impl_.dos_.i_ = i;
  }
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.i)
}
void DesignObjectSyn::set_allocated_nl(::DesignObjects::NetListClass* nl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_dos();
  if (nl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nl);
    if (message_arena != submessage_arena) {
      nl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nl, submessage_arena);
    }
    set_has_nl();
    _impl_.dos_.nl_ = nl;
  }
  // @@protoc_insertion_point(field_set_allocated:DesignObjects.DesignObjectSyn.nl)
}
DesignObjectSyn::DesignObjectSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DesignObjects.DesignObjectSyn)
}
DesignObjectSyn::DesignObjectSyn(const DesignObjectSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DesignObjectSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.dos_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::DesignObjects::DesignObjectClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  clear_has_dos();
  switch (from.dos_case()) {
    case kN: {
      _this->_internal_mutable_n()->::DesignObjects::NetClass::MergeFrom(
          from._internal_n());
      break;
    }
    case kPib: {
      _this->_internal_mutable_pib()->::DesignObjects::PinBusClass::MergeFrom(
          from._internal_pib());
      break;
    }
    case kPi: {
      _this->_internal_mutable_pi()->::DesignObjects::PinClass::MergeFrom(
          from._internal_pi());
      break;
    }
    case kPo: {
      _this->_internal_mutable_po()->::DesignObjects::PortClass::MergeFrom(
          from._internal_po());
      break;
    }
    case kPob: {
      _this->_internal_mutable_pob()->::DesignObjects::PortBusClass::MergeFrom(
          from._internal_pob());
      break;
    }
    case kI: {
      _this->_internal_mutable_i()->::DesignObjects::InstanceClass::MergeFrom(
          from._internal_i());
      break;
    }
    case kNl: {
      _this->_internal_mutable_nl()->::DesignObjects::NetListClass::MergeFrom(
          from._internal_nl());
      break;
    }
    case DOS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:DesignObjects.DesignObjectSyn)
}

inline void DesignObjectSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.dos_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_dos();
}

DesignObjectSyn::~DesignObjectSyn() {
  // @@protoc_insertion_point(destructor:DesignObjects.DesignObjectSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DesignObjectSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_dos()) {
    clear_dos();
  }
}

void DesignObjectSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DesignObjectSyn::clear_dos() {
// @@protoc_insertion_point(one_of_clear_start:DesignObjects.DesignObjectSyn)
  switch (dos_case()) {
    case kN: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dos_.n_;
      }
      break;
    }
    case kPib: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dos_.pib_;
      }
      break;
    }
    case kPi: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dos_.pi_;
      }
      break;
    }
    case kPo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dos_.po_;
      }
      break;
    }
    case kPob: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dos_.pob_;
      }
      break;
    }
    case kI: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dos_.i_;
      }
      break;
    }
    case kNl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.dos_.nl_;
      }
      break;
    }
    case DOS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DOS_NOT_SET;
}


void DesignObjectSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:DesignObjects.DesignObjectSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  clear_dos();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DesignObjectSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .DesignObjects.DesignObjectClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DesignObjects.NetClass n = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_n(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DesignObjects.PinBusClass pib = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_pib(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DesignObjects.PinClass pi = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DesignObjects.PortClass po = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_po(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DesignObjects.PortBusClass pob = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_pob(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DesignObjects.InstanceClass i = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_i(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DesignObjects.NetListClass nl = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_nl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DesignObjectSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DesignObjects.DesignObjectSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  // required .DesignObjects.DesignObjectClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (dos_case()) {
    case kN: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::n(this),
          _Internal::n(this).GetCachedSize(), target, stream);
      break;
    }
    case kPib: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::pib(this),
          _Internal::pib(this).GetCachedSize(), target, stream);
      break;
    }
    case kPi: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::pi(this),
          _Internal::pi(this).GetCachedSize(), target, stream);
      break;
    }
    case kPo: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::po(this),
          _Internal::po(this).GetCachedSize(), target, stream);
      break;
    }
    case kPob: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::pob(this),
          _Internal::pob(this).GetCachedSize(), target, stream);
      break;
    }
    case kI: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::i(this),
          _Internal::i(this).GetCachedSize(), target, stream);
      break;
    }
    case kNl: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::nl(this),
          _Internal::nl(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DesignObjects.DesignObjectSyn)
  return target;
}

size_t DesignObjectSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DesignObjects.DesignObjectSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .DesignObjects.DesignObjectClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_type()) {
    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t DesignObjectSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DesignObjects.DesignObjectSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .DesignObjects.DesignObjectClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (dos_case()) {
    // .DesignObjects.NetClass n = 4;
    case kN: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dos_.n_);
      break;
    }
    // .DesignObjects.PinBusClass pib = 5;
    case kPib: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dos_.pib_);
      break;
    }
    // .DesignObjects.PinClass pi = 6;
    case kPi: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dos_.pi_);
      break;
    }
    // .DesignObjects.PortClass po = 7;
    case kPo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dos_.po_);
      break;
    }
    // .DesignObjects.PortBusClass pob = 8;
    case kPob: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dos_.pob_);
      break;
    }
    // .DesignObjects.InstanceClass i = 9;
    case kI: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dos_.i_);
      break;
    }
    // .DesignObjects.NetListClass nl = 10;
    case kNl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dos_.nl_);
      break;
    }
    case DOS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DesignObjectSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DesignObjectSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DesignObjectSyn::GetClassData() const { return &_class_data_; }


void DesignObjectSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DesignObjectSyn*>(&to_msg);
  auto& from = static_cast<const DesignObjectSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DesignObjects.DesignObjectSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::DesignObjects::DesignObjectClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.dos_case()) {
    case kN: {
      _this->_internal_mutable_n()->::DesignObjects::NetClass::MergeFrom(
          from._internal_n());
      break;
    }
    case kPib: {
      _this->_internal_mutable_pib()->::DesignObjects::PinBusClass::MergeFrom(
          from._internal_pib());
      break;
    }
    case kPi: {
      _this->_internal_mutable_pi()->::DesignObjects::PinClass::MergeFrom(
          from._internal_pi());
      break;
    }
    case kPo: {
      _this->_internal_mutable_po()->::DesignObjects::PortClass::MergeFrom(
          from._internal_po());
      break;
    }
    case kPob: {
      _this->_internal_mutable_pob()->::DesignObjects::PortBusClass::MergeFrom(
          from._internal_pob());
      break;
    }
    case kI: {
      _this->_internal_mutable_i()->::DesignObjects::InstanceClass::MergeFrom(
          from._internal_i());
      break;
    }
    case kNl: {
      _this->_internal_mutable_nl()->::DesignObjects::NetListClass::MergeFrom(
          from._internal_nl());
      break;
    }
    case DOS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DesignObjectSyn::CopyFrom(const DesignObjectSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DesignObjects.DesignObjectSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DesignObjectSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (dos_case()) {
    case kN: {
      if (_internal_has_n()) {
        if (!_impl_.dos_.n_->IsInitialized()) return false;
      }
      break;
    }
    case kPib: {
      if (_internal_has_pib()) {
        if (!_impl_.dos_.pib_->IsInitialized()) return false;
      }
      break;
    }
    case kPi: {
      if (_internal_has_pi()) {
        if (!_impl_.dos_.pi_->IsInitialized()) return false;
      }
      break;
    }
    case kPo: {
      if (_internal_has_po()) {
        if (!_impl_.dos_.po_->IsInitialized()) return false;
      }
      break;
    }
    case kPob: {
      if (_internal_has_pob()) {
        if (!_impl_.dos_.pob_->IsInitialized()) return false;
      }
      break;
    }
    case kI: {
      if (_internal_has_i()) {
        if (!_impl_.dos_.i_->IsInitialized()) return false;
      }
      break;
    }
    case kNl: {
      break;
    }
    case DOS_NOT_SET: {
      break;
    }
  }
  return true;
}

void DesignObjectSyn::InternalSwap(DesignObjectSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DesignObjectSyn, _impl_.type_)
      + sizeof(DesignObjectSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(DesignObjectSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.dos_, other->_impl_.dos_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata DesignObjectSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DesignObjects_2eproto_getter, &descriptor_table_DesignObjects_2eproto_once,
      file_level_metadata_DesignObjects_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace DesignObjects
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::DesignObjects::DesignObjectClass*
Arena::CreateMaybeMessage< ::DesignObjects::DesignObjectClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::DesignObjectClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::NetClass*
Arena::CreateMaybeMessage< ::DesignObjects::NetClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::NetClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::PinBusClass*
Arena::CreateMaybeMessage< ::DesignObjects::PinBusClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::PinBusClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::PinClass*
Arena::CreateMaybeMessage< ::DesignObjects::PinClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::PinClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::PortDirEnum*
Arena::CreateMaybeMessage< ::DesignObjects::PortDirEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::PortDirEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::PortClass*
Arena::CreateMaybeMessage< ::DesignObjects::PortClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::PortClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::PortBusClass*
Arena::CreateMaybeMessage< ::DesignObjects::PortBusClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::PortBusClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::InstanceClass*
Arena::CreateMaybeMessage< ::DesignObjects::InstanceClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::InstanceClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::NetListClass*
Arena::CreateMaybeMessage< ::DesignObjects::NetListClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::NetListClass >(arena);
}
template<> PROTOBUF_NOINLINE ::DesignObjects::DesignObjectSyn*
Arena::CreateMaybeMessage< ::DesignObjects::DesignObjectSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DesignObjects::DesignObjectSyn >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
