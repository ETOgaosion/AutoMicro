// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: VerilogReader.proto

#include "VerilogReader.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace VerilogParser {
PROTOBUF_CONSTEXPR VerilogIDClass::VerilogIDClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct VerilogIDClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogIDClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogIDClassDefaultTypeInternal() {}
  union {
    VerilogIDClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogIDClassDefaultTypeInternal _VerilogIDClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogIndexIDClass::VerilogIndexIDClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._index_)*/0} {}
struct VerilogIndexIDClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogIndexIDClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogIndexIDClassDefaultTypeInternal() {}
  union {
    VerilogIndexIDClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogIndexIDClassDefaultTypeInternal _VerilogIndexIDClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogSliceIDClass::VerilogSliceIDClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._range_from_)*/0
  , /*decltype(_impl_._range_to_)*/0} {}
struct VerilogSliceIDClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogSliceIDClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogSliceIDClassDefaultTypeInternal() {}
  union {
    VerilogSliceIDClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogSliceIDClassDefaultTypeInternal _VerilogSliceIDClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogChildIDClass::VerilogChildIDClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vid_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct VerilogChildIDClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogChildIDClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogChildIDClassDefaultTypeInternal() {}
  union {
    VerilogChildIDClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogChildIDClassDefaultTypeInternal _VerilogChildIDClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogIDSyn::VerilogIDSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.child_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.vid_type_)*/0} {}
struct VerilogIDSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogIDSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogIDSynDefaultTypeInternal() {}
  union {
    VerilogIDSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogIDSynDefaultTypeInternal _VerilogIDSyn_default_instance_;
PROTOBUF_CONSTEXPR VerilogNetExprClass::VerilogNetExprClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._line_no_)*/0u} {}
struct VerilogNetExprClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogNetExprClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogNetExprClassDefaultTypeInternal() {}
  union {
    VerilogNetExprClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogNetExprClassDefaultTypeInternal _VerilogNetExprClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogNetIDExprClass::VerilogNetIDExprClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._verilog_id_)*/0} {}
struct VerilogNetIDExprClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogNetIDExprClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogNetIDExprClassDefaultTypeInternal() {}
  union {
    VerilogNetIDExprClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogNetIDExprClassDefaultTypeInternal _VerilogNetIDExprClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogNetConcatExprClass::VerilogNetConcatExprClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._verilog_id_concat_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VerilogNetConcatExprClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogNetConcatExprClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogNetConcatExprClassDefaultTypeInternal() {}
  union {
    VerilogNetConcatExprClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogNetConcatExprClassDefaultTypeInternal _VerilogNetConcatExprClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogConstantExprClass::VerilogConstantExprClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._verilog_id_)*/0} {}
struct VerilogConstantExprClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogConstantExprClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogConstantExprClassDefaultTypeInternal() {}
  union {
    VerilogConstantExprClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogConstantExprClassDefaultTypeInternal _VerilogConstantExprClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogNetExprSyn::VerilogNetExprSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.vnes_type_)*/0
  , /*decltype(_impl_.vnes_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct VerilogNetExprSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogNetExprSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogNetExprSynDefaultTypeInternal() {}
  union {
    VerilogNetExprSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogNetExprSynDefaultTypeInternal _VerilogNetExprSyn_default_instance_;
PROTOBUF_CONSTEXPR VerilogPortRefPortConnectClass::VerilogPortRefPortConnectClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._port_id_)*/0
  , /*decltype(_impl_._net_expr_)*/0} {}
struct VerilogPortRefPortConnectClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogPortRefPortConnectClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogPortRefPortConnectClassDefaultTypeInternal() {}
  union {
    VerilogPortRefPortConnectClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogPortRefPortConnectClassDefaultTypeInternal _VerilogPortRefPortConnectClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogStmtClass::VerilogStmtClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._line_)*/0} {}
struct VerilogStmtClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogStmtClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogStmtClassDefaultTypeInternal() {}
  union {
    VerilogStmtClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogStmtClassDefaultTypeInternal _VerilogStmtClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogInstClass::VerilogInstClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._port_connections_)*/{}
  , /*decltype(_impl_._inst_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cell_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct VerilogInstClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogInstClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogInstClassDefaultTypeInternal() {}
  union {
    VerilogInstClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogInstClassDefaultTypeInternal _VerilogInstClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogDclTypeEnum::VerilogDclTypeEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dt_)*/0} {}
struct VerilogDclTypeEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogDclTypeEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogDclTypeEnumDefaultTypeInternal() {}
  union {
    VerilogDclTypeEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogDclTypeEnumDefaultTypeInternal _VerilogDclTypeEnum_default_instance_;
PROTOBUF_CONSTEXPR VerilogDclClass::VerilogDclClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._dcl_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._dcl_type_)*/nullptr
  , /*decltype(_impl_._range_)*/nullptr
  , /*decltype(_impl_.id_)*/0} {}
struct VerilogDclClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogDclClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogDclClassDefaultTypeInternal() {}
  union {
    VerilogDclClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogDclClassDefaultTypeInternal _VerilogDclClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogDclsClass::VerilogDclsClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._verilog_dcls_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VerilogDclsClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogDclsClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogDclsClassDefaultTypeInternal() {}
  union {
    VerilogDclsClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogDclsClassDefaultTypeInternal _VerilogDclsClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogModuleClass::VerilogModuleClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._port_list_)*/{}
  , /*decltype(_impl_._module_stmts_)*/{}
  , /*decltype(_impl_._module_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct VerilogModuleClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogModuleClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogModuleClassDefaultTypeInternal() {}
  union {
    VerilogModuleClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogModuleClassDefaultTypeInternal _VerilogModuleClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogStmtSyn::VerilogStmtSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.vss_type_)*/0
  , /*decltype(_impl_.vss_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct VerilogStmtSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogStmtSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogStmtSynDefaultTypeInternal() {}
  union {
    VerilogStmtSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogStmtSynDefaultTypeInternal _VerilogStmtSyn_default_instance_;
PROTOBUF_CONSTEXPR VerilogReaderClass::VerilogReaderClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._verilog_modules_)*/{}
  , /*decltype(_impl_._file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.meta_data_)*/0} {}
struct VerilogReaderClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogReaderClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogReaderClassDefaultTypeInternal() {}
  union {
    VerilogReaderClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogReaderClassDefaultTypeInternal _VerilogReaderClass_default_instance_;
PROTOBUF_CONSTEXPR VerilogMetaData::VerilogMetaData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.verilog_reader_id_)*/0} {}
struct VerilogMetaDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogMetaDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogMetaDataDefaultTypeInternal() {}
  union {
    VerilogMetaData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogMetaDataDefaultTypeInternal _VerilogMetaData_default_instance_;
PROTOBUF_CONSTEXPR BatchRequest::BatchRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.idl_)*/{}
  , /*decltype(_impl_.batch_size_)*/0} {}
struct BatchRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchRequestDefaultTypeInternal() {}
  union {
    BatchRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchRequestDefaultTypeInternal _BatchRequest_default_instance_;
PROTOBUF_CONSTEXPR VerilogStmtSynBatch::VerilogStmtSynBatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vssl_)*/{}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.syn_id_)*/0
  , /*decltype(_impl_.start_stmt_id_)*/int64_t{0}
  , /*decltype(_impl_.end_stmt_id_)*/int64_t{0}} {}
struct VerilogStmtSynBatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerilogStmtSynBatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerilogStmtSynBatchDefaultTypeInternal() {}
  union {
    VerilogStmtSynBatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerilogStmtSynBatchDefaultTypeInternal _VerilogStmtSynBatch_default_instance_;
}  // namespace VerilogParser
static ::_pb::Metadata file_level_metadata_VerilogReader_2eproto[22];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_VerilogReader_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_VerilogReader_2eproto = nullptr;

const uint32_t TableStruct_VerilogReader_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDClass, _impl_._id_),
  0,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIndexIDClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIndexIDClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIndexIDClass, _impl_._index_),
  0,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogSliceIDClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogSliceIDClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogSliceIDClass, _impl_._range_from_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogSliceIDClass, _impl_._range_to_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogChildIDClass, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogChildIDClass, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogChildIDClass, _impl_.vid_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDSyn, _impl_.vid_type_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDSyn, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogIDSyn, _impl_.child_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprClass, _impl_._line_no_),
  0,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetIDExprClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetIDExprClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetIDExprClass, _impl_._verilog_id_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetConcatExprClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetConcatExprClass, _impl_._verilog_id_concat_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogConstantExprClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogConstantExprClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogConstantExprClass, _impl_._verilog_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprSyn, _impl_.vnes_type_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogNetExprSyn, _impl_.vnes_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogPortRefPortConnectClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogPortRefPortConnectClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogPortRefPortConnectClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogPortRefPortConnectClass, _impl_._port_id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogPortRefPortConnectClass, _impl_._net_expr_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtClass, _impl_._line_),
  0,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogInstClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogInstClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogInstClass, _impl_._inst_name_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogInstClass, _impl_._cell_name_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogInstClass, _impl_._port_connections_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclTypeEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclTypeEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclTypeEnum, _impl_.dt_),
  0,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclClass, _impl_._dcl_type_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclClass, _impl_._dcl_name_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclClass, _impl_._range_),
  3,
  1,
  0,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclsClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogDclsClass, _impl_._verilog_dcls_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogModuleClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogModuleClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogModuleClass, _impl_._module_name_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogModuleClass, _impl_._port_list_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogModuleClass, _impl_._module_stmts_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSyn, _impl_.vss_type_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSyn, _impl_.vss_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogReaderClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogReaderClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogReaderClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogReaderClass, _impl_.meta_data_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogReaderClass, _impl_._file_name_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogReaderClass, _impl_._verilog_modules_),
  1,
  2,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogMetaData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogMetaData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogMetaData, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogMetaData, _impl_.verilog_reader_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::BatchRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::BatchRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::BatchRequest, _impl_.batch_size_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::BatchRequest, _impl_.idl_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSynBatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSynBatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSynBatch, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSynBatch, _impl_.syn_id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSynBatch, _impl_.start_stmt_id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSynBatch, _impl_.end_stmt_id_),
  PROTOBUF_FIELD_OFFSET(::VerilogParser::VerilogStmtSynBatch, _impl_.vssl_),
  0,
  1,
  2,
  3,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::VerilogParser::VerilogIDClass)},
  { 8, 15, -1, sizeof(::VerilogParser::VerilogIndexIDClass)},
  { 16, 24, -1, sizeof(::VerilogParser::VerilogSliceIDClass)},
  { 26, -1, -1, sizeof(::VerilogParser::VerilogChildIDClass)},
  { 35, 45, -1, sizeof(::VerilogParser::VerilogIDSyn)},
  { 49, 56, -1, sizeof(::VerilogParser::VerilogNetExprClass)},
  { 57, 64, -1, sizeof(::VerilogParser::VerilogNetIDExprClass)},
  { 65, -1, -1, sizeof(::VerilogParser::VerilogNetConcatExprClass)},
  { 72, 79, -1, sizeof(::VerilogParser::VerilogConstantExprClass)},
  { 80, 93, -1, sizeof(::VerilogParser::VerilogNetExprSyn)},
  { 99, 108, -1, sizeof(::VerilogParser::VerilogPortRefPortConnectClass)},
  { 111, 118, -1, sizeof(::VerilogParser::VerilogStmtClass)},
  { 119, 128, -1, sizeof(::VerilogParser::VerilogInstClass)},
  { 131, 138, -1, sizeof(::VerilogParser::VerilogDclTypeEnum)},
  { 139, 149, -1, sizeof(::VerilogParser::VerilogDclClass)},
  { 153, -1, -1, sizeof(::VerilogParser::VerilogDclsClass)},
  { 160, 169, -1, sizeof(::VerilogParser::VerilogModuleClass)},
  { 172, 186, -1, sizeof(::VerilogParser::VerilogStmtSyn)},
  { 193, 203, -1, sizeof(::VerilogParser::VerilogReaderClass)},
  { 207, 215, -1, sizeof(::VerilogParser::VerilogMetaData)},
  { 217, 225, -1, sizeof(::VerilogParser::BatchRequest)},
  { 227, 238, -1, sizeof(::VerilogParser::VerilogStmtSynBatch)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::VerilogParser::_VerilogIDClass_default_instance_._instance,
  &::VerilogParser::_VerilogIndexIDClass_default_instance_._instance,
  &::VerilogParser::_VerilogSliceIDClass_default_instance_._instance,
  &::VerilogParser::_VerilogChildIDClass_default_instance_._instance,
  &::VerilogParser::_VerilogIDSyn_default_instance_._instance,
  &::VerilogParser::_VerilogNetExprClass_default_instance_._instance,
  &::VerilogParser::_VerilogNetIDExprClass_default_instance_._instance,
  &::VerilogParser::_VerilogNetConcatExprClass_default_instance_._instance,
  &::VerilogParser::_VerilogConstantExprClass_default_instance_._instance,
  &::VerilogParser::_VerilogNetExprSyn_default_instance_._instance,
  &::VerilogParser::_VerilogPortRefPortConnectClass_default_instance_._instance,
  &::VerilogParser::_VerilogStmtClass_default_instance_._instance,
  &::VerilogParser::_VerilogInstClass_default_instance_._instance,
  &::VerilogParser::_VerilogDclTypeEnum_default_instance_._instance,
  &::VerilogParser::_VerilogDclClass_default_instance_._instance,
  &::VerilogParser::_VerilogDclsClass_default_instance_._instance,
  &::VerilogParser::_VerilogModuleClass_default_instance_._instance,
  &::VerilogParser::_VerilogStmtSyn_default_instance_._instance,
  &::VerilogParser::_VerilogReaderClass_default_instance_._instance,
  &::VerilogParser::_VerilogMetaData_default_instance_._instance,
  &::VerilogParser::_BatchRequest_default_instance_._instance,
  &::VerilogParser::_VerilogStmtSynBatch_default_instance_._instance,
};

const char descriptor_table_protodef_VerilogReader_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023VerilogReader.proto\022\rVerilogParser\032\021Co"
  "mmonTypes.proto\"\035\n\016VerilogIDClass\022\013\n\003_id"
  "\030\001 \002(\t\"%\n\023VerilogIndexIDClass\022\016\n\006_index\030"
  "\002 \002(\005\"=\n\023VerilogSliceIDClass\022\023\n\013_range_f"
  "rom\030\002 \002(\005\022\021\n\t_range_to\030\003 \002(\005\"\202\001\n\023Verilog"
  "ChildIDClass\0221\n\003idx\030\001 \001(\0132\".VerilogParse"
  "r.VerilogIndexIDClassH\000\0221\n\003sid\030\002 \001(\0132\".V"
  "erilogParser.VerilogSliceIDClassH\000B\005\n\003vi"
  "d\"\216\001\n\014VerilogIDSyn\022\n\n\002id\030\001 \002(\005\022\020\n\010vid_ty"
  "pe\030\002 \002(\005\022-\n\006parent\030\003 \002(\0132\035.VerilogParser"
  ".VerilogIDClass\0221\n\005child\030\004 \001(\0132\".Verilog"
  "Parser.VerilogChildIDClass\"\'\n\023VerilogNet"
  "ExprClass\022\020\n\010_line_no\030\001 \002(\r\",\n\025VerilogNe"
  "tIDExprClass\022\023\n\013_verilog_id\030\002 \002(\005\"7\n\031Ver"
  "ilogNetConcatExprClass\022\032\n\022_verilog_id_co"
  "ncat\030\001 \003(\005\"/\n\030VerilogConstantExprClass\022\023"
  "\n\013_verilog_id\030\001 \002(\005\"\227\002\n\021VerilogNetExprSy"
  "n\022\n\n\002id\030\001 \002(\005\022\021\n\tvnes_type\030\002 \002(\005\0222\n\006pare"
  "nt\030\003 \002(\0132\".VerilogParser.VerilogNetExprC"
  "lass\0225\n\005nidec\030\004 \001(\0132$.VerilogParser.Veri"
  "logNetIDExprClassH\000\0228\n\004ncec\030\005 \001(\0132(.Veri"
  "logParser.VerilogNetConcatExprClassH\000\0226\n"
  "\003cec\030\006 \001(\0132\'.VerilogParser.VerilogConsta"
  "ntExprClassH\000B\006\n\004vnes\"Q\n\036VerilogPortRefP"
  "ortConnectClass\022\n\n\002id\030\001 \002(\005\022\020\n\010_port_id\030"
  "\002 \002(\005\022\021\n\t_net_expr\030\003 \001(\005\"!\n\020VerilogStmtC"
  "lass\022\r\n\005_line\030\001 \002(\005\"U\n\020VerilogInstClass\022"
  "\022\n\n_inst_name\030\001 \002(\t\022\022\n\n_cell_name\030\002 \002(\t\022"
  "\031\n\021_port_connections\030\003 \003(\005\"\305\001\n\022VerilogDc"
  "lTypeEnum\0225\n\002dt\030\001 \002(\0162).VerilogParser.Ve"
  "rilogDclTypeEnum.DclType\"x\n\007DclType\022\n\n\006k"
  "Input\020\000\022\n\n\006kInout\020\001\022\013\n\007kOutput\020\002\022\014\n\010kSup"
  "ply0\020\003\022\014\n\010kSupply1\020\004\022\010\n\004kTri\020\005\022\t\n\005kWand\020"
  "\006\022\t\n\005kWire\020\007\022\010\n\004kWor\020\007\032\002\020\001\"\215\001\n\017VerilogDc"
  "lClass\022\n\n\002id\030\001 \002(\005\0224\n\t_dcl_type\030\002 \002(\0132!."
  "VerilogParser.VerilogDclTypeEnum\022\021\n\t_dcl"
  "_name\030\003 \002(\t\022%\n\006_range\030\004 \001(\0132\025.Common.Typ"
  "es.IntPair\")\n\020VerilogDclsClass\022\025\n\r_veril"
  "og_dcls\030\002 \003(\005\"U\n\022VerilogModuleClass\022\024\n\014_"
  "module_name\030\001 \002(\t\022\022\n\n_port_list\030\002 \003(\005\022\025\n"
  "\r_module_stmts\030\003 \003(\005\"\240\002\n\016VerilogStmtSyn\022"
  "\n\n\002id\030\001 \002(\005\022\020\n\010vss_type\030\002 \002(\005\022/\n\006parent\030"
  "\003 \002(\0132\037.VerilogParser.VerilogStmtClass\022,"
  "\n\001i\030\004 \001(\0132\037.VerilogParser.VerilogInstCla"
  "ssH\000\022+\n\001d\030\005 \001(\0132\036.VerilogParser.VerilogD"
  "clClassH\000\022-\n\002ds\030\006 \001(\0132\037.VerilogParser.Ve"
  "rilogDclsClassH\000\022.\n\001m\030\007 \001(\0132!.VerilogPar"
  "ser.VerilogModuleClassH\000B\005\n\003vss\"a\n\022Veril"
  "ogReaderClass\022\n\n\002id\030\001 \002(\005\022\021\n\tmeta_data\030\002"
  " \002(\005\022\022\n\n_file_name\030\003 \002(\t\022\030\n\020_verilog_mod"
  "ules\030\004 \003(\005\"8\n\017VerilogMetaData\022\n\n\002id\030\001 \002("
  "\005\022\031\n\021verilog_reader_id\030\002 \002(\005\"/\n\014BatchReq"
  "uest\022\022\n\nbatch_size\030\001 \002(\005\022\013\n\003idl\030\002 \003(\005\"k\n"
  "\023VerilogStmtSynBatch\022\n\n\002id\030\001 \002(\005\022\016\n\006syn_"
  "id\030\002 \002(\005\022\025\n\rstart_stmt_id\030\003 \002(\003\022\023\n\013end_s"
  "tmt_id\030\004 \002(\003\022\014\n\004vssl\030\005 \003(\0142P\n\024VerilogRea"
  "derService\0228\n\004read\022\027.Common.Types.String"
  "Msg\032\025.Common.Types.BoolMsg\"\000"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_VerilogReader_2eproto_deps[1] = {
  &::descriptor_table_CommonTypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_VerilogReader_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_VerilogReader_2eproto = {
    false, false, 2308, descriptor_table_protodef_VerilogReader_2eproto,
    "VerilogReader.proto",
    &descriptor_table_VerilogReader_2eproto_once, descriptor_table_VerilogReader_2eproto_deps, 1, 22,
    schemas, file_default_instances, TableStruct_VerilogReader_2eproto::offsets,
    file_level_metadata_VerilogReader_2eproto, file_level_enum_descriptors_VerilogReader_2eproto,
    file_level_service_descriptors_VerilogReader_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_VerilogReader_2eproto_getter() {
  return &descriptor_table_VerilogReader_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_VerilogReader_2eproto(&descriptor_table_VerilogReader_2eproto);
namespace VerilogParser {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VerilogDclTypeEnum_DclType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_VerilogReader_2eproto);
  return file_level_enum_descriptors_VerilogReader_2eproto[0];
}
bool VerilogDclTypeEnum_DclType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kInput;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kInout;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kOutput;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kSupply0;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kSupply1;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kTri;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kWand;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kWire;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::kWor;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::DclType_MIN;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum::DclType_MAX;
constexpr int VerilogDclTypeEnum::DclType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class VerilogIDClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogIDClass>()._impl_._has_bits_);
  static void set_has__id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogIDClass::VerilogIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogIDClass)
}
VerilogIDClass::VerilogIDClass(const VerilogIDClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogIDClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__id()) {
    _this->_impl_._id_.Set(from._internal__id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogIDClass)
}

inline void VerilogIDClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._id_){}
  };
  _impl_._id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VerilogIDClass::~VerilogIDClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogIDClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogIDClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._id_.Destroy();
}

void VerilogIDClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogIDClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogIDClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogIDClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "VerilogParser.VerilogIDClass._id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogIDClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogIDClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__id().data(), static_cast<int>(this->_internal__id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "VerilogParser.VerilogIDClass._id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogIDClass)
  return target;
}

size_t VerilogIDClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogIDClass)
  size_t total_size = 0;

  // required string _id = 1;
  if (_internal_has__id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogIDClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogIDClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogIDClass::GetClassData() const { return &_class_data_; }


void VerilogIDClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogIDClass*>(&to_msg);
  auto& from = static_cast<const VerilogIDClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogIDClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__id()) {
    _this->_internal_set__id(from._internal__id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogIDClass::CopyFrom(const VerilogIDClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogIDClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogIDClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogIDClass::InternalSwap(VerilogIDClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._id_, lhs_arena,
      &other->_impl_._id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogIDClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[0]);
}

// ===================================================================

class VerilogIndexIDClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogIndexIDClass>()._impl_._has_bits_);
  static void set_has__index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogIndexIDClass::VerilogIndexIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogIndexIDClass)
}
VerilogIndexIDClass::VerilogIndexIDClass(const VerilogIndexIDClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogIndexIDClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._index_ = from._impl_._index_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogIndexIDClass)
}

inline void VerilogIndexIDClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._index_){0}
  };
}

VerilogIndexIDClass::~VerilogIndexIDClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogIndexIDClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogIndexIDClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogIndexIDClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogIndexIDClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogIndexIDClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogIndexIDClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__index(&has_bits);
          _impl_._index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogIndexIDClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogIndexIDClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _index = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal__index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogIndexIDClass)
  return target;
}

size_t VerilogIndexIDClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogIndexIDClass)
  size_t total_size = 0;

  // required int32 _index = 2;
  if (_internal_has__index()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__index());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogIndexIDClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogIndexIDClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogIndexIDClass::GetClassData() const { return &_class_data_; }


void VerilogIndexIDClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogIndexIDClass*>(&to_msg);
  auto& from = static_cast<const VerilogIndexIDClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogIndexIDClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__index()) {
    _this->_internal_set__index(from._internal__index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogIndexIDClass::CopyFrom(const VerilogIndexIDClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogIndexIDClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogIndexIDClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogIndexIDClass::InternalSwap(VerilogIndexIDClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._index_, other->_impl_._index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogIndexIDClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[1]);
}

// ===================================================================

class VerilogSliceIDClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogSliceIDClass>()._impl_._has_bits_);
  static void set_has__range_from(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__range_to(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

VerilogSliceIDClass::VerilogSliceIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogSliceIDClass)
}
VerilogSliceIDClass::VerilogSliceIDClass(const VerilogSliceIDClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogSliceIDClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._range_from_){}
    , decltype(_impl_._range_to_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._range_from_, &from._impl_._range_from_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._range_to_) -
    reinterpret_cast<char*>(&_impl_._range_from_)) + sizeof(_impl_._range_to_));
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogSliceIDClass)
}

inline void VerilogSliceIDClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._range_from_){0}
    , decltype(_impl_._range_to_){0}
  };
}

VerilogSliceIDClass::~VerilogSliceIDClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogSliceIDClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogSliceIDClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogSliceIDClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogSliceIDClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogSliceIDClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._range_from_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._range_to_) -
        reinterpret_cast<char*>(&_impl_._range_from_)) + sizeof(_impl_._range_to_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogSliceIDClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _range_from = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__range_from(&has_bits);
          _impl_._range_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 _range_to = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__range_to(&has_bits);
          _impl_._range_to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogSliceIDClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogSliceIDClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _range_from = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal__range_from(), target);
  }

  // required int32 _range_to = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal__range_to(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogSliceIDClass)
  return target;
}

size_t VerilogSliceIDClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogSliceIDClass)
  size_t total_size = 0;

  if (_internal_has__range_from()) {
    // required int32 _range_from = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__range_from());
  }

  if (_internal_has__range_to()) {
    // required int32 _range_to = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__range_to());
  }

  return total_size;
}
size_t VerilogSliceIDClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogSliceIDClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 _range_from = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__range_from());

    // required int32 _range_to = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__range_to());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogSliceIDClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogSliceIDClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogSliceIDClass::GetClassData() const { return &_class_data_; }


void VerilogSliceIDClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogSliceIDClass*>(&to_msg);
  auto& from = static_cast<const VerilogSliceIDClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogSliceIDClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._range_from_ = from._impl_._range_from_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._range_to_ = from._impl_._range_to_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogSliceIDClass::CopyFrom(const VerilogSliceIDClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogSliceIDClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogSliceIDClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogSliceIDClass::InternalSwap(VerilogSliceIDClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogSliceIDClass, _impl_._range_to_)
      + sizeof(VerilogSliceIDClass::_impl_._range_to_)
      - PROTOBUF_FIELD_OFFSET(VerilogSliceIDClass, _impl_._range_from_)>(
          reinterpret_cast<char*>(&_impl_._range_from_),
          reinterpret_cast<char*>(&other->_impl_._range_from_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogSliceIDClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[2]);
}

// ===================================================================

class VerilogChildIDClass::_Internal {
 public:
  static const ::VerilogParser::VerilogIndexIDClass& idx(const VerilogChildIDClass* msg);
  static const ::VerilogParser::VerilogSliceIDClass& sid(const VerilogChildIDClass* msg);
};

const ::VerilogParser::VerilogIndexIDClass&
VerilogChildIDClass::_Internal::idx(const VerilogChildIDClass* msg) {
  return *msg->_impl_.vid_.idx_;
}
const ::VerilogParser::VerilogSliceIDClass&
VerilogChildIDClass::_Internal::sid(const VerilogChildIDClass* msg) {
  return *msg->_impl_.vid_.sid_;
}
void VerilogChildIDClass::set_allocated_idx(::VerilogParser::VerilogIndexIDClass* idx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vid();
  if (idx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(idx);
    if (message_arena != submessage_arena) {
      idx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, idx, submessage_arena);
    }
    set_has_idx();
    _impl_.vid_.idx_ = idx;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogChildIDClass.idx)
}
void VerilogChildIDClass::set_allocated_sid(::VerilogParser::VerilogSliceIDClass* sid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vid();
  if (sid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sid);
    if (message_arena != submessage_arena) {
      sid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sid, submessage_arena);
    }
    set_has_sid();
    _impl_.vid_.sid_ = sid;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogChildIDClass.sid)
}
VerilogChildIDClass::VerilogChildIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogChildIDClass)
}
VerilogChildIDClass::VerilogChildIDClass(const VerilogChildIDClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogChildIDClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vid_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_vid();
  switch (from.vid_case()) {
    case kIdx: {
      _this->_internal_mutable_idx()->::VerilogParser::VerilogIndexIDClass::MergeFrom(
          from._internal_idx());
      break;
    }
    case kSid: {
      _this->_internal_mutable_sid()->::VerilogParser::VerilogSliceIDClass::MergeFrom(
          from._internal_sid());
      break;
    }
    case VID_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogChildIDClass)
}

inline void VerilogChildIDClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vid_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_vid();
}

VerilogChildIDClass::~VerilogChildIDClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogChildIDClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogChildIDClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_vid()) {
    clear_vid();
  }
}

void VerilogChildIDClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogChildIDClass::clear_vid() {
// @@protoc_insertion_point(one_of_clear_start:VerilogParser.VerilogChildIDClass)
  switch (vid_case()) {
    case kIdx: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vid_.idx_;
      }
      break;
    }
    case kSid: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vid_.sid_;
      }
      break;
    }
    case VID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VID_NOT_SET;
}


void VerilogChildIDClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogChildIDClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_vid();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogChildIDClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .VerilogParser.VerilogIndexIDClass idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_idx(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogSliceIDClass sid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogChildIDClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogChildIDClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (vid_case()) {
    case kIdx: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::idx(this),
          _Internal::idx(this).GetCachedSize(), target, stream);
      break;
    }
    case kSid: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::sid(this),
          _Internal::sid(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogChildIDClass)
  return target;
}

size_t VerilogChildIDClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogChildIDClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (vid_case()) {
    // .VerilogParser.VerilogIndexIDClass idx = 1;
    case kIdx: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vid_.idx_);
      break;
    }
    // .VerilogParser.VerilogSliceIDClass sid = 2;
    case kSid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vid_.sid_);
      break;
    }
    case VID_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogChildIDClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogChildIDClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogChildIDClass::GetClassData() const { return &_class_data_; }


void VerilogChildIDClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogChildIDClass*>(&to_msg);
  auto& from = static_cast<const VerilogChildIDClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogChildIDClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.vid_case()) {
    case kIdx: {
      _this->_internal_mutable_idx()->::VerilogParser::VerilogIndexIDClass::MergeFrom(
          from._internal_idx());
      break;
    }
    case kSid: {
      _this->_internal_mutable_sid()->::VerilogParser::VerilogSliceIDClass::MergeFrom(
          from._internal_sid());
      break;
    }
    case VID_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogChildIDClass::CopyFrom(const VerilogChildIDClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogChildIDClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogChildIDClass::IsInitialized() const {
  switch (vid_case()) {
    case kIdx: {
      if (_internal_has_idx()) {
        if (!_impl_.vid_.idx_->IsInitialized()) return false;
      }
      break;
    }
    case kSid: {
      if (_internal_has_sid()) {
        if (!_impl_.vid_.sid_->IsInitialized()) return false;
      }
      break;
    }
    case VID_NOT_SET: {
      break;
    }
  }
  return true;
}

void VerilogChildIDClass::InternalSwap(VerilogChildIDClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.vid_, other->_impl_.vid_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogChildIDClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[3]);
}

// ===================================================================

class VerilogIDSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogIDSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vid_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::VerilogParser::VerilogIDClass& parent(const VerilogIDSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::VerilogParser::VerilogChildIDClass& child(const VerilogIDSyn* msg);
  static void set_has_child(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000d) ^ 0x0000000d) != 0;
  }
};

const ::VerilogParser::VerilogIDClass&
VerilogIDSyn::_Internal::parent(const VerilogIDSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::VerilogParser::VerilogChildIDClass&
VerilogIDSyn::_Internal::child(const VerilogIDSyn* msg) {
  return *msg->_impl_.child_;
}
VerilogIDSyn::VerilogIDSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogIDSyn)
}
VerilogIDSyn::VerilogIDSyn(const VerilogIDSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogIDSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.child_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.vid_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::VerilogParser::VerilogIDClass(*from._impl_.parent_);
  }
  if (from._internal_has_child()) {
    _this->_impl_.child_ = new ::VerilogParser::VerilogChildIDClass(*from._impl_.child_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vid_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.vid_type_));
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogIDSyn)
}

inline void VerilogIDSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.child_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.vid_type_){0}
  };
}

VerilogIDSyn::~VerilogIDSyn() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogIDSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogIDSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.child_;
}

void VerilogIDSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogIDSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogIDSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.child_ != nullptr);
      _impl_.child_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vid_type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.vid_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogIDSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 vid_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vid_type(&has_bits);
          _impl_.vid_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .VerilogParser.VerilogIDClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .VerilogParser.VerilogChildIDClass child = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_child(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogIDSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogIDSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 vid_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_vid_type(), target);
  }

  // required .VerilogParser.VerilogIDClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .VerilogParser.VerilogChildIDClass child = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::child(this),
        _Internal::child(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogIDSyn)
  return target;
}

size_t VerilogIDSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogIDSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .VerilogParser.VerilogIDClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_vid_type()) {
    // required int32 vid_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vid_type());
  }

  return total_size;
}
size_t VerilogIDSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogIDSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000d) ^ 0x0000000d) == 0) {  // All required fields are present.
    // required .VerilogParser.VerilogIDClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 vid_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vid_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .VerilogParser.VerilogChildIDClass child = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.child_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogIDSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogIDSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogIDSyn::GetClassData() const { return &_class_data_; }


void VerilogIDSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogIDSyn*>(&to_msg);
  auto& from = static_cast<const VerilogIDSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogIDSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::VerilogParser::VerilogIDClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_child()->::VerilogParser::VerilogChildIDClass::MergeFrom(
          from._internal_child());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vid_type_ = from._impl_.vid_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogIDSyn::CopyFrom(const VerilogIDSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogIDSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogIDSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  if (_internal_has_child()) {
    if (!_impl_.child_->IsInitialized()) return false;
  }
  return true;
}

void VerilogIDSyn::InternalSwap(VerilogIDSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogIDSyn, _impl_.vid_type_)
      + sizeof(VerilogIDSyn::_impl_.vid_type_)
      - PROTOBUF_FIELD_OFFSET(VerilogIDSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogIDSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[4]);
}

// ===================================================================

class VerilogNetExprClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogNetExprClass>()._impl_._has_bits_);
  static void set_has__line_no(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogNetExprClass::VerilogNetExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogNetExprClass)
}
VerilogNetExprClass::VerilogNetExprClass(const VerilogNetExprClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogNetExprClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._line_no_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._line_no_ = from._impl_._line_no_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogNetExprClass)
}

inline void VerilogNetExprClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._line_no_){0u}
  };
}

VerilogNetExprClass::~VerilogNetExprClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogNetExprClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogNetExprClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogNetExprClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogNetExprClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogNetExprClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._line_no_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogNetExprClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 _line_no = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__line_no(&has_bits);
          _impl_._line_no_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogNetExprClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogNetExprClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 _line_no = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal__line_no(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogNetExprClass)
  return target;
}

size_t VerilogNetExprClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogNetExprClass)
  size_t total_size = 0;

  // required uint32 _line_no = 1;
  if (_internal_has__line_no()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__line_no());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogNetExprClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogNetExprClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogNetExprClass::GetClassData() const { return &_class_data_; }


void VerilogNetExprClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogNetExprClass*>(&to_msg);
  auto& from = static_cast<const VerilogNetExprClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogNetExprClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__line_no()) {
    _this->_internal_set__line_no(from._internal__line_no());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogNetExprClass::CopyFrom(const VerilogNetExprClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogNetExprClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogNetExprClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogNetExprClass::InternalSwap(VerilogNetExprClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._line_no_, other->_impl_._line_no_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogNetExprClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[5]);
}

// ===================================================================

class VerilogNetIDExprClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogNetIDExprClass>()._impl_._has_bits_);
  static void set_has__verilog_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogNetIDExprClass::VerilogNetIDExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogNetIDExprClass)
}
VerilogNetIDExprClass::VerilogNetIDExprClass(const VerilogNetIDExprClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogNetIDExprClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._verilog_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._verilog_id_ = from._impl_._verilog_id_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogNetIDExprClass)
}

inline void VerilogNetIDExprClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._verilog_id_){0}
  };
}

VerilogNetIDExprClass::~VerilogNetIDExprClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogNetIDExprClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogNetIDExprClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogNetIDExprClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogNetIDExprClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogNetIDExprClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._verilog_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogNetIDExprClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _verilog_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__verilog_id(&has_bits);
          _impl_._verilog_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogNetIDExprClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogNetIDExprClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _verilog_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal__verilog_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogNetIDExprClass)
  return target;
}

size_t VerilogNetIDExprClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogNetIDExprClass)
  size_t total_size = 0;

  // required int32 _verilog_id = 2;
  if (_internal_has__verilog_id()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__verilog_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogNetIDExprClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogNetIDExprClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogNetIDExprClass::GetClassData() const { return &_class_data_; }


void VerilogNetIDExprClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogNetIDExprClass*>(&to_msg);
  auto& from = static_cast<const VerilogNetIDExprClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogNetIDExprClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__verilog_id()) {
    _this->_internal_set__verilog_id(from._internal__verilog_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogNetIDExprClass::CopyFrom(const VerilogNetIDExprClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogNetIDExprClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogNetIDExprClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogNetIDExprClass::InternalSwap(VerilogNetIDExprClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._verilog_id_, other->_impl_._verilog_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogNetIDExprClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[6]);
}

// ===================================================================

class VerilogNetConcatExprClass::_Internal {
 public:
};

VerilogNetConcatExprClass::VerilogNetConcatExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogNetConcatExprClass)
}
VerilogNetConcatExprClass::VerilogNetConcatExprClass(const VerilogNetConcatExprClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogNetConcatExprClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._verilog_id_concat_){from._impl_._verilog_id_concat_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogNetConcatExprClass)
}

inline void VerilogNetConcatExprClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._verilog_id_concat_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VerilogNetConcatExprClass::~VerilogNetConcatExprClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogNetConcatExprClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogNetConcatExprClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._verilog_id_concat_.~RepeatedField();
}

void VerilogNetConcatExprClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogNetConcatExprClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogNetConcatExprClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._verilog_id_concat_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogNetConcatExprClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 _verilog_id_concat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__verilog_id_concat(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable__verilog_id_concat(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogNetConcatExprClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogNetConcatExprClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 _verilog_id_concat = 1;
  for (int i = 0, n = this->_internal__verilog_id_concat_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal__verilog_id_concat(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogNetConcatExprClass)
  return target;
}

size_t VerilogNetConcatExprClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogNetConcatExprClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 _verilog_id_concat = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_._verilog_id_concat_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__verilog_id_concat_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogNetConcatExprClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogNetConcatExprClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogNetConcatExprClass::GetClassData() const { return &_class_data_; }


void VerilogNetConcatExprClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogNetConcatExprClass*>(&to_msg);
  auto& from = static_cast<const VerilogNetConcatExprClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogNetConcatExprClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._verilog_id_concat_.MergeFrom(from._impl_._verilog_id_concat_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogNetConcatExprClass::CopyFrom(const VerilogNetConcatExprClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogNetConcatExprClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogNetConcatExprClass::IsInitialized() const {
  return true;
}

void VerilogNetConcatExprClass::InternalSwap(VerilogNetConcatExprClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._verilog_id_concat_.InternalSwap(&other->_impl_._verilog_id_concat_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogNetConcatExprClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[7]);
}

// ===================================================================

class VerilogConstantExprClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogConstantExprClass>()._impl_._has_bits_);
  static void set_has__verilog_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogConstantExprClass::VerilogConstantExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogConstantExprClass)
}
VerilogConstantExprClass::VerilogConstantExprClass(const VerilogConstantExprClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogConstantExprClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._verilog_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._verilog_id_ = from._impl_._verilog_id_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogConstantExprClass)
}

inline void VerilogConstantExprClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._verilog_id_){0}
  };
}

VerilogConstantExprClass::~VerilogConstantExprClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogConstantExprClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogConstantExprClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogConstantExprClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogConstantExprClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogConstantExprClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._verilog_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogConstantExprClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _verilog_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__verilog_id(&has_bits);
          _impl_._verilog_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogConstantExprClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogConstantExprClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _verilog_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal__verilog_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogConstantExprClass)
  return target;
}

size_t VerilogConstantExprClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogConstantExprClass)
  size_t total_size = 0;

  // required int32 _verilog_id = 1;
  if (_internal_has__verilog_id()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__verilog_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogConstantExprClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogConstantExprClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogConstantExprClass::GetClassData() const { return &_class_data_; }


void VerilogConstantExprClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogConstantExprClass*>(&to_msg);
  auto& from = static_cast<const VerilogConstantExprClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogConstantExprClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__verilog_id()) {
    _this->_internal_set__verilog_id(from._internal__verilog_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogConstantExprClass::CopyFrom(const VerilogConstantExprClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogConstantExprClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogConstantExprClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogConstantExprClass::InternalSwap(VerilogConstantExprClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._verilog_id_, other->_impl_._verilog_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogConstantExprClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[8]);
}

// ===================================================================

class VerilogNetExprSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogNetExprSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vnes_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::VerilogParser::VerilogNetExprClass& parent(const VerilogNetExprSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::VerilogParser::VerilogNetIDExprClass& nidec(const VerilogNetExprSyn* msg);
  static const ::VerilogParser::VerilogNetConcatExprClass& ncec(const VerilogNetExprSyn* msg);
  static const ::VerilogParser::VerilogConstantExprClass& cec(const VerilogNetExprSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::VerilogParser::VerilogNetExprClass&
VerilogNetExprSyn::_Internal::parent(const VerilogNetExprSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::VerilogParser::VerilogNetIDExprClass&
VerilogNetExprSyn::_Internal::nidec(const VerilogNetExprSyn* msg) {
  return *msg->_impl_.vnes_.nidec_;
}
const ::VerilogParser::VerilogNetConcatExprClass&
VerilogNetExprSyn::_Internal::ncec(const VerilogNetExprSyn* msg) {
  return *msg->_impl_.vnes_.ncec_;
}
const ::VerilogParser::VerilogConstantExprClass&
VerilogNetExprSyn::_Internal::cec(const VerilogNetExprSyn* msg) {
  return *msg->_impl_.vnes_.cec_;
}
void VerilogNetExprSyn::set_allocated_nidec(::VerilogParser::VerilogNetIDExprClass* nidec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vnes();
  if (nidec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nidec);
    if (message_arena != submessage_arena) {
      nidec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nidec, submessage_arena);
    }
    set_has_nidec();
    _impl_.vnes_.nidec_ = nidec;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogNetExprSyn.nidec)
}
void VerilogNetExprSyn::set_allocated_ncec(::VerilogParser::VerilogNetConcatExprClass* ncec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vnes();
  if (ncec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ncec);
    if (message_arena != submessage_arena) {
      ncec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ncec, submessage_arena);
    }
    set_has_ncec();
    _impl_.vnes_.ncec_ = ncec;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogNetExprSyn.ncec)
}
void VerilogNetExprSyn::set_allocated_cec(::VerilogParser::VerilogConstantExprClass* cec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vnes();
  if (cec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cec);
    if (message_arena != submessage_arena) {
      cec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cec, submessage_arena);
    }
    set_has_cec();
    _impl_.vnes_.cec_ = cec;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogNetExprSyn.cec)
}
VerilogNetExprSyn::VerilogNetExprSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogNetExprSyn)
}
VerilogNetExprSyn::VerilogNetExprSyn(const VerilogNetExprSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogNetExprSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.vnes_type_){}
    , decltype(_impl_.vnes_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::VerilogParser::VerilogNetExprClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vnes_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.vnes_type_));
  clear_has_vnes();
  switch (from.vnes_case()) {
    case kNidec: {
      _this->_internal_mutable_nidec()->::VerilogParser::VerilogNetIDExprClass::MergeFrom(
          from._internal_nidec());
      break;
    }
    case kNcec: {
      _this->_internal_mutable_ncec()->::VerilogParser::VerilogNetConcatExprClass::MergeFrom(
          from._internal_ncec());
      break;
    }
    case kCec: {
      _this->_internal_mutable_cec()->::VerilogParser::VerilogConstantExprClass::MergeFrom(
          from._internal_cec());
      break;
    }
    case VNES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogNetExprSyn)
}

inline void VerilogNetExprSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.vnes_type_){0}
    , decltype(_impl_.vnes_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_vnes();
}

VerilogNetExprSyn::~VerilogNetExprSyn() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogNetExprSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogNetExprSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_vnes()) {
    clear_vnes();
  }
}

void VerilogNetExprSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogNetExprSyn::clear_vnes() {
// @@protoc_insertion_point(one_of_clear_start:VerilogParser.VerilogNetExprSyn)
  switch (vnes_case()) {
    case kNidec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vnes_.nidec_;
      }
      break;
    }
    case kNcec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vnes_.ncec_;
      }
      break;
    }
    case kCec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vnes_.cec_;
      }
      break;
    }
    case VNES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VNES_NOT_SET;
}


void VerilogNetExprSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogNetExprSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vnes_type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.vnes_type_));
  }
  clear_vnes();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogNetExprSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 vnes_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vnes_type(&has_bits);
          _impl_.vnes_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .VerilogParser.VerilogNetExprClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogNetIDExprClass nidec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_nidec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogNetConcatExprClass ncec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ncec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogConstantExprClass cec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_cec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogNetExprSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogNetExprSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 vnes_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_vnes_type(), target);
  }

  // required .VerilogParser.VerilogNetExprClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (vnes_case()) {
    case kNidec: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::nidec(this),
          _Internal::nidec(this).GetCachedSize(), target, stream);
      break;
    }
    case kNcec: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::ncec(this),
          _Internal::ncec(this).GetCachedSize(), target, stream);
      break;
    }
    case kCec: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::cec(this),
          _Internal::cec(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogNetExprSyn)
  return target;
}

size_t VerilogNetExprSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogNetExprSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .VerilogParser.VerilogNetExprClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_vnes_type()) {
    // required int32 vnes_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vnes_type());
  }

  return total_size;
}
size_t VerilogNetExprSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogNetExprSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .VerilogParser.VerilogNetExprClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 vnes_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vnes_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (vnes_case()) {
    // .VerilogParser.VerilogNetIDExprClass nidec = 4;
    case kNidec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vnes_.nidec_);
      break;
    }
    // .VerilogParser.VerilogNetConcatExprClass ncec = 5;
    case kNcec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vnes_.ncec_);
      break;
    }
    // .VerilogParser.VerilogConstantExprClass cec = 6;
    case kCec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vnes_.cec_);
      break;
    }
    case VNES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogNetExprSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogNetExprSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogNetExprSyn::GetClassData() const { return &_class_data_; }


void VerilogNetExprSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogNetExprSyn*>(&to_msg);
  auto& from = static_cast<const VerilogNetExprSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogNetExprSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::VerilogParser::VerilogNetExprClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vnes_type_ = from._impl_.vnes_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.vnes_case()) {
    case kNidec: {
      _this->_internal_mutable_nidec()->::VerilogParser::VerilogNetIDExprClass::MergeFrom(
          from._internal_nidec());
      break;
    }
    case kNcec: {
      _this->_internal_mutable_ncec()->::VerilogParser::VerilogNetConcatExprClass::MergeFrom(
          from._internal_ncec());
      break;
    }
    case kCec: {
      _this->_internal_mutable_cec()->::VerilogParser::VerilogConstantExprClass::MergeFrom(
          from._internal_cec());
      break;
    }
    case VNES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogNetExprSyn::CopyFrom(const VerilogNetExprSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogNetExprSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogNetExprSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (vnes_case()) {
    case kNidec: {
      if (_internal_has_nidec()) {
        if (!_impl_.vnes_.nidec_->IsInitialized()) return false;
      }
      break;
    }
    case kNcec: {
      break;
    }
    case kCec: {
      if (_internal_has_cec()) {
        if (!_impl_.vnes_.cec_->IsInitialized()) return false;
      }
      break;
    }
    case VNES_NOT_SET: {
      break;
    }
  }
  return true;
}

void VerilogNetExprSyn::InternalSwap(VerilogNetExprSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogNetExprSyn, _impl_.vnes_type_)
      + sizeof(VerilogNetExprSyn::_impl_.vnes_type_)
      - PROTOBUF_FIELD_OFFSET(VerilogNetExprSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.vnes_, other->_impl_.vnes_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogNetExprSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[9]);
}

// ===================================================================

class VerilogPortRefPortConnectClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogPortRefPortConnectClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__port_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__net_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

VerilogPortRefPortConnectClass::VerilogPortRefPortConnectClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogPortRefPortConnectClass)
}
VerilogPortRefPortConnectClass::VerilogPortRefPortConnectClass(const VerilogPortRefPortConnectClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogPortRefPortConnectClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_._port_id_){}
    , decltype(_impl_._net_expr_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._net_expr_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._net_expr_));
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogPortRefPortConnectClass)
}

inline void VerilogPortRefPortConnectClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){0}
    , decltype(_impl_._port_id_){0}
    , decltype(_impl_._net_expr_){0}
  };
}

VerilogPortRefPortConnectClass::~VerilogPortRefPortConnectClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogPortRefPortConnectClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogPortRefPortConnectClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogPortRefPortConnectClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogPortRefPortConnectClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogPortRefPortConnectClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._net_expr_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._net_expr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogPortRefPortConnectClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 _port_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__port_id(&has_bits);
          _impl_._port_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 _net_expr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__net_expr(&has_bits);
          _impl_._net_expr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogPortRefPortConnectClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogPortRefPortConnectClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 _port_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal__port_id(), target);
  }

  // optional int32 _net_expr = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal__net_expr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogPortRefPortConnectClass)
  return target;
}

size_t VerilogPortRefPortConnectClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogPortRefPortConnectClass)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has__port_id()) {
    // required int32 _port_id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__port_id());
  }

  return total_size;
}
size_t VerilogPortRefPortConnectClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogPortRefPortConnectClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 _port_id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__port_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 _net_expr = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__net_expr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogPortRefPortConnectClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogPortRefPortConnectClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogPortRefPortConnectClass::GetClassData() const { return &_class_data_; }


void VerilogPortRefPortConnectClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogPortRefPortConnectClass*>(&to_msg);
  auto& from = static_cast<const VerilogPortRefPortConnectClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogPortRefPortConnectClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._port_id_ = from._impl_._port_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._net_expr_ = from._impl_._net_expr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogPortRefPortConnectClass::CopyFrom(const VerilogPortRefPortConnectClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogPortRefPortConnectClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogPortRefPortConnectClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogPortRefPortConnectClass::InternalSwap(VerilogPortRefPortConnectClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogPortRefPortConnectClass, _impl_._net_expr_)
      + sizeof(VerilogPortRefPortConnectClass::_impl_._net_expr_)
      - PROTOBUF_FIELD_OFFSET(VerilogPortRefPortConnectClass, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogPortRefPortConnectClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[10]);
}

// ===================================================================

class VerilogStmtClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogStmtClass>()._impl_._has_bits_);
  static void set_has__line(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogStmtClass::VerilogStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogStmtClass)
}
VerilogStmtClass::VerilogStmtClass(const VerilogStmtClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogStmtClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._line_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._line_ = from._impl_._line_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogStmtClass)
}

inline void VerilogStmtClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._line_){0}
  };
}

VerilogStmtClass::~VerilogStmtClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogStmtClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogStmtClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogStmtClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogStmtClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogStmtClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._line_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogStmtClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _line = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__line(&has_bits);
          _impl_._line_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogStmtClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogStmtClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _line = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal__line(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogStmtClass)
  return target;
}

size_t VerilogStmtClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogStmtClass)
  size_t total_size = 0;

  // required int32 _line = 1;
  if (_internal_has__line()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__line());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogStmtClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogStmtClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogStmtClass::GetClassData() const { return &_class_data_; }


void VerilogStmtClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogStmtClass*>(&to_msg);
  auto& from = static_cast<const VerilogStmtClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogStmtClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__line()) {
    _this->_internal_set__line(from._internal__line());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogStmtClass::CopyFrom(const VerilogStmtClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogStmtClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogStmtClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogStmtClass::InternalSwap(VerilogStmtClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._line_, other->_impl_._line_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogStmtClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[11]);
}

// ===================================================================

class VerilogInstClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogInstClass>()._impl_._has_bits_);
  static void set_has__inst_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__cell_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

VerilogInstClass::VerilogInstClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogInstClass)
}
VerilogInstClass::VerilogInstClass(const VerilogInstClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogInstClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_connections_){from._impl_._port_connections_}
    , decltype(_impl_._inst_name_){}
    , decltype(_impl_._cell_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._inst_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._inst_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__inst_name()) {
    _this->_impl_._inst_name_.Set(from._internal__inst_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_._cell_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__cell_name()) {
    _this->_impl_._cell_name_.Set(from._internal__cell_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogInstClass)
}

inline void VerilogInstClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_connections_){arena}
    , decltype(_impl_._inst_name_){}
    , decltype(_impl_._cell_name_){}
  };
  _impl_._inst_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._inst_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._cell_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VerilogInstClass::~VerilogInstClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogInstClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogInstClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._port_connections_.~RepeatedField();
  _impl_._inst_name_.Destroy();
  _impl_._cell_name_.Destroy();
}

void VerilogInstClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogInstClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogInstClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._port_connections_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._inst_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._cell_name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogInstClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _inst_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__inst_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "VerilogParser.VerilogInstClass._inst_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _cell_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__cell_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "VerilogParser.VerilogInstClass._cell_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated int32 _port_connections = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__port_connections(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable__port_connections(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogInstClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogInstClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _inst_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__inst_name().data(), static_cast<int>(this->_internal__inst_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "VerilogParser.VerilogInstClass._inst_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__inst_name(), target);
  }

  // required string _cell_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__cell_name().data(), static_cast<int>(this->_internal__cell_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "VerilogParser.VerilogInstClass._cell_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__cell_name(), target);
  }

  // repeated int32 _port_connections = 3;
  for (int i = 0, n = this->_internal__port_connections_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal__port_connections(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogInstClass)
  return target;
}

size_t VerilogInstClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogInstClass)
  size_t total_size = 0;

  if (_internal_has__inst_name()) {
    // required string _inst_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__inst_name());
  }

  if (_internal_has__cell_name()) {
    // required string _cell_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__cell_name());
  }

  return total_size;
}
size_t VerilogInstClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogInstClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string _inst_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__inst_name());

    // required string _cell_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__cell_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 _port_connections = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_._port_connections_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__port_connections_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogInstClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogInstClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogInstClass::GetClassData() const { return &_class_data_; }


void VerilogInstClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogInstClass*>(&to_msg);
  auto& from = static_cast<const VerilogInstClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogInstClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._port_connections_.MergeFrom(from._impl_._port_connections_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__inst_name(from._internal__inst_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__cell_name(from._internal__cell_name());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogInstClass::CopyFrom(const VerilogInstClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogInstClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogInstClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogInstClass::InternalSwap(VerilogInstClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._port_connections_.InternalSwap(&other->_impl_._port_connections_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._inst_name_, lhs_arena,
      &other->_impl_._inst_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._cell_name_, lhs_arena,
      &other->_impl_._cell_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogInstClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[12]);
}

// ===================================================================

class VerilogDclTypeEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogDclTypeEnum>()._impl_._has_bits_);
  static void set_has_dt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogDclTypeEnum::VerilogDclTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogDclTypeEnum)
}
VerilogDclTypeEnum::VerilogDclTypeEnum(const VerilogDclTypeEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogDclTypeEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dt_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.dt_ = from._impl_.dt_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogDclTypeEnum)
}

inline void VerilogDclTypeEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dt_){0}
  };
}

VerilogDclTypeEnum::~VerilogDclTypeEnum() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogDclTypeEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogDclTypeEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogDclTypeEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogDclTypeEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogDclTypeEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dt_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogDclTypeEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .VerilogParser.VerilogDclTypeEnum.DclType dt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::VerilogParser::VerilogDclTypeEnum_DclType_IsValid(val))) {
            _internal_set_dt(static_cast<::VerilogParser::VerilogDclTypeEnum_DclType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogDclTypeEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogDclTypeEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .VerilogParser.VerilogDclTypeEnum.DclType dt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogDclTypeEnum)
  return target;
}

size_t VerilogDclTypeEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogDclTypeEnum)
  size_t total_size = 0;

  // required .VerilogParser.VerilogDclTypeEnum.DclType dt = 1;
  if (_internal_has_dt()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dt());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogDclTypeEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogDclTypeEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogDclTypeEnum::GetClassData() const { return &_class_data_; }


void VerilogDclTypeEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogDclTypeEnum*>(&to_msg);
  auto& from = static_cast<const VerilogDclTypeEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogDclTypeEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dt()) {
    _this->_internal_set_dt(from._internal_dt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogDclTypeEnum::CopyFrom(const VerilogDclTypeEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogDclTypeEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogDclTypeEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogDclTypeEnum::InternalSwap(VerilogDclTypeEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.dt_, other->_impl_.dt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogDclTypeEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[13]);
}

// ===================================================================

class VerilogDclClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogDclClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::VerilogParser::VerilogDclTypeEnum& _dcl_type(const VerilogDclClass* msg);
  static void set_has__dcl_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__dcl_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Common::Types::IntPair& _range(const VerilogDclClass* msg);
  static void set_has__range(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

const ::VerilogParser::VerilogDclTypeEnum&
VerilogDclClass::_Internal::_dcl_type(const VerilogDclClass* msg) {
  return *msg->_impl_._dcl_type_;
}
const ::Common::Types::IntPair&
VerilogDclClass::_Internal::_range(const VerilogDclClass* msg) {
  return *msg->_impl_._range_;
}
void VerilogDclClass::clear__range() {
  if (_impl_._range_ != nullptr) _impl_._range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
VerilogDclClass::VerilogDclClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogDclClass)
}
VerilogDclClass::VerilogDclClass(const VerilogDclClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogDclClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._dcl_name_){}
    , decltype(_impl_._dcl_type_){nullptr}
    , decltype(_impl_._range_){nullptr}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._dcl_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._dcl_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__dcl_name()) {
    _this->_impl_._dcl_name_.Set(from._internal__dcl_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has__dcl_type()) {
    _this->_impl_._dcl_type_ = new ::VerilogParser::VerilogDclTypeEnum(*from._impl_._dcl_type_);
  }
  if (from._internal_has__range()) {
    _this->_impl_._range_ = new ::Common::Types::IntPair(*from._impl_._range_);
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogDclClass)
}

inline void VerilogDclClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._dcl_name_){}
    , decltype(_impl_._dcl_type_){nullptr}
    , decltype(_impl_._range_){nullptr}
    , decltype(_impl_.id_){0}
  };
  _impl_._dcl_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._dcl_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VerilogDclClass::~VerilogDclClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogDclClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogDclClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._dcl_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_._dcl_type_;
  if (this != internal_default_instance()) delete _impl_._range_;
}

void VerilogDclClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogDclClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogDclClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._dcl_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_._dcl_type_ != nullptr);
      _impl_._dcl_type_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_._range_ != nullptr);
      _impl_._range_->Clear();
    }
  }
  _impl_.id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogDclClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .VerilogParser.VerilogDclTypeEnum _dcl_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable__dcl_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _dcl_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable__dcl_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "VerilogParser.VerilogDclClass._dcl_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .Common.Types.IntPair _range = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable__range(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogDclClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogDclClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required .VerilogParser.VerilogDclTypeEnum _dcl_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::_dcl_type(this),
        _Internal::_dcl_type(this).GetCachedSize(), target, stream);
  }

  // required string _dcl_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__dcl_name().data(), static_cast<int>(this->_internal__dcl_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "VerilogParser.VerilogDclClass._dcl_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal__dcl_name(), target);
  }

  // optional .Common.Types.IntPair _range = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::_range(this),
        _Internal::_range(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogDclClass)
  return target;
}

size_t VerilogDclClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogDclClass)
  size_t total_size = 0;

  if (_internal_has__dcl_name()) {
    // required string _dcl_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__dcl_name());
  }

  if (_internal_has__dcl_type()) {
    // required .VerilogParser.VerilogDclTypeEnum _dcl_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._dcl_type_);
  }

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return total_size;
}
size_t VerilogDclClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogDclClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required string _dcl_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__dcl_name());

    // required .VerilogParser.VerilogDclTypeEnum _dcl_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._dcl_type_);

    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Common.Types.IntPair _range = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._range_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogDclClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogDclClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogDclClass::GetClassData() const { return &_class_data_; }


void VerilogDclClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogDclClass*>(&to_msg);
  auto& from = static_cast<const VerilogDclClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogDclClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__dcl_name(from._internal__dcl_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable__dcl_type()->::VerilogParser::VerilogDclTypeEnum::MergeFrom(
          from._internal__dcl_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable__range()->::Common::Types::IntPair::MergeFrom(
          from._internal__range());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogDclClass::CopyFrom(const VerilogDclClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogDclClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogDclClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__dcl_type()) {
    if (!_impl_._dcl_type_->IsInitialized()) return false;
  }
  if (_internal_has__range()) {
    if (!_impl_._range_->IsInitialized()) return false;
  }
  return true;
}

void VerilogDclClass::InternalSwap(VerilogDclClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._dcl_name_, lhs_arena,
      &other->_impl_._dcl_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogDclClass, _impl_.id_)
      + sizeof(VerilogDclClass::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(VerilogDclClass, _impl_._dcl_type_)>(
          reinterpret_cast<char*>(&_impl_._dcl_type_),
          reinterpret_cast<char*>(&other->_impl_._dcl_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogDclClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[14]);
}

// ===================================================================

class VerilogDclsClass::_Internal {
 public:
};

VerilogDclsClass::VerilogDclsClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogDclsClass)
}
VerilogDclsClass::VerilogDclsClass(const VerilogDclsClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogDclsClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._verilog_dcls_){from._impl_._verilog_dcls_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogDclsClass)
}

inline void VerilogDclsClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._verilog_dcls_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VerilogDclsClass::~VerilogDclsClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogDclsClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogDclsClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._verilog_dcls_.~RepeatedField();
}

void VerilogDclsClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogDclsClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogDclsClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._verilog_dcls_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogDclsClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 _verilog_dcls = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__verilog_dcls(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable__verilog_dcls(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogDclsClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogDclsClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 _verilog_dcls = 2;
  for (int i = 0, n = this->_internal__verilog_dcls_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal__verilog_dcls(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogDclsClass)
  return target;
}

size_t VerilogDclsClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogDclsClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 _verilog_dcls = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_._verilog_dcls_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__verilog_dcls_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogDclsClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogDclsClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogDclsClass::GetClassData() const { return &_class_data_; }


void VerilogDclsClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogDclsClass*>(&to_msg);
  auto& from = static_cast<const VerilogDclsClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogDclsClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._verilog_dcls_.MergeFrom(from._impl_._verilog_dcls_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogDclsClass::CopyFrom(const VerilogDclsClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogDclsClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogDclsClass::IsInitialized() const {
  return true;
}

void VerilogDclsClass::InternalSwap(VerilogDclsClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._verilog_dcls_.InternalSwap(&other->_impl_._verilog_dcls_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogDclsClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[15]);
}

// ===================================================================

class VerilogModuleClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogModuleClass>()._impl_._has_bits_);
  static void set_has__module_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VerilogModuleClass::VerilogModuleClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogModuleClass)
}
VerilogModuleClass::VerilogModuleClass(const VerilogModuleClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogModuleClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_list_){from._impl_._port_list_}
    , decltype(_impl_._module_stmts_){from._impl_._module_stmts_}
    , decltype(_impl_._module_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._module_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._module_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__module_name()) {
    _this->_impl_._module_name_.Set(from._internal__module_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogModuleClass)
}

inline void VerilogModuleClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_list_){arena}
    , decltype(_impl_._module_stmts_){arena}
    , decltype(_impl_._module_name_){}
  };
  _impl_._module_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._module_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VerilogModuleClass::~VerilogModuleClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogModuleClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogModuleClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._port_list_.~RepeatedField();
  _impl_._module_stmts_.~RepeatedField();
  _impl_._module_name_.Destroy();
}

void VerilogModuleClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogModuleClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogModuleClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._port_list_.Clear();
  _impl_._module_stmts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._module_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogModuleClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _module_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__module_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "VerilogParser.VerilogModuleClass._module_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated int32 _port_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__port_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable__port_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 _module_stmts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__module_stmts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable__module_stmts(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogModuleClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogModuleClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _module_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__module_name().data(), static_cast<int>(this->_internal__module_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "VerilogParser.VerilogModuleClass._module_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__module_name(), target);
  }

  // repeated int32 _port_list = 2;
  for (int i = 0, n = this->_internal__port_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal__port_list(i), target);
  }

  // repeated int32 _module_stmts = 3;
  for (int i = 0, n = this->_internal__module_stmts_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal__module_stmts(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogModuleClass)
  return target;
}

size_t VerilogModuleClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogModuleClass)
  size_t total_size = 0;

  // required string _module_name = 1;
  if (_internal_has__module_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__module_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 _port_list = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_._port_list_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__port_list_size());
    total_size += data_size;
  }

  // repeated int32 _module_stmts = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_._module_stmts_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__module_stmts_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogModuleClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogModuleClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogModuleClass::GetClassData() const { return &_class_data_; }


void VerilogModuleClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogModuleClass*>(&to_msg);
  auto& from = static_cast<const VerilogModuleClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogModuleClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._port_list_.MergeFrom(from._impl_._port_list_);
  _this->_impl_._module_stmts_.MergeFrom(from._impl_._module_stmts_);
  if (from._internal_has__module_name()) {
    _this->_internal_set__module_name(from._internal__module_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogModuleClass::CopyFrom(const VerilogModuleClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogModuleClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogModuleClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogModuleClass::InternalSwap(VerilogModuleClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._port_list_.InternalSwap(&other->_impl_._port_list_);
  _impl_._module_stmts_.InternalSwap(&other->_impl_._module_stmts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._module_name_, lhs_arena,
      &other->_impl_._module_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogModuleClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[16]);
}

// ===================================================================

class VerilogStmtSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogStmtSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vss_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::VerilogParser::VerilogStmtClass& parent(const VerilogStmtSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::VerilogParser::VerilogInstClass& i(const VerilogStmtSyn* msg);
  static const ::VerilogParser::VerilogDclClass& d(const VerilogStmtSyn* msg);
  static const ::VerilogParser::VerilogDclsClass& ds(const VerilogStmtSyn* msg);
  static const ::VerilogParser::VerilogModuleClass& m(const VerilogStmtSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::VerilogParser::VerilogStmtClass&
VerilogStmtSyn::_Internal::parent(const VerilogStmtSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::VerilogParser::VerilogInstClass&
VerilogStmtSyn::_Internal::i(const VerilogStmtSyn* msg) {
  return *msg->_impl_.vss_.i_;
}
const ::VerilogParser::VerilogDclClass&
VerilogStmtSyn::_Internal::d(const VerilogStmtSyn* msg) {
  return *msg->_impl_.vss_.d_;
}
const ::VerilogParser::VerilogDclsClass&
VerilogStmtSyn::_Internal::ds(const VerilogStmtSyn* msg) {
  return *msg->_impl_.vss_.ds_;
}
const ::VerilogParser::VerilogModuleClass&
VerilogStmtSyn::_Internal::m(const VerilogStmtSyn* msg) {
  return *msg->_impl_.vss_.m_;
}
void VerilogStmtSyn::set_allocated_i(::VerilogParser::VerilogInstClass* i) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vss();
  if (i) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(i);
    if (message_arena != submessage_arena) {
      i = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, i, submessage_arena);
    }
    set_has_i();
    _impl_.vss_.i_ = i;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogStmtSyn.i)
}
void VerilogStmtSyn::set_allocated_d(::VerilogParser::VerilogDclClass* d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vss();
  if (d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(d);
    if (message_arena != submessage_arena) {
      d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, d, submessage_arena);
    }
    set_has_d();
    _impl_.vss_.d_ = d;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogStmtSyn.d)
}
void VerilogStmtSyn::set_allocated_ds(::VerilogParser::VerilogDclsClass* ds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vss();
  if (ds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ds);
    if (message_arena != submessage_arena) {
      ds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ds, submessage_arena);
    }
    set_has_ds();
    _impl_.vss_.ds_ = ds;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogStmtSyn.ds)
}
void VerilogStmtSyn::set_allocated_m(::VerilogParser::VerilogModuleClass* m) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_vss();
  if (m) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m);
    if (message_arena != submessage_arena) {
      m = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m, submessage_arena);
    }
    set_has_m();
    _impl_.vss_.m_ = m;
  }
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogStmtSyn.m)
}
VerilogStmtSyn::VerilogStmtSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogStmtSyn)
}
VerilogStmtSyn::VerilogStmtSyn(const VerilogStmtSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogStmtSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.vss_type_){}
    , decltype(_impl_.vss_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::VerilogParser::VerilogStmtClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vss_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.vss_type_));
  clear_has_vss();
  switch (from.vss_case()) {
    case kI: {
      _this->_internal_mutable_i()->::VerilogParser::VerilogInstClass::MergeFrom(
          from._internal_i());
      break;
    }
    case kD: {
      _this->_internal_mutable_d()->::VerilogParser::VerilogDclClass::MergeFrom(
          from._internal_d());
      break;
    }
    case kDs: {
      _this->_internal_mutable_ds()->::VerilogParser::VerilogDclsClass::MergeFrom(
          from._internal_ds());
      break;
    }
    case kM: {
      _this->_internal_mutable_m()->::VerilogParser::VerilogModuleClass::MergeFrom(
          from._internal_m());
      break;
    }
    case VSS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogStmtSyn)
}

inline void VerilogStmtSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.vss_type_){0}
    , decltype(_impl_.vss_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_vss();
}

VerilogStmtSyn::~VerilogStmtSyn() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogStmtSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogStmtSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_vss()) {
    clear_vss();
  }
}

void VerilogStmtSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogStmtSyn::clear_vss() {
// @@protoc_insertion_point(one_of_clear_start:VerilogParser.VerilogStmtSyn)
  switch (vss_case()) {
    case kI: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vss_.i_;
      }
      break;
    }
    case kD: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vss_.d_;
      }
      break;
    }
    case kDs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vss_.ds_;
      }
      break;
    }
    case kM: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.vss_.m_;
      }
      break;
    }
    case VSS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VSS_NOT_SET;
}


void VerilogStmtSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogStmtSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vss_type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.vss_type_));
  }
  clear_vss();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogStmtSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 vss_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vss_type(&has_bits);
          _impl_.vss_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .VerilogParser.VerilogStmtClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogInstClass i = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_i(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogDclClass d = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogDclsClass ds = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ds(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VerilogParser.VerilogModuleClass m = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_m(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogStmtSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogStmtSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 vss_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_vss_type(), target);
  }

  // required .VerilogParser.VerilogStmtClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (vss_case()) {
    case kI: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::i(this),
          _Internal::i(this).GetCachedSize(), target, stream);
      break;
    }
    case kD: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::d(this),
          _Internal::d(this).GetCachedSize(), target, stream);
      break;
    }
    case kDs: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::ds(this),
          _Internal::ds(this).GetCachedSize(), target, stream);
      break;
    }
    case kM: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::m(this),
          _Internal::m(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogStmtSyn)
  return target;
}

size_t VerilogStmtSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogStmtSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .VerilogParser.VerilogStmtClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_vss_type()) {
    // required int32 vss_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vss_type());
  }

  return total_size;
}
size_t VerilogStmtSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogStmtSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .VerilogParser.VerilogStmtClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 vss_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vss_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (vss_case()) {
    // .VerilogParser.VerilogInstClass i = 4;
    case kI: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vss_.i_);
      break;
    }
    // .VerilogParser.VerilogDclClass d = 5;
    case kD: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vss_.d_);
      break;
    }
    // .VerilogParser.VerilogDclsClass ds = 6;
    case kDs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vss_.ds_);
      break;
    }
    // .VerilogParser.VerilogModuleClass m = 7;
    case kM: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vss_.m_);
      break;
    }
    case VSS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogStmtSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogStmtSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogStmtSyn::GetClassData() const { return &_class_data_; }


void VerilogStmtSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogStmtSyn*>(&to_msg);
  auto& from = static_cast<const VerilogStmtSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogStmtSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::VerilogParser::VerilogStmtClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vss_type_ = from._impl_.vss_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.vss_case()) {
    case kI: {
      _this->_internal_mutable_i()->::VerilogParser::VerilogInstClass::MergeFrom(
          from._internal_i());
      break;
    }
    case kD: {
      _this->_internal_mutable_d()->::VerilogParser::VerilogDclClass::MergeFrom(
          from._internal_d());
      break;
    }
    case kDs: {
      _this->_internal_mutable_ds()->::VerilogParser::VerilogDclsClass::MergeFrom(
          from._internal_ds());
      break;
    }
    case kM: {
      _this->_internal_mutable_m()->::VerilogParser::VerilogModuleClass::MergeFrom(
          from._internal_m());
      break;
    }
    case VSS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogStmtSyn::CopyFrom(const VerilogStmtSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogStmtSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogStmtSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (vss_case()) {
    case kI: {
      if (_internal_has_i()) {
        if (!_impl_.vss_.i_->IsInitialized()) return false;
      }
      break;
    }
    case kD: {
      if (_internal_has_d()) {
        if (!_impl_.vss_.d_->IsInitialized()) return false;
      }
      break;
    }
    case kDs: {
      break;
    }
    case kM: {
      if (_internal_has_m()) {
        if (!_impl_.vss_.m_->IsInitialized()) return false;
      }
      break;
    }
    case VSS_NOT_SET: {
      break;
    }
  }
  return true;
}

void VerilogStmtSyn::InternalSwap(VerilogStmtSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogStmtSyn, _impl_.vss_type_)
      + sizeof(VerilogStmtSyn::_impl_.vss_type_)
      - PROTOBUF_FIELD_OFFSET(VerilogStmtSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.vss_, other->_impl_.vss_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogStmtSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[17]);
}

// ===================================================================

class VerilogReaderClass::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogReaderClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_meta_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

VerilogReaderClass::VerilogReaderClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogReaderClass)
}
VerilogReaderClass::VerilogReaderClass(const VerilogReaderClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogReaderClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._verilog_modules_){from._impl_._verilog_modules_}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.meta_data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__file_name()) {
    _this->_impl_._file_name_.Set(from._internal__file_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.meta_data_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.meta_data_));
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogReaderClass)
}

inline void VerilogReaderClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._verilog_modules_){arena}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.meta_data_){0}
  };
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VerilogReaderClass::~VerilogReaderClass() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogReaderClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogReaderClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._verilog_modules_.~RepeatedField();
  _impl_._file_name_.Destroy();
}

void VerilogReaderClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogReaderClass::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogReaderClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._verilog_modules_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._file_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.meta_data_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.meta_data_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogReaderClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 meta_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_meta_data(&has_bits);
          _impl_.meta_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _file_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable__file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "VerilogParser.VerilogReaderClass._file_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated int32 _verilog_modules = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__verilog_modules(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable__verilog_modules(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogReaderClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogReaderClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 meta_data = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_meta_data(), target);
  }

  // required string _file_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__file_name().data(), static_cast<int>(this->_internal__file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "VerilogParser.VerilogReaderClass._file_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal__file_name(), target);
  }

  // repeated int32 _verilog_modules = 4;
  for (int i = 0, n = this->_internal__verilog_modules_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal__verilog_modules(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogReaderClass)
  return target;
}

size_t VerilogReaderClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogReaderClass)
  size_t total_size = 0;

  if (_internal_has__file_name()) {
    // required string _file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());
  }

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_meta_data()) {
    // required int32 meta_data = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_meta_data());
  }

  return total_size;
}
size_t VerilogReaderClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogReaderClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string _file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());

    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 meta_data = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_meta_data());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 _verilog_modules = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_._verilog_modules_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__verilog_modules_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogReaderClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogReaderClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogReaderClass::GetClassData() const { return &_class_data_; }


void VerilogReaderClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogReaderClass*>(&to_msg);
  auto& from = static_cast<const VerilogReaderClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogReaderClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._verilog_modules_.MergeFrom(from._impl_._verilog_modules_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__file_name(from._internal__file_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.meta_data_ = from._impl_.meta_data_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogReaderClass::CopyFrom(const VerilogReaderClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogReaderClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogReaderClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogReaderClass::InternalSwap(VerilogReaderClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._verilog_modules_.InternalSwap(&other->_impl_._verilog_modules_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._file_name_, lhs_arena,
      &other->_impl_._file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogReaderClass, _impl_.meta_data_)
      + sizeof(VerilogReaderClass::_impl_.meta_data_)
      - PROTOBUF_FIELD_OFFSET(VerilogReaderClass, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogReaderClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[18]);
}

// ===================================================================

class VerilogMetaData::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogMetaData>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_verilog_reader_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

VerilogMetaData::VerilogMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogMetaData)
}
VerilogMetaData::VerilogMetaData(const VerilogMetaData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogMetaData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.verilog_reader_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.verilog_reader_id_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.verilog_reader_id_));
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogMetaData)
}

inline void VerilogMetaData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.verilog_reader_id_){0}
  };
}

VerilogMetaData::~VerilogMetaData() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogMetaData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogMetaData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerilogMetaData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogMetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogMetaData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.verilog_reader_id_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.verilog_reader_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogMetaData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 verilog_reader_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_verilog_reader_id(&has_bits);
          _impl_.verilog_reader_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogMetaData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogMetaData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 verilog_reader_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_verilog_reader_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogMetaData)
  return target;
}

size_t VerilogMetaData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogMetaData)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_verilog_reader_id()) {
    // required int32 verilog_reader_id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_verilog_reader_id());
  }

  return total_size;
}
size_t VerilogMetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogMetaData)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 verilog_reader_id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_verilog_reader_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogMetaData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogMetaData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogMetaData::GetClassData() const { return &_class_data_; }


void VerilogMetaData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogMetaData*>(&to_msg);
  auto& from = static_cast<const VerilogMetaData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogMetaData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.verilog_reader_id_ = from._impl_.verilog_reader_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogMetaData::CopyFrom(const VerilogMetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogMetaData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogMetaData::InternalSwap(VerilogMetaData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogMetaData, _impl_.verilog_reader_id_)
      + sizeof(VerilogMetaData::_impl_.verilog_reader_id_)
      - PROTOBUF_FIELD_OFFSET(VerilogMetaData, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogMetaData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[19]);
}

// ===================================================================

class BatchRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<BatchRequest>()._impl_._has_bits_);
  static void set_has_batch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

BatchRequest::BatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.BatchRequest)
}
BatchRequest::BatchRequest(const BatchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.idl_){from._impl_.idl_}
    , decltype(_impl_.batch_size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.batch_size_ = from._impl_.batch_size_;
  // @@protoc_insertion_point(copy_constructor:VerilogParser.BatchRequest)
}

inline void BatchRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.idl_){arena}
    , decltype(_impl_.batch_size_){0}
  };
}

BatchRequest::~BatchRequest() {
  // @@protoc_insertion_point(destructor:VerilogParser.BatchRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.idl_.~RepeatedField();
}

void BatchRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.BatchRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.idl_.Clear();
  _impl_.batch_size_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_batch_size(&has_bits);
          _impl_.batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 idl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_idl(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_idl(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.BatchRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 batch_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_batch_size(), target);
  }

  // repeated int32 idl = 2;
  for (int i = 0, n = this->_internal_idl_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_idl(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.BatchRequest)
  return target;
}

size_t BatchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.BatchRequest)
  size_t total_size = 0;

  // required int32 batch_size = 1;
  if (_internal_has_batch_size()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_batch_size());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 idl = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.idl_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_idl_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchRequest::GetClassData() const { return &_class_data_; }


void BatchRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchRequest*>(&to_msg);
  auto& from = static_cast<const BatchRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.BatchRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.idl_.MergeFrom(from._impl_.idl_);
  if (from._internal_has_batch_size()) {
    _this->_internal_set_batch_size(from._internal_batch_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchRequest::CopyFrom(const BatchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.BatchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void BatchRequest::InternalSwap(BatchRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.idl_.InternalSwap(&other->_impl_.idl_);
  swap(_impl_.batch_size_, other->_impl_.batch_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[20]);
}

// ===================================================================

class VerilogStmtSynBatch::_Internal {
 public:
  using HasBits = decltype(std::declval<VerilogStmtSynBatch>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_syn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_stmt_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end_stmt_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

VerilogStmtSynBatch::VerilogStmtSynBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VerilogParser.VerilogStmtSynBatch)
}
VerilogStmtSynBatch::VerilogStmtSynBatch(const VerilogStmtSynBatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerilogStmtSynBatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vssl_){from._impl_.vssl_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.syn_id_){}
    , decltype(_impl_.start_stmt_id_){}
    , decltype(_impl_.end_stmt_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_stmt_id_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.end_stmt_id_));
  // @@protoc_insertion_point(copy_constructor:VerilogParser.VerilogStmtSynBatch)
}

inline void VerilogStmtSynBatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vssl_){arena}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.syn_id_){0}
    , decltype(_impl_.start_stmt_id_){int64_t{0}}
    , decltype(_impl_.end_stmt_id_){int64_t{0}}
  };
}

VerilogStmtSynBatch::~VerilogStmtSynBatch() {
  // @@protoc_insertion_point(destructor:VerilogParser.VerilogStmtSynBatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerilogStmtSynBatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vssl_.~RepeatedPtrField();
}

void VerilogStmtSynBatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerilogStmtSynBatch::Clear() {
// @@protoc_insertion_point(message_clear_start:VerilogParser.VerilogStmtSynBatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vssl_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.end_stmt_id_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.end_stmt_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerilogStmtSynBatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 syn_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_syn_id(&has_bits);
          _impl_.syn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 start_stmt_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_start_stmt_id(&has_bits);
          _impl_.start_stmt_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 end_stmt_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_end_stmt_id(&has_bits);
          _impl_.end_stmt_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes vssl = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_vssl();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerilogStmtSynBatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VerilogParser.VerilogStmtSynBatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 syn_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_syn_id(), target);
  }

  // required int64 start_stmt_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_start_stmt_id(), target);
  }

  // required int64 end_stmt_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_end_stmt_id(), target);
  }

  // repeated bytes vssl = 5;
  for (int i = 0, n = this->_internal_vssl_size(); i < n; i++) {
    const auto& s = this->_internal_vssl(i);
    target = stream->WriteBytes(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VerilogParser.VerilogStmtSynBatch)
  return target;
}

size_t VerilogStmtSynBatch::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:VerilogParser.VerilogStmtSynBatch)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_syn_id()) {
    // required int32 syn_id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_syn_id());
  }

  if (_internal_has_start_stmt_id()) {
    // required int64 start_stmt_id = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_stmt_id());
  }

  if (_internal_has_end_stmt_id()) {
    // required int64 end_stmt_id = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_stmt_id());
  }

  return total_size;
}
size_t VerilogStmtSynBatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VerilogParser.VerilogStmtSynBatch)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 syn_id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_syn_id());

    // required int64 start_stmt_id = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_stmt_id());

    // required int64 end_stmt_id = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_stmt_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes vssl = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.vssl_.size());
  for (int i = 0, n = _impl_.vssl_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.vssl_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerilogStmtSynBatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerilogStmtSynBatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerilogStmtSynBatch::GetClassData() const { return &_class_data_; }


void VerilogStmtSynBatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerilogStmtSynBatch*>(&to_msg);
  auto& from = static_cast<const VerilogStmtSynBatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VerilogParser.VerilogStmtSynBatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vssl_.MergeFrom(from._impl_.vssl_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.syn_id_ = from._impl_.syn_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_stmt_id_ = from._impl_.start_stmt_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.end_stmt_id_ = from._impl_.end_stmt_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerilogStmtSynBatch::CopyFrom(const VerilogStmtSynBatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VerilogParser.VerilogStmtSynBatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerilogStmtSynBatch::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VerilogStmtSynBatch::InternalSwap(VerilogStmtSynBatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vssl_.InternalSwap(&other->_impl_.vssl_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerilogStmtSynBatch, _impl_.end_stmt_id_)
      + sizeof(VerilogStmtSynBatch::_impl_.end_stmt_id_)
      - PROTOBUF_FIELD_OFFSET(VerilogStmtSynBatch, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerilogStmtSynBatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_VerilogReader_2eproto_getter, &descriptor_table_VerilogReader_2eproto_once,
      file_level_metadata_VerilogReader_2eproto[21]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace VerilogParser
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogIDClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogIDClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogIDClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogIndexIDClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogIndexIDClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogIndexIDClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogSliceIDClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogSliceIDClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogSliceIDClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogChildIDClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogChildIDClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogChildIDClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogIDSyn*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogIDSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogIDSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogNetExprClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogNetExprClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogNetExprClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogNetIDExprClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogNetIDExprClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogNetIDExprClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogNetConcatExprClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogNetConcatExprClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogNetConcatExprClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogConstantExprClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogConstantExprClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogConstantExprClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogNetExprSyn*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogNetExprSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogNetExprSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogPortRefPortConnectClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogPortRefPortConnectClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogPortRefPortConnectClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogStmtClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogStmtClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogStmtClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogInstClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogInstClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogInstClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogDclTypeEnum*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogDclTypeEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogDclTypeEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogDclClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogDclClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogDclClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogDclsClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogDclsClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogDclsClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogModuleClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogModuleClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogModuleClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogStmtSyn*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogStmtSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogStmtSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogReaderClass*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogReaderClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogReaderClass >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogMetaData*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogMetaData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogMetaData >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::BatchRequest*
Arena::CreateMaybeMessage< ::VerilogParser::BatchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::BatchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::VerilogParser::VerilogStmtSynBatch*
Arena::CreateMaybeMessage< ::VerilogParser::VerilogStmtSynBatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VerilogParser::VerilogStmtSynBatch >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
