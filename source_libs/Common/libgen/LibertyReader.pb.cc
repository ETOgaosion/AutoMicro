// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LibertyReader.proto

#include "LibertyReader.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Liberty {
PROTOBUF_CONSTEXPR LibertyExprOperatorEnum::LibertyExprOperatorEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.o_)*/1} {}
struct LibertyExprOperatorEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyExprOperatorEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyExprOperatorEnumDefaultTypeInternal() {}
  union {
    LibertyExprOperatorEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyExprOperatorEnumDefaultTypeInternal _LibertyExprOperatorEnum_default_instance_;
PROTOBUF_CONSTEXPR LibertyExprClass::LibertyExprClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._op_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._left_)*/uint64_t{0u}
  , /*decltype(_impl_._right_)*/uint64_t{0u}} {}
struct LibertyExprClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyExprClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyExprClassDefaultTypeInternal() {}
  union {
    LibertyExprClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyExprClassDefaultTypeInternal _LibertyExprClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyStmtClass::LibertyStmtClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._line_no_)*/0u} {}
struct LibertyStmtClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyStmtClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyStmtClassDefaultTypeInternal() {}
  union {
    LibertyStmtClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyStmtClassDefaultTypeInternal _LibertyStmtClass_default_instance_;
PROTOBUF_CONSTEXPR LibertySimpleAttrStmtClass::LibertySimpleAttrStmtClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._attri_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._attri_value_)*/nullptr
  , /*decltype(_impl_.lavs_type_)*/0u} {}
struct LibertySimpleAttrStmtClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertySimpleAttrStmtClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertySimpleAttrStmtClassDefaultTypeInternal() {}
  union {
    LibertySimpleAttrStmtClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertySimpleAttrStmtClassDefaultTypeInternal _LibertySimpleAttrStmtClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyComplexAttrStmtClass::LibertyComplexAttrStmtClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lavs_type_)*/{}
  , /*decltype(_impl_._attri_values_)*/{}
  , /*decltype(_impl_._attri_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LibertyComplexAttrStmtClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyComplexAttrStmtClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyComplexAttrStmtClassDefaultTypeInternal() {}
  union {
    LibertyComplexAttrStmtClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyComplexAttrStmtClassDefaultTypeInternal _LibertyComplexAttrStmtClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyGroupStmtClass::LibertyGroupStmtClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lavs_type_)*/{}
  , /*decltype(_impl_._attri_values_)*/{}
  , /*decltype(_impl_._stmts_)*/{}
  , /*decltype(_impl_._group_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LibertyGroupStmtClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyGroupStmtClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyGroupStmtClassDefaultTypeInternal() {}
  union {
    LibertyGroupStmtClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyGroupStmtClassDefaultTypeInternal _LibertyGroupStmtClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyStmtSyn::LibertyStmtSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.lss_type_)*/0
  , /*decltype(_impl_.lss_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LibertyStmtSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyStmtSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyStmtSynDefaultTypeInternal() {}
  union {
    LibertyStmtSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyStmtSynDefaultTypeInternal _LibertyStmtSyn_default_instance_;
PROTOBUF_CONSTEXPR LibertyObjectClass::LibertyObjectClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._line_no_)*/0u} {}
struct LibertyObjectClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyObjectClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyObjectClassDefaultTypeInternal() {}
  union {
    LibertyObjectClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyObjectClassDefaultTypeInternal _LibertyObjectClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyAxisClass::LibertyAxisClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lavs_type_)*/{}
  , /*decltype(_impl_._axis_values_)*/{}
  , /*decltype(_impl_._axis_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LibertyAxisClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyAxisClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyAxisClassDefaultTypeInternal() {}
  union {
    LibertyAxisClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyAxisClassDefaultTypeInternal _LibertyAxisClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyTableTypeEnum::LibertyTableTypeEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tt_)*/0} {}
struct LibertyTableTypeEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyTableTypeEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyTableTypeEnumDefaultTypeInternal() {}
  union {
    LibertyTableTypeEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyTableTypeEnumDefaultTypeInternal _LibertyTableTypeEnum_default_instance_;
PROTOBUF_CONSTEXPR LibertyTableClass::LibertyTableClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._axes_)*/{}
  , /*decltype(_impl_.lavs_type_)*/{}
  , /*decltype(_impl_._table_values_)*/{}
  , /*decltype(_impl_._table_type_)*/nullptr
  , /*decltype(_impl_._table_template_)*/uint64_t{0u}} {}
struct LibertyTableClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyTableClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyTableClassDefaultTypeInternal() {}
  union {
    LibertyTableClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyTableClassDefaultTypeInternal _LibertyTableClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyVectorTableClass::LibertyVectorTableClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._ref_time_)*/0} {}
struct LibertyVectorTableClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyVectorTableClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyVectorTableClassDefaultTypeInternal() {}
  union {
    LibertyVectorTableClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyVectorTableClassDefaultTypeInternal _LibertyVectorTableClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyTableSyn::LibertyTableSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.lvtc_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.lts_type_)*/0u} {}
struct LibertyTableSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyTableSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyTableSynDefaultTypeInternal() {}
  union {
    LibertyTableSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyTableSynDefaultTypeInternal _LibertyTableSyn_default_instance_;
PROTOBUF_CONSTEXPR LibertyCCSTableClass::LibertyCCSTableClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._vector_tables_)*/{}
  , /*decltype(_impl_._table_type_)*/nullptr} {}
struct LibertyCCSTableClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyCCSTableClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyCCSTableClassDefaultTypeInternal() {}
  union {
    LibertyCCSTableClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyCCSTableClassDefaultTypeInternal _LibertyCCSTableClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyDelayTableModelClass::LibertyDelayTableModelClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._tables_)*/{}
  , /*decltype(_impl_._current_tables_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LibertyDelayTableModelClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyDelayTableModelClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyDelayTableModelClassDefaultTypeInternal() {}
  union {
    LibertyDelayTableModelClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyDelayTableModelClassDefaultTypeInternal _LibertyDelayTableModelClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyCheckTableModelClass::LibertyCheckTableModelClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._tables_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LibertyCheckTableModelClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyCheckTableModelClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyCheckTableModelClassDefaultTypeInternal() {}
  union {
    LibertyCheckTableModelClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyCheckTableModelClassDefaultTypeInternal _LibertyCheckTableModelClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyPowerTableModelClass::LibertyPowerTableModelClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._tables_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LibertyPowerTableModelClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyPowerTableModelClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyPowerTableModelClassDefaultTypeInternal() {}
  union {
    LibertyPowerTableModelClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyPowerTableModelClassDefaultTypeInternal _LibertyPowerTableModelClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyTableModelSyn::LibertyTableModelSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.ltms_type_)*/0u
  , /*decltype(_impl_.ltms_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LibertyTableModelSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyTableModelSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyTableModelSynDefaultTypeInternal() {}
  union {
    LibertyTableModelSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyTableModelSynDefaultTypeInternal _LibertyTableModelSyn_default_instance_;
PROTOBUF_CONSTEXPR LibertyTypeClass::LibertyTypeClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._type_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._base_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._data_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._bit_width_)*/0u
  , /*decltype(_impl_._bit_from_)*/0u
  , /*decltype(_impl_._bit_to_)*/0u} {}
struct LibertyTypeClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyTypeClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyTypeClassDefaultTypeInternal() {}
  union {
    LibertyTypeClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyTypeClassDefaultTypeInternal _LibertyTypeClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyPortTypeEnum::LibertyPortTypeEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pt_)*/1} {}
struct LibertyPortTypeEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyPortTypeEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyPortTypeEnumDefaultTypeInternal() {}
  union {
    LibertyPortTypeEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyPortTypeEnumDefaultTypeInternal _LibertyPortTypeEnum_default_instance_;
PROTOBUF_CONSTEXPR LibertyPortClass::LibertyPortClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._port_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._port_type_)*/nullptr
  , /*decltype(_impl_._owner_cell_)*/uint64_t{0u}
  , /*decltype(_impl_._func_expr_)*/uint64_t{0u}
  , /*decltype(_impl_._port_cap_)*/0
  , /*decltype(_impl_._fanout_load_)*/0
  , /*decltype(_impl_._power_table_model_)*/uint64_t{0u}} {}
struct LibertyPortClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyPortClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyPortClassDefaultTypeInternal() {}
  union {
    LibertyPortClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyPortClassDefaultTypeInternal _LibertyPortClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyPortBusClass::LibertyPortBusClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._ports_)*/{}
  , /*decltype(_impl_._bus_type_)*/uint64_t{0u}} {}
struct LibertyPortBusClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyPortBusClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyPortBusClassDefaultTypeInternal() {}
  union {
    LibertyPortBusClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyPortBusClassDefaultTypeInternal _LibertyPortBusClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyPortSyn::LibertyPortSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.lpbc_)*/nullptr
  , /*decltype(_impl_.lps_type_)*/0u} {}
struct LibertyPortSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyPortSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyPortSynDefaultTypeInternal() {}
  union {
    LibertyPortSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyPortSynDefaultTypeInternal _LibertyPortSyn_default_instance_;
PROTOBUF_CONSTEXPR LibertyArcClass::LibertyArcClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._src_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._snk_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._timing_sense_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._timing_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._owner_cell_)*/uint64_t{0u}
  , /*decltype(_impl_._table_model_)*/uint64_t{0u}} {}
struct LibertyArcClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyArcClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyArcClassDefaultTypeInternal() {}
  union {
    LibertyArcClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyArcClassDefaultTypeInternal _LibertyArcClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyArcSetClass::LibertyArcSetClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._arcs_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}} {}
struct LibertyArcSetClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyArcSetClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyArcSetClassDefaultTypeInternal() {}
  union {
    LibertyArcSetClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyArcSetClassDefaultTypeInternal _LibertyArcSetClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyPowerArcClass::LibertyPowerArcClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._src_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._snk_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._related_pg_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._when_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._owner_cell_)*/uint64_t{0u}
  , /*decltype(_impl_._power_table_model_)*/uint64_t{0u}} {}
struct LibertyPowerArcClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyPowerArcClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyPowerArcClassDefaultTypeInternal() {}
  union {
    LibertyPowerArcClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyPowerArcClassDefaultTypeInternal _LibertyPowerArcClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyPowerArcSetClass::LibertyPowerArcSetClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._power_arcs_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}} {}
struct LibertyPowerArcSetClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyPowerArcSetClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyPowerArcSetClassDefaultTypeInternal() {}
  union {
    LibertyPowerArcSetClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyPowerArcSetClassDefaultTypeInternal _LibertyPowerArcSetClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyLeakagePowerClass::LibertyLeakagePowerClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._related_pg_port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._when_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._value_)*/0
  , /*decltype(_impl_._owner_cell_)*/uint64_t{0u}} {}
struct LibertyLeakagePowerClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyLeakagePowerClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyLeakagePowerClassDefaultTypeInternal() {}
  union {
    LibertyLeakagePowerClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyLeakagePowerClassDefaultTypeInternal _LibertyLeakagePowerClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyCellClass::LibertyCellClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._leakage_power_list_)*/{}
  , /*decltype(_impl_._cell_ports_)*/{}
  , /*decltype(_impl_._cell_port_buses_)*/{}
  , /*decltype(_impl_._cell_arcs_)*/{}
  , /*decltype(_impl_._cell_power_arcs_)*/{}
  , /*decltype(_impl_._cell_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cell_leakage_power_)*/0
  , /*decltype(_impl_._owner_lib_)*/uint64_t{0u}
  , /*decltype(_impl_._is_dont_use_)*/0u} {}
struct LibertyCellClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyCellClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyCellClassDefaultTypeInternal() {}
  union {
    LibertyCellClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyCellClassDefaultTypeInternal _LibertyCellClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LibertyWireLoadClass_FanoutToLengthEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyWireLoadClass_FanoutToLengthEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyWireLoadClass_FanoutToLengthEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyWireLoadClass_FanoutToLengthEntry_DoNotUseDefaultTypeInternal _LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LibertyWireLoadClass::LibertyWireLoadClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._fanout_to_length_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._wire_load_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cap_per_length_unit_)*/0
  , /*decltype(_impl_._resistance_per_length_unit_)*/0
  , /*decltype(_impl_._slope_)*/0} {}
struct LibertyWireLoadClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyWireLoadClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyWireLoadClassDefaultTypeInternal() {}
  union {
    LibertyWireLoadClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyWireLoadClassDefaultTypeInternal _LibertyWireLoadClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyLutTableTemplateClass::LibertyLutTableTemplateClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._axes_)*/{}
  , /*decltype(_impl_._template_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._template_variable1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._template_variable2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._template_variable3_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._template_variable4_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LibertyLutTableTemplateClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyLutTableTemplateClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyLutTableTemplateClassDefaultTypeInternal() {}
  union {
    LibertyLutTableTemplateClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyLutTableTemplateClassDefaultTypeInternal _LibertyLutTableTemplateClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyCurrentTemplateClass::LibertyCurrentTemplateClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._template_axis_)*/uint64_t{0u}} {}
struct LibertyCurrentTemplateClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyCurrentTemplateClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyCurrentTemplateClassDefaultTypeInternal() {}
  union {
    LibertyCurrentTemplateClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyCurrentTemplateClassDefaultTypeInternal _LibertyCurrentTemplateClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyLutTableTemplateSyn::LibertyLutTableTemplateSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.lctc_)*/nullptr
  , /*decltype(_impl_.lltts_type_)*/0u} {}
struct LibertyLutTableTemplateSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyLutTableTemplateSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyLutTableTemplateSynDefaultTypeInternal() {}
  union {
    LibertyLutTableTemplateSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyLutTableTemplateSynDefaultTypeInternal _LibertyLutTableTemplateSyn_default_instance_;
PROTOBUF_CONSTEXPR LibertyObjectSyn::LibertyObjectSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.los_type_)*/0u
  , /*decltype(_impl_.los_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LibertyObjectSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyObjectSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyObjectSynDefaultTypeInternal() {}
  union {
    LibertyObjectSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyObjectSynDefaultTypeInternal _LibertyObjectSyn_default_instance_;
PROTOBUF_CONSTEXPR LibertyLibraryClass::LibertyLibraryClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._cells_)*/{}
  , /*decltype(_impl_._lut_template_)*/{}
  , /*decltype(_impl_._wire_loads_)*/{}
  , /*decltype(_impl_._types_)*/{}
  , /*decltype(_impl_._lib_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._default_wire_load_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cap_unit_)*/nullptr
  , /*decltype(_impl_._resistance_unit_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._default_max_transition_)*/0
  , /*decltype(_impl_._default_max_fanout_)*/0
  , /*decltype(_impl_._default_fanout_load_)*/0} {}
struct LibertyLibraryClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyLibraryClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyLibraryClassDefaultTypeInternal() {}
  union {
    LibertyLibraryClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyLibraryClassDefaultTypeInternal _LibertyLibraryClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyOwnPortTypeEnum::LibertyOwnPortTypeEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lopt_)*/1} {}
struct LibertyOwnPortTypeEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyOwnPortTypeEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyOwnPortTypeEnumDefaultTypeInternal() {}
  union {
    LibertyOwnPortTypeEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyOwnPortTypeEnumDefaultTypeInternal _LibertyOwnPortTypeEnum_default_instance_;
PROTOBUF_CONSTEXPR LibertyOwnPgOrWhenTypeEnum::LibertyOwnPgOrWhenTypeEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lopowt_)*/1} {}
struct LibertyOwnPgOrWhenTypeEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyOwnPgOrWhenTypeEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyOwnPgOrWhenTypeEnumDefaultTypeInternal() {}
  union {
    LibertyOwnPgOrWhenTypeEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyOwnPgOrWhenTypeEnumDefaultTypeInternal _LibertyOwnPgOrWhenTypeEnum_default_instance_;
PROTOBUF_CONSTEXPR LibertyBuilderClass::LibertyBuilderClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._lib_)*/uint64_t{0u}} {}
struct LibertyBuilderClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyBuilderClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyBuilderClassDefaultTypeInternal() {}
  union {
    LibertyBuilderClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyBuilderClassDefaultTypeInternal _LibertyBuilderClass_default_instance_;
PROTOBUF_CONSTEXPR LibertyReaderClass::LibertyReaderClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._library_group_)*/uint64_t{0u}
  , /*decltype(_impl_._liberty_builder_)*/uint64_t{0u}} {}
struct LibertyReaderClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibertyReaderClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibertyReaderClassDefaultTypeInternal() {}
  union {
    LibertyReaderClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibertyReaderClassDefaultTypeInternal _LibertyReaderClass_default_instance_;
}  // namespace Liberty
static ::_pb::Metadata file_level_metadata_LibertyReader_2eproto[40];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_LibertyReader_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_LibertyReader_2eproto = nullptr;

const uint32_t TableStruct_LibertyReader_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprOperatorEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprOperatorEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprOperatorEnum, _impl_.o_),
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprClass, _impl_._op_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprClass, _impl_._left_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprClass, _impl_._right_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyExprClass, _impl_._port_),
  2,
  1,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtClass, _impl_._file_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtClass, _impl_._line_no_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertySimpleAttrStmtClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertySimpleAttrStmtClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertySimpleAttrStmtClass, _impl_._attri_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertySimpleAttrStmtClass, _impl_.lavs_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertySimpleAttrStmtClass, _impl_._attri_value_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyComplexAttrStmtClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyComplexAttrStmtClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyComplexAttrStmtClass, _impl_._attri_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyComplexAttrStmtClass, _impl_.lavs_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyComplexAttrStmtClass, _impl_._attri_values_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyGroupStmtClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyGroupStmtClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyGroupStmtClass, _impl_._group_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyGroupStmtClass, _impl_.lavs_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyGroupStmtClass, _impl_._attri_values_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyGroupStmtClass, _impl_._stmts_),
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtSyn, _impl_.lss_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyStmtSyn, _impl_.lss_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectClass, _impl_._file_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectClass, _impl_._line_no_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyAxisClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyAxisClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyAxisClass, _impl_._axis_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyAxisClass, _impl_.lavs_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyAxisClass, _impl_._axis_values_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableTypeEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableTypeEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableTypeEnum, _impl_.tt_),
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableClass, _impl_._axes_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableClass, _impl_.lavs_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableClass, _impl_._table_values_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableClass, _impl_._table_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableClass, _impl_._table_template_),
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyVectorTableClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyVectorTableClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyVectorTableClass, _impl_._ref_time_),
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableSyn, _impl_.lts_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableSyn, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableSyn, _impl_.lvtc_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCCSTableClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCCSTableClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCCSTableClass, _impl_._table_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCCSTableClass, _impl_._vector_tables_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyDelayTableModelClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyDelayTableModelClass, _impl_._tables_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyDelayTableModelClass, _impl_._current_tables_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCheckTableModelClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCheckTableModelClass, _impl_._tables_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerTableModelClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerTableModelClass, _impl_._tables_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableModelSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableModelSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableModelSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableModelSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableModelSyn, _impl_.ltms_type_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTableModelSyn, _impl_.ltms_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _impl_._type_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _impl_._base_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _impl_._data_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _impl_._bit_width_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _impl_._bit_from_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyTypeClass, _impl_._bit_to_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortTypeEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortTypeEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortTypeEnum, _impl_.pt_),
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._port_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._owner_cell_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._port_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._func_expr_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._port_cap_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._fanout_load_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortClass, _impl_._power_table_model_),
  0,
  2,
  1,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortBusClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortBusClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortBusClass, _impl_._ports_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortBusClass, _impl_._bus_type_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortSyn, _impl_.lps_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortSyn, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPortSyn, _impl_.lpbc_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _impl_._src_port_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _impl_._snk_port_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _impl_._owner_cell_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _impl_._timing_sense_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _impl_._timing_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcClass, _impl_._table_model_),
  0,
  1,
  4,
  2,
  3,
  5,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcSetClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcSetClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcSetClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyArcSetClass, _impl_._arcs_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _impl_._src_port_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _impl_._snk_port_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _impl_._related_pg_port_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _impl_._when_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _impl_._owner_cell_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcClass, _impl_._power_table_model_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcSetClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcSetClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcSetClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyPowerArcSetClass, _impl_._power_arcs_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLeakagePowerClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLeakagePowerClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLeakagePowerClass, _impl_._related_pg_port_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLeakagePowerClass, _impl_._when_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLeakagePowerClass, _impl_._value_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLeakagePowerClass, _impl_._owner_cell_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._cell_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._cell_leakage_power_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._leakage_power_list_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._cell_ports_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._cell_port_buses_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._cell_arcs_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._cell_power_arcs_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._owner_lib_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCellClass, _impl_._is_dont_use_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass, _impl_._wire_load_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass, _impl_._fanout_to_length_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass, _impl_._cap_per_length_unit_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass, _impl_._resistance_per_length_unit_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyWireLoadClass, _impl_._slope_),
  0,
  ~0u,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _impl_._template_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _impl_._template_variable1_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _impl_._template_variable2_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _impl_._template_variable3_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _impl_._template_variable4_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateClass, _impl_._axes_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCurrentTemplateClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCurrentTemplateClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyCurrentTemplateClass, _impl_._template_axis_),
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateSyn, _impl_.lltts_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateSyn, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLutTableTemplateSyn, _impl_.lctc_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectSyn, _impl_.los_type_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyObjectSyn, _impl_.los_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._lib_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._cells_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._lut_template_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._wire_loads_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._types_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._cap_unit_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._resistance_unit_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._default_max_transition_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._default_max_fanout_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._default_fanout_load_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyLibraryClass, _impl_._default_wire_load_),
  4,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  5,
  6,
  7,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyOwnPortTypeEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyOwnPortTypeEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyOwnPortTypeEnum, _impl_.lopt_),
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyOwnPgOrWhenTypeEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyOwnPgOrWhenTypeEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyOwnPgOrWhenTypeEnum, _impl_.lopowt_),
  0,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyBuilderClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyBuilderClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyBuilderClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyBuilderClass, _impl_._lib_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyReaderClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyReaderClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyReaderClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyReaderClass, _impl_._library_group_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyReaderClass, _impl_._file_name_),
  PROTOBUF_FIELD_OFFSET(::Liberty::LibertyReaderClass, _impl_._liberty_builder_),
  1,
  2,
  0,
  3,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::Liberty::LibertyExprOperatorEnum)},
  { 8, 19, -1, sizeof(::Liberty::LibertyExprClass)},
  { 24, 32, -1, sizeof(::Liberty::LibertyStmtClass)},
  { 34, 43, -1, sizeof(::Liberty::LibertySimpleAttrStmtClass)},
  { 46, 55, -1, sizeof(::Liberty::LibertyComplexAttrStmtClass)},
  { 58, 68, -1, sizeof(::Liberty::LibertyGroupStmtClass)},
  { 72, 85, -1, sizeof(::Liberty::LibertyStmtSyn)},
  { 91, 99, -1, sizeof(::Liberty::LibertyObjectClass)},
  { 101, 110, -1, sizeof(::Liberty::LibertyAxisClass)},
  { 113, 120, -1, sizeof(::Liberty::LibertyTableTypeEnum)},
  { 121, 132, -1, sizeof(::Liberty::LibertyTableClass)},
  { 137, 144, -1, sizeof(::Liberty::LibertyVectorTableClass)},
  { 145, 155, -1, sizeof(::Liberty::LibertyTableSyn)},
  { 159, 167, -1, sizeof(::Liberty::LibertyCCSTableClass)},
  { 169, -1, -1, sizeof(::Liberty::LibertyDelayTableModelClass)},
  { 177, -1, -1, sizeof(::Liberty::LibertyCheckTableModelClass)},
  { 184, -1, -1, sizeof(::Liberty::LibertyPowerTableModelClass)},
  { 191, 203, -1, sizeof(::Liberty::LibertyTableModelSyn)},
  { 208, 220, -1, sizeof(::Liberty::LibertyTypeClass)},
  { 226, 233, -1, sizeof(::Liberty::LibertyPortTypeEnum)},
  { 234, 247, -1, sizeof(::Liberty::LibertyPortClass)},
  { 254, 262, -1, sizeof(::Liberty::LibertyPortBusClass)},
  { 264, 273, -1, sizeof(::Liberty::LibertyPortSyn)},
  { 276, 288, -1, sizeof(::Liberty::LibertyArcClass)},
  { 294, 302, -1, sizeof(::Liberty::LibertyArcSetClass)},
  { 304, 316, -1, sizeof(::Liberty::LibertyPowerArcClass)},
  { 322, 330, -1, sizeof(::Liberty::LibertyPowerArcSetClass)},
  { 332, 342, -1, sizeof(::Liberty::LibertyLeakagePowerClass)},
  { 346, 361, -1, sizeof(::Liberty::LibertyCellClass)},
  { 370, 378, -1, sizeof(::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse)},
  { 380, 391, -1, sizeof(::Liberty::LibertyWireLoadClass)},
  { 396, 408, -1, sizeof(::Liberty::LibertyLutTableTemplateClass)},
  { 414, 421, -1, sizeof(::Liberty::LibertyCurrentTemplateClass)},
  { 422, 431, -1, sizeof(::Liberty::LibertyLutTableTemplateSyn)},
  { 434, 456, -1, sizeof(::Liberty::LibertyObjectSyn)},
  { 471, 489, -1, sizeof(::Liberty::LibertyLibraryClass)},
  { 501, 508, -1, sizeof(::Liberty::LibertyOwnPortTypeEnum)},
  { 509, 516, -1, sizeof(::Liberty::LibertyOwnPgOrWhenTypeEnum)},
  { 517, 525, -1, sizeof(::Liberty::LibertyBuilderClass)},
  { 527, 537, -1, sizeof(::Liberty::LibertyReaderClass)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Liberty::_LibertyExprOperatorEnum_default_instance_._instance,
  &::Liberty::_LibertyExprClass_default_instance_._instance,
  &::Liberty::_LibertyStmtClass_default_instance_._instance,
  &::Liberty::_LibertySimpleAttrStmtClass_default_instance_._instance,
  &::Liberty::_LibertyComplexAttrStmtClass_default_instance_._instance,
  &::Liberty::_LibertyGroupStmtClass_default_instance_._instance,
  &::Liberty::_LibertyStmtSyn_default_instance_._instance,
  &::Liberty::_LibertyObjectClass_default_instance_._instance,
  &::Liberty::_LibertyAxisClass_default_instance_._instance,
  &::Liberty::_LibertyTableTypeEnum_default_instance_._instance,
  &::Liberty::_LibertyTableClass_default_instance_._instance,
  &::Liberty::_LibertyVectorTableClass_default_instance_._instance,
  &::Liberty::_LibertyTableSyn_default_instance_._instance,
  &::Liberty::_LibertyCCSTableClass_default_instance_._instance,
  &::Liberty::_LibertyDelayTableModelClass_default_instance_._instance,
  &::Liberty::_LibertyCheckTableModelClass_default_instance_._instance,
  &::Liberty::_LibertyPowerTableModelClass_default_instance_._instance,
  &::Liberty::_LibertyTableModelSyn_default_instance_._instance,
  &::Liberty::_LibertyTypeClass_default_instance_._instance,
  &::Liberty::_LibertyPortTypeEnum_default_instance_._instance,
  &::Liberty::_LibertyPortClass_default_instance_._instance,
  &::Liberty::_LibertyPortBusClass_default_instance_._instance,
  &::Liberty::_LibertyPortSyn_default_instance_._instance,
  &::Liberty::_LibertyArcClass_default_instance_._instance,
  &::Liberty::_LibertyArcSetClass_default_instance_._instance,
  &::Liberty::_LibertyPowerArcClass_default_instance_._instance,
  &::Liberty::_LibertyPowerArcSetClass_default_instance_._instance,
  &::Liberty::_LibertyLeakagePowerClass_default_instance_._instance,
  &::Liberty::_LibertyCellClass_default_instance_._instance,
  &::Liberty::_LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse_default_instance_._instance,
  &::Liberty::_LibertyWireLoadClass_default_instance_._instance,
  &::Liberty::_LibertyLutTableTemplateClass_default_instance_._instance,
  &::Liberty::_LibertyCurrentTemplateClass_default_instance_._instance,
  &::Liberty::_LibertyLutTableTemplateSyn_default_instance_._instance,
  &::Liberty::_LibertyObjectSyn_default_instance_._instance,
  &::Liberty::_LibertyLibraryClass_default_instance_._instance,
  &::Liberty::_LibertyOwnPortTypeEnum_default_instance_._instance,
  &::Liberty::_LibertyOwnPgOrWhenTypeEnum_default_instance_._instance,
  &::Liberty::_LibertyBuilderClass_default_instance_._instance,
  &::Liberty::_LibertyReaderClass_default_instance_._instance,
};

const char descriptor_table_protodef_LibertyReader_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023LibertyReader.proto\022\007Liberty\032\021CommonTy"
  "pes.proto\"\272\001\n\027LibertyExprOperatorEnum\0224\n"
  "\001o\030\001 \002(\0162).Liberty.LibertyExprOperatorEn"
  "um.Operator\"i\n\010Operator\022\013\n\007kBuffer\020\001\022\010\n\004"
  "kNot\020\002\022\007\n\003kOr\020\003\022\010\n\004kAnd\020\004\022\010\n\004kXor\020\005\022\010\n\004k"
  "One\020\006\022\t\n\005kZero\020\007\022\t\n\005kPlus\020\010\022\t\n\005kMult\020\t\"{"
  "\n\020LibertyExprClass\022\n\n\002id\030\001 \002(\004\022-\n\003_op\030\002 "
  "\002(\0132 .Liberty.LibertyExprOperatorEnum\022\r\n"
  "\005_left\030\003 \001(\004\022\016\n\006_right\030\004 \001(\004\022\r\n\005_port\030\005 "
  "\001(\014\"8\n\020LibertyStmtClass\022\022\n\n_file_name\030\001 "
  "\002(\t\022\020\n\010_line_no\030\002 \002(\r\"u\n\032LibertySimpleAt"
  "trStmtClass\022\023\n\013_attri_name\030\001 \002(\t\022\021\n\tlavs"
  "_type\030\002 \002(\r\022/\n\014_attri_value\030\003 \002(\0132\031.Comm"
  "on.Types.DoubleOrStr\"w\n\033LibertyComplexAt"
  "trStmtClass\022\023\n\013_attri_name\030\001 \002(\t\022\021\n\tlavs"
  "_type\030\002 \003(\r\0220\n\r_attri_values\030\003 \003(\0132\031.Com"
  "mon.Types.DoubleOrStr\"\201\001\n\025LibertyGroupSt"
  "mtClass\022\023\n\013_group_name\030\001 \002(\t\022\021\n\tlavs_typ"
  "e\030\002 \003(\r\0220\n\r_attri_values\030\003 \003(\0132\031.Common."
  "Types.DoubleOrStr\022\016\n\006_stmts\030\005 \003(\004\"\375\001\n\016Li"
  "bertyStmtSyn\022\n\n\002id\030\001 \002(\004\022\020\n\010lss_type\030\002 \002"
  "(\005\022)\n\006parent\030\003 \002(\0132\031.Liberty.LibertyStmt"
  "Class\0224\n\005lsasc\030\004 \001(\0132#.Liberty.LibertySi"
  "mpleAttrStmtClassH\000\0225\n\005lcasc\030\005 \001(\0132$.Lib"
  "erty.LibertyComplexAttrStmtClassH\000\022.\n\004lg"
  "sc\030\006 \001(\0132\036.Liberty.LibertyGroupStmtClass"
  "H\000B\005\n\003lss\":\n\022LibertyObjectClass\022\022\n\n_file"
  "_name\030\001 \001(\t\022\020\n\010_line_no\030\002 \001(\r\"j\n\020Liberty"
  "AxisClass\022\022\n\n_axis_name\030\001 \002(\t\022\021\n\tlavs_ty"
  "pe\030\002 \003(\r\022/\n\014_axis_values\030\003 \003(\0132\031.Common."
  "Types.DoubleOrStr\"\215\002\n\024LibertyTableTypeEn"
  "um\0223\n\002tt\030\001 \002(\0162\'.Liberty.LibertyTableTyp"
  "eEnum.TableType\"\277\001\n\tTableType\022\r\n\tkCellRi"
  "se\020\000\022\r\n\tkCellFall\020\001\022\023\n\017kRiseTransition\020\002"
  "\022\023\n\017kFallTransition\020\003\022\022\n\016kRiseConstrain\020"
  "\004\022\022\n\016kFallConstrain\020\005\022\020\n\014kRiseCurrent\020\006\022"
  "\020\n\014kFallCurrent\020\007\022\016\n\nkRisePower\020\010\022\016\n\nkFa"
  "llPower\020\t\"\264\001\n\021LibertyTableClass\022\r\n\005_axes"
  "\030\001 \003(\004\022\021\n\tlavs_type\030\002 \003(\r\0220\n\r_table_valu"
  "es\030\003 \003(\0132\031.Common.Types.DoubleOrStr\0222\n\013_"
  "table_type\030\004 \002(\0132\035.Liberty.LibertyTableT"
  "ypeEnum\022\027\n\017_table_template\030\005 \001(\004\",\n\027Libe"
  "rtyVectorTableClass\022\021\n\t_ref_time\030\001 \002(\001\"\213"
  "\001\n\017LibertyTableSyn\022\n\n\002id\030\001 \002(\004\022\020\n\010lts_ty"
  "pe\030\002 \002(\r\022*\n\006parent\030\003 \002(\0132\032.Liberty.Liber"
  "tyTableClass\022.\n\004lvtc\030\004 \001(\0132 .Liberty.Lib"
  "ertyVectorTableClass\"b\n\024LibertyCCSTableC"
  "lass\0222\n\013_table_type\030\001 \002(\0132\035.Liberty.Libe"
  "rtyTableTypeEnum\022\026\n\016_vector_tables\030\002 \003(\004"
  "\"G\n\033LibertyDelayTableModelClass\022\017\n\007_tabl"
  "es\030\001 \003(\004\022\027\n\017_current_tables\030\002 \003(\004\".\n\033Lib"
  "ertyCheckTableModelClass\022\017\n\007_tables\030\001 \003("
  "\004\".\n\033LibertyPowerTableModelClass\022\017\n\007_tab"
  "les\030\001 \003(\004\"\342\001\n\024LibertyTableModelSyn\022\n\n\002id"
  "\030\001 \002(\004\022\021\n\tltms_type\030\002 \002(\r\0225\n\005ldtmc\030\003 \001(\013"
  "2$.Liberty.LibertyDelayTableModelClassH\000"
  "\0225\n\005lctmc\030\004 \001(\0132$.Liberty.LibertyCheckTa"
  "bleModelClassH\000\0225\n\005lptmc\030\005 \001(\0132$.Liberty"
  ".LibertyPowerTableModelClassH\000B\006\n\004ltms\"\206"
  "\001\n\020LibertyTypeClass\022\022\n\n_type_name\030\001 \002(\t\022"
  "\022\n\n_base_type\030\002 \002(\t\022\022\n\n_data_type\030\003 \002(\t\022"
  "\022\n\n_bit_width\030\004 \002(\r\022\021\n\t_bit_from\030\005 \002(\r\022\017"
  "\n\007_bit_to\030\006 \002(\r\"y\n\023LibertyPortTypeEnum\0221"
  "\n\002pt\030\001 \002(\0162%.Liberty.LibertyPortTypeEnum"
  ".PortType\"/\n\010PortType\022\n\n\006kInput\020\001\022\013\n\007kOu"
  "tput\020\002\022\n\n\006kInOut\020\003\"\306\001\n\020LibertyPortClass\022"
  "\022\n\n_port_name\030\001 \002(\t\022\023\n\013_owner_cell\030\002 \002(\004"
  "\0220\n\n_port_type\030\003 \002(\0132\034.Liberty.LibertyPo"
  "rtTypeEnum\022\022\n\n_func_expr\030\004 \001(\004\022\021\n\t_port_"
  "cap\030\005 \002(\001\022\024\n\014_fanout_load\030\006 \001(\001\022\032\n\022_powe"
  "r_table_model\030\007 \001(\004\"8\n\023LibertyPortBusCla"
  "ss\022\016\n\006_ports\030\001 \003(\004\022\021\n\t_bus_type\030\002 \002(\004\"y\n"
  "\016LibertyPortSyn\022\020\n\010lps_type\030\001 \002(\r\022)\n\006par"
  "ent\030\002 \001(\0132\031.Liberty.LibertyPortClass\022*\n\004"
  "lpbc\030\003 \001(\0132\034.Liberty.LibertyPortBusClass"
  "\"\217\001\n\017LibertyArcClass\022\021\n\t_src_port\030\001 \002(\t\022"
  "\021\n\t_snk_port\030\002 \002(\t\022\023\n\013_owner_cell\030\003 \002(\004\022"
  "\025\n\r_timing_sense\030\004 \002(\t\022\024\n\014_timing_type\030\005"
  " \002(\t\022\024\n\014_table_model\030\006 \002(\004\"/\n\022LibertyArc"
  "SetClass\022\n\n\002id\030\001 \002(\004\022\r\n\005_arcs\030\002 \003(\004\"\226\001\n\024"
  "LibertyPowerArcClass\022\021\n\t_src_port\030\001 \002(\t\022"
  "\021\n\t_snk_port\030\002 \002(\t\022\030\n\020_related_pg_port\030\003"
  " \002(\t\022\r\n\005_when\030\004 \002(\t\022\023\n\013_owner_cell\030\005 \002(\004"
  "\022\032\n\022_power_table_model\030\006 \001(\004\":\n\027LibertyP"
  "owerArcSetClass\022\n\n\002id\030\001 \002(\004\022\023\n\013_power_ar"
  "cs\030\002 \003(\004\"h\n\030LibertyLeakagePowerClass\022\030\n\020"
  "_related_pg_port\030\001 \002(\t\022\r\n\005_when\030\002 \002(\t\022\016\n"
  "\006_value\030\003 \002(\001\022\023\n\013_owner_cell\030\004 \002(\004\"\347\001\n\020L"
  "ibertyCellClass\022\022\n\n_cell_name\030\001 \002(\t\022\033\n\023_"
  "cell_leakage_power\030\002 \002(\001\022\033\n\023_leakage_pow"
  "er_list\030\003 \003(\004\022\023\n\013_cell_ports\030\004 \003(\004\022\030\n\020_c"
  "ell_port_buses\030\005 \003(\004\022\022\n\n_cell_arcs\030\006 \003(\004"
  "\022\030\n\020_cell_power_arcs\030\007 \003(\004\022\022\n\n_owner_lib"
  "\030\010 \002(\004\022\024\n\014_is_dont_use\030\t \002(\r\"\207\002\n\024Liberty"
  "WireLoadClass\022\027\n\017_wire_load_name\030\001 \002(\t\022L"
  "\n\021_fanout_to_length\030\002 \003(\01321.Liberty.Libe"
  "rtyWireLoadClass.FanoutToLengthEntry\022\034\n\024"
  "_cap_per_length_unit\030\003 \001(\001\022#\n\033_resistanc"
  "e_per_length_unit\030\004 \001(\001\022\016\n\006_slope\030\005 \001(\001\032"
  "5\n\023FanoutToLengthEntry\022\013\n\003key\030\001 \001(\005\022\r\n\005v"
  "alue\030\002 \001(\001:\0028\001\"\271\001\n\034LibertyLutTableTempla"
  "teClass\022\026\n\016_template_name\030\001 \002(\t\022\033\n\023_temp"
  "late_variable1\030\002 \001(\t\022\033\n\023_template_variab"
  "le2\030\003 \001(\t\022\033\n\023_template_variable3\030\004 \001(\t\022\033"
  "\n\023_template_variable4\030\005 \001(\t\022\r\n\005_axes\030\006 \003"
  "(\004\"5\n\033LibertyCurrentTemplateClass\022\026\n\016_te"
  "mplate_axis\030\001 \001(\004\"\233\001\n\032LibertyLutTableTem"
  "plateSyn\022\022\n\nlltts_type\030\001 \002(\r\0225\n\006parent\030\002"
  " \002(\0132%.Liberty.LibertyLutTableTemplateCl"
  "ass\0222\n\004lctc\030\003 \001(\0132$.Liberty.LibertyCurre"
  "ntTemplateClass\"\205\005\n\020LibertyObjectSyn\022\n\n\002"
  "id\030\001 \002(\004\022\020\n\010los_type\030\002 \002(\r\022+\n\006parent\030\003 \002"
  "(\0132\033.Liberty.LibertyObjectClass\022)\n\004laxc\030"
  "\004 \001(\0132\031.Liberty.LibertyAxisClassH\000\022\'\n\003lt"
  "s\030\005 \001(\0132\030.Liberty.LibertyTableSynH\000\022/\n\006l"
  "ccstc\030\006 \001(\0132\035.Liberty.LibertyCCSTableCla"
  "ssH\000\022-\n\004ltms\030\007 \001(\0132\035.Liberty.LibertyTabl"
  "eModelSynH\000\022&\n\003lps\030\010 \001(\0132\027.Liberty.Liber"
  "tyPortSynH\000\022(\n\003ltc\030\t \001(\0132\031.Liberty.Liber"
  "tyTypeClassH\000\0221\n\004llpc\030\n \001(\0132!.Liberty.Li"
  "bertyLeakagePowerClassH\000\022(\n\004larc\030\013 \001(\0132\030"
  ".Liberty.LibertyArcClassH\000\022-\n\004lpac\030\014 \001(\013"
  "2\035.Liberty.LibertyPowerArcClassH\000\022(\n\003lcc"
  "\030\r \001(\0132\031.Liberty.LibertyCellClassH\000\022-\n\004l"
  "wlc\030\016 \001(\0132\035.Liberty.LibertyWireLoadClass"
  "H\000\0224\n\005lltts\030\017 \001(\0132#.Liberty.LibertyLutTa"
  "bleTemplateSynH\000B\005\n\003los\"\351\002\n\023LibertyLibra"
  "ryClass\022\n\n\002id\030\001 \002(\004\022\021\n\t_lib_name\030\002 \002(\t\022\016"
  "\n\006_cells\030\003 \003(\004\022\025\n\r_lut_template\030\004 \003(\004\022\023\n"
  "\013_wire_loads\030\005 \003(\004\022\016\n\006_types\030\006 \003(\004\0223\n\t_c"
  "ap_unit\030\007 \002(\0132 .Common.Types.CapacitiveU"
  "nitEnum\022:\n\020_resistance_unit\030\010 \002(\0132 .Comm"
  "on.Types.ResistanceUnitEnum\022\037\n\027_default_"
  "max_transition\030\t \001(\001\022\033\n\023_default_max_fan"
  "out\030\n \001(\001\022\034\n\024_default_fanout_load\030\013 \001(\001\022"
  "\032\n\022_default_wire_load\030\014 \002(\t\"\217\001\n\026LibertyO"
  "wnPortTypeEnum\022@\n\004lopt\030\001 \002(\01622.Liberty.L"
  "ibertyOwnPortTypeEnum.LibertyOwnPortType"
  "\"3\n\022LibertyOwnPortType\022\016\n\nkTimingArc\020\001\022\r"
  "\n\tkPowerArc\020\002\"\253\001\n\032LibertyOwnPgOrWhenType"
  "Enum\022J\n\006lopowt\030\001 \002(\0162:.Liberty.LibertyOw"
  "nPgOrWhenTypeEnum.LibertyOwnPgOrWhenType"
  "\"A\n\026LibertyOwnPgOrWhenType\022\030\n\024kLibertyLe"
  "akagePower\020\001\022\r\n\tkPowerArc\020\002\"/\n\023LibertyBu"
  "ilderClass\022\n\n\002id\030\001 \002(\004\022\014\n\004_lib\030\002 \002(\004\"f\n\022"
  "LibertyReaderClass\022\n\n\002id\030\001 \002(\004\022\026\n\016_libra"
  "ry_group\030\002 \002(\004\022\022\n\n_file_name\030\003 \002(\t\022\030\n\020_l"
  "iberty_builder\030\004 \002(\0042U\n\024LibertyReaderSer"
  "vice\022=\n\013loadLiberty\022\027.Common.Types.Strin"
  "gMsg\032\025.Common.Types.BoolMsg"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_LibertyReader_2eproto_deps[1] = {
  &::descriptor_table_CommonTypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_LibertyReader_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_LibertyReader_2eproto = {
    false, false, 5987, descriptor_table_protodef_LibertyReader_2eproto,
    "LibertyReader.proto",
    &descriptor_table_LibertyReader_2eproto_once, descriptor_table_LibertyReader_2eproto_deps, 1, 40,
    schemas, file_default_instances, TableStruct_LibertyReader_2eproto::offsets,
    file_level_metadata_LibertyReader_2eproto, file_level_enum_descriptors_LibertyReader_2eproto,
    file_level_service_descriptors_LibertyReader_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_LibertyReader_2eproto_getter() {
  return &descriptor_table_LibertyReader_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_LibertyReader_2eproto(&descriptor_table_LibertyReader_2eproto);
namespace Liberty {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyExprOperatorEnum_Operator_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_LibertyReader_2eproto);
  return file_level_enum_descriptors_LibertyReader_2eproto[0];
}
bool LibertyExprOperatorEnum_Operator_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kBuffer;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kNot;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kOr;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kAnd;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kXor;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kOne;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kZero;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kPlus;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::kMult;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::Operator_MIN;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::Operator_MAX;
constexpr int LibertyExprOperatorEnum::Operator_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyTableTypeEnum_TableType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_LibertyReader_2eproto);
  return file_level_enum_descriptors_LibertyReader_2eproto[1];
}
bool LibertyTableTypeEnum_TableType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kCellRise;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kCellFall;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kRiseTransition;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kFallTransition;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kRiseConstrain;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kFallConstrain;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kRiseCurrent;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kFallCurrent;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kRisePower;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::kFallPower;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::TableType_MIN;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum::TableType_MAX;
constexpr int LibertyTableTypeEnum::TableType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyPortTypeEnum_PortType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_LibertyReader_2eproto);
  return file_level_enum_descriptors_LibertyReader_2eproto[2];
}
bool LibertyPortTypeEnum_PortType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LibertyPortTypeEnum_PortType LibertyPortTypeEnum::kInput;
constexpr LibertyPortTypeEnum_PortType LibertyPortTypeEnum::kOutput;
constexpr LibertyPortTypeEnum_PortType LibertyPortTypeEnum::kInOut;
constexpr LibertyPortTypeEnum_PortType LibertyPortTypeEnum::PortType_MIN;
constexpr LibertyPortTypeEnum_PortType LibertyPortTypeEnum::PortType_MAX;
constexpr int LibertyPortTypeEnum::PortType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyOwnPortTypeEnum_LibertyOwnPortType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_LibertyReader_2eproto);
  return file_level_enum_descriptors_LibertyReader_2eproto[3];
}
bool LibertyOwnPortTypeEnum_LibertyOwnPortType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum::kTimingArc;
constexpr LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum::kPowerArc;
constexpr LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum::LibertyOwnPortType_MIN;
constexpr LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum::LibertyOwnPortType_MAX;
constexpr int LibertyOwnPortTypeEnum::LibertyOwnPortType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_LibertyReader_2eproto);
  return file_level_enum_descriptors_LibertyReader_2eproto[4];
}
bool LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum::kLibertyLeakagePower;
constexpr LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum::kPowerArc;
constexpr LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum::LibertyOwnPgOrWhenType_MIN;
constexpr LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum::LibertyOwnPgOrWhenType_MAX;
constexpr int LibertyOwnPgOrWhenTypeEnum::LibertyOwnPgOrWhenType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class LibertyExprOperatorEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyExprOperatorEnum>()._impl_._has_bits_);
  static void set_has_o(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyExprOperatorEnum::LibertyExprOperatorEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyExprOperatorEnum)
}
LibertyExprOperatorEnum::LibertyExprOperatorEnum(const LibertyExprOperatorEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyExprOperatorEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.o_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.o_ = from._impl_.o_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyExprOperatorEnum)
}

inline void LibertyExprOperatorEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.o_){1}
  };
}

LibertyExprOperatorEnum::~LibertyExprOperatorEnum() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyExprOperatorEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyExprOperatorEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyExprOperatorEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyExprOperatorEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyExprOperatorEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.o_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyExprOperatorEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Liberty.LibertyExprOperatorEnum.Operator o = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Liberty::LibertyExprOperatorEnum_Operator_IsValid(val))) {
            _internal_set_o(static_cast<::Liberty::LibertyExprOperatorEnum_Operator>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyExprOperatorEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyExprOperatorEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Liberty.LibertyExprOperatorEnum.Operator o = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_o(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyExprOperatorEnum)
  return target;
}

size_t LibertyExprOperatorEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyExprOperatorEnum)
  size_t total_size = 0;

  // required .Liberty.LibertyExprOperatorEnum.Operator o = 1;
  if (_internal_has_o()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_o());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyExprOperatorEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyExprOperatorEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyExprOperatorEnum::GetClassData() const { return &_class_data_; }


void LibertyExprOperatorEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyExprOperatorEnum*>(&to_msg);
  auto& from = static_cast<const LibertyExprOperatorEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyExprOperatorEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_o()) {
    _this->_internal_set_o(from._internal_o());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyExprOperatorEnum::CopyFrom(const LibertyExprOperatorEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyExprOperatorEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyExprOperatorEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyExprOperatorEnum::InternalSwap(LibertyExprOperatorEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.o_, other->_impl_.o_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyExprOperatorEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[0]);
}

// ===================================================================

class LibertyExprClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyExprClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Liberty::LibertyExprOperatorEnum& _op(const LibertyExprClass* msg);
  static void set_has__op(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__left(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__right(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has__port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::Liberty::LibertyExprOperatorEnum&
LibertyExprClass::_Internal::_op(const LibertyExprClass* msg) {
  return *msg->_impl_._op_;
}
LibertyExprClass::LibertyExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyExprClass)
}
LibertyExprClass::LibertyExprClass(const LibertyExprClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyExprClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_){}
    , decltype(_impl_._op_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_._left_){}
    , decltype(_impl_._right_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__port()) {
    _this->_impl_._port_.Set(from._internal__port(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has__op()) {
    _this->_impl_._op_ = new ::Liberty::LibertyExprOperatorEnum(*from._impl_._op_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._right_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._right_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyExprClass)
}

inline void LibertyExprClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_){}
    , decltype(_impl_._op_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._left_){uint64_t{0u}}
    , decltype(_impl_._right_){uint64_t{0u}}
  };
  _impl_._port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyExprClass::~LibertyExprClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyExprClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyExprClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._port_.Destroy();
  if (this != internal_default_instance()) delete _impl_._op_;
}

void LibertyExprClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyExprClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyExprClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_._op_ != nullptr);
      _impl_._op_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._right_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._right_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyExprClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Liberty.LibertyExprOperatorEnum _op = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable__op(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _left = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__left(&has_bits);
          _impl_._left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _right = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__right(&has_bits);
          _impl_._right_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes _port = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable__port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyExprClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyExprClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required .Liberty.LibertyExprOperatorEnum _op = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::_op(this),
        _Internal::_op(this).GetCachedSize(), target, stream);
  }

  // optional uint64 _left = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__left(), target);
  }

  // optional uint64 _right = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__right(), target);
  }

  // optional bytes _port = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal__port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyExprClass)
  return target;
}

size_t LibertyExprClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyExprClass)
  size_t total_size = 0;

  if (_internal_has__op()) {
    // required .Liberty.LibertyExprOperatorEnum _op = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._op_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return total_size;
}
size_t LibertyExprClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyExprClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .Liberty.LibertyExprOperatorEnum _op = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._op_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes _port = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal__port());
  }

  if (cached_has_bits & 0x00000018u) {
    // optional uint64 _left = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__left());
    }

    // optional uint64 _right = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__right());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyExprClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyExprClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyExprClass::GetClassData() const { return &_class_data_; }


void LibertyExprClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyExprClass*>(&to_msg);
  auto& from = static_cast<const LibertyExprClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyExprClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__port(from._internal__port());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable__op()->::Liberty::LibertyExprOperatorEnum::MergeFrom(
          from._internal__op());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._left_ = from._impl_._left_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_._right_ = from._impl_._right_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyExprClass::CopyFrom(const LibertyExprClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyExprClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyExprClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__op()) {
    if (!_impl_._op_->IsInitialized()) return false;
  }
  return true;
}

void LibertyExprClass::InternalSwap(LibertyExprClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._port_, lhs_arena,
      &other->_impl_._port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyExprClass, _impl_._right_)
      + sizeof(LibertyExprClass::_impl_._right_)
      - PROTOBUF_FIELD_OFFSET(LibertyExprClass, _impl_._op_)>(
          reinterpret_cast<char*>(&_impl_._op_),
          reinterpret_cast<char*>(&other->_impl_._op_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyExprClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[1]);
}

// ===================================================================

class LibertyStmtClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyStmtClass>()._impl_._has_bits_);
  static void set_has__file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__line_no(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

LibertyStmtClass::LibertyStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyStmtClass)
}
LibertyStmtClass::LibertyStmtClass(const LibertyStmtClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyStmtClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_._line_no_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__file_name()) {
    _this->_impl_._file_name_.Set(from._internal__file_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_._line_no_ = from._impl_._line_no_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyStmtClass)
}

inline void LibertyStmtClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_._line_no_){0u}
  };
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyStmtClass::~LibertyStmtClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyStmtClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyStmtClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._file_name_.Destroy();
}

void LibertyStmtClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyStmtClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyStmtClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._file_name_.ClearNonDefaultToEmpty();
  }
  _impl_._line_no_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyStmtClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _file_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyStmtClass._file_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 _line_no = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__line_no(&has_bits);
          _impl_._line_no_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyStmtClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyStmtClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _file_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__file_name().data(), static_cast<int>(this->_internal__file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyStmtClass._file_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__file_name(), target);
  }

  // required uint32 _line_no = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal__line_no(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyStmtClass)
  return target;
}

size_t LibertyStmtClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyStmtClass)
  size_t total_size = 0;

  if (_internal_has__file_name()) {
    // required string _file_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());
  }

  if (_internal_has__line_no()) {
    // required uint32 _line_no = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__line_no());
  }

  return total_size;
}
size_t LibertyStmtClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyStmtClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string _file_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());

    // required uint32 _line_no = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__line_no());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyStmtClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyStmtClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyStmtClass::GetClassData() const { return &_class_data_; }


void LibertyStmtClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyStmtClass*>(&to_msg);
  auto& from = static_cast<const LibertyStmtClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyStmtClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__file_name(from._internal__file_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._line_no_ = from._impl_._line_no_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyStmtClass::CopyFrom(const LibertyStmtClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyStmtClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyStmtClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyStmtClass::InternalSwap(LibertyStmtClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._file_name_, lhs_arena,
      &other->_impl_._file_name_, rhs_arena
  );
  swap(_impl_._line_no_, other->_impl_._line_no_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyStmtClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[2]);
}

// ===================================================================

class LibertySimpleAttrStmtClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertySimpleAttrStmtClass>()._impl_._has_bits_);
  static void set_has__attri_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lavs_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Common::Types::DoubleOrStr& _attri_value(const LibertySimpleAttrStmtClass* msg);
  static void set_has__attri_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Common::Types::DoubleOrStr&
LibertySimpleAttrStmtClass::_Internal::_attri_value(const LibertySimpleAttrStmtClass* msg) {
  return *msg->_impl_._attri_value_;
}
void LibertySimpleAttrStmtClass::clear__attri_value() {
  if (_impl_._attri_value_ != nullptr) _impl_._attri_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
LibertySimpleAttrStmtClass::LibertySimpleAttrStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertySimpleAttrStmtClass)
}
LibertySimpleAttrStmtClass::LibertySimpleAttrStmtClass(const LibertySimpleAttrStmtClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertySimpleAttrStmtClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._attri_name_){}
    , decltype(_impl_._attri_value_){nullptr}
    , decltype(_impl_.lavs_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._attri_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__attri_name()) {
    _this->_impl_._attri_name_.Set(from._internal__attri_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has__attri_value()) {
    _this->_impl_._attri_value_ = new ::Common::Types::DoubleOrStr(*from._impl_._attri_value_);
  }
  _this->_impl_.lavs_type_ = from._impl_.lavs_type_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertySimpleAttrStmtClass)
}

inline void LibertySimpleAttrStmtClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._attri_name_){}
    , decltype(_impl_._attri_value_){nullptr}
    , decltype(_impl_.lavs_type_){0u}
  };
  _impl_._attri_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertySimpleAttrStmtClass::~LibertySimpleAttrStmtClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertySimpleAttrStmtClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertySimpleAttrStmtClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._attri_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_._attri_value_;
}

void LibertySimpleAttrStmtClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertySimpleAttrStmtClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertySimpleAttrStmtClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._attri_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_._attri_value_ != nullptr);
      _impl_._attri_value_->Clear();
    }
  }
  _impl_.lavs_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertySimpleAttrStmtClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _attri_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__attri_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertySimpleAttrStmtClass._attri_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 lavs_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lavs_type(&has_bits);
          _impl_.lavs_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Common.Types.DoubleOrStr _attri_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable__attri_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertySimpleAttrStmtClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertySimpleAttrStmtClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _attri_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__attri_name().data(), static_cast<int>(this->_internal__attri_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertySimpleAttrStmtClass._attri_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__attri_name(), target);
  }

  // required uint32 lavs_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lavs_type(), target);
  }

  // required .Common.Types.DoubleOrStr _attri_value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::_attri_value(this),
        _Internal::_attri_value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertySimpleAttrStmtClass)
  return target;
}

size_t LibertySimpleAttrStmtClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertySimpleAttrStmtClass)
  size_t total_size = 0;

  if (_internal_has__attri_name()) {
    // required string _attri_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__attri_name());
  }

  if (_internal_has__attri_value()) {
    // required .Common.Types.DoubleOrStr _attri_value = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._attri_value_);
  }

  if (_internal_has_lavs_type()) {
    // required uint32 lavs_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lavs_type());
  }

  return total_size;
}
size_t LibertySimpleAttrStmtClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertySimpleAttrStmtClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string _attri_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__attri_name());

    // required .Common.Types.DoubleOrStr _attri_value = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._attri_value_);

    // required uint32 lavs_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lavs_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertySimpleAttrStmtClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertySimpleAttrStmtClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertySimpleAttrStmtClass::GetClassData() const { return &_class_data_; }


void LibertySimpleAttrStmtClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertySimpleAttrStmtClass*>(&to_msg);
  auto& from = static_cast<const LibertySimpleAttrStmtClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertySimpleAttrStmtClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__attri_name(from._internal__attri_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable__attri_value()->::Common::Types::DoubleOrStr::MergeFrom(
          from._internal__attri_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lavs_type_ = from._impl_.lavs_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertySimpleAttrStmtClass::CopyFrom(const LibertySimpleAttrStmtClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertySimpleAttrStmtClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertySimpleAttrStmtClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertySimpleAttrStmtClass::InternalSwap(LibertySimpleAttrStmtClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._attri_name_, lhs_arena,
      &other->_impl_._attri_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertySimpleAttrStmtClass, _impl_.lavs_type_)
      + sizeof(LibertySimpleAttrStmtClass::_impl_.lavs_type_)
      - PROTOBUF_FIELD_OFFSET(LibertySimpleAttrStmtClass, _impl_._attri_value_)>(
          reinterpret_cast<char*>(&_impl_._attri_value_),
          reinterpret_cast<char*>(&other->_impl_._attri_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertySimpleAttrStmtClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[3]);
}

// ===================================================================

class LibertyComplexAttrStmtClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyComplexAttrStmtClass>()._impl_._has_bits_);
  static void set_has__attri_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void LibertyComplexAttrStmtClass::clear__attri_values() {
  _impl_._attri_values_.Clear();
}
LibertyComplexAttrStmtClass::LibertyComplexAttrStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyComplexAttrStmtClass)
}
LibertyComplexAttrStmtClass::LibertyComplexAttrStmtClass(const LibertyComplexAttrStmtClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyComplexAttrStmtClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lavs_type_){from._impl_.lavs_type_}
    , decltype(_impl_._attri_values_){from._impl_._attri_values_}
    , decltype(_impl_._attri_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._attri_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__attri_name()) {
    _this->_impl_._attri_name_.Set(from._internal__attri_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyComplexAttrStmtClass)
}

inline void LibertyComplexAttrStmtClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lavs_type_){arena}
    , decltype(_impl_._attri_values_){arena}
    , decltype(_impl_._attri_name_){}
  };
  _impl_._attri_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyComplexAttrStmtClass::~LibertyComplexAttrStmtClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyComplexAttrStmtClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyComplexAttrStmtClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lavs_type_.~RepeatedField();
  _impl_._attri_values_.~RepeatedPtrField();
  _impl_._attri_name_.Destroy();
}

void LibertyComplexAttrStmtClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyComplexAttrStmtClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyComplexAttrStmtClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lavs_type_.Clear();
  _impl_._attri_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._attri_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyComplexAttrStmtClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _attri_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__attri_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyComplexAttrStmtClass._attri_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 lavs_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_lavs_type(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_lavs_type(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.DoubleOrStr _attri_values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__attri_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyComplexAttrStmtClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyComplexAttrStmtClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _attri_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__attri_name().data(), static_cast<int>(this->_internal__attri_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyComplexAttrStmtClass._attri_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__attri_name(), target);
  }

  // repeated uint32 lavs_type = 2;
  for (int i = 0, n = this->_internal_lavs_type_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lavs_type(i), target);
  }

  // repeated .Common.Types.DoubleOrStr _attri_values = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__attri_values_size()); i < n; i++) {
    const auto& repfield = this->_internal__attri_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyComplexAttrStmtClass)
  return target;
}

size_t LibertyComplexAttrStmtClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyComplexAttrStmtClass)
  size_t total_size = 0;

  // required string _attri_name = 1;
  if (_internal_has__attri_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__attri_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 lavs_type = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.lavs_type_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_lavs_type_size());
    total_size += data_size;
  }

  // repeated .Common.Types.DoubleOrStr _attri_values = 3;
  total_size += 1UL * this->_internal__attri_values_size();
  for (const auto& msg : this->_impl_._attri_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyComplexAttrStmtClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyComplexAttrStmtClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyComplexAttrStmtClass::GetClassData() const { return &_class_data_; }


void LibertyComplexAttrStmtClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyComplexAttrStmtClass*>(&to_msg);
  auto& from = static_cast<const LibertyComplexAttrStmtClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyComplexAttrStmtClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.lavs_type_.MergeFrom(from._impl_.lavs_type_);
  _this->_impl_._attri_values_.MergeFrom(from._impl_._attri_values_);
  if (from._internal_has__attri_name()) {
    _this->_internal_set__attri_name(from._internal__attri_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyComplexAttrStmtClass::CopyFrom(const LibertyComplexAttrStmtClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyComplexAttrStmtClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyComplexAttrStmtClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyComplexAttrStmtClass::InternalSwap(LibertyComplexAttrStmtClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.lavs_type_.InternalSwap(&other->_impl_.lavs_type_);
  _impl_._attri_values_.InternalSwap(&other->_impl_._attri_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._attri_name_, lhs_arena,
      &other->_impl_._attri_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyComplexAttrStmtClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[4]);
}

// ===================================================================

class LibertyGroupStmtClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyGroupStmtClass>()._impl_._has_bits_);
  static void set_has__group_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void LibertyGroupStmtClass::clear__attri_values() {
  _impl_._attri_values_.Clear();
}
LibertyGroupStmtClass::LibertyGroupStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyGroupStmtClass)
}
LibertyGroupStmtClass::LibertyGroupStmtClass(const LibertyGroupStmtClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyGroupStmtClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lavs_type_){from._impl_.lavs_type_}
    , decltype(_impl_._attri_values_){from._impl_._attri_values_}
    , decltype(_impl_._stmts_){from._impl_._stmts_}
    , decltype(_impl_._group_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__group_name()) {
    _this->_impl_._group_name_.Set(from._internal__group_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyGroupStmtClass)
}

inline void LibertyGroupStmtClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lavs_type_){arena}
    , decltype(_impl_._attri_values_){arena}
    , decltype(_impl_._stmts_){arena}
    , decltype(_impl_._group_name_){}
  };
  _impl_._group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyGroupStmtClass::~LibertyGroupStmtClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyGroupStmtClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyGroupStmtClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lavs_type_.~RepeatedField();
  _impl_._attri_values_.~RepeatedPtrField();
  _impl_._stmts_.~RepeatedField();
  _impl_._group_name_.Destroy();
}

void LibertyGroupStmtClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyGroupStmtClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyGroupStmtClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lavs_type_.Clear();
  _impl_._attri_values_.Clear();
  _impl_._stmts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._group_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyGroupStmtClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _group_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__group_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyGroupStmtClass._group_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 lavs_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_lavs_type(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_lavs_type(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.DoubleOrStr _attri_values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__attri_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _stmts = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__stmts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__stmts(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyGroupStmtClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyGroupStmtClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _group_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__group_name().data(), static_cast<int>(this->_internal__group_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyGroupStmtClass._group_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__group_name(), target);
  }

  // repeated uint32 lavs_type = 2;
  for (int i = 0, n = this->_internal_lavs_type_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lavs_type(i), target);
  }

  // repeated .Common.Types.DoubleOrStr _attri_values = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__attri_values_size()); i < n; i++) {
    const auto& repfield = this->_internal__attri_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint64 _stmts = 5;
  for (int i = 0, n = this->_internal__stmts_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__stmts(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyGroupStmtClass)
  return target;
}

size_t LibertyGroupStmtClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyGroupStmtClass)
  size_t total_size = 0;

  // required string _group_name = 1;
  if (_internal_has__group_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__group_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 lavs_type = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.lavs_type_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_lavs_type_size());
    total_size += data_size;
  }

  // repeated .Common.Types.DoubleOrStr _attri_values = 3;
  total_size += 1UL * this->_internal__attri_values_size();
  for (const auto& msg : this->_impl_._attri_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint64 _stmts = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._stmts_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__stmts_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyGroupStmtClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyGroupStmtClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyGroupStmtClass::GetClassData() const { return &_class_data_; }


void LibertyGroupStmtClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyGroupStmtClass*>(&to_msg);
  auto& from = static_cast<const LibertyGroupStmtClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyGroupStmtClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.lavs_type_.MergeFrom(from._impl_.lavs_type_);
  _this->_impl_._attri_values_.MergeFrom(from._impl_._attri_values_);
  _this->_impl_._stmts_.MergeFrom(from._impl_._stmts_);
  if (from._internal_has__group_name()) {
    _this->_internal_set__group_name(from._internal__group_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyGroupStmtClass::CopyFrom(const LibertyGroupStmtClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyGroupStmtClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyGroupStmtClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyGroupStmtClass::InternalSwap(LibertyGroupStmtClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.lavs_type_.InternalSwap(&other->_impl_.lavs_type_);
  _impl_._attri_values_.InternalSwap(&other->_impl_._attri_values_);
  _impl_._stmts_.InternalSwap(&other->_impl_._stmts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._group_name_, lhs_arena,
      &other->_impl_._group_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyGroupStmtClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[5]);
}

// ===================================================================

class LibertyStmtSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyStmtSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lss_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Liberty::LibertyStmtClass& parent(const LibertyStmtSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Liberty::LibertySimpleAttrStmtClass& lsasc(const LibertyStmtSyn* msg);
  static const ::Liberty::LibertyComplexAttrStmtClass& lcasc(const LibertyStmtSyn* msg);
  static const ::Liberty::LibertyGroupStmtClass& lgsc(const LibertyStmtSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Liberty::LibertyStmtClass&
LibertyStmtSyn::_Internal::parent(const LibertyStmtSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Liberty::LibertySimpleAttrStmtClass&
LibertyStmtSyn::_Internal::lsasc(const LibertyStmtSyn* msg) {
  return *msg->_impl_.lss_.lsasc_;
}
const ::Liberty::LibertyComplexAttrStmtClass&
LibertyStmtSyn::_Internal::lcasc(const LibertyStmtSyn* msg) {
  return *msg->_impl_.lss_.lcasc_;
}
const ::Liberty::LibertyGroupStmtClass&
LibertyStmtSyn::_Internal::lgsc(const LibertyStmtSyn* msg) {
  return *msg->_impl_.lss_.lgsc_;
}
void LibertyStmtSyn::set_allocated_lsasc(::Liberty::LibertySimpleAttrStmtClass* lsasc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_lss();
  if (lsasc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lsasc);
    if (message_arena != submessage_arena) {
      lsasc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lsasc, submessage_arena);
    }
    set_has_lsasc();
    _impl_.lss_.lsasc_ = lsasc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyStmtSyn.lsasc)
}
void LibertyStmtSyn::set_allocated_lcasc(::Liberty::LibertyComplexAttrStmtClass* lcasc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_lss();
  if (lcasc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lcasc);
    if (message_arena != submessage_arena) {
      lcasc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lcasc, submessage_arena);
    }
    set_has_lcasc();
    _impl_.lss_.lcasc_ = lcasc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyStmtSyn.lcasc)
}
void LibertyStmtSyn::set_allocated_lgsc(::Liberty::LibertyGroupStmtClass* lgsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_lss();
  if (lgsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lgsc);
    if (message_arena != submessage_arena) {
      lgsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lgsc, submessage_arena);
    }
    set_has_lgsc();
    _impl_.lss_.lgsc_ = lgsc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyStmtSyn.lgsc)
}
LibertyStmtSyn::LibertyStmtSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyStmtSyn)
}
LibertyStmtSyn::LibertyStmtSyn(const LibertyStmtSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyStmtSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.lss_type_){}
    , decltype(_impl_.lss_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Liberty::LibertyStmtClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lss_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.lss_type_));
  clear_has_lss();
  switch (from.lss_case()) {
    case kLsasc: {
      _this->_internal_mutable_lsasc()->::Liberty::LibertySimpleAttrStmtClass::MergeFrom(
          from._internal_lsasc());
      break;
    }
    case kLcasc: {
      _this->_internal_mutable_lcasc()->::Liberty::LibertyComplexAttrStmtClass::MergeFrom(
          from._internal_lcasc());
      break;
    }
    case kLgsc: {
      _this->_internal_mutable_lgsc()->::Liberty::LibertyGroupStmtClass::MergeFrom(
          from._internal_lgsc());
      break;
    }
    case LSS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyStmtSyn)
}

inline void LibertyStmtSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.lss_type_){0}
    , decltype(_impl_.lss_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_lss();
}

LibertyStmtSyn::~LibertyStmtSyn() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyStmtSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyStmtSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_lss()) {
    clear_lss();
  }
}

void LibertyStmtSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyStmtSyn::clear_lss() {
// @@protoc_insertion_point(one_of_clear_start:Liberty.LibertyStmtSyn)
  switch (lss_case()) {
    case kLsasc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.lss_.lsasc_;
      }
      break;
    }
    case kLcasc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.lss_.lcasc_;
      }
      break;
    }
    case kLgsc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.lss_.lgsc_;
      }
      break;
    }
    case LSS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LSS_NOT_SET;
}


void LibertyStmtSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyStmtSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lss_type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.lss_type_));
  }
  clear_lss();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyStmtSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 lss_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lss_type(&has_bits);
          _impl_.lss_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Liberty.LibertyStmtClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertySimpleAttrStmtClass lsasc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lsasc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyComplexAttrStmtClass lcasc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_lcasc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyGroupStmtClass lgsc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_lgsc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyStmtSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyStmtSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required int32 lss_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_lss_type(), target);
  }

  // required .Liberty.LibertyStmtClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (lss_case()) {
    case kLsasc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::lsasc(this),
          _Internal::lsasc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLcasc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::lcasc(this),
          _Internal::lcasc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLgsc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::lgsc(this),
          _Internal::lgsc(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyStmtSyn)
  return target;
}

size_t LibertyStmtSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyStmtSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Liberty.LibertyStmtClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_lss_type()) {
    // required int32 lss_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lss_type());
  }

  return total_size;
}
size_t LibertyStmtSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyStmtSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Liberty.LibertyStmtClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required int32 lss_type = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lss_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (lss_case()) {
    // .Liberty.LibertySimpleAttrStmtClass lsasc = 4;
    case kLsasc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lss_.lsasc_);
      break;
    }
    // .Liberty.LibertyComplexAttrStmtClass lcasc = 5;
    case kLcasc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lss_.lcasc_);
      break;
    }
    // .Liberty.LibertyGroupStmtClass lgsc = 6;
    case kLgsc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lss_.lgsc_);
      break;
    }
    case LSS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyStmtSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyStmtSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyStmtSyn::GetClassData() const { return &_class_data_; }


void LibertyStmtSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyStmtSyn*>(&to_msg);
  auto& from = static_cast<const LibertyStmtSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyStmtSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Liberty::LibertyStmtClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lss_type_ = from._impl_.lss_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.lss_case()) {
    case kLsasc: {
      _this->_internal_mutable_lsasc()->::Liberty::LibertySimpleAttrStmtClass::MergeFrom(
          from._internal_lsasc());
      break;
    }
    case kLcasc: {
      _this->_internal_mutable_lcasc()->::Liberty::LibertyComplexAttrStmtClass::MergeFrom(
          from._internal_lcasc());
      break;
    }
    case kLgsc: {
      _this->_internal_mutable_lgsc()->::Liberty::LibertyGroupStmtClass::MergeFrom(
          from._internal_lgsc());
      break;
    }
    case LSS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyStmtSyn::CopyFrom(const LibertyStmtSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyStmtSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyStmtSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (lss_case()) {
    case kLsasc: {
      if (_internal_has_lsasc()) {
        if (!_impl_.lss_.lsasc_->IsInitialized()) return false;
      }
      break;
    }
    case kLcasc: {
      if (_internal_has_lcasc()) {
        if (!_impl_.lss_.lcasc_->IsInitialized()) return false;
      }
      break;
    }
    case kLgsc: {
      if (_internal_has_lgsc()) {
        if (!_impl_.lss_.lgsc_->IsInitialized()) return false;
      }
      break;
    }
    case LSS_NOT_SET: {
      break;
    }
  }
  return true;
}

void LibertyStmtSyn::InternalSwap(LibertyStmtSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyStmtSyn, _impl_.lss_type_)
      + sizeof(LibertyStmtSyn::_impl_.lss_type_)
      - PROTOBUF_FIELD_OFFSET(LibertyStmtSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.lss_, other->_impl_.lss_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyStmtSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[6]);
}

// ===================================================================

class LibertyObjectClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyObjectClass>()._impl_._has_bits_);
  static void set_has__file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__line_no(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LibertyObjectClass::LibertyObjectClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyObjectClass)
}
LibertyObjectClass::LibertyObjectClass(const LibertyObjectClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyObjectClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_._line_no_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__file_name()) {
    _this->_impl_._file_name_.Set(from._internal__file_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_._line_no_ = from._impl_._line_no_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyObjectClass)
}

inline void LibertyObjectClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_._line_no_){0u}
  };
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyObjectClass::~LibertyObjectClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyObjectClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyObjectClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._file_name_.Destroy();
}

void LibertyObjectClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyObjectClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyObjectClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._file_name_.ClearNonDefaultToEmpty();
  }
  _impl_._line_no_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyObjectClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string _file_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyObjectClass._file_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 _line_no = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__line_no(&has_bits);
          _impl_._line_no_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyObjectClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyObjectClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string _file_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__file_name().data(), static_cast<int>(this->_internal__file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyObjectClass._file_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__file_name(), target);
  }

  // optional uint32 _line_no = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal__line_no(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyObjectClass)
  return target;
}

size_t LibertyObjectClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyObjectClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string _file_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal__file_name());
    }

    // optional uint32 _line_no = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__line_no());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyObjectClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyObjectClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyObjectClass::GetClassData() const { return &_class_data_; }


void LibertyObjectClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyObjectClass*>(&to_msg);
  auto& from = static_cast<const LibertyObjectClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyObjectClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__file_name(from._internal__file_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._line_no_ = from._impl_._line_no_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyObjectClass::CopyFrom(const LibertyObjectClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyObjectClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyObjectClass::IsInitialized() const {
  return true;
}

void LibertyObjectClass::InternalSwap(LibertyObjectClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._file_name_, lhs_arena,
      &other->_impl_._file_name_, rhs_arena
  );
  swap(_impl_._line_no_, other->_impl_._line_no_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyObjectClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[7]);
}

// ===================================================================

class LibertyAxisClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyAxisClass>()._impl_._has_bits_);
  static void set_has__axis_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void LibertyAxisClass::clear__axis_values() {
  _impl_._axis_values_.Clear();
}
LibertyAxisClass::LibertyAxisClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyAxisClass)
}
LibertyAxisClass::LibertyAxisClass(const LibertyAxisClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyAxisClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lavs_type_){from._impl_.lavs_type_}
    , decltype(_impl_._axis_values_){from._impl_._axis_values_}
    , decltype(_impl_._axis_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._axis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._axis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__axis_name()) {
    _this->_impl_._axis_name_.Set(from._internal__axis_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyAxisClass)
}

inline void LibertyAxisClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lavs_type_){arena}
    , decltype(_impl_._axis_values_){arena}
    , decltype(_impl_._axis_name_){}
  };
  _impl_._axis_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._axis_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyAxisClass::~LibertyAxisClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyAxisClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyAxisClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lavs_type_.~RepeatedField();
  _impl_._axis_values_.~RepeatedPtrField();
  _impl_._axis_name_.Destroy();
}

void LibertyAxisClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyAxisClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyAxisClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lavs_type_.Clear();
  _impl_._axis_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._axis_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyAxisClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _axis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__axis_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyAxisClass._axis_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 lavs_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_lavs_type(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_lavs_type(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.DoubleOrStr _axis_values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__axis_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyAxisClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyAxisClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _axis_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__axis_name().data(), static_cast<int>(this->_internal__axis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyAxisClass._axis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__axis_name(), target);
  }

  // repeated uint32 lavs_type = 2;
  for (int i = 0, n = this->_internal_lavs_type_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lavs_type(i), target);
  }

  // repeated .Common.Types.DoubleOrStr _axis_values = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__axis_values_size()); i < n; i++) {
    const auto& repfield = this->_internal__axis_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyAxisClass)
  return target;
}

size_t LibertyAxisClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyAxisClass)
  size_t total_size = 0;

  // required string _axis_name = 1;
  if (_internal_has__axis_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__axis_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 lavs_type = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.lavs_type_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_lavs_type_size());
    total_size += data_size;
  }

  // repeated .Common.Types.DoubleOrStr _axis_values = 3;
  total_size += 1UL * this->_internal__axis_values_size();
  for (const auto& msg : this->_impl_._axis_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyAxisClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyAxisClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyAxisClass::GetClassData() const { return &_class_data_; }


void LibertyAxisClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyAxisClass*>(&to_msg);
  auto& from = static_cast<const LibertyAxisClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyAxisClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.lavs_type_.MergeFrom(from._impl_.lavs_type_);
  _this->_impl_._axis_values_.MergeFrom(from._impl_._axis_values_);
  if (from._internal_has__axis_name()) {
    _this->_internal_set__axis_name(from._internal__axis_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyAxisClass::CopyFrom(const LibertyAxisClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyAxisClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyAxisClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyAxisClass::InternalSwap(LibertyAxisClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.lavs_type_.InternalSwap(&other->_impl_.lavs_type_);
  _impl_._axis_values_.InternalSwap(&other->_impl_._axis_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._axis_name_, lhs_arena,
      &other->_impl_._axis_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyAxisClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[8]);
}

// ===================================================================

class LibertyTableTypeEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyTableTypeEnum>()._impl_._has_bits_);
  static void set_has_tt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyTableTypeEnum::LibertyTableTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyTableTypeEnum)
}
LibertyTableTypeEnum::LibertyTableTypeEnum(const LibertyTableTypeEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyTableTypeEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tt_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.tt_ = from._impl_.tt_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyTableTypeEnum)
}

inline void LibertyTableTypeEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tt_){0}
  };
}

LibertyTableTypeEnum::~LibertyTableTypeEnum() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyTableTypeEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyTableTypeEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyTableTypeEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyTableTypeEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyTableTypeEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tt_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyTableTypeEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Liberty.LibertyTableTypeEnum.TableType tt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Liberty::LibertyTableTypeEnum_TableType_IsValid(val))) {
            _internal_set_tt(static_cast<::Liberty::LibertyTableTypeEnum_TableType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyTableTypeEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyTableTypeEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Liberty.LibertyTableTypeEnum.TableType tt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_tt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyTableTypeEnum)
  return target;
}

size_t LibertyTableTypeEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyTableTypeEnum)
  size_t total_size = 0;

  // required .Liberty.LibertyTableTypeEnum.TableType tt = 1;
  if (_internal_has_tt()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_tt());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyTableTypeEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyTableTypeEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyTableTypeEnum::GetClassData() const { return &_class_data_; }


void LibertyTableTypeEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyTableTypeEnum*>(&to_msg);
  auto& from = static_cast<const LibertyTableTypeEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyTableTypeEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tt()) {
    _this->_internal_set_tt(from._internal_tt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyTableTypeEnum::CopyFrom(const LibertyTableTypeEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyTableTypeEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyTableTypeEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyTableTypeEnum::InternalSwap(LibertyTableTypeEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.tt_, other->_impl_.tt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyTableTypeEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[9]);
}

// ===================================================================

class LibertyTableClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyTableClass>()._impl_._has_bits_);
  static const ::Liberty::LibertyTableTypeEnum& _table_type(const LibertyTableClass* msg);
  static void set_has__table_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__table_template(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::Liberty::LibertyTableTypeEnum&
LibertyTableClass::_Internal::_table_type(const LibertyTableClass* msg) {
  return *msg->_impl_._table_type_;
}
void LibertyTableClass::clear__table_values() {
  _impl_._table_values_.Clear();
}
LibertyTableClass::LibertyTableClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyTableClass)
}
LibertyTableClass::LibertyTableClass(const LibertyTableClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyTableClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._axes_){from._impl_._axes_}
    , decltype(_impl_.lavs_type_){from._impl_.lavs_type_}
    , decltype(_impl_._table_values_){from._impl_._table_values_}
    , decltype(_impl_._table_type_){nullptr}
    , decltype(_impl_._table_template_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has__table_type()) {
    _this->_impl_._table_type_ = new ::Liberty::LibertyTableTypeEnum(*from._impl_._table_type_);
  }
  _this->_impl_._table_template_ = from._impl_._table_template_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyTableClass)
}

inline void LibertyTableClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._axes_){arena}
    , decltype(_impl_.lavs_type_){arena}
    , decltype(_impl_._table_values_){arena}
    , decltype(_impl_._table_type_){nullptr}
    , decltype(_impl_._table_template_){uint64_t{0u}}
  };
}

LibertyTableClass::~LibertyTableClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyTableClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyTableClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._axes_.~RepeatedField();
  _impl_.lavs_type_.~RepeatedField();
  _impl_._table_values_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_._table_type_;
}

void LibertyTableClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyTableClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyTableClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._axes_.Clear();
  _impl_.lavs_type_.Clear();
  _impl_._table_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_._table_type_ != nullptr);
    _impl_._table_type_->Clear();
  }
  _impl_._table_template_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyTableClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 _axes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__axes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 lavs_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_lavs_type(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_lavs_type(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.DoubleOrStr _table_values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__table_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .Liberty.LibertyTableTypeEnum _table_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable__table_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _table_template = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__table_template(&has_bits);
          _impl_._table_template_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyTableClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyTableClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 _axes = 1;
  for (int i = 0, n = this->_internal__axes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__axes(i), target);
  }

  // repeated uint32 lavs_type = 2;
  for (int i = 0, n = this->_internal_lavs_type_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lavs_type(i), target);
  }

  // repeated .Common.Types.DoubleOrStr _table_values = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__table_values_size()); i < n; i++) {
    const auto& repfield = this->_internal__table_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required .Liberty.LibertyTableTypeEnum _table_type = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::_table_type(this),
        _Internal::_table_type(this).GetCachedSize(), target, stream);
  }

  // optional uint64 _table_template = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__table_template(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyTableClass)
  return target;
}

size_t LibertyTableClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyTableClass)
  size_t total_size = 0;

  // required .Liberty.LibertyTableTypeEnum _table_type = 4;
  if (_internal_has__table_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._table_type_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _axes = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._axes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__axes_size());
    total_size += data_size;
  }

  // repeated uint32 lavs_type = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.lavs_type_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_lavs_type_size());
    total_size += data_size;
  }

  // repeated .Common.Types.DoubleOrStr _table_values = 3;
  total_size += 1UL * this->_internal__table_values_size();
  for (const auto& msg : this->_impl_._table_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 _table_template = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__table_template());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyTableClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyTableClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyTableClass::GetClassData() const { return &_class_data_; }


void LibertyTableClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyTableClass*>(&to_msg);
  auto& from = static_cast<const LibertyTableClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyTableClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._axes_.MergeFrom(from._impl_._axes_);
  _this->_impl_.lavs_type_.MergeFrom(from._impl_.lavs_type_);
  _this->_impl_._table_values_.MergeFrom(from._impl_._table_values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable__table_type()->::Liberty::LibertyTableTypeEnum::MergeFrom(
          from._internal__table_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._table_template_ = from._impl_._table_template_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyTableClass::CopyFrom(const LibertyTableClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyTableClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyTableClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__table_type()) {
    if (!_impl_._table_type_->IsInitialized()) return false;
  }
  return true;
}

void LibertyTableClass::InternalSwap(LibertyTableClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._axes_.InternalSwap(&other->_impl_._axes_);
  _impl_.lavs_type_.InternalSwap(&other->_impl_.lavs_type_);
  _impl_._table_values_.InternalSwap(&other->_impl_._table_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyTableClass, _impl_._table_template_)
      + sizeof(LibertyTableClass::_impl_._table_template_)
      - PROTOBUF_FIELD_OFFSET(LibertyTableClass, _impl_._table_type_)>(
          reinterpret_cast<char*>(&_impl_._table_type_),
          reinterpret_cast<char*>(&other->_impl_._table_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyTableClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[10]);
}

// ===================================================================

class LibertyVectorTableClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyVectorTableClass>()._impl_._has_bits_);
  static void set_has__ref_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyVectorTableClass::LibertyVectorTableClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyVectorTableClass)
}
LibertyVectorTableClass::LibertyVectorTableClass(const LibertyVectorTableClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyVectorTableClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._ref_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._ref_time_ = from._impl_._ref_time_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyVectorTableClass)
}

inline void LibertyVectorTableClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._ref_time_){0}
  };
}

LibertyVectorTableClass::~LibertyVectorTableClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyVectorTableClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyVectorTableClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyVectorTableClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyVectorTableClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyVectorTableClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._ref_time_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyVectorTableClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double _ref_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has__ref_time(&has_bits);
          _impl_._ref_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyVectorTableClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyVectorTableClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double _ref_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal__ref_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyVectorTableClass)
  return target;
}

size_t LibertyVectorTableClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyVectorTableClass)
  size_t total_size = 0;

  // required double _ref_time = 1;
  if (_internal_has__ref_time()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyVectorTableClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyVectorTableClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyVectorTableClass::GetClassData() const { return &_class_data_; }


void LibertyVectorTableClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyVectorTableClass*>(&to_msg);
  auto& from = static_cast<const LibertyVectorTableClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyVectorTableClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__ref_time()) {
    _this->_internal_set__ref_time(from._internal__ref_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyVectorTableClass::CopyFrom(const LibertyVectorTableClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyVectorTableClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyVectorTableClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyVectorTableClass::InternalSwap(LibertyVectorTableClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._ref_time_, other->_impl_._ref_time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyVectorTableClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[11]);
}

// ===================================================================

class LibertyTableSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyTableSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lts_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::Liberty::LibertyTableClass& parent(const LibertyTableSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Liberty::LibertyVectorTableClass& lvtc(const LibertyTableSyn* msg);
  static void set_has_lvtc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000d) ^ 0x0000000d) != 0;
  }
};

const ::Liberty::LibertyTableClass&
LibertyTableSyn::_Internal::parent(const LibertyTableSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Liberty::LibertyVectorTableClass&
LibertyTableSyn::_Internal::lvtc(const LibertyTableSyn* msg) {
  return *msg->_impl_.lvtc_;
}
LibertyTableSyn::LibertyTableSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyTableSyn)
}
LibertyTableSyn::LibertyTableSyn(const LibertyTableSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyTableSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.lvtc_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.lts_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Liberty::LibertyTableClass(*from._impl_.parent_);
  }
  if (from._internal_has_lvtc()) {
    _this->_impl_.lvtc_ = new ::Liberty::LibertyVectorTableClass(*from._impl_.lvtc_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lts_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.lts_type_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyTableSyn)
}

inline void LibertyTableSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.lvtc_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.lts_type_){0u}
  };
}

LibertyTableSyn::~LibertyTableSyn() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyTableSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyTableSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.lvtc_;
}

void LibertyTableSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyTableSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyTableSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.lvtc_ != nullptr);
      _impl_.lvtc_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lts_type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.lts_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyTableSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 lts_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lts_type(&has_bits);
          _impl_.lts_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Liberty.LibertyTableClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Liberty.LibertyVectorTableClass lvtc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lvtc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyTableSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyTableSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 lts_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lts_type(), target);
  }

  // required .Liberty.LibertyTableClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .Liberty.LibertyVectorTableClass lvtc = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lvtc(this),
        _Internal::lvtc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyTableSyn)
  return target;
}

size_t LibertyTableSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyTableSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Liberty.LibertyTableClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_lts_type()) {
    // required uint32 lts_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lts_type());
  }

  return total_size;
}
size_t LibertyTableSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyTableSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000d) ^ 0x0000000d) == 0) {  // All required fields are present.
    // required .Liberty.LibertyTableClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 lts_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lts_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Liberty.LibertyVectorTableClass lvtc = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lvtc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyTableSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyTableSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyTableSyn::GetClassData() const { return &_class_data_; }


void LibertyTableSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyTableSyn*>(&to_msg);
  auto& from = static_cast<const LibertyTableSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyTableSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Liberty::LibertyTableClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_lvtc()->::Liberty::LibertyVectorTableClass::MergeFrom(
          from._internal_lvtc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lts_type_ = from._impl_.lts_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyTableSyn::CopyFrom(const LibertyTableSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyTableSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyTableSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  if (_internal_has_lvtc()) {
    if (!_impl_.lvtc_->IsInitialized()) return false;
  }
  return true;
}

void LibertyTableSyn::InternalSwap(LibertyTableSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyTableSyn, _impl_.lts_type_)
      + sizeof(LibertyTableSyn::_impl_.lts_type_)
      - PROTOBUF_FIELD_OFFSET(LibertyTableSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyTableSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[12]);
}

// ===================================================================

class LibertyCCSTableClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyCCSTableClass>()._impl_._has_bits_);
  static const ::Liberty::LibertyTableTypeEnum& _table_type(const LibertyCCSTableClass* msg);
  static void set_has__table_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::Liberty::LibertyTableTypeEnum&
LibertyCCSTableClass::_Internal::_table_type(const LibertyCCSTableClass* msg) {
  return *msg->_impl_._table_type_;
}
LibertyCCSTableClass::LibertyCCSTableClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyCCSTableClass)
}
LibertyCCSTableClass::LibertyCCSTableClass(const LibertyCCSTableClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyCCSTableClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._vector_tables_){from._impl_._vector_tables_}
    , decltype(_impl_._table_type_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has__table_type()) {
    _this->_impl_._table_type_ = new ::Liberty::LibertyTableTypeEnum(*from._impl_._table_type_);
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyCCSTableClass)
}

inline void LibertyCCSTableClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._vector_tables_){arena}
    , decltype(_impl_._table_type_){nullptr}
  };
}

LibertyCCSTableClass::~LibertyCCSTableClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyCCSTableClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyCCSTableClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._vector_tables_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_._table_type_;
}

void LibertyCCSTableClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyCCSTableClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyCCSTableClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._vector_tables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_._table_type_ != nullptr);
    _impl_._table_type_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyCCSTableClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Liberty.LibertyTableTypeEnum _table_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable__table_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _vector_tables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__vector_tables(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__vector_tables(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyCCSTableClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyCCSTableClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Liberty.LibertyTableTypeEnum _table_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::_table_type(this),
        _Internal::_table_type(this).GetCachedSize(), target, stream);
  }

  // repeated uint64 _vector_tables = 2;
  for (int i = 0, n = this->_internal__vector_tables_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__vector_tables(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyCCSTableClass)
  return target;
}

size_t LibertyCCSTableClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyCCSTableClass)
  size_t total_size = 0;

  // required .Liberty.LibertyTableTypeEnum _table_type = 1;
  if (_internal_has__table_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._table_type_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _vector_tables = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._vector_tables_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__vector_tables_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyCCSTableClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyCCSTableClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyCCSTableClass::GetClassData() const { return &_class_data_; }


void LibertyCCSTableClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyCCSTableClass*>(&to_msg);
  auto& from = static_cast<const LibertyCCSTableClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyCCSTableClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._vector_tables_.MergeFrom(from._impl_._vector_tables_);
  if (from._internal_has__table_type()) {
    _this->_internal_mutable__table_type()->::Liberty::LibertyTableTypeEnum::MergeFrom(
        from._internal__table_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyCCSTableClass::CopyFrom(const LibertyCCSTableClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyCCSTableClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyCCSTableClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__table_type()) {
    if (!_impl_._table_type_->IsInitialized()) return false;
  }
  return true;
}

void LibertyCCSTableClass::InternalSwap(LibertyCCSTableClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._vector_tables_.InternalSwap(&other->_impl_._vector_tables_);
  swap(_impl_._table_type_, other->_impl_._table_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyCCSTableClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[13]);
}

// ===================================================================

class LibertyDelayTableModelClass::_Internal {
 public:
};

LibertyDelayTableModelClass::LibertyDelayTableModelClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyDelayTableModelClass)
}
LibertyDelayTableModelClass::LibertyDelayTableModelClass(const LibertyDelayTableModelClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyDelayTableModelClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._tables_){from._impl_._tables_}
    , decltype(_impl_._current_tables_){from._impl_._current_tables_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyDelayTableModelClass)
}

inline void LibertyDelayTableModelClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._tables_){arena}
    , decltype(_impl_._current_tables_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LibertyDelayTableModelClass::~LibertyDelayTableModelClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyDelayTableModelClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyDelayTableModelClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._tables_.~RepeatedField();
  _impl_._current_tables_.~RepeatedField();
}

void LibertyDelayTableModelClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyDelayTableModelClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyDelayTableModelClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._tables_.Clear();
  _impl_._current_tables_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyDelayTableModelClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 _tables = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__tables(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__tables(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _current_tables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__current_tables(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__current_tables(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyDelayTableModelClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyDelayTableModelClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 _tables = 1;
  for (int i = 0, n = this->_internal__tables_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__tables(i), target);
  }

  // repeated uint64 _current_tables = 2;
  for (int i = 0, n = this->_internal__current_tables_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__current_tables(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyDelayTableModelClass)
  return target;
}

size_t LibertyDelayTableModelClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyDelayTableModelClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _tables = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._tables_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__tables_size());
    total_size += data_size;
  }

  // repeated uint64 _current_tables = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._current_tables_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__current_tables_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyDelayTableModelClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyDelayTableModelClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyDelayTableModelClass::GetClassData() const { return &_class_data_; }


void LibertyDelayTableModelClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyDelayTableModelClass*>(&to_msg);
  auto& from = static_cast<const LibertyDelayTableModelClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyDelayTableModelClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._tables_.MergeFrom(from._impl_._tables_);
  _this->_impl_._current_tables_.MergeFrom(from._impl_._current_tables_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyDelayTableModelClass::CopyFrom(const LibertyDelayTableModelClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyDelayTableModelClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyDelayTableModelClass::IsInitialized() const {
  return true;
}

void LibertyDelayTableModelClass::InternalSwap(LibertyDelayTableModelClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._tables_.InternalSwap(&other->_impl_._tables_);
  _impl_._current_tables_.InternalSwap(&other->_impl_._current_tables_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyDelayTableModelClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[14]);
}

// ===================================================================

class LibertyCheckTableModelClass::_Internal {
 public:
};

LibertyCheckTableModelClass::LibertyCheckTableModelClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyCheckTableModelClass)
}
LibertyCheckTableModelClass::LibertyCheckTableModelClass(const LibertyCheckTableModelClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyCheckTableModelClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._tables_){from._impl_._tables_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyCheckTableModelClass)
}

inline void LibertyCheckTableModelClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._tables_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LibertyCheckTableModelClass::~LibertyCheckTableModelClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyCheckTableModelClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyCheckTableModelClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._tables_.~RepeatedField();
}

void LibertyCheckTableModelClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyCheckTableModelClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyCheckTableModelClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._tables_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyCheckTableModelClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 _tables = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__tables(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__tables(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyCheckTableModelClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyCheckTableModelClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 _tables = 1;
  for (int i = 0, n = this->_internal__tables_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__tables(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyCheckTableModelClass)
  return target;
}

size_t LibertyCheckTableModelClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyCheckTableModelClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _tables = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._tables_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__tables_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyCheckTableModelClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyCheckTableModelClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyCheckTableModelClass::GetClassData() const { return &_class_data_; }


void LibertyCheckTableModelClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyCheckTableModelClass*>(&to_msg);
  auto& from = static_cast<const LibertyCheckTableModelClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyCheckTableModelClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._tables_.MergeFrom(from._impl_._tables_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyCheckTableModelClass::CopyFrom(const LibertyCheckTableModelClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyCheckTableModelClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyCheckTableModelClass::IsInitialized() const {
  return true;
}

void LibertyCheckTableModelClass::InternalSwap(LibertyCheckTableModelClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._tables_.InternalSwap(&other->_impl_._tables_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyCheckTableModelClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[15]);
}

// ===================================================================

class LibertyPowerTableModelClass::_Internal {
 public:
};

LibertyPowerTableModelClass::LibertyPowerTableModelClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyPowerTableModelClass)
}
LibertyPowerTableModelClass::LibertyPowerTableModelClass(const LibertyPowerTableModelClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyPowerTableModelClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._tables_){from._impl_._tables_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyPowerTableModelClass)
}

inline void LibertyPowerTableModelClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._tables_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LibertyPowerTableModelClass::~LibertyPowerTableModelClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyPowerTableModelClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyPowerTableModelClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._tables_.~RepeatedField();
}

void LibertyPowerTableModelClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyPowerTableModelClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyPowerTableModelClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._tables_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyPowerTableModelClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 _tables = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__tables(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__tables(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyPowerTableModelClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyPowerTableModelClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 _tables = 1;
  for (int i = 0, n = this->_internal__tables_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__tables(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyPowerTableModelClass)
  return target;
}

size_t LibertyPowerTableModelClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyPowerTableModelClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _tables = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._tables_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__tables_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyPowerTableModelClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyPowerTableModelClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyPowerTableModelClass::GetClassData() const { return &_class_data_; }


void LibertyPowerTableModelClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyPowerTableModelClass*>(&to_msg);
  auto& from = static_cast<const LibertyPowerTableModelClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyPowerTableModelClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._tables_.MergeFrom(from._impl_._tables_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyPowerTableModelClass::CopyFrom(const LibertyPowerTableModelClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyPowerTableModelClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyPowerTableModelClass::IsInitialized() const {
  return true;
}

void LibertyPowerTableModelClass::InternalSwap(LibertyPowerTableModelClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._tables_.InternalSwap(&other->_impl_._tables_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyPowerTableModelClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[16]);
}

// ===================================================================

class LibertyTableModelSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyTableModelSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ltms_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Liberty::LibertyDelayTableModelClass& ldtmc(const LibertyTableModelSyn* msg);
  static const ::Liberty::LibertyCheckTableModelClass& lctmc(const LibertyTableModelSyn* msg);
  static const ::Liberty::LibertyPowerTableModelClass& lptmc(const LibertyTableModelSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::Liberty::LibertyDelayTableModelClass&
LibertyTableModelSyn::_Internal::ldtmc(const LibertyTableModelSyn* msg) {
  return *msg->_impl_.ltms_.ldtmc_;
}
const ::Liberty::LibertyCheckTableModelClass&
LibertyTableModelSyn::_Internal::lctmc(const LibertyTableModelSyn* msg) {
  return *msg->_impl_.ltms_.lctmc_;
}
const ::Liberty::LibertyPowerTableModelClass&
LibertyTableModelSyn::_Internal::lptmc(const LibertyTableModelSyn* msg) {
  return *msg->_impl_.ltms_.lptmc_;
}
void LibertyTableModelSyn::set_allocated_ldtmc(::Liberty::LibertyDelayTableModelClass* ldtmc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ltms();
  if (ldtmc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ldtmc);
    if (message_arena != submessage_arena) {
      ldtmc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldtmc, submessage_arena);
    }
    set_has_ldtmc();
    _impl_.ltms_.ldtmc_ = ldtmc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTableModelSyn.ldtmc)
}
void LibertyTableModelSyn::set_allocated_lctmc(::Liberty::LibertyCheckTableModelClass* lctmc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ltms();
  if (lctmc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lctmc);
    if (message_arena != submessage_arena) {
      lctmc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lctmc, submessage_arena);
    }
    set_has_lctmc();
    _impl_.ltms_.lctmc_ = lctmc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTableModelSyn.lctmc)
}
void LibertyTableModelSyn::set_allocated_lptmc(::Liberty::LibertyPowerTableModelClass* lptmc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ltms();
  if (lptmc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lptmc);
    if (message_arena != submessage_arena) {
      lptmc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lptmc, submessage_arena);
    }
    set_has_lptmc();
    _impl_.ltms_.lptmc_ = lptmc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTableModelSyn.lptmc)
}
LibertyTableModelSyn::LibertyTableModelSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyTableModelSyn)
}
LibertyTableModelSyn::LibertyTableModelSyn(const LibertyTableModelSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyTableModelSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.ltms_type_){}
    , decltype(_impl_.ltms_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ltms_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.ltms_type_));
  clear_has_ltms();
  switch (from.ltms_case()) {
    case kLdtmc: {
      _this->_internal_mutable_ldtmc()->::Liberty::LibertyDelayTableModelClass::MergeFrom(
          from._internal_ldtmc());
      break;
    }
    case kLctmc: {
      _this->_internal_mutable_lctmc()->::Liberty::LibertyCheckTableModelClass::MergeFrom(
          from._internal_lctmc());
      break;
    }
    case kLptmc: {
      _this->_internal_mutable_lptmc()->::Liberty::LibertyPowerTableModelClass::MergeFrom(
          from._internal_lptmc());
      break;
    }
    case LTMS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyTableModelSyn)
}

inline void LibertyTableModelSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.ltms_type_){0u}
    , decltype(_impl_.ltms_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ltms();
}

LibertyTableModelSyn::~LibertyTableModelSyn() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyTableModelSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyTableModelSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ltms()) {
    clear_ltms();
  }
}

void LibertyTableModelSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyTableModelSyn::clear_ltms() {
// @@protoc_insertion_point(one_of_clear_start:Liberty.LibertyTableModelSyn)
  switch (ltms_case()) {
    case kLdtmc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ltms_.ldtmc_;
      }
      break;
    }
    case kLctmc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ltms_.lctmc_;
      }
      break;
    }
    case kLptmc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ltms_.lptmc_;
      }
      break;
    }
    case LTMS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LTMS_NOT_SET;
}


void LibertyTableModelSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyTableModelSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ltms_type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.ltms_type_));
  }
  clear_ltms();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyTableModelSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ltms_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ltms_type(&has_bits);
          _impl_.ltms_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyDelayTableModelClass ldtmc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ldtmc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyCheckTableModelClass lctmc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lctmc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyPowerTableModelClass lptmc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_lptmc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyTableModelSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyTableModelSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 ltms_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ltms_type(), target);
  }

  switch (ltms_case()) {
    case kLdtmc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::ldtmc(this),
          _Internal::ldtmc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLctmc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::lctmc(this),
          _Internal::lctmc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLptmc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::lptmc(this),
          _Internal::lptmc(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyTableModelSyn)
  return target;
}

size_t LibertyTableModelSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyTableModelSyn)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_ltms_type()) {
    // required uint32 ltms_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ltms_type());
  }

  return total_size;
}
size_t LibertyTableModelSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyTableModelSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 ltms_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ltms_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ltms_case()) {
    // .Liberty.LibertyDelayTableModelClass ldtmc = 3;
    case kLdtmc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ltms_.ldtmc_);
      break;
    }
    // .Liberty.LibertyCheckTableModelClass lctmc = 4;
    case kLctmc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ltms_.lctmc_);
      break;
    }
    // .Liberty.LibertyPowerTableModelClass lptmc = 5;
    case kLptmc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ltms_.lptmc_);
      break;
    }
    case LTMS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyTableModelSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyTableModelSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyTableModelSyn::GetClassData() const { return &_class_data_; }


void LibertyTableModelSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyTableModelSyn*>(&to_msg);
  auto& from = static_cast<const LibertyTableModelSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyTableModelSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ltms_type_ = from._impl_.ltms_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.ltms_case()) {
    case kLdtmc: {
      _this->_internal_mutable_ldtmc()->::Liberty::LibertyDelayTableModelClass::MergeFrom(
          from._internal_ldtmc());
      break;
    }
    case kLctmc: {
      _this->_internal_mutable_lctmc()->::Liberty::LibertyCheckTableModelClass::MergeFrom(
          from._internal_lctmc());
      break;
    }
    case kLptmc: {
      _this->_internal_mutable_lptmc()->::Liberty::LibertyPowerTableModelClass::MergeFrom(
          from._internal_lptmc());
      break;
    }
    case LTMS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyTableModelSyn::CopyFrom(const LibertyTableModelSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyTableModelSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyTableModelSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyTableModelSyn::InternalSwap(LibertyTableModelSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyTableModelSyn, _impl_.ltms_type_)
      + sizeof(LibertyTableModelSyn::_impl_.ltms_type_)
      - PROTOBUF_FIELD_OFFSET(LibertyTableModelSyn, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
  swap(_impl_.ltms_, other->_impl_.ltms_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyTableModelSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[17]);
}

// ===================================================================

class LibertyTypeClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyTypeClass>()._impl_._has_bits_);
  static void set_has__type_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__base_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__bit_width(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__bit_from(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has__bit_to(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

LibertyTypeClass::LibertyTypeClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyTypeClass)
}
LibertyTypeClass::LibertyTypeClass(const LibertyTypeClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyTypeClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._type_name_){}
    , decltype(_impl_._base_type_){}
    , decltype(_impl_._data_type_){}
    , decltype(_impl_._bit_width_){}
    , decltype(_impl_._bit_from_){}
    , decltype(_impl_._bit_to_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._type_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._type_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__type_name()) {
    _this->_impl_._type_name_.Set(from._internal__type_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_._base_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._base_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__base_type()) {
    _this->_impl_._base_type_.Set(from._internal__base_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_._data_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._data_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__data_type()) {
    _this->_impl_._data_type_.Set(from._internal__data_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._bit_width_, &from._impl_._bit_width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._bit_to_) -
    reinterpret_cast<char*>(&_impl_._bit_width_)) + sizeof(_impl_._bit_to_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyTypeClass)
}

inline void LibertyTypeClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._type_name_){}
    , decltype(_impl_._base_type_){}
    , decltype(_impl_._data_type_){}
    , decltype(_impl_._bit_width_){0u}
    , decltype(_impl_._bit_from_){0u}
    , decltype(_impl_._bit_to_){0u}
  };
  _impl_._type_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._type_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._base_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._base_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._data_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._data_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyTypeClass::~LibertyTypeClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyTypeClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyTypeClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._type_name_.Destroy();
  _impl_._base_type_.Destroy();
  _impl_._data_type_.Destroy();
}

void LibertyTypeClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyTypeClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyTypeClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._type_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._base_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_._data_type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_._bit_width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._bit_to_) -
        reinterpret_cast<char*>(&_impl_._bit_width_)) + sizeof(_impl_._bit_to_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyTypeClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _type_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__type_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyTypeClass._type_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _base_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__base_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyTypeClass._base_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _data_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable__data_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyTypeClass._data_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 _bit_width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__bit_width(&has_bits);
          _impl_._bit_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _bit_from = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__bit_from(&has_bits);
          _impl_._bit_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _bit_to = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has__bit_to(&has_bits);
          _impl_._bit_to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyTypeClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyTypeClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _type_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__type_name().data(), static_cast<int>(this->_internal__type_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyTypeClass._type_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__type_name(), target);
  }

  // required string _base_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__base_type().data(), static_cast<int>(this->_internal__base_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyTypeClass._base_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__base_type(), target);
  }

  // required string _data_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__data_type().data(), static_cast<int>(this->_internal__data_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyTypeClass._data_type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal__data_type(), target);
  }

  // required uint32 _bit_width = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal__bit_width(), target);
  }

  // required uint32 _bit_from = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal__bit_from(), target);
  }

  // required uint32 _bit_to = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal__bit_to(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyTypeClass)
  return target;
}

size_t LibertyTypeClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyTypeClass)
  size_t total_size = 0;

  if (_internal_has__type_name()) {
    // required string _type_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__type_name());
  }

  if (_internal_has__base_type()) {
    // required string _base_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__base_type());
  }

  if (_internal_has__data_type()) {
    // required string _data_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__data_type());
  }

  if (_internal_has__bit_width()) {
    // required uint32 _bit_width = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__bit_width());
  }

  if (_internal_has__bit_from()) {
    // required uint32 _bit_from = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__bit_from());
  }

  if (_internal_has__bit_to()) {
    // required uint32 _bit_to = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__bit_to());
  }

  return total_size;
}
size_t LibertyTypeClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyTypeClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required string _type_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__type_name());

    // required string _base_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__base_type());

    // required string _data_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__data_type());

    // required uint32 _bit_width = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__bit_width());

    // required uint32 _bit_from = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__bit_from());

    // required uint32 _bit_to = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__bit_to());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyTypeClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyTypeClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyTypeClass::GetClassData() const { return &_class_data_; }


void LibertyTypeClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyTypeClass*>(&to_msg);
  auto& from = static_cast<const LibertyTypeClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyTypeClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__type_name(from._internal__type_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__base_type(from._internal__base_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set__data_type(from._internal__data_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._bit_width_ = from._impl_._bit_width_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_._bit_from_ = from._impl_._bit_from_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_._bit_to_ = from._impl_._bit_to_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyTypeClass::CopyFrom(const LibertyTypeClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyTypeClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyTypeClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyTypeClass::InternalSwap(LibertyTypeClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._type_name_, lhs_arena,
      &other->_impl_._type_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._base_type_, lhs_arena,
      &other->_impl_._base_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._data_type_, lhs_arena,
      &other->_impl_._data_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyTypeClass, _impl_._bit_to_)
      + sizeof(LibertyTypeClass::_impl_._bit_to_)
      - PROTOBUF_FIELD_OFFSET(LibertyTypeClass, _impl_._bit_width_)>(
          reinterpret_cast<char*>(&_impl_._bit_width_),
          reinterpret_cast<char*>(&other->_impl_._bit_width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyTypeClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[18]);
}

// ===================================================================

class LibertyPortTypeEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyPortTypeEnum>()._impl_._has_bits_);
  static void set_has_pt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyPortTypeEnum::LibertyPortTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyPortTypeEnum)
}
LibertyPortTypeEnum::LibertyPortTypeEnum(const LibertyPortTypeEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyPortTypeEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pt_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.pt_ = from._impl_.pt_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyPortTypeEnum)
}

inline void LibertyPortTypeEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pt_){1}
  };
}

LibertyPortTypeEnum::~LibertyPortTypeEnum() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyPortTypeEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyPortTypeEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyPortTypeEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyPortTypeEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyPortTypeEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pt_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyPortTypeEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Liberty.LibertyPortTypeEnum.PortType pt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Liberty::LibertyPortTypeEnum_PortType_IsValid(val))) {
            _internal_set_pt(static_cast<::Liberty::LibertyPortTypeEnum_PortType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyPortTypeEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyPortTypeEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Liberty.LibertyPortTypeEnum.PortType pt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyPortTypeEnum)
  return target;
}

size_t LibertyPortTypeEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyPortTypeEnum)
  size_t total_size = 0;

  // required .Liberty.LibertyPortTypeEnum.PortType pt = 1;
  if (_internal_has_pt()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pt());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyPortTypeEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyPortTypeEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyPortTypeEnum::GetClassData() const { return &_class_data_; }


void LibertyPortTypeEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyPortTypeEnum*>(&to_msg);
  auto& from = static_cast<const LibertyPortTypeEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyPortTypeEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pt()) {
    _this->_internal_set_pt(from._internal_pt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyPortTypeEnum::CopyFrom(const LibertyPortTypeEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyPortTypeEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyPortTypeEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyPortTypeEnum::InternalSwap(LibertyPortTypeEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.pt_, other->_impl_.pt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyPortTypeEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[19]);
}

// ===================================================================

class LibertyPortClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyPortClass>()._impl_._has_bits_);
  static void set_has__port_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__owner_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Liberty::LibertyPortTypeEnum& _port_type(const LibertyPortClass* msg);
  static void set_has__port_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__func_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__port_cap(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has__fanout_load(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has__power_table_model(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000017) ^ 0x00000017) != 0;
  }
};

const ::Liberty::LibertyPortTypeEnum&
LibertyPortClass::_Internal::_port_type(const LibertyPortClass* msg) {
  return *msg->_impl_._port_type_;
}
LibertyPortClass::LibertyPortClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyPortClass)
}
LibertyPortClass::LibertyPortClass(const LibertyPortClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyPortClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_name_){}
    , decltype(_impl_._port_type_){nullptr}
    , decltype(_impl_._owner_cell_){}
    , decltype(_impl_._func_expr_){}
    , decltype(_impl_._port_cap_){}
    , decltype(_impl_._fanout_load_){}
    , decltype(_impl_._power_table_model_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._port_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._port_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__port_name()) {
    _this->_impl_._port_name_.Set(from._internal__port_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has__port_type()) {
    _this->_impl_._port_type_ = new ::Liberty::LibertyPortTypeEnum(*from._impl_._port_type_);
  }
  ::memcpy(&_impl_._owner_cell_, &from._impl_._owner_cell_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._power_table_model_) -
    reinterpret_cast<char*>(&_impl_._owner_cell_)) + sizeof(_impl_._power_table_model_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyPortClass)
}

inline void LibertyPortClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_name_){}
    , decltype(_impl_._port_type_){nullptr}
    , decltype(_impl_._owner_cell_){uint64_t{0u}}
    , decltype(_impl_._func_expr_){uint64_t{0u}}
    , decltype(_impl_._port_cap_){0}
    , decltype(_impl_._fanout_load_){0}
    , decltype(_impl_._power_table_model_){uint64_t{0u}}
  };
  _impl_._port_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._port_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyPortClass::~LibertyPortClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyPortClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyPortClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._port_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_._port_type_;
}

void LibertyPortClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyPortClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyPortClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._port_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_._port_type_ != nullptr);
      _impl_._port_type_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_._owner_cell_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._power_table_model_) -
        reinterpret_cast<char*>(&_impl_._owner_cell_)) + sizeof(_impl_._power_table_model_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyPortClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _port_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__port_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyPortClass._port_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 _owner_cell = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__owner_cell(&has_bits);
          _impl_._owner_cell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Liberty.LibertyPortTypeEnum _port_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable__port_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _func_expr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__func_expr(&has_bits);
          _impl_._func_expr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double _port_cap = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has__port_cap(&has_bits);
          _impl_._port_cap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double _fanout_load = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has__fanout_load(&has_bits);
          _impl_._fanout_load_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _power_table_model = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has__power_table_model(&has_bits);
          _impl_._power_table_model_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyPortClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyPortClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _port_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__port_name().data(), static_cast<int>(this->_internal__port_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyPortClass._port_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__port_name(), target);
  }

  // required uint64 _owner_cell = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__owner_cell(), target);
  }

  // required .Liberty.LibertyPortTypeEnum _port_type = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::_port_type(this),
        _Internal::_port_type(this).GetCachedSize(), target, stream);
  }

  // optional uint64 _func_expr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__func_expr(), target);
  }

  // required double _port_cap = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal__port_cap(), target);
  }

  // optional double _fanout_load = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal__fanout_load(), target);
  }

  // optional uint64 _power_table_model = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal__power_table_model(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyPortClass)
  return target;
}

size_t LibertyPortClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyPortClass)
  size_t total_size = 0;

  if (_internal_has__port_name()) {
    // required string _port_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__port_name());
  }

  if (_internal_has__port_type()) {
    // required .Liberty.LibertyPortTypeEnum _port_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._port_type_);
  }

  if (_internal_has__owner_cell()) {
    // required uint64 _owner_cell = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());
  }

  if (_internal_has__port_cap()) {
    // required double _port_cap = 5;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t LibertyPortClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyPortClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000017) ^ 0x00000017) == 0) {  // All required fields are present.
    // required string _port_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__port_name());

    // required .Liberty.LibertyPortTypeEnum _port_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._port_type_);

    // required uint64 _owner_cell = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());

    // required double _port_cap = 5;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 _func_expr = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__func_expr());
  }

  if (cached_has_bits & 0x00000060u) {
    // optional double _fanout_load = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint64 _power_table_model = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__power_table_model());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyPortClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyPortClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyPortClass::GetClassData() const { return &_class_data_; }


void LibertyPortClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyPortClass*>(&to_msg);
  auto& from = static_cast<const LibertyPortClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyPortClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__port_name(from._internal__port_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable__port_type()->::Liberty::LibertyPortTypeEnum::MergeFrom(
          from._internal__port_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._owner_cell_ = from._impl_._owner_cell_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._func_expr_ = from._impl_._func_expr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_._port_cap_ = from._impl_._port_cap_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_._fanout_load_ = from._impl_._fanout_load_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_._power_table_model_ = from._impl_._power_table_model_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyPortClass::CopyFrom(const LibertyPortClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyPortClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyPortClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__port_type()) {
    if (!_impl_._port_type_->IsInitialized()) return false;
  }
  return true;
}

void LibertyPortClass::InternalSwap(LibertyPortClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._port_name_, lhs_arena,
      &other->_impl_._port_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyPortClass, _impl_._power_table_model_)
      + sizeof(LibertyPortClass::_impl_._power_table_model_)
      - PROTOBUF_FIELD_OFFSET(LibertyPortClass, _impl_._port_type_)>(
          reinterpret_cast<char*>(&_impl_._port_type_),
          reinterpret_cast<char*>(&other->_impl_._port_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyPortClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[20]);
}

// ===================================================================

class LibertyPortBusClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyPortBusClass>()._impl_._has_bits_);
  static void set_has__bus_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyPortBusClass::LibertyPortBusClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyPortBusClass)
}
LibertyPortBusClass::LibertyPortBusClass(const LibertyPortBusClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyPortBusClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._ports_){from._impl_._ports_}
    , decltype(_impl_._bus_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._bus_type_ = from._impl_._bus_type_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyPortBusClass)
}

inline void LibertyPortBusClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._ports_){arena}
    , decltype(_impl_._bus_type_){uint64_t{0u}}
  };
}

LibertyPortBusClass::~LibertyPortBusClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyPortBusClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyPortBusClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._ports_.~RepeatedField();
}

void LibertyPortBusClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyPortBusClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyPortBusClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._ports_.Clear();
  _impl_._bus_type_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyPortBusClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 _ports = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__ports(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__ports(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _bus_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__bus_type(&has_bits);
          _impl_._bus_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyPortBusClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyPortBusClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 _ports = 1;
  for (int i = 0, n = this->_internal__ports_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__ports(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 _bus_type = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__bus_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyPortBusClass)
  return target;
}

size_t LibertyPortBusClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyPortBusClass)
  size_t total_size = 0;

  // required uint64 _bus_type = 2;
  if (_internal_has__bus_type()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__bus_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _ports = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._ports_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__ports_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyPortBusClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyPortBusClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyPortBusClass::GetClassData() const { return &_class_data_; }


void LibertyPortBusClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyPortBusClass*>(&to_msg);
  auto& from = static_cast<const LibertyPortBusClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyPortBusClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._ports_.MergeFrom(from._impl_._ports_);
  if (from._internal_has__bus_type()) {
    _this->_internal_set__bus_type(from._internal__bus_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyPortBusClass::CopyFrom(const LibertyPortBusClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyPortBusClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyPortBusClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyPortBusClass::InternalSwap(LibertyPortBusClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._ports_.InternalSwap(&other->_impl_._ports_);
  swap(_impl_._bus_type_, other->_impl_._bus_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyPortBusClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[21]);
}

// ===================================================================

class LibertyPortSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyPortSyn>()._impl_._has_bits_);
  static void set_has_lps_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Liberty::LibertyPortClass& parent(const LibertyPortSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Liberty::LibertyPortBusClass& lpbc(const LibertyPortSyn* msg);
  static void set_has_lpbc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::Liberty::LibertyPortClass&
LibertyPortSyn::_Internal::parent(const LibertyPortSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Liberty::LibertyPortBusClass&
LibertyPortSyn::_Internal::lpbc(const LibertyPortSyn* msg) {
  return *msg->_impl_.lpbc_;
}
LibertyPortSyn::LibertyPortSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyPortSyn)
}
LibertyPortSyn::LibertyPortSyn(const LibertyPortSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyPortSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.lpbc_){nullptr}
    , decltype(_impl_.lps_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Liberty::LibertyPortClass(*from._impl_.parent_);
  }
  if (from._internal_has_lpbc()) {
    _this->_impl_.lpbc_ = new ::Liberty::LibertyPortBusClass(*from._impl_.lpbc_);
  }
  _this->_impl_.lps_type_ = from._impl_.lps_type_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyPortSyn)
}

inline void LibertyPortSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.lpbc_){nullptr}
    , decltype(_impl_.lps_type_){0u}
  };
}

LibertyPortSyn::~LibertyPortSyn() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyPortSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyPortSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.lpbc_;
}

void LibertyPortSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyPortSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyPortSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.lpbc_ != nullptr);
      _impl_.lpbc_->Clear();
    }
  }
  _impl_.lps_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyPortSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 lps_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lps_type(&has_bits);
          _impl_.lps_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Liberty.LibertyPortClass parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Liberty.LibertyPortBusClass lpbc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lpbc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyPortSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyPortSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 lps_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_lps_type(), target);
  }

  // optional .Liberty.LibertyPortClass parent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .Liberty.LibertyPortBusClass lpbc = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lpbc(this),
        _Internal::lpbc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyPortSyn)
  return target;
}

size_t LibertyPortSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyPortSyn)
  size_t total_size = 0;

  // required uint32 lps_type = 1;
  if (_internal_has_lps_type()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lps_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .Liberty.LibertyPortClass parent = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parent_);
    }

    // optional .Liberty.LibertyPortBusClass lpbc = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lpbc_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyPortSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyPortSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyPortSyn::GetClassData() const { return &_class_data_; }


void LibertyPortSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyPortSyn*>(&to_msg);
  auto& from = static_cast<const LibertyPortSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyPortSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Liberty::LibertyPortClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_lpbc()->::Liberty::LibertyPortBusClass::MergeFrom(
          from._internal_lpbc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lps_type_ = from._impl_.lps_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyPortSyn::CopyFrom(const LibertyPortSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyPortSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyPortSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  if (_internal_has_lpbc()) {
    if (!_impl_.lpbc_->IsInitialized()) return false;
  }
  return true;
}

void LibertyPortSyn::InternalSwap(LibertyPortSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyPortSyn, _impl_.lps_type_)
      + sizeof(LibertyPortSyn::_impl_.lps_type_)
      - PROTOBUF_FIELD_OFFSET(LibertyPortSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyPortSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[22]);
}

// ===================================================================

class LibertyArcClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyArcClass>()._impl_._has_bits_);
  static void set_has__src_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__snk_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__owner_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has__timing_sense(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__timing_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__table_model(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

LibertyArcClass::LibertyArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyArcClass)
}
LibertyArcClass::LibertyArcClass(const LibertyArcClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyArcClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_port_){}
    , decltype(_impl_._snk_port_){}
    , decltype(_impl_._timing_sense_){}
    , decltype(_impl_._timing_type_){}
    , decltype(_impl_._owner_cell_){}
    , decltype(_impl_._table_model_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._src_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._src_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__src_port()) {
    _this->_impl_._src_port_.Set(from._internal__src_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_._snk_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__snk_port()) {
    _this->_impl_._snk_port_.Set(from._internal__snk_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_._timing_sense_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._timing_sense_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__timing_sense()) {
    _this->_impl_._timing_sense_.Set(from._internal__timing_sense(), 
      _this->GetArenaForAllocation());
  }
  _impl_._timing_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._timing_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__timing_type()) {
    _this->_impl_._timing_type_.Set(from._internal__timing_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._owner_cell_, &from._impl_._owner_cell_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._table_model_) -
    reinterpret_cast<char*>(&_impl_._owner_cell_)) + sizeof(_impl_._table_model_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyArcClass)
}

inline void LibertyArcClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_port_){}
    , decltype(_impl_._snk_port_){}
    , decltype(_impl_._timing_sense_){}
    , decltype(_impl_._timing_type_){}
    , decltype(_impl_._owner_cell_){uint64_t{0u}}
    , decltype(_impl_._table_model_){uint64_t{0u}}
  };
  _impl_._src_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._src_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._snk_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._timing_sense_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._timing_sense_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._timing_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._timing_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyArcClass::~LibertyArcClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyArcClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyArcClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._src_port_.Destroy();
  _impl_._snk_port_.Destroy();
  _impl_._timing_sense_.Destroy();
  _impl_._timing_type_.Destroy();
}

void LibertyArcClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyArcClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyArcClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._src_port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._snk_port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_._timing_sense_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_._timing_type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_._owner_cell_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._table_model_) -
        reinterpret_cast<char*>(&_impl_._owner_cell_)) + sizeof(_impl_._table_model_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyArcClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _src_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__src_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyArcClass._src_port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _snk_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__snk_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyArcClass._snk_port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 _owner_cell = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__owner_cell(&has_bits);
          _impl_._owner_cell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _timing_sense = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable__timing_sense();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyArcClass._timing_sense");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _timing_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable__timing_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyArcClass._timing_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 _table_model = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has__table_model(&has_bits);
          _impl_._table_model_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyArcClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyArcClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _src_port = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__src_port().data(), static_cast<int>(this->_internal__src_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyArcClass._src_port");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__src_port(), target);
  }

  // required string _snk_port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__snk_port().data(), static_cast<int>(this->_internal__snk_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyArcClass._snk_port");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__snk_port(), target);
  }

  // required uint64 _owner_cell = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__owner_cell(), target);
  }

  // required string _timing_sense = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__timing_sense().data(), static_cast<int>(this->_internal__timing_sense().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyArcClass._timing_sense");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal__timing_sense(), target);
  }

  // required string _timing_type = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__timing_type().data(), static_cast<int>(this->_internal__timing_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyArcClass._timing_type");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal__timing_type(), target);
  }

  // required uint64 _table_model = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal__table_model(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyArcClass)
  return target;
}

size_t LibertyArcClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyArcClass)
  size_t total_size = 0;

  if (_internal_has__src_port()) {
    // required string _src_port = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__src_port());
  }

  if (_internal_has__snk_port()) {
    // required string _snk_port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__snk_port());
  }

  if (_internal_has__timing_sense()) {
    // required string _timing_sense = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__timing_sense());
  }

  if (_internal_has__timing_type()) {
    // required string _timing_type = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__timing_type());
  }

  if (_internal_has__owner_cell()) {
    // required uint64 _owner_cell = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());
  }

  if (_internal_has__table_model()) {
    // required uint64 _table_model = 6;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__table_model());
  }

  return total_size;
}
size_t LibertyArcClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyArcClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required string _src_port = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__src_port());

    // required string _snk_port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__snk_port());

    // required string _timing_sense = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__timing_sense());

    // required string _timing_type = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__timing_type());

    // required uint64 _owner_cell = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());

    // required uint64 _table_model = 6;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__table_model());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyArcClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyArcClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyArcClass::GetClassData() const { return &_class_data_; }


void LibertyArcClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyArcClass*>(&to_msg);
  auto& from = static_cast<const LibertyArcClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyArcClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__src_port(from._internal__src_port());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__snk_port(from._internal__snk_port());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set__timing_sense(from._internal__timing_sense());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set__timing_type(from._internal__timing_type());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_._owner_cell_ = from._impl_._owner_cell_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_._table_model_ = from._impl_._table_model_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyArcClass::CopyFrom(const LibertyArcClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyArcClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyArcClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyArcClass::InternalSwap(LibertyArcClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._src_port_, lhs_arena,
      &other->_impl_._src_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._snk_port_, lhs_arena,
      &other->_impl_._snk_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._timing_sense_, lhs_arena,
      &other->_impl_._timing_sense_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._timing_type_, lhs_arena,
      &other->_impl_._timing_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyArcClass, _impl_._table_model_)
      + sizeof(LibertyArcClass::_impl_._table_model_)
      - PROTOBUF_FIELD_OFFSET(LibertyArcClass, _impl_._owner_cell_)>(
          reinterpret_cast<char*>(&_impl_._owner_cell_),
          reinterpret_cast<char*>(&other->_impl_._owner_cell_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyArcClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[23]);
}

// ===================================================================

class LibertyArcSetClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyArcSetClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyArcSetClass::LibertyArcSetClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyArcSetClass)
}
LibertyArcSetClass::LibertyArcSetClass(const LibertyArcSetClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyArcSetClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._arcs_){from._impl_._arcs_}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyArcSetClass)
}

inline void LibertyArcSetClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._arcs_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
  };
}

LibertyArcSetClass::~LibertyArcSetClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyArcSetClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyArcSetClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._arcs_.~RepeatedField();
}

void LibertyArcSetClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyArcSetClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyArcSetClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._arcs_.Clear();
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyArcSetClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _arcs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__arcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__arcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyArcSetClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyArcSetClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // repeated uint64 _arcs = 2;
  for (int i = 0, n = this->_internal__arcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__arcs(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyArcSetClass)
  return target;
}

size_t LibertyArcSetClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyArcSetClass)
  size_t total_size = 0;

  // required uint64 id = 1;
  if (_internal_has_id()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _arcs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._arcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__arcs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyArcSetClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyArcSetClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyArcSetClass::GetClassData() const { return &_class_data_; }


void LibertyArcSetClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyArcSetClass*>(&to_msg);
  auto& from = static_cast<const LibertyArcSetClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyArcSetClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._arcs_.MergeFrom(from._impl_._arcs_);
  if (from._internal_has_id()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyArcSetClass::CopyFrom(const LibertyArcSetClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyArcSetClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyArcSetClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyArcSetClass::InternalSwap(LibertyArcSetClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._arcs_.InternalSwap(&other->_impl_._arcs_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyArcSetClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[24]);
}

// ===================================================================

class LibertyPowerArcClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyPowerArcClass>()._impl_._has_bits_);
  static void set_has__src_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__snk_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__related_pg_port(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__when(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__owner_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has__power_table_model(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

LibertyPowerArcClass::LibertyPowerArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyPowerArcClass)
}
LibertyPowerArcClass::LibertyPowerArcClass(const LibertyPowerArcClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyPowerArcClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_port_){}
    , decltype(_impl_._snk_port_){}
    , decltype(_impl_._related_pg_port_){}
    , decltype(_impl_._when_){}
    , decltype(_impl_._owner_cell_){}
    , decltype(_impl_._power_table_model_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._src_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._src_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__src_port()) {
    _this->_impl_._src_port_.Set(from._internal__src_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_._snk_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__snk_port()) {
    _this->_impl_._snk_port_.Set(from._internal__snk_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_._related_pg_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__related_pg_port()) {
    _this->_impl_._related_pg_port_.Set(from._internal__related_pg_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_._when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__when()) {
    _this->_impl_._when_.Set(from._internal__when(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._owner_cell_, &from._impl_._owner_cell_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._power_table_model_) -
    reinterpret_cast<char*>(&_impl_._owner_cell_)) + sizeof(_impl_._power_table_model_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyPowerArcClass)
}

inline void LibertyPowerArcClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_port_){}
    , decltype(_impl_._snk_port_){}
    , decltype(_impl_._related_pg_port_){}
    , decltype(_impl_._when_){}
    , decltype(_impl_._owner_cell_){uint64_t{0u}}
    , decltype(_impl_._power_table_model_){uint64_t{0u}}
  };
  _impl_._src_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._src_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._snk_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._related_pg_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyPowerArcClass::~LibertyPowerArcClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyPowerArcClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyPowerArcClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._src_port_.Destroy();
  _impl_._snk_port_.Destroy();
  _impl_._related_pg_port_.Destroy();
  _impl_._when_.Destroy();
}

void LibertyPowerArcClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyPowerArcClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyPowerArcClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._src_port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._snk_port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_._related_pg_port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_._when_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_._owner_cell_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._power_table_model_) -
        reinterpret_cast<char*>(&_impl_._owner_cell_)) + sizeof(_impl_._power_table_model_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyPowerArcClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _src_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__src_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyPowerArcClass._src_port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _snk_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__snk_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyPowerArcClass._snk_port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _related_pg_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable__related_pg_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyPowerArcClass._related_pg_port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _when = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable__when();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyPowerArcClass._when");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 _owner_cell = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__owner_cell(&has_bits);
          _impl_._owner_cell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _power_table_model = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has__power_table_model(&has_bits);
          _impl_._power_table_model_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyPowerArcClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyPowerArcClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _src_port = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__src_port().data(), static_cast<int>(this->_internal__src_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyPowerArcClass._src_port");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__src_port(), target);
  }

  // required string _snk_port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__snk_port().data(), static_cast<int>(this->_internal__snk_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyPowerArcClass._snk_port");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__snk_port(), target);
  }

  // required string _related_pg_port = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__related_pg_port().data(), static_cast<int>(this->_internal__related_pg_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyPowerArcClass._related_pg_port");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal__related_pg_port(), target);
  }

  // required string _when = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__when().data(), static_cast<int>(this->_internal__when().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyPowerArcClass._when");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal__when(), target);
  }

  // required uint64 _owner_cell = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__owner_cell(), target);
  }

  // optional uint64 _power_table_model = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal__power_table_model(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyPowerArcClass)
  return target;
}

size_t LibertyPowerArcClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyPowerArcClass)
  size_t total_size = 0;

  if (_internal_has__src_port()) {
    // required string _src_port = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__src_port());
  }

  if (_internal_has__snk_port()) {
    // required string _snk_port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__snk_port());
  }

  if (_internal_has__related_pg_port()) {
    // required string _related_pg_port = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__related_pg_port());
  }

  if (_internal_has__when()) {
    // required string _when = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__when());
  }

  if (_internal_has__owner_cell()) {
    // required uint64 _owner_cell = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());
  }

  return total_size;
}
size_t LibertyPowerArcClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyPowerArcClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string _src_port = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__src_port());

    // required string _snk_port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__snk_port());

    // required string _related_pg_port = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__related_pg_port());

    // required string _when = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__when());

    // required uint64 _owner_cell = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 _power_table_model = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000020u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__power_table_model());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyPowerArcClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyPowerArcClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyPowerArcClass::GetClassData() const { return &_class_data_; }


void LibertyPowerArcClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyPowerArcClass*>(&to_msg);
  auto& from = static_cast<const LibertyPowerArcClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyPowerArcClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__src_port(from._internal__src_port());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__snk_port(from._internal__snk_port());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set__related_pg_port(from._internal__related_pg_port());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set__when(from._internal__when());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_._owner_cell_ = from._impl_._owner_cell_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_._power_table_model_ = from._impl_._power_table_model_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyPowerArcClass::CopyFrom(const LibertyPowerArcClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyPowerArcClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyPowerArcClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyPowerArcClass::InternalSwap(LibertyPowerArcClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._src_port_, lhs_arena,
      &other->_impl_._src_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._snk_port_, lhs_arena,
      &other->_impl_._snk_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._related_pg_port_, lhs_arena,
      &other->_impl_._related_pg_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._when_, lhs_arena,
      &other->_impl_._when_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyPowerArcClass, _impl_._power_table_model_)
      + sizeof(LibertyPowerArcClass::_impl_._power_table_model_)
      - PROTOBUF_FIELD_OFFSET(LibertyPowerArcClass, _impl_._owner_cell_)>(
          reinterpret_cast<char*>(&_impl_._owner_cell_),
          reinterpret_cast<char*>(&other->_impl_._owner_cell_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyPowerArcClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[25]);
}

// ===================================================================

class LibertyPowerArcSetClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyPowerArcSetClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyPowerArcSetClass::LibertyPowerArcSetClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyPowerArcSetClass)
}
LibertyPowerArcSetClass::LibertyPowerArcSetClass(const LibertyPowerArcSetClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyPowerArcSetClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._power_arcs_){from._impl_._power_arcs_}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyPowerArcSetClass)
}

inline void LibertyPowerArcSetClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._power_arcs_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
  };
}

LibertyPowerArcSetClass::~LibertyPowerArcSetClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyPowerArcSetClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyPowerArcSetClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._power_arcs_.~RepeatedField();
}

void LibertyPowerArcSetClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyPowerArcSetClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyPowerArcSetClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._power_arcs_.Clear();
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyPowerArcSetClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _power_arcs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__power_arcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__power_arcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyPowerArcSetClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyPowerArcSetClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // repeated uint64 _power_arcs = 2;
  for (int i = 0, n = this->_internal__power_arcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__power_arcs(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyPowerArcSetClass)
  return target;
}

size_t LibertyPowerArcSetClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyPowerArcSetClass)
  size_t total_size = 0;

  // required uint64 id = 1;
  if (_internal_has_id()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _power_arcs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._power_arcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__power_arcs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyPowerArcSetClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyPowerArcSetClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyPowerArcSetClass::GetClassData() const { return &_class_data_; }


void LibertyPowerArcSetClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyPowerArcSetClass*>(&to_msg);
  auto& from = static_cast<const LibertyPowerArcSetClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyPowerArcSetClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._power_arcs_.MergeFrom(from._impl_._power_arcs_);
  if (from._internal_has_id()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyPowerArcSetClass::CopyFrom(const LibertyPowerArcSetClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyPowerArcSetClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyPowerArcSetClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyPowerArcSetClass::InternalSwap(LibertyPowerArcSetClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._power_arcs_.InternalSwap(&other->_impl_._power_arcs_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyPowerArcSetClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[26]);
}

// ===================================================================

class LibertyLeakagePowerClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyLeakagePowerClass>()._impl_._has_bits_);
  static void set_has__related_pg_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__when(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__owner_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

LibertyLeakagePowerClass::LibertyLeakagePowerClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyLeakagePowerClass)
}
LibertyLeakagePowerClass::LibertyLeakagePowerClass(const LibertyLeakagePowerClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyLeakagePowerClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._related_pg_port_){}
    , decltype(_impl_._when_){}
    , decltype(_impl_._value_){}
    , decltype(_impl_._owner_cell_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._related_pg_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__related_pg_port()) {
    _this->_impl_._related_pg_port_.Set(from._internal__related_pg_port(), 
      _this->GetArenaForAllocation());
  }
  _impl_._when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__when()) {
    _this->_impl_._when_.Set(from._internal__when(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._value_, &from._impl_._value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._owner_cell_) -
    reinterpret_cast<char*>(&_impl_._value_)) + sizeof(_impl_._owner_cell_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyLeakagePowerClass)
}

inline void LibertyLeakagePowerClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._related_pg_port_){}
    , decltype(_impl_._when_){}
    , decltype(_impl_._value_){0}
    , decltype(_impl_._owner_cell_){uint64_t{0u}}
  };
  _impl_._related_pg_port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyLeakagePowerClass::~LibertyLeakagePowerClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyLeakagePowerClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyLeakagePowerClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._related_pg_port_.Destroy();
  _impl_._when_.Destroy();
}

void LibertyLeakagePowerClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyLeakagePowerClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyLeakagePowerClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._related_pg_port_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._when_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_._value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._owner_cell_) -
        reinterpret_cast<char*>(&_impl_._value_)) + sizeof(_impl_._owner_cell_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyLeakagePowerClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _related_pg_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__related_pg_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLeakagePowerClass._related_pg_port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string _when = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__when();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLeakagePowerClass._when");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required double _value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has__value(&has_bits);
          _impl_._value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _owner_cell = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__owner_cell(&has_bits);
          _impl_._owner_cell_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyLeakagePowerClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyLeakagePowerClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _related_pg_port = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__related_pg_port().data(), static_cast<int>(this->_internal__related_pg_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLeakagePowerClass._related_pg_port");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__related_pg_port(), target);
  }

  // required string _when = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__when().data(), static_cast<int>(this->_internal__when().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLeakagePowerClass._when");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__when(), target);
  }

  // required double _value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal__value(), target);
  }

  // required uint64 _owner_cell = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__owner_cell(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyLeakagePowerClass)
  return target;
}

size_t LibertyLeakagePowerClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyLeakagePowerClass)
  size_t total_size = 0;

  if (_internal_has__related_pg_port()) {
    // required string _related_pg_port = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__related_pg_port());
  }

  if (_internal_has__when()) {
    // required string _when = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__when());
  }

  if (_internal_has__value()) {
    // required double _value = 3;
    total_size += 1 + 8;
  }

  if (_internal_has__owner_cell()) {
    // required uint64 _owner_cell = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());
  }

  return total_size;
}
size_t LibertyLeakagePowerClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyLeakagePowerClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string _related_pg_port = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__related_pg_port());

    // required string _when = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__when());

    // required double _value = 3;
    total_size += 1 + 8;

    // required uint64 _owner_cell = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_cell());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyLeakagePowerClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyLeakagePowerClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyLeakagePowerClass::GetClassData() const { return &_class_data_; }


void LibertyLeakagePowerClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyLeakagePowerClass*>(&to_msg);
  auto& from = static_cast<const LibertyLeakagePowerClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyLeakagePowerClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__related_pg_port(from._internal__related_pg_port());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__when(from._internal__when());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._value_ = from._impl_._value_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._owner_cell_ = from._impl_._owner_cell_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyLeakagePowerClass::CopyFrom(const LibertyLeakagePowerClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyLeakagePowerClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyLeakagePowerClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyLeakagePowerClass::InternalSwap(LibertyLeakagePowerClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._related_pg_port_, lhs_arena,
      &other->_impl_._related_pg_port_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._when_, lhs_arena,
      &other->_impl_._when_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyLeakagePowerClass, _impl_._owner_cell_)
      + sizeof(LibertyLeakagePowerClass::_impl_._owner_cell_)
      - PROTOBUF_FIELD_OFFSET(LibertyLeakagePowerClass, _impl_._value_)>(
          reinterpret_cast<char*>(&_impl_._value_),
          reinterpret_cast<char*>(&other->_impl_._value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyLeakagePowerClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[27]);
}

// ===================================================================

class LibertyCellClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyCellClass>()._impl_._has_bits_);
  static void set_has__cell_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__cell_leakage_power(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__owner_lib(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__is_dont_use(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

LibertyCellClass::LibertyCellClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyCellClass)
}
LibertyCellClass::LibertyCellClass(const LibertyCellClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyCellClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._leakage_power_list_){from._impl_._leakage_power_list_}
    , decltype(_impl_._cell_ports_){from._impl_._cell_ports_}
    , decltype(_impl_._cell_port_buses_){from._impl_._cell_port_buses_}
    , decltype(_impl_._cell_arcs_){from._impl_._cell_arcs_}
    , decltype(_impl_._cell_power_arcs_){from._impl_._cell_power_arcs_}
    , decltype(_impl_._cell_name_){}
    , decltype(_impl_._cell_leakage_power_){}
    , decltype(_impl_._owner_lib_){}
    , decltype(_impl_._is_dont_use_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._cell_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__cell_name()) {
    _this->_impl_._cell_name_.Set(from._internal__cell_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._cell_leakage_power_, &from._impl_._cell_leakage_power_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._is_dont_use_) -
    reinterpret_cast<char*>(&_impl_._cell_leakage_power_)) + sizeof(_impl_._is_dont_use_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyCellClass)
}

inline void LibertyCellClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._leakage_power_list_){arena}
    , decltype(_impl_._cell_ports_){arena}
    , decltype(_impl_._cell_port_buses_){arena}
    , decltype(_impl_._cell_arcs_){arena}
    , decltype(_impl_._cell_power_arcs_){arena}
    , decltype(_impl_._cell_name_){}
    , decltype(_impl_._cell_leakage_power_){0}
    , decltype(_impl_._owner_lib_){uint64_t{0u}}
    , decltype(_impl_._is_dont_use_){0u}
  };
  _impl_._cell_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyCellClass::~LibertyCellClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyCellClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyCellClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._leakage_power_list_.~RepeatedField();
  _impl_._cell_ports_.~RepeatedField();
  _impl_._cell_port_buses_.~RepeatedField();
  _impl_._cell_arcs_.~RepeatedField();
  _impl_._cell_power_arcs_.~RepeatedField();
  _impl_._cell_name_.Destroy();
}

void LibertyCellClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyCellClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyCellClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._leakage_power_list_.Clear();
  _impl_._cell_ports_.Clear();
  _impl_._cell_port_buses_.Clear();
  _impl_._cell_arcs_.Clear();
  _impl_._cell_power_arcs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._cell_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_._cell_leakage_power_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._is_dont_use_) -
        reinterpret_cast<char*>(&_impl_._cell_leakage_power_)) + sizeof(_impl_._is_dont_use_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyCellClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _cell_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__cell_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyCellClass._cell_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required double _cell_leakage_power = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has__cell_leakage_power(&has_bits);
          _impl_._cell_leakage_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _leakage_power_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__leakage_power_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__leakage_power_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _cell_ports = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__cell_ports(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__cell_ports(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _cell_port_buses = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__cell_port_buses(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__cell_port_buses(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _cell_arcs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__cell_arcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__cell_arcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _cell_power_arcs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__cell_power_arcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__cell_power_arcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _owner_lib = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has__owner_lib(&has_bits);
          _impl_._owner_lib_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _is_dont_use = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has__is_dont_use(&has_bits);
          _impl_._is_dont_use_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyCellClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyCellClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _cell_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__cell_name().data(), static_cast<int>(this->_internal__cell_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyCellClass._cell_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__cell_name(), target);
  }

  // required double _cell_leakage_power = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal__cell_leakage_power(), target);
  }

  // repeated uint64 _leakage_power_list = 3;
  for (int i = 0, n = this->_internal__leakage_power_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__leakage_power_list(i), target);
  }

  // repeated uint64 _cell_ports = 4;
  for (int i = 0, n = this->_internal__cell_ports_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__cell_ports(i), target);
  }

  // repeated uint64 _cell_port_buses = 5;
  for (int i = 0, n = this->_internal__cell_port_buses_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__cell_port_buses(i), target);
  }

  // repeated uint64 _cell_arcs = 6;
  for (int i = 0, n = this->_internal__cell_arcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal__cell_arcs(i), target);
  }

  // repeated uint64 _cell_power_arcs = 7;
  for (int i = 0, n = this->_internal__cell_power_arcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal__cell_power_arcs(i), target);
  }

  // required uint64 _owner_lib = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal__owner_lib(), target);
  }

  // required uint32 _is_dont_use = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal__is_dont_use(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyCellClass)
  return target;
}

size_t LibertyCellClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyCellClass)
  size_t total_size = 0;

  if (_internal_has__cell_name()) {
    // required string _cell_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__cell_name());
  }

  if (_internal_has__cell_leakage_power()) {
    // required double _cell_leakage_power = 2;
    total_size += 1 + 8;
  }

  if (_internal_has__owner_lib()) {
    // required uint64 _owner_lib = 8;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_lib());
  }

  if (_internal_has__is_dont_use()) {
    // required uint32 _is_dont_use = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__is_dont_use());
  }

  return total_size;
}
size_t LibertyCellClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyCellClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string _cell_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__cell_name());

    // required double _cell_leakage_power = 2;
    total_size += 1 + 8;

    // required uint64 _owner_lib = 8;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__owner_lib());

    // required uint32 _is_dont_use = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__is_dont_use());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _leakage_power_list = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._leakage_power_list_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__leakage_power_list_size());
    total_size += data_size;
  }

  // repeated uint64 _cell_ports = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._cell_ports_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__cell_ports_size());
    total_size += data_size;
  }

  // repeated uint64 _cell_port_buses = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._cell_port_buses_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__cell_port_buses_size());
    total_size += data_size;
  }

  // repeated uint64 _cell_arcs = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._cell_arcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__cell_arcs_size());
    total_size += data_size;
  }

  // repeated uint64 _cell_power_arcs = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._cell_power_arcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__cell_power_arcs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyCellClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyCellClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyCellClass::GetClassData() const { return &_class_data_; }


void LibertyCellClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyCellClass*>(&to_msg);
  auto& from = static_cast<const LibertyCellClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyCellClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._leakage_power_list_.MergeFrom(from._impl_._leakage_power_list_);
  _this->_impl_._cell_ports_.MergeFrom(from._impl_._cell_ports_);
  _this->_impl_._cell_port_buses_.MergeFrom(from._impl_._cell_port_buses_);
  _this->_impl_._cell_arcs_.MergeFrom(from._impl_._cell_arcs_);
  _this->_impl_._cell_power_arcs_.MergeFrom(from._impl_._cell_power_arcs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__cell_name(from._internal__cell_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._cell_leakage_power_ = from._impl_._cell_leakage_power_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._owner_lib_ = from._impl_._owner_lib_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._is_dont_use_ = from._impl_._is_dont_use_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyCellClass::CopyFrom(const LibertyCellClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyCellClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyCellClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyCellClass::InternalSwap(LibertyCellClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._leakage_power_list_.InternalSwap(&other->_impl_._leakage_power_list_);
  _impl_._cell_ports_.InternalSwap(&other->_impl_._cell_ports_);
  _impl_._cell_port_buses_.InternalSwap(&other->_impl_._cell_port_buses_);
  _impl_._cell_arcs_.InternalSwap(&other->_impl_._cell_arcs_);
  _impl_._cell_power_arcs_.InternalSwap(&other->_impl_._cell_power_arcs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._cell_name_, lhs_arena,
      &other->_impl_._cell_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyCellClass, _impl_._is_dont_use_)
      + sizeof(LibertyCellClass::_impl_._is_dont_use_)
      - PROTOBUF_FIELD_OFFSET(LibertyCellClass, _impl_._cell_leakage_power_)>(
          reinterpret_cast<char*>(&_impl_._cell_leakage_power_),
          reinterpret_cast<char*>(&other->_impl_._cell_leakage_power_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyCellClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[28]);
}

// ===================================================================

LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse() {}
LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse::MergeFrom(const LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[29]);
}

// ===================================================================

class LibertyWireLoadClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyWireLoadClass>()._impl_._has_bits_);
  static void set_has__wire_load_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__cap_per_length_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__resistance_per_length_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__slope(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyWireLoadClass::LibertyWireLoadClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &LibertyWireLoadClass::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyWireLoadClass)
}
LibertyWireLoadClass::LibertyWireLoadClass(const LibertyWireLoadClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyWireLoadClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._fanout_to_length_)*/{}
    , decltype(_impl_._wire_load_name_){}
    , decltype(_impl_._cap_per_length_unit_){}
    , decltype(_impl_._resistance_per_length_unit_){}
    , decltype(_impl_._slope_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._fanout_to_length_.MergeFrom(from._impl_._fanout_to_length_);
  _impl_._wire_load_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._wire_load_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__wire_load_name()) {
    _this->_impl_._wire_load_name_.Set(from._internal__wire_load_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._cap_per_length_unit_, &from._impl_._cap_per_length_unit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._slope_) -
    reinterpret_cast<char*>(&_impl_._cap_per_length_unit_)) + sizeof(_impl_._slope_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyWireLoadClass)
}

inline void LibertyWireLoadClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._fanout_to_length_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._wire_load_name_){}
    , decltype(_impl_._cap_per_length_unit_){0}
    , decltype(_impl_._resistance_per_length_unit_){0}
    , decltype(_impl_._slope_){0}
  };
  _impl_._wire_load_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._wire_load_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyWireLoadClass::~LibertyWireLoadClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyWireLoadClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void LibertyWireLoadClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._fanout_to_length_.Destruct();
  _impl_._fanout_to_length_.~MapField();
  _impl_._wire_load_name_.Destroy();
}

void LibertyWireLoadClass::ArenaDtor(void* object) {
  LibertyWireLoadClass* _this = reinterpret_cast< LibertyWireLoadClass* >(object);
  _this->_impl_._fanout_to_length_.Destruct();
}
void LibertyWireLoadClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyWireLoadClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyWireLoadClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._fanout_to_length_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._wire_load_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_._cap_per_length_unit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._slope_) -
        reinterpret_cast<char*>(&_impl_._cap_per_length_unit_)) + sizeof(_impl_._slope_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyWireLoadClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _wire_load_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__wire_load_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyWireLoadClass._wire_load_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // map<int32, double> _fanout_to_length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_._fanout_to_length_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double _cap_per_length_unit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has__cap_per_length_unit(&has_bits);
          _impl_._cap_per_length_unit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double _resistance_per_length_unit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has__resistance_per_length_unit(&has_bits);
          _impl_._resistance_per_length_unit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double _slope = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has__slope(&has_bits);
          _impl_._slope_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyWireLoadClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyWireLoadClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _wire_load_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__wire_load_name().data(), static_cast<int>(this->_internal__wire_load_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyWireLoadClass._wire_load_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__wire_load_name(), target);
  }

  // map<int32, double> _fanout_to_length = 2;
  if (!this->_internal__fanout_to_length().empty()) {
    using MapType = ::_pb::Map<int32_t, double>;
    using WireHelper = LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal__fanout_to_length();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  // optional double _cap_per_length_unit = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal__cap_per_length_unit(), target);
  }

  // optional double _resistance_per_length_unit = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal__resistance_per_length_unit(), target);
  }

  // optional double _slope = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal__slope(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyWireLoadClass)
  return target;
}

size_t LibertyWireLoadClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyWireLoadClass)
  size_t total_size = 0;

  // required string _wire_load_name = 1;
  if (_internal_has__wire_load_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__wire_load_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, double> _fanout_to_length = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal__fanout_to_length_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >::const_iterator
      it = this->_internal__fanout_to_length().begin();
      it != this->_internal__fanout_to_length().end(); ++it) {
    total_size += LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional double _cap_per_length_unit = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double _resistance_per_length_unit = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double _slope = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyWireLoadClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyWireLoadClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyWireLoadClass::GetClassData() const { return &_class_data_; }


void LibertyWireLoadClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyWireLoadClass*>(&to_msg);
  auto& from = static_cast<const LibertyWireLoadClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyWireLoadClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._fanout_to_length_.MergeFrom(from._impl_._fanout_to_length_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__wire_load_name(from._internal__wire_load_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._cap_per_length_unit_ = from._impl_._cap_per_length_unit_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._resistance_per_length_unit_ = from._impl_._resistance_per_length_unit_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._slope_ = from._impl_._slope_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyWireLoadClass::CopyFrom(const LibertyWireLoadClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyWireLoadClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyWireLoadClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyWireLoadClass::InternalSwap(LibertyWireLoadClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._fanout_to_length_.InternalSwap(&other->_impl_._fanout_to_length_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._wire_load_name_, lhs_arena,
      &other->_impl_._wire_load_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyWireLoadClass, _impl_._slope_)
      + sizeof(LibertyWireLoadClass::_impl_._slope_)
      - PROTOBUF_FIELD_OFFSET(LibertyWireLoadClass, _impl_._cap_per_length_unit_)>(
          reinterpret_cast<char*>(&_impl_._cap_per_length_unit_),
          reinterpret_cast<char*>(&other->_impl_._cap_per_length_unit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyWireLoadClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[30]);
}

// ===================================================================

class LibertyLutTableTemplateClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyLutTableTemplateClass>()._impl_._has_bits_);
  static void set_has__template_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__template_variable1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__template_variable2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__template_variable3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__template_variable4(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyLutTableTemplateClass::LibertyLutTableTemplateClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyLutTableTemplateClass)
}
LibertyLutTableTemplateClass::LibertyLutTableTemplateClass(const LibertyLutTableTemplateClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyLutTableTemplateClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._axes_){from._impl_._axes_}
    , decltype(_impl_._template_name_){}
    , decltype(_impl_._template_variable1_){}
    , decltype(_impl_._template_variable2_){}
    , decltype(_impl_._template_variable3_){}
    , decltype(_impl_._template_variable4_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._template_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__template_name()) {
    _this->_impl_._template_name_.Set(from._internal__template_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_._template_variable1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__template_variable1()) {
    _this->_impl_._template_variable1_.Set(from._internal__template_variable1(), 
      _this->GetArenaForAllocation());
  }
  _impl_._template_variable2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__template_variable2()) {
    _this->_impl_._template_variable2_.Set(from._internal__template_variable2(), 
      _this->GetArenaForAllocation());
  }
  _impl_._template_variable3_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable3_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__template_variable3()) {
    _this->_impl_._template_variable3_.Set(from._internal__template_variable3(), 
      _this->GetArenaForAllocation());
  }
  _impl_._template_variable4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__template_variable4()) {
    _this->_impl_._template_variable4_.Set(from._internal__template_variable4(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyLutTableTemplateClass)
}

inline void LibertyLutTableTemplateClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._axes_){arena}
    , decltype(_impl_._template_name_){}
    , decltype(_impl_._template_variable1_){}
    , decltype(_impl_._template_variable2_){}
    , decltype(_impl_._template_variable3_){}
    , decltype(_impl_._template_variable4_){}
  };
  _impl_._template_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._template_variable1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._template_variable2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._template_variable3_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable3_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._template_variable4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._template_variable4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyLutTableTemplateClass::~LibertyLutTableTemplateClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyLutTableTemplateClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyLutTableTemplateClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._axes_.~RepeatedField();
  _impl_._template_name_.Destroy();
  _impl_._template_variable1_.Destroy();
  _impl_._template_variable2_.Destroy();
  _impl_._template_variable3_.Destroy();
  _impl_._template_variable4_.Destroy();
}

void LibertyLutTableTemplateClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyLutTableTemplateClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyLutTableTemplateClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._axes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._template_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._template_variable1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_._template_variable2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_._template_variable3_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_._template_variable4_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyLutTableTemplateClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _template_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__template_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLutTableTemplateClass._template_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string _template_variable1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__template_variable1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLutTableTemplateClass._template_variable1");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string _template_variable2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable__template_variable2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLutTableTemplateClass._template_variable2");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string _template_variable3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable__template_variable3();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLutTableTemplateClass._template_variable3");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string _template_variable4 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable__template_variable4();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLutTableTemplateClass._template_variable4");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _axes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__axes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__axes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyLutTableTemplateClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyLutTableTemplateClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _template_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__template_name().data(), static_cast<int>(this->_internal__template_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLutTableTemplateClass._template_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__template_name(), target);
  }

  // optional string _template_variable1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__template_variable1().data(), static_cast<int>(this->_internal__template_variable1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLutTableTemplateClass._template_variable1");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__template_variable1(), target);
  }

  // optional string _template_variable2 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__template_variable2().data(), static_cast<int>(this->_internal__template_variable2().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLutTableTemplateClass._template_variable2");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal__template_variable2(), target);
  }

  // optional string _template_variable3 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__template_variable3().data(), static_cast<int>(this->_internal__template_variable3().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLutTableTemplateClass._template_variable3");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal__template_variable3(), target);
  }

  // optional string _template_variable4 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__template_variable4().data(), static_cast<int>(this->_internal__template_variable4().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLutTableTemplateClass._template_variable4");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal__template_variable4(), target);
  }

  // repeated uint64 _axes = 6;
  for (int i = 0, n = this->_internal__axes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal__axes(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyLutTableTemplateClass)
  return target;
}

size_t LibertyLutTableTemplateClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyLutTableTemplateClass)
  size_t total_size = 0;

  // required string _template_name = 1;
  if (_internal_has__template_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__template_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _axes = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._axes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__axes_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional string _template_variable1 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal__template_variable1());
    }

    // optional string _template_variable2 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal__template_variable2());
    }

    // optional string _template_variable3 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal__template_variable3());
    }

    // optional string _template_variable4 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal__template_variable4());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyLutTableTemplateClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyLutTableTemplateClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyLutTableTemplateClass::GetClassData() const { return &_class_data_; }


void LibertyLutTableTemplateClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyLutTableTemplateClass*>(&to_msg);
  auto& from = static_cast<const LibertyLutTableTemplateClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyLutTableTemplateClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._axes_.MergeFrom(from._impl_._axes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__template_name(from._internal__template_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__template_variable1(from._internal__template_variable1());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set__template_variable2(from._internal__template_variable2());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set__template_variable3(from._internal__template_variable3());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set__template_variable4(from._internal__template_variable4());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyLutTableTemplateClass::CopyFrom(const LibertyLutTableTemplateClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyLutTableTemplateClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyLutTableTemplateClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyLutTableTemplateClass::InternalSwap(LibertyLutTableTemplateClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._axes_.InternalSwap(&other->_impl_._axes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._template_name_, lhs_arena,
      &other->_impl_._template_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._template_variable1_, lhs_arena,
      &other->_impl_._template_variable1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._template_variable2_, lhs_arena,
      &other->_impl_._template_variable2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._template_variable3_, lhs_arena,
      &other->_impl_._template_variable3_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._template_variable4_, lhs_arena,
      &other->_impl_._template_variable4_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyLutTableTemplateClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[31]);
}

// ===================================================================

class LibertyCurrentTemplateClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyCurrentTemplateClass>()._impl_._has_bits_);
  static void set_has__template_axis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LibertyCurrentTemplateClass::LibertyCurrentTemplateClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyCurrentTemplateClass)
}
LibertyCurrentTemplateClass::LibertyCurrentTemplateClass(const LibertyCurrentTemplateClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyCurrentTemplateClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._template_axis_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._template_axis_ = from._impl_._template_axis_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyCurrentTemplateClass)
}

inline void LibertyCurrentTemplateClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._template_axis_){uint64_t{0u}}
  };
}

LibertyCurrentTemplateClass::~LibertyCurrentTemplateClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyCurrentTemplateClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyCurrentTemplateClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyCurrentTemplateClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyCurrentTemplateClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyCurrentTemplateClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._template_axis_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyCurrentTemplateClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 _template_axis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__template_axis(&has_bits);
          _impl_._template_axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyCurrentTemplateClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyCurrentTemplateClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 _template_axis = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__template_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyCurrentTemplateClass)
  return target;
}

size_t LibertyCurrentTemplateClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyCurrentTemplateClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 _template_axis = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__template_axis());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyCurrentTemplateClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyCurrentTemplateClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyCurrentTemplateClass::GetClassData() const { return &_class_data_; }


void LibertyCurrentTemplateClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyCurrentTemplateClass*>(&to_msg);
  auto& from = static_cast<const LibertyCurrentTemplateClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyCurrentTemplateClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__template_axis()) {
    _this->_internal_set__template_axis(from._internal__template_axis());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyCurrentTemplateClass::CopyFrom(const LibertyCurrentTemplateClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyCurrentTemplateClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyCurrentTemplateClass::IsInitialized() const {
  return true;
}

void LibertyCurrentTemplateClass::InternalSwap(LibertyCurrentTemplateClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._template_axis_, other->_impl_._template_axis_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyCurrentTemplateClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[32]);
}

// ===================================================================

class LibertyLutTableTemplateSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyLutTableTemplateSyn>()._impl_._has_bits_);
  static void set_has_lltts_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Liberty::LibertyLutTableTemplateClass& parent(const LibertyLutTableTemplateSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Liberty::LibertyCurrentTemplateClass& lctc(const LibertyLutTableTemplateSyn* msg);
  static void set_has_lctc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::Liberty::LibertyLutTableTemplateClass&
LibertyLutTableTemplateSyn::_Internal::parent(const LibertyLutTableTemplateSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Liberty::LibertyCurrentTemplateClass&
LibertyLutTableTemplateSyn::_Internal::lctc(const LibertyLutTableTemplateSyn* msg) {
  return *msg->_impl_.lctc_;
}
LibertyLutTableTemplateSyn::LibertyLutTableTemplateSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyLutTableTemplateSyn)
}
LibertyLutTableTemplateSyn::LibertyLutTableTemplateSyn(const LibertyLutTableTemplateSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyLutTableTemplateSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.lctc_){nullptr}
    , decltype(_impl_.lltts_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Liberty::LibertyLutTableTemplateClass(*from._impl_.parent_);
  }
  if (from._internal_has_lctc()) {
    _this->_impl_.lctc_ = new ::Liberty::LibertyCurrentTemplateClass(*from._impl_.lctc_);
  }
  _this->_impl_.lltts_type_ = from._impl_.lltts_type_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyLutTableTemplateSyn)
}

inline void LibertyLutTableTemplateSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.lctc_){nullptr}
    , decltype(_impl_.lltts_type_){0u}
  };
}

LibertyLutTableTemplateSyn::~LibertyLutTableTemplateSyn() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyLutTableTemplateSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyLutTableTemplateSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.lctc_;
}

void LibertyLutTableTemplateSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyLutTableTemplateSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyLutTableTemplateSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.lctc_ != nullptr);
      _impl_.lctc_->Clear();
    }
  }
  _impl_.lltts_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyLutTableTemplateSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 lltts_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lltts_type(&has_bits);
          _impl_.lltts_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Liberty.LibertyLutTableTemplateClass parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Liberty.LibertyCurrentTemplateClass lctc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lctc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyLutTableTemplateSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyLutTableTemplateSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 lltts_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_lltts_type(), target);
  }

  // required .Liberty.LibertyLutTableTemplateClass parent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .Liberty.LibertyCurrentTemplateClass lctc = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lctc(this),
        _Internal::lctc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyLutTableTemplateSyn)
  return target;
}

size_t LibertyLutTableTemplateSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyLutTableTemplateSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Liberty.LibertyLutTableTemplateClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_lltts_type()) {
    // required uint32 lltts_type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lltts_type());
  }

  return total_size;
}
size_t LibertyLutTableTemplateSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyLutTableTemplateSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .Liberty.LibertyLutTableTemplateClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint32 lltts_type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lltts_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Liberty.LibertyCurrentTemplateClass lctc = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lctc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyLutTableTemplateSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyLutTableTemplateSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyLutTableTemplateSyn::GetClassData() const { return &_class_data_; }


void LibertyLutTableTemplateSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyLutTableTemplateSyn*>(&to_msg);
  auto& from = static_cast<const LibertyLutTableTemplateSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyLutTableTemplateSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Liberty::LibertyLutTableTemplateClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_lctc()->::Liberty::LibertyCurrentTemplateClass::MergeFrom(
          from._internal_lctc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lltts_type_ = from._impl_.lltts_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyLutTableTemplateSyn::CopyFrom(const LibertyLutTableTemplateSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyLutTableTemplateSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyLutTableTemplateSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  return true;
}

void LibertyLutTableTemplateSyn::InternalSwap(LibertyLutTableTemplateSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyLutTableTemplateSyn, _impl_.lltts_type_)
      + sizeof(LibertyLutTableTemplateSyn::_impl_.lltts_type_)
      - PROTOBUF_FIELD_OFFSET(LibertyLutTableTemplateSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyLutTableTemplateSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[33]);
}

// ===================================================================

class LibertyObjectSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyObjectSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_los_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Liberty::LibertyObjectClass& parent(const LibertyObjectSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Liberty::LibertyAxisClass& laxc(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyTableSyn& lts(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyCCSTableClass& lccstc(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyTableModelSyn& ltms(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyPortSyn& lps(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyTypeClass& ltc(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyLeakagePowerClass& llpc(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyArcClass& larc(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyPowerArcClass& lpac(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyCellClass& lcc(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyWireLoadClass& lwlc(const LibertyObjectSyn* msg);
  static const ::Liberty::LibertyLutTableTemplateSyn& lltts(const LibertyObjectSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Liberty::LibertyObjectClass&
LibertyObjectSyn::_Internal::parent(const LibertyObjectSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Liberty::LibertyAxisClass&
LibertyObjectSyn::_Internal::laxc(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.laxc_;
}
const ::Liberty::LibertyTableSyn&
LibertyObjectSyn::_Internal::lts(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.lts_;
}
const ::Liberty::LibertyCCSTableClass&
LibertyObjectSyn::_Internal::lccstc(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.lccstc_;
}
const ::Liberty::LibertyTableModelSyn&
LibertyObjectSyn::_Internal::ltms(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.ltms_;
}
const ::Liberty::LibertyPortSyn&
LibertyObjectSyn::_Internal::lps(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.lps_;
}
const ::Liberty::LibertyTypeClass&
LibertyObjectSyn::_Internal::ltc(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.ltc_;
}
const ::Liberty::LibertyLeakagePowerClass&
LibertyObjectSyn::_Internal::llpc(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.llpc_;
}
const ::Liberty::LibertyArcClass&
LibertyObjectSyn::_Internal::larc(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.larc_;
}
const ::Liberty::LibertyPowerArcClass&
LibertyObjectSyn::_Internal::lpac(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.lpac_;
}
const ::Liberty::LibertyCellClass&
LibertyObjectSyn::_Internal::lcc(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.lcc_;
}
const ::Liberty::LibertyWireLoadClass&
LibertyObjectSyn::_Internal::lwlc(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.lwlc_;
}
const ::Liberty::LibertyLutTableTemplateSyn&
LibertyObjectSyn::_Internal::lltts(const LibertyObjectSyn* msg) {
  return *msg->_impl_.los_.lltts_;
}
void LibertyObjectSyn::set_allocated_laxc(::Liberty::LibertyAxisClass* laxc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (laxc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(laxc);
    if (message_arena != submessage_arena) {
      laxc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laxc, submessage_arena);
    }
    set_has_laxc();
    _impl_.los_.laxc_ = laxc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.laxc)
}
void LibertyObjectSyn::set_allocated_lts(::Liberty::LibertyTableSyn* lts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (lts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lts);
    if (message_arena != submessage_arena) {
      lts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lts, submessage_arena);
    }
    set_has_lts();
    _impl_.los_.lts_ = lts;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.lts)
}
void LibertyObjectSyn::set_allocated_lccstc(::Liberty::LibertyCCSTableClass* lccstc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (lccstc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lccstc);
    if (message_arena != submessage_arena) {
      lccstc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lccstc, submessage_arena);
    }
    set_has_lccstc();
    _impl_.los_.lccstc_ = lccstc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.lccstc)
}
void LibertyObjectSyn::set_allocated_ltms(::Liberty::LibertyTableModelSyn* ltms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (ltms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ltms);
    if (message_arena != submessage_arena) {
      ltms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ltms, submessage_arena);
    }
    set_has_ltms();
    _impl_.los_.ltms_ = ltms;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.ltms)
}
void LibertyObjectSyn::set_allocated_lps(::Liberty::LibertyPortSyn* lps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (lps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lps);
    if (message_arena != submessage_arena) {
      lps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lps, submessage_arena);
    }
    set_has_lps();
    _impl_.los_.lps_ = lps;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.lps)
}
void LibertyObjectSyn::set_allocated_ltc(::Liberty::LibertyTypeClass* ltc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (ltc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ltc);
    if (message_arena != submessage_arena) {
      ltc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ltc, submessage_arena);
    }
    set_has_ltc();
    _impl_.los_.ltc_ = ltc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.ltc)
}
void LibertyObjectSyn::set_allocated_llpc(::Liberty::LibertyLeakagePowerClass* llpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (llpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(llpc);
    if (message_arena != submessage_arena) {
      llpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, llpc, submessage_arena);
    }
    set_has_llpc();
    _impl_.los_.llpc_ = llpc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.llpc)
}
void LibertyObjectSyn::set_allocated_larc(::Liberty::LibertyArcClass* larc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (larc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(larc);
    if (message_arena != submessage_arena) {
      larc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, larc, submessage_arena);
    }
    set_has_larc();
    _impl_.los_.larc_ = larc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.larc)
}
void LibertyObjectSyn::set_allocated_lpac(::Liberty::LibertyPowerArcClass* lpac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (lpac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lpac);
    if (message_arena != submessage_arena) {
      lpac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lpac, submessage_arena);
    }
    set_has_lpac();
    _impl_.los_.lpac_ = lpac;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.lpac)
}
void LibertyObjectSyn::set_allocated_lcc(::Liberty::LibertyCellClass* lcc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (lcc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lcc);
    if (message_arena != submessage_arena) {
      lcc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lcc, submessage_arena);
    }
    set_has_lcc();
    _impl_.los_.lcc_ = lcc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.lcc)
}
void LibertyObjectSyn::set_allocated_lwlc(::Liberty::LibertyWireLoadClass* lwlc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (lwlc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lwlc);
    if (message_arena != submessage_arena) {
      lwlc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lwlc, submessage_arena);
    }
    set_has_lwlc();
    _impl_.los_.lwlc_ = lwlc;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.lwlc)
}
void LibertyObjectSyn::set_allocated_lltts(::Liberty::LibertyLutTableTemplateSyn* lltts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_los();
  if (lltts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lltts);
    if (message_arena != submessage_arena) {
      lltts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lltts, submessage_arena);
    }
    set_has_lltts();
    _impl_.los_.lltts_ = lltts;
  }
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.lltts)
}
LibertyObjectSyn::LibertyObjectSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyObjectSyn)
}
LibertyObjectSyn::LibertyObjectSyn(const LibertyObjectSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyObjectSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.los_type_){}
    , decltype(_impl_.los_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Liberty::LibertyObjectClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.los_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.los_type_));
  clear_has_los();
  switch (from.los_case()) {
    case kLaxc: {
      _this->_internal_mutable_laxc()->::Liberty::LibertyAxisClass::MergeFrom(
          from._internal_laxc());
      break;
    }
    case kLts: {
      _this->_internal_mutable_lts()->::Liberty::LibertyTableSyn::MergeFrom(
          from._internal_lts());
      break;
    }
    case kLccstc: {
      _this->_internal_mutable_lccstc()->::Liberty::LibertyCCSTableClass::MergeFrom(
          from._internal_lccstc());
      break;
    }
    case kLtms: {
      _this->_internal_mutable_ltms()->::Liberty::LibertyTableModelSyn::MergeFrom(
          from._internal_ltms());
      break;
    }
    case kLps: {
      _this->_internal_mutable_lps()->::Liberty::LibertyPortSyn::MergeFrom(
          from._internal_lps());
      break;
    }
    case kLtc: {
      _this->_internal_mutable_ltc()->::Liberty::LibertyTypeClass::MergeFrom(
          from._internal_ltc());
      break;
    }
    case kLlpc: {
      _this->_internal_mutable_llpc()->::Liberty::LibertyLeakagePowerClass::MergeFrom(
          from._internal_llpc());
      break;
    }
    case kLarc: {
      _this->_internal_mutable_larc()->::Liberty::LibertyArcClass::MergeFrom(
          from._internal_larc());
      break;
    }
    case kLpac: {
      _this->_internal_mutable_lpac()->::Liberty::LibertyPowerArcClass::MergeFrom(
          from._internal_lpac());
      break;
    }
    case kLcc: {
      _this->_internal_mutable_lcc()->::Liberty::LibertyCellClass::MergeFrom(
          from._internal_lcc());
      break;
    }
    case kLwlc: {
      _this->_internal_mutable_lwlc()->::Liberty::LibertyWireLoadClass::MergeFrom(
          from._internal_lwlc());
      break;
    }
    case kLltts: {
      _this->_internal_mutable_lltts()->::Liberty::LibertyLutTableTemplateSyn::MergeFrom(
          from._internal_lltts());
      break;
    }
    case LOS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyObjectSyn)
}

inline void LibertyObjectSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.los_type_){0u}
    , decltype(_impl_.los_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_los();
}

LibertyObjectSyn::~LibertyObjectSyn() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyObjectSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyObjectSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_los()) {
    clear_los();
  }
}

void LibertyObjectSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyObjectSyn::clear_los() {
// @@protoc_insertion_point(one_of_clear_start:Liberty.LibertyObjectSyn)
  switch (los_case()) {
    case kLaxc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.laxc_;
      }
      break;
    }
    case kLts: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.lts_;
      }
      break;
    }
    case kLccstc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.lccstc_;
      }
      break;
    }
    case kLtms: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.ltms_;
      }
      break;
    }
    case kLps: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.lps_;
      }
      break;
    }
    case kLtc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.ltc_;
      }
      break;
    }
    case kLlpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.llpc_;
      }
      break;
    }
    case kLarc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.larc_;
      }
      break;
    }
    case kLpac: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.lpac_;
      }
      break;
    }
    case kLcc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.lcc_;
      }
      break;
    }
    case kLwlc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.lwlc_;
      }
      break;
    }
    case kLltts: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.los_.lltts_;
      }
      break;
    }
    case LOS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LOS_NOT_SET;
}


void LibertyObjectSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyObjectSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.los_type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.los_type_));
  }
  clear_los();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyObjectSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 los_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_los_type(&has_bits);
          _impl_.los_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Liberty.LibertyObjectClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyAxisClass laxc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_laxc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyTableSyn lts = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_lts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyCCSTableClass lccstc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_lccstc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyTableModelSyn ltms = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_ltms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyPortSyn lps = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_lps(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyTypeClass ltc = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_ltc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyLeakagePowerClass llpc = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_llpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyArcClass larc = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_larc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyPowerArcClass lpac = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_lpac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyCellClass lcc = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_lcc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyWireLoadClass lwlc = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_lwlc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Liberty.LibertyLutTableTemplateSyn lltts = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_lltts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyObjectSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyObjectSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 los_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_los_type(), target);
  }

  // required .Liberty.LibertyObjectClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (los_case()) {
    case kLaxc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::laxc(this),
          _Internal::laxc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLts: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::lts(this),
          _Internal::lts(this).GetCachedSize(), target, stream);
      break;
    }
    case kLccstc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::lccstc(this),
          _Internal::lccstc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLtms: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::ltms(this),
          _Internal::ltms(this).GetCachedSize(), target, stream);
      break;
    }
    case kLps: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::lps(this),
          _Internal::lps(this).GetCachedSize(), target, stream);
      break;
    }
    case kLtc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::ltc(this),
          _Internal::ltc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLlpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::llpc(this),
          _Internal::llpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLarc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::larc(this),
          _Internal::larc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLpac: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::lpac(this),
          _Internal::lpac(this).GetCachedSize(), target, stream);
      break;
    }
    case kLcc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::lcc(this),
          _Internal::lcc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLwlc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::lwlc(this),
          _Internal::lwlc(this).GetCachedSize(), target, stream);
      break;
    }
    case kLltts: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::lltts(this),
          _Internal::lltts(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyObjectSyn)
  return target;
}

size_t LibertyObjectSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyObjectSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Liberty.LibertyObjectClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_los_type()) {
    // required uint32 los_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_los_type());
  }

  return total_size;
}
size_t LibertyObjectSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyObjectSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Liberty.LibertyObjectClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 los_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_los_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (los_case()) {
    // .Liberty.LibertyAxisClass laxc = 4;
    case kLaxc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.laxc_);
      break;
    }
    // .Liberty.LibertyTableSyn lts = 5;
    case kLts: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.lts_);
      break;
    }
    // .Liberty.LibertyCCSTableClass lccstc = 6;
    case kLccstc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.lccstc_);
      break;
    }
    // .Liberty.LibertyTableModelSyn ltms = 7;
    case kLtms: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.ltms_);
      break;
    }
    // .Liberty.LibertyPortSyn lps = 8;
    case kLps: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.lps_);
      break;
    }
    // .Liberty.LibertyTypeClass ltc = 9;
    case kLtc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.ltc_);
      break;
    }
    // .Liberty.LibertyLeakagePowerClass llpc = 10;
    case kLlpc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.llpc_);
      break;
    }
    // .Liberty.LibertyArcClass larc = 11;
    case kLarc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.larc_);
      break;
    }
    // .Liberty.LibertyPowerArcClass lpac = 12;
    case kLpac: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.lpac_);
      break;
    }
    // .Liberty.LibertyCellClass lcc = 13;
    case kLcc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.lcc_);
      break;
    }
    // .Liberty.LibertyWireLoadClass lwlc = 14;
    case kLwlc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.lwlc_);
      break;
    }
    // .Liberty.LibertyLutTableTemplateSyn lltts = 15;
    case kLltts: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.los_.lltts_);
      break;
    }
    case LOS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyObjectSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyObjectSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyObjectSyn::GetClassData() const { return &_class_data_; }


void LibertyObjectSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyObjectSyn*>(&to_msg);
  auto& from = static_cast<const LibertyObjectSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyObjectSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Liberty::LibertyObjectClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.los_type_ = from._impl_.los_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.los_case()) {
    case kLaxc: {
      _this->_internal_mutable_laxc()->::Liberty::LibertyAxisClass::MergeFrom(
          from._internal_laxc());
      break;
    }
    case kLts: {
      _this->_internal_mutable_lts()->::Liberty::LibertyTableSyn::MergeFrom(
          from._internal_lts());
      break;
    }
    case kLccstc: {
      _this->_internal_mutable_lccstc()->::Liberty::LibertyCCSTableClass::MergeFrom(
          from._internal_lccstc());
      break;
    }
    case kLtms: {
      _this->_internal_mutable_ltms()->::Liberty::LibertyTableModelSyn::MergeFrom(
          from._internal_ltms());
      break;
    }
    case kLps: {
      _this->_internal_mutable_lps()->::Liberty::LibertyPortSyn::MergeFrom(
          from._internal_lps());
      break;
    }
    case kLtc: {
      _this->_internal_mutable_ltc()->::Liberty::LibertyTypeClass::MergeFrom(
          from._internal_ltc());
      break;
    }
    case kLlpc: {
      _this->_internal_mutable_llpc()->::Liberty::LibertyLeakagePowerClass::MergeFrom(
          from._internal_llpc());
      break;
    }
    case kLarc: {
      _this->_internal_mutable_larc()->::Liberty::LibertyArcClass::MergeFrom(
          from._internal_larc());
      break;
    }
    case kLpac: {
      _this->_internal_mutable_lpac()->::Liberty::LibertyPowerArcClass::MergeFrom(
          from._internal_lpac());
      break;
    }
    case kLcc: {
      _this->_internal_mutable_lcc()->::Liberty::LibertyCellClass::MergeFrom(
          from._internal_lcc());
      break;
    }
    case kLwlc: {
      _this->_internal_mutable_lwlc()->::Liberty::LibertyWireLoadClass::MergeFrom(
          from._internal_lwlc());
      break;
    }
    case kLltts: {
      _this->_internal_mutable_lltts()->::Liberty::LibertyLutTableTemplateSyn::MergeFrom(
          from._internal_lltts());
      break;
    }
    case LOS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyObjectSyn::CopyFrom(const LibertyObjectSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyObjectSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyObjectSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (los_case()) {
    case kLaxc: {
      if (_internal_has_laxc()) {
        if (!_impl_.los_.laxc_->IsInitialized()) return false;
      }
      break;
    }
    case kLts: {
      if (_internal_has_lts()) {
        if (!_impl_.los_.lts_->IsInitialized()) return false;
      }
      break;
    }
    case kLccstc: {
      if (_internal_has_lccstc()) {
        if (!_impl_.los_.lccstc_->IsInitialized()) return false;
      }
      break;
    }
    case kLtms: {
      if (_internal_has_ltms()) {
        if (!_impl_.los_.ltms_->IsInitialized()) return false;
      }
      break;
    }
    case kLps: {
      if (_internal_has_lps()) {
        if (!_impl_.los_.lps_->IsInitialized()) return false;
      }
      break;
    }
    case kLtc: {
      if (_internal_has_ltc()) {
        if (!_impl_.los_.ltc_->IsInitialized()) return false;
      }
      break;
    }
    case kLlpc: {
      if (_internal_has_llpc()) {
        if (!_impl_.los_.llpc_->IsInitialized()) return false;
      }
      break;
    }
    case kLarc: {
      if (_internal_has_larc()) {
        if (!_impl_.los_.larc_->IsInitialized()) return false;
      }
      break;
    }
    case kLpac: {
      if (_internal_has_lpac()) {
        if (!_impl_.los_.lpac_->IsInitialized()) return false;
      }
      break;
    }
    case kLcc: {
      if (_internal_has_lcc()) {
        if (!_impl_.los_.lcc_->IsInitialized()) return false;
      }
      break;
    }
    case kLwlc: {
      if (_internal_has_lwlc()) {
        if (!_impl_.los_.lwlc_->IsInitialized()) return false;
      }
      break;
    }
    case kLltts: {
      if (_internal_has_lltts()) {
        if (!_impl_.los_.lltts_->IsInitialized()) return false;
      }
      break;
    }
    case LOS_NOT_SET: {
      break;
    }
  }
  return true;
}

void LibertyObjectSyn::InternalSwap(LibertyObjectSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyObjectSyn, _impl_.los_type_)
      + sizeof(LibertyObjectSyn::_impl_.los_type_)
      - PROTOBUF_FIELD_OFFSET(LibertyObjectSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.los_, other->_impl_.los_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyObjectSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[34]);
}

// ===================================================================

class LibertyLibraryClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyLibraryClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has__lib_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Common::Types::CapacitiveUnitEnum& _cap_unit(const LibertyLibraryClass* msg);
  static void set_has__cap_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Common::Types::ResistanceUnitEnum& _resistance_unit(const LibertyLibraryClass* msg);
  static void set_has__resistance_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__default_max_transition(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has__default_max_fanout(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has__default_fanout_load(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has__default_wire_load(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::Common::Types::CapacitiveUnitEnum&
LibertyLibraryClass::_Internal::_cap_unit(const LibertyLibraryClass* msg) {
  return *msg->_impl_._cap_unit_;
}
const ::Common::Types::ResistanceUnitEnum&
LibertyLibraryClass::_Internal::_resistance_unit(const LibertyLibraryClass* msg) {
  return *msg->_impl_._resistance_unit_;
}
void LibertyLibraryClass::clear__cap_unit() {
  if (_impl_._cap_unit_ != nullptr) _impl_._cap_unit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void LibertyLibraryClass::clear__resistance_unit() {
  if (_impl_._resistance_unit_ != nullptr) _impl_._resistance_unit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
LibertyLibraryClass::LibertyLibraryClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyLibraryClass)
}
LibertyLibraryClass::LibertyLibraryClass(const LibertyLibraryClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyLibraryClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._cells_){from._impl_._cells_}
    , decltype(_impl_._lut_template_){from._impl_._lut_template_}
    , decltype(_impl_._wire_loads_){from._impl_._wire_loads_}
    , decltype(_impl_._types_){from._impl_._types_}
    , decltype(_impl_._lib_name_){}
    , decltype(_impl_._default_wire_load_){}
    , decltype(_impl_._cap_unit_){nullptr}
    , decltype(_impl_._resistance_unit_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_._default_max_transition_){}
    , decltype(_impl_._default_max_fanout_){}
    , decltype(_impl_._default_fanout_load_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._lib_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._lib_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__lib_name()) {
    _this->_impl_._lib_name_.Set(from._internal__lib_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_._default_wire_load_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._default_wire_load_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__default_wire_load()) {
    _this->_impl_._default_wire_load_.Set(from._internal__default_wire_load(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has__cap_unit()) {
    _this->_impl_._cap_unit_ = new ::Common::Types::CapacitiveUnitEnum(*from._impl_._cap_unit_);
  }
  if (from._internal_has__resistance_unit()) {
    _this->_impl_._resistance_unit_ = new ::Common::Types::ResistanceUnitEnum(*from._impl_._resistance_unit_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._default_fanout_load_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._default_fanout_load_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyLibraryClass)
}

inline void LibertyLibraryClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._cells_){arena}
    , decltype(_impl_._lut_template_){arena}
    , decltype(_impl_._wire_loads_){arena}
    , decltype(_impl_._types_){arena}
    , decltype(_impl_._lib_name_){}
    , decltype(_impl_._default_wire_load_){}
    , decltype(_impl_._cap_unit_){nullptr}
    , decltype(_impl_._resistance_unit_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._default_max_transition_){0}
    , decltype(_impl_._default_max_fanout_){0}
    , decltype(_impl_._default_fanout_load_){0}
  };
  _impl_._lib_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._lib_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._default_wire_load_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._default_wire_load_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyLibraryClass::~LibertyLibraryClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyLibraryClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyLibraryClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._cells_.~RepeatedField();
  _impl_._lut_template_.~RepeatedField();
  _impl_._wire_loads_.~RepeatedField();
  _impl_._types_.~RepeatedField();
  _impl_._lib_name_.Destroy();
  _impl_._default_wire_load_.Destroy();
  if (this != internal_default_instance()) delete _impl_._cap_unit_;
  if (this != internal_default_instance()) delete _impl_._resistance_unit_;
}

void LibertyLibraryClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyLibraryClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyLibraryClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._cells_.Clear();
  _impl_._lut_template_.Clear();
  _impl_._wire_loads_.Clear();
  _impl_._types_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._lib_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._default_wire_load_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_._cap_unit_ != nullptr);
      _impl_._cap_unit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_._resistance_unit_ != nullptr);
      _impl_._resistance_unit_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._default_fanout_load_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._default_fanout_load_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyLibraryClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _lib_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__lib_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLibraryClass._lib_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _cells = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__cells(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__cells(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _lut_template = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__lut_template(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__lut_template(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _wire_loads = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__wire_loads(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__wire_loads(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _types = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__types(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__types(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Common.Types.CapacitiveUnitEnum _cap_unit = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable__cap_unit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Common.Types.ResistanceUnitEnum _resistance_unit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable__resistance_unit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double _default_max_transition = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has__default_max_transition(&has_bits);
          _impl_._default_max_transition_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double _default_max_fanout = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has__default_max_fanout(&has_bits);
          _impl_._default_max_fanout_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double _default_fanout_load = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has__default_fanout_load(&has_bits);
          _impl_._default_fanout_load_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required string _default_wire_load = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable__default_wire_load();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyLibraryClass._default_wire_load");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyLibraryClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyLibraryClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required string _lib_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__lib_name().data(), static_cast<int>(this->_internal__lib_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLibraryClass._lib_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__lib_name(), target);
  }

  // repeated uint64 _cells = 3;
  for (int i = 0, n = this->_internal__cells_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__cells(i), target);
  }

  // repeated uint64 _lut_template = 4;
  for (int i = 0, n = this->_internal__lut_template_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__lut_template(i), target);
  }

  // repeated uint64 _wire_loads = 5;
  for (int i = 0, n = this->_internal__wire_loads_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__wire_loads(i), target);
  }

  // repeated uint64 _types = 6;
  for (int i = 0, n = this->_internal__types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal__types(i), target);
  }

  // required .Common.Types.CapacitiveUnitEnum _cap_unit = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::_cap_unit(this),
        _Internal::_cap_unit(this).GetCachedSize(), target, stream);
  }

  // required .Common.Types.ResistanceUnitEnum _resistance_unit = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::_resistance_unit(this),
        _Internal::_resistance_unit(this).GetCachedSize(), target, stream);
  }

  // optional double _default_max_transition = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal__default_max_transition(), target);
  }

  // optional double _default_max_fanout = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal__default_max_fanout(), target);
  }

  // optional double _default_fanout_load = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal__default_fanout_load(), target);
  }

  // required string _default_wire_load = 12;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__default_wire_load().data(), static_cast<int>(this->_internal__default_wire_load().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyLibraryClass._default_wire_load");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal__default_wire_load(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyLibraryClass)
  return target;
}

size_t LibertyLibraryClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyLibraryClass)
  size_t total_size = 0;

  if (_internal_has__lib_name()) {
    // required string _lib_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__lib_name());
  }

  if (_internal_has__default_wire_load()) {
    // required string _default_wire_load = 12;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__default_wire_load());
  }

  if (_internal_has__cap_unit()) {
    // required .Common.Types.CapacitiveUnitEnum _cap_unit = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._cap_unit_);
  }

  if (_internal_has__resistance_unit()) {
    // required .Common.Types.ResistanceUnitEnum _resistance_unit = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._resistance_unit_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return total_size;
}
size_t LibertyLibraryClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyLibraryClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string _lib_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__lib_name());

    // required string _default_wire_load = 12;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__default_wire_load());

    // required .Common.Types.CapacitiveUnitEnum _cap_unit = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._cap_unit_);

    // required .Common.Types.ResistanceUnitEnum _resistance_unit = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._resistance_unit_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _cells = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._cells_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__cells_size());
    total_size += data_size;
  }

  // repeated uint64 _lut_template = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._lut_template_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__lut_template_size());
    total_size += data_size;
  }

  // repeated uint64 _wire_loads = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._wire_loads_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__wire_loads_size());
    total_size += data_size;
  }

  // repeated uint64 _types = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._types_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__types_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000e0u) {
    // optional double _default_max_transition = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double _default_max_fanout = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double _default_fanout_load = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyLibraryClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyLibraryClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyLibraryClass::GetClassData() const { return &_class_data_; }


void LibertyLibraryClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyLibraryClass*>(&to_msg);
  auto& from = static_cast<const LibertyLibraryClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyLibraryClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._cells_.MergeFrom(from._impl_._cells_);
  _this->_impl_._lut_template_.MergeFrom(from._impl_._lut_template_);
  _this->_impl_._wire_loads_.MergeFrom(from._impl_._wire_loads_);
  _this->_impl_._types_.MergeFrom(from._impl_._types_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__lib_name(from._internal__lib_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__default_wire_load(from._internal__default_wire_load());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable__cap_unit()->::Common::Types::CapacitiveUnitEnum::MergeFrom(
          from._internal__cap_unit());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable__resistance_unit()->::Common::Types::ResistanceUnitEnum::MergeFrom(
          from._internal__resistance_unit());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_._default_max_transition_ = from._impl_._default_max_transition_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_._default_max_fanout_ = from._impl_._default_max_fanout_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_._default_fanout_load_ = from._impl_._default_fanout_load_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyLibraryClass::CopyFrom(const LibertyLibraryClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyLibraryClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyLibraryClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__cap_unit()) {
    if (!_impl_._cap_unit_->IsInitialized()) return false;
  }
  if (_internal_has__resistance_unit()) {
    if (!_impl_._resistance_unit_->IsInitialized()) return false;
  }
  return true;
}

void LibertyLibraryClass::InternalSwap(LibertyLibraryClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._cells_.InternalSwap(&other->_impl_._cells_);
  _impl_._lut_template_.InternalSwap(&other->_impl_._lut_template_);
  _impl_._wire_loads_.InternalSwap(&other->_impl_._wire_loads_);
  _impl_._types_.InternalSwap(&other->_impl_._types_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._lib_name_, lhs_arena,
      &other->_impl_._lib_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._default_wire_load_, lhs_arena,
      &other->_impl_._default_wire_load_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyLibraryClass, _impl_._default_fanout_load_)
      + sizeof(LibertyLibraryClass::_impl_._default_fanout_load_)
      - PROTOBUF_FIELD_OFFSET(LibertyLibraryClass, _impl_._cap_unit_)>(
          reinterpret_cast<char*>(&_impl_._cap_unit_),
          reinterpret_cast<char*>(&other->_impl_._cap_unit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyLibraryClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[35]);
}

// ===================================================================

class LibertyOwnPortTypeEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyOwnPortTypeEnum>()._impl_._has_bits_);
  static void set_has_lopt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyOwnPortTypeEnum::LibertyOwnPortTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyOwnPortTypeEnum)
}
LibertyOwnPortTypeEnum::LibertyOwnPortTypeEnum(const LibertyOwnPortTypeEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyOwnPortTypeEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lopt_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.lopt_ = from._impl_.lopt_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyOwnPortTypeEnum)
}

inline void LibertyOwnPortTypeEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lopt_){1}
  };
}

LibertyOwnPortTypeEnum::~LibertyOwnPortTypeEnum() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyOwnPortTypeEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyOwnPortTypeEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyOwnPortTypeEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyOwnPortTypeEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyOwnPortTypeEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lopt_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyOwnPortTypeEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Liberty.LibertyOwnPortTypeEnum.LibertyOwnPortType lopt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType_IsValid(val))) {
            _internal_set_lopt(static_cast<::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyOwnPortTypeEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyOwnPortTypeEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Liberty.LibertyOwnPortTypeEnum.LibertyOwnPortType lopt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_lopt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyOwnPortTypeEnum)
  return target;
}

size_t LibertyOwnPortTypeEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyOwnPortTypeEnum)
  size_t total_size = 0;

  // required .Liberty.LibertyOwnPortTypeEnum.LibertyOwnPortType lopt = 1;
  if (_internal_has_lopt()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_lopt());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyOwnPortTypeEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyOwnPortTypeEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyOwnPortTypeEnum::GetClassData() const { return &_class_data_; }


void LibertyOwnPortTypeEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyOwnPortTypeEnum*>(&to_msg);
  auto& from = static_cast<const LibertyOwnPortTypeEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyOwnPortTypeEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_lopt()) {
    _this->_internal_set_lopt(from._internal_lopt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyOwnPortTypeEnum::CopyFrom(const LibertyOwnPortTypeEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyOwnPortTypeEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyOwnPortTypeEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyOwnPortTypeEnum::InternalSwap(LibertyOwnPortTypeEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.lopt_, other->_impl_.lopt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyOwnPortTypeEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[36]);
}

// ===================================================================

class LibertyOwnPgOrWhenTypeEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyOwnPgOrWhenTypeEnum>()._impl_._has_bits_);
  static void set_has_lopowt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LibertyOwnPgOrWhenTypeEnum::LibertyOwnPgOrWhenTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyOwnPgOrWhenTypeEnum)
}
LibertyOwnPgOrWhenTypeEnum::LibertyOwnPgOrWhenTypeEnum(const LibertyOwnPgOrWhenTypeEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyOwnPgOrWhenTypeEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lopowt_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.lopowt_ = from._impl_.lopowt_;
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyOwnPgOrWhenTypeEnum)
}

inline void LibertyOwnPgOrWhenTypeEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lopowt_){1}
  };
}

LibertyOwnPgOrWhenTypeEnum::~LibertyOwnPgOrWhenTypeEnum() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyOwnPgOrWhenTypeEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyOwnPgOrWhenTypeEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyOwnPgOrWhenTypeEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyOwnPgOrWhenTypeEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyOwnPgOrWhenTypeEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lopowt_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyOwnPgOrWhenTypeEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Liberty.LibertyOwnPgOrWhenTypeEnum.LibertyOwnPgOrWhenType lopowt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_IsValid(val))) {
            _internal_set_lopowt(static_cast<::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyOwnPgOrWhenTypeEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyOwnPgOrWhenTypeEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Liberty.LibertyOwnPgOrWhenTypeEnum.LibertyOwnPgOrWhenType lopowt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_lopowt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyOwnPgOrWhenTypeEnum)
  return target;
}

size_t LibertyOwnPgOrWhenTypeEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyOwnPgOrWhenTypeEnum)
  size_t total_size = 0;

  // required .Liberty.LibertyOwnPgOrWhenTypeEnum.LibertyOwnPgOrWhenType lopowt = 1;
  if (_internal_has_lopowt()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_lopowt());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyOwnPgOrWhenTypeEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyOwnPgOrWhenTypeEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyOwnPgOrWhenTypeEnum::GetClassData() const { return &_class_data_; }


void LibertyOwnPgOrWhenTypeEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyOwnPgOrWhenTypeEnum*>(&to_msg);
  auto& from = static_cast<const LibertyOwnPgOrWhenTypeEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyOwnPgOrWhenTypeEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_lopowt()) {
    _this->_internal_set_lopowt(from._internal_lopowt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyOwnPgOrWhenTypeEnum::CopyFrom(const LibertyOwnPgOrWhenTypeEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyOwnPgOrWhenTypeEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyOwnPgOrWhenTypeEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyOwnPgOrWhenTypeEnum::InternalSwap(LibertyOwnPgOrWhenTypeEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.lopowt_, other->_impl_.lopowt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyOwnPgOrWhenTypeEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[37]);
}

// ===================================================================

class LibertyBuilderClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyBuilderClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__lib(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

LibertyBuilderClass::LibertyBuilderClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyBuilderClass)
}
LibertyBuilderClass::LibertyBuilderClass(const LibertyBuilderClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyBuilderClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_._lib_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._lib_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._lib_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyBuilderClass)
}

inline void LibertyBuilderClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._lib_){uint64_t{0u}}
  };
}

LibertyBuilderClass::~LibertyBuilderClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyBuilderClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyBuilderClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LibertyBuilderClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyBuilderClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyBuilderClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._lib_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._lib_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyBuilderClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _lib = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__lib(&has_bits);
          _impl_._lib_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyBuilderClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyBuilderClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint64 _lib = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__lib(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyBuilderClass)
  return target;
}

size_t LibertyBuilderClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyBuilderClass)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has__lib()) {
    // required uint64 _lib = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__lib());
  }

  return total_size;
}
size_t LibertyBuilderClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyBuilderClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint64 _lib = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__lib());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyBuilderClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyBuilderClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyBuilderClass::GetClassData() const { return &_class_data_; }


void LibertyBuilderClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyBuilderClass*>(&to_msg);
  auto& from = static_cast<const LibertyBuilderClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyBuilderClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._lib_ = from._impl_._lib_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyBuilderClass::CopyFrom(const LibertyBuilderClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyBuilderClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyBuilderClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyBuilderClass::InternalSwap(LibertyBuilderClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyBuilderClass, _impl_._lib_)
      + sizeof(LibertyBuilderClass::_impl_._lib_)
      - PROTOBUF_FIELD_OFFSET(LibertyBuilderClass, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyBuilderClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[38]);
}

// ===================================================================

class LibertyReaderClass::_Internal {
 public:
  using HasBits = decltype(std::declval<LibertyReaderClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__library_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__liberty_builder(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

LibertyReaderClass::LibertyReaderClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Liberty.LibertyReaderClass)
}
LibertyReaderClass::LibertyReaderClass(const LibertyReaderClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibertyReaderClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_._library_group_){}
    , decltype(_impl_._liberty_builder_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__file_name()) {
    _this->_impl_._file_name_.Set(from._internal__file_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._liberty_builder_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._liberty_builder_));
  // @@protoc_insertion_point(copy_constructor:Liberty.LibertyReaderClass)
}

inline void LibertyReaderClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._library_group_){uint64_t{0u}}
    , decltype(_impl_._liberty_builder_){uint64_t{0u}}
  };
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LibertyReaderClass::~LibertyReaderClass() {
  // @@protoc_insertion_point(destructor:Liberty.LibertyReaderClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibertyReaderClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._file_name_.Destroy();
}

void LibertyReaderClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibertyReaderClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Liberty.LibertyReaderClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._file_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._liberty_builder_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._liberty_builder_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibertyReaderClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _library_group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__library_group(&has_bits);
          _impl_._library_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _file_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable__file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Liberty.LibertyReaderClass._file_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint64 _liberty_builder = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__liberty_builder(&has_bits);
          _impl_._liberty_builder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibertyReaderClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Liberty.LibertyReaderClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint64 _library_group = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__library_group(), target);
  }

  // required string _file_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__file_name().data(), static_cast<int>(this->_internal__file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Liberty.LibertyReaderClass._file_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal__file_name(), target);
  }

  // required uint64 _liberty_builder = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__liberty_builder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Liberty.LibertyReaderClass)
  return target;
}

size_t LibertyReaderClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Liberty.LibertyReaderClass)
  size_t total_size = 0;

  if (_internal_has__file_name()) {
    // required string _file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has__library_group()) {
    // required uint64 _library_group = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__library_group());
  }

  if (_internal_has__liberty_builder()) {
    // required uint64 _liberty_builder = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__liberty_builder());
  }

  return total_size;
}
size_t LibertyReaderClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Liberty.LibertyReaderClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string _file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint64 _library_group = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__library_group());

    // required uint64 _liberty_builder = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__liberty_builder());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibertyReaderClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibertyReaderClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibertyReaderClass::GetClassData() const { return &_class_data_; }


void LibertyReaderClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibertyReaderClass*>(&to_msg);
  auto& from = static_cast<const LibertyReaderClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Liberty.LibertyReaderClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__file_name(from._internal__file_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._library_group_ = from._impl_._library_group_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._liberty_builder_ = from._impl_._liberty_builder_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibertyReaderClass::CopyFrom(const LibertyReaderClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Liberty.LibertyReaderClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibertyReaderClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LibertyReaderClass::InternalSwap(LibertyReaderClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._file_name_, lhs_arena,
      &other->_impl_._file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LibertyReaderClass, _impl_._liberty_builder_)
      + sizeof(LibertyReaderClass::_impl_._liberty_builder_)
      - PROTOBUF_FIELD_OFFSET(LibertyReaderClass, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LibertyReaderClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_LibertyReader_2eproto_getter, &descriptor_table_LibertyReader_2eproto_once,
      file_level_metadata_LibertyReader_2eproto[39]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Liberty
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Liberty::LibertyExprOperatorEnum*
Arena::CreateMaybeMessage< ::Liberty::LibertyExprOperatorEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyExprOperatorEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyExprClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyExprClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyExprClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyStmtClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyStmtClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyStmtClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertySimpleAttrStmtClass*
Arena::CreateMaybeMessage< ::Liberty::LibertySimpleAttrStmtClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertySimpleAttrStmtClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyComplexAttrStmtClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyComplexAttrStmtClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyComplexAttrStmtClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyGroupStmtClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyGroupStmtClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyGroupStmtClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyStmtSyn*
Arena::CreateMaybeMessage< ::Liberty::LibertyStmtSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyStmtSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyObjectClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyObjectClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyObjectClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyAxisClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyAxisClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyAxisClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyTableTypeEnum*
Arena::CreateMaybeMessage< ::Liberty::LibertyTableTypeEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyTableTypeEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyTableClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyTableClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyTableClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyVectorTableClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyVectorTableClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyVectorTableClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyTableSyn*
Arena::CreateMaybeMessage< ::Liberty::LibertyTableSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyTableSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyCCSTableClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyCCSTableClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyCCSTableClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyDelayTableModelClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyDelayTableModelClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyDelayTableModelClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyCheckTableModelClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyCheckTableModelClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyCheckTableModelClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyPowerTableModelClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyPowerTableModelClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyPowerTableModelClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyTableModelSyn*
Arena::CreateMaybeMessage< ::Liberty::LibertyTableModelSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyTableModelSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyTypeClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyTypeClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyTypeClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyPortTypeEnum*
Arena::CreateMaybeMessage< ::Liberty::LibertyPortTypeEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyPortTypeEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyPortClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyPortClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyPortClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyPortBusClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyPortBusClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyPortBusClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyPortSyn*
Arena::CreateMaybeMessage< ::Liberty::LibertyPortSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyPortSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyArcClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyArcClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyArcClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyArcSetClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyArcSetClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyArcSetClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyPowerArcClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyPowerArcClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyPowerArcClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyPowerArcSetClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyPowerArcSetClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyPowerArcSetClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyLeakagePowerClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyLeakagePowerClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyLeakagePowerClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyCellClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyCellClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyCellClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyWireLoadClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyWireLoadClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyWireLoadClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyLutTableTemplateClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyLutTableTemplateClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyLutTableTemplateClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyCurrentTemplateClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyCurrentTemplateClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyCurrentTemplateClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyLutTableTemplateSyn*
Arena::CreateMaybeMessage< ::Liberty::LibertyLutTableTemplateSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyLutTableTemplateSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyObjectSyn*
Arena::CreateMaybeMessage< ::Liberty::LibertyObjectSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyObjectSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyLibraryClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyLibraryClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyLibraryClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyOwnPortTypeEnum*
Arena::CreateMaybeMessage< ::Liberty::LibertyOwnPortTypeEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyOwnPortTypeEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyOwnPgOrWhenTypeEnum*
Arena::CreateMaybeMessage< ::Liberty::LibertyOwnPgOrWhenTypeEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyOwnPgOrWhenTypeEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyBuilderClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyBuilderClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyBuilderClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Liberty::LibertyReaderClass*
Arena::CreateMaybeMessage< ::Liberty::LibertyReaderClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Liberty::LibertyReaderClass >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
