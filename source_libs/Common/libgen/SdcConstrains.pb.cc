// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SdcConstrains.proto

#include "SdcConstrains.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Sdc {
PROTOBUF_CONSTEXPR SdcCommandObjClass::SdcCommandObjClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._line_no_)*/0u} {}
struct SdcCommandObjClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcCommandObjClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcCommandObjClassDefaultTypeInternal() {}
  union {
    SdcCommandObjClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcCommandObjClassDefaultTypeInternal _SdcCommandObjClass_default_instance_;
PROTOBUF_CONSTEXPR SdcIOConstrainClass::SdcIOConstrainClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._constrain_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SdcIOConstrainClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcIOConstrainClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcIOConstrainClassDefaultTypeInternal() {}
  union {
    SdcIOConstrainClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcIOConstrainClassDefaultTypeInternal _SdcIOConstrainClass_default_instance_;
PROTOBUF_CONSTEXPR SdcSetInputTransitionClass::SdcSetInputTransitionClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._objs_)*/{}
  , /*decltype(_impl_._transition_value_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcSetInputTransitionClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcSetInputTransitionClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcSetInputTransitionClassDefaultTypeInternal() {}
  union {
    SdcSetInputTransitionClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcSetInputTransitionClassDefaultTypeInternal _SdcSetInputTransitionClass_default_instance_;
PROTOBUF_CONSTEXPR SdcSetIODelayClass::SdcSetIODelayClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._objs_)*/{}
  , /*decltype(_impl_._clock_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._delay_value_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcSetIODelayClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcSetIODelayClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcSetIODelayClassDefaultTypeInternal() {}
  union {
    SdcSetIODelayClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcSetIODelayClassDefaultTypeInternal _SdcSetIODelayClass_default_instance_;
PROTOBUF_CONSTEXPR SdcSetLoadClass::SdcSetLoadClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._objs_)*/{}
  , /*decltype(_impl_._load_value_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcSetLoadClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcSetLoadClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcSetLoadClassDefaultTypeInternal() {}
  union {
    SdcSetLoadClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcSetLoadClassDefaultTypeInternal _SdcSetLoadClass_default_instance_;
PROTOBUF_CONSTEXPR SdcIOConstrainSyn::SdcIOConstrainSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.siocs_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SdcIOConstrainSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcIOConstrainSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcIOConstrainSynDefaultTypeInternal() {}
  union {
    SdcIOConstrainSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcIOConstrainSynDefaultTypeInternal _SdcIOConstrainSyn_default_instance_;
PROTOBUF_CONSTEXPR SdcClockClass::SdcClockClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._objs_)*/{}
  , /*decltype(_impl_._edges_)*/{}
  , /*decltype(_impl_._clock_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._tracking_comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._period_)*/0
  , /*decltype(_impl_._is_propagated_)*/0u} {}
struct SdcClockClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcClockClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcClockClassDefaultTypeInternal() {}
  union {
    SdcClockClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcClockClassDefaultTypeInternal _SdcClockClass_default_instance_;
PROTOBUF_CONSTEXPR SdcGenrateClockClass::SdcGenrateClockClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._source_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SdcGenrateClockClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcGenrateClockClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcGenrateClockClassDefaultTypeInternal() {}
  union {
    SdcGenrateClockClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcGenrateClockClassDefaultTypeInternal _SdcGenrateClockClass_default_instance_;
PROTOBUF_CONSTEXPR SdcClockSyn::SdcClockSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.child_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcClockSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcClockSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcClockSynDefaultTypeInternal() {}
  union {
    SdcClockSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcClockSynDefaultTypeInternal _SdcClockSyn_default_instance_;
PROTOBUF_CONSTEXPR SdcAllClocksClass::SdcAllClocksClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._clocks_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SdcAllClocksClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcAllClocksClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcAllClocksClassDefaultTypeInternal() {}
  union {
    SdcAllClocksClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcAllClocksClassDefaultTypeInternal _SdcAllClocksClass_default_instance_;
PROTOBUF_CONSTEXPR SdcClockGroupClass::SdcClockGroupClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._clock_group_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SdcClockGroupClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcClockGroupClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcClockGroupClassDefaultTypeInternal() {}
  union {
    SdcClockGroupClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcClockGroupClassDefaultTypeInternal _SdcClockGroupClass_default_instance_;
PROTOBUF_CONSTEXPR SdcClockGroupsClass::SdcClockGroupsClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._clock_groups_)*/{}
  , /*decltype(_impl_._group_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SdcClockGroupsClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcClockGroupsClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcClockGroupsClassDefaultTypeInternal() {}
  union {
    SdcClockGroupsClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcClockGroupsClassDefaultTypeInternal _SdcClockGroupsClass_default_instance_;
PROTOBUF_CONSTEXPR SdcCollectionTypeEnum::SdcCollectionTypeEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ct_)*/0} {}
struct SdcCollectionTypeEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcCollectionTypeEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcCollectionTypeEnumDefaultTypeInternal() {}
  union {
    SdcCollectionTypeEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcCollectionTypeEnumDefaultTypeInternal _SdcCollectionTypeEnum_default_instance_;
PROTOBUF_CONSTEXPR SdcCollectionClass::SdcCollectionClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._collection_objs_)*/{}
  , /*decltype(_impl_._collection_obj_types_)*/{}
  , /*decltype(_impl_.scte_)*/nullptr} {}
struct SdcCollectionClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcCollectionClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcCollectionClassDefaultTypeInternal() {}
  union {
    SdcCollectionClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcCollectionClassDefaultTypeInternal _SdcCollectionClass_default_instance_;
PROTOBUF_CONSTEXPR SdcTimingDerateClass::SdcTimingDerateClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._derate_value_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcTimingDerateClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcTimingDerateClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcTimingDerateClassDefaultTypeInternal() {}
  union {
    SdcTimingDerateClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcTimingDerateClassDefaultTypeInternal _SdcTimingDerateClass_default_instance_;
PROTOBUF_CONSTEXPR SdcTimingDRCClass::SdcTimingDRCClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._objs_)*/{}
  , /*decltype(_impl_._obj_types_)*/{}
  , /*decltype(_impl_._drc_val_)*/0} {}
struct SdcTimingDRCClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcTimingDRCClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcTimingDRCClassDefaultTypeInternal() {}
  union {
    SdcTimingDRCClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcTimingDRCClassDefaultTypeInternal _SdcTimingDRCClass_default_instance_;
PROTOBUF_CONSTEXPR SdcSetMaxTransitionClass::SdcSetMaxTransitionClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcSetMaxTransitionClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcSetMaxTransitionClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcSetMaxTransitionClassDefaultTypeInternal() {}
  union {
    SdcSetMaxTransitionClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcSetMaxTransitionClassDefaultTypeInternal _SdcSetMaxTransitionClass_default_instance_;
PROTOBUF_CONSTEXPR SdcSetMaxCapacitanceClass::SdcSetMaxCapacitanceClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcSetMaxCapacitanceClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcSetMaxCapacitanceClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcSetMaxCapacitanceClassDefaultTypeInternal() {}
  union {
    SdcSetMaxCapacitanceClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcSetMaxCapacitanceClassDefaultTypeInternal _SdcSetMaxCapacitanceClass_default_instance_;
PROTOBUF_CONSTEXPR SdcTimingDRCSyn::SdcTimingDRCSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.stdrcs_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SdcTimingDRCSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcTimingDRCSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcTimingDRCSynDefaultTypeInternal() {}
  union {
    SdcTimingDRCSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcTimingDRCSynDefaultTypeInternal _SdcTimingDRCSyn_default_instance_;
PROTOBUF_CONSTEXPR SdcSetClockLatencyClass::SdcSetClockLatencyClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._objs_)*/{}
  , /*decltype(_impl_._delay_value_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcSetClockLatencyClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcSetClockLatencyClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcSetClockLatencyClassDefaultTypeInternal() {}
  union {
    SdcSetClockLatencyClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcSetClockLatencyClassDefaultTypeInternal _SdcSetClockLatencyClass_default_instance_;
PROTOBUF_CONSTEXPR SdcSetClockUncertaintyClass::SdcSetClockUncertaintyClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._objs_)*/{}
  , /*decltype(_impl_._uncertainty_value_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcSetClockUncertaintyClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcSetClockUncertaintyClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcSetClockUncertaintyClassDefaultTypeInternal() {}
  union {
    SdcSetClockUncertaintyClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcSetClockUncertaintyClassDefaultTypeInternal _SdcSetClockUncertaintyClass_default_instance_;
PROTOBUF_CONSTEXPR SdcExceptionClass::SdcExceptionClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._prop_froms_)*/{}
  , /*decltype(_impl_._prop_tos_)*/{}
  , /*decltype(_impl_._prop_throughs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SdcExceptionClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcExceptionClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcExceptionClassDefaultTypeInternal() {}
  union {
    SdcExceptionClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcExceptionClassDefaultTypeInternal _SdcExceptionClass_default_instance_;
PROTOBUF_CONSTEXPR SdcMulticyclePathClass::SdcMulticyclePathClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._path_multiplier_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcMulticyclePathClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcMulticyclePathClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcMulticyclePathClassDefaultTypeInternal() {}
  union {
    SdcMulticyclePathClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcMulticyclePathClassDefaultTypeInternal _SdcMulticyclePathClass_default_instance_;
PROTOBUF_CONSTEXPR SdcExceptionSyn::SdcExceptionSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.child_)*/nullptr
  , /*decltype(_impl_.type_)*/0u} {}
struct SdcExceptionSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcExceptionSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcExceptionSynDefaultTypeInternal() {}
  union {
    SdcExceptionSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcExceptionSynDefaultTypeInternal _SdcExceptionSyn_default_instance_;
PROTOBUF_CONSTEXPR SdcCommandObjSyn::SdcCommandObjSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.scos_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SdcCommandObjSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcCommandObjSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcCommandObjSynDefaultTypeInternal() {}
  union {
    SdcCommandObjSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcCommandObjSynDefaultTypeInternal _SdcCommandObjSyn_default_instance_;
PROTOBUF_CONSTEXPR SdcConstrainClass::SdcConstrainClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._sdc_clocks_)*/{}
  , /*decltype(_impl_._sdc_io_constraints_)*/{}
  , /*decltype(_impl_._sdc_timing_derates_)*/{}
  , /*decltype(_impl_._sdc_timing_drcs_)*/{}
  , /*decltype(_impl_._sdc_clock_latencys_)*/{}
  , /*decltype(_impl_._sdc_clock_uncertaintys_)*/{}
  , /*decltype(_impl_._sdc_clock_groups_)*/{}
  , /*decltype(_impl_._sdc_exceptions_)*/{}
  , /*decltype(_impl_._sdc_collections_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}} {}
struct SdcConstrainClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdcConstrainClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdcConstrainClassDefaultTypeInternal() {}
  union {
    SdcConstrainClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdcConstrainClassDefaultTypeInternal _SdcConstrainClass_default_instance_;
}  // namespace Sdc
static ::_pb::Metadata file_level_metadata_SdcConstrains_2eproto[26];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_SdcConstrains_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_SdcConstrains_2eproto = nullptr;

const uint32_t TableStruct_SdcConstrains_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjClass, _impl_._file_name_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjClass, _impl_._line_no_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainClass, _impl_._constrain_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetInputTransitionClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetInputTransitionClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetInputTransitionClass, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetInputTransitionClass, _impl_._objs_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetInputTransitionClass, _impl_._transition_value_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetIODelayClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetIODelayClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetIODelayClass, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetIODelayClass, _impl_._clock_name_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetIODelayClass, _impl_._delay_value_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetIODelayClass, _impl_._objs_),
  2,
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetLoadClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetLoadClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetLoadClass, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetLoadClass, _impl_._objs_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetLoadClass, _impl_._load_value_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcIOConstrainSyn, _impl_.siocs_),
  1,
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _impl_._clock_name_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _impl_._period_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _impl_._objs_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _impl_._edges_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _impl_._is_propagated_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockClass, _impl_._tracking_comment_),
  0,
  2,
  ~0u,
  ~0u,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcGenrateClockClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcGenrateClockClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcGenrateClockClass, _impl_._source_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockSyn, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockSyn, _impl_.child_),
  2,
  3,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcAllClocksClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcAllClocksClass, _impl_._clocks_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockGroupClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockGroupClass, _impl_._clock_group_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockGroupsClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockGroupsClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockGroupsClass, _impl_._clock_groups_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcClockGroupsClass, _impl_._group_name_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionTypeEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionTypeEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionTypeEnum, _impl_.ct_),
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionClass, _impl_.scte_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionClass, _impl_._collection_objs_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCollectionClass, _impl_._collection_obj_types_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDerateClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDerateClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDerateClass, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDerateClass, _impl_._derate_value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCClass, _impl_._drc_val_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCClass, _impl_._objs_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCClass, _impl_._obj_types_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetMaxTransitionClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetMaxTransitionClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetMaxTransitionClass, _impl_.type_),
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetMaxCapacitanceClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetMaxCapacitanceClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetMaxCapacitanceClass, _impl_.type_),
  0,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcTimingDRCSyn, _impl_.stdrcs_),
  1,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockLatencyClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockLatencyClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockLatencyClass, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockLatencyClass, _impl_._delay_value_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockLatencyClass, _impl_._objs_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockUncertaintyClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockUncertaintyClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockUncertaintyClass, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockUncertaintyClass, _impl_._uncertainty_value_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcSetClockUncertaintyClass, _impl_._objs_),
  1,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionClass, _impl_._prop_froms_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionClass, _impl_._prop_tos_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionClass, _impl_._prop_throughs_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcMulticyclePathClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcMulticyclePathClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcMulticyclePathClass, _impl_._path_multiplier_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcMulticyclePathClass, _impl_.type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionSyn, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcExceptionSyn, _impl_.child_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcCommandObjSyn, _impl_.scos_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_clocks_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_io_constraints_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_timing_derates_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_timing_drcs_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_clock_latencys_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_clock_uncertaintys_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_clock_groups_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_exceptions_),
  PROTOBUF_FIELD_OFFSET(::Sdc::SdcConstrainClass, _impl_._sdc_collections_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::Sdc::SdcCommandObjClass)},
  { 10, 17, -1, sizeof(::Sdc::SdcIOConstrainClass)},
  { 18, 27, -1, sizeof(::Sdc::SdcSetInputTransitionClass)},
  { 30, 40, -1, sizeof(::Sdc::SdcSetIODelayClass)},
  { 44, 53, -1, sizeof(::Sdc::SdcSetLoadClass)},
  { 56, 68, -1, sizeof(::Sdc::SdcIOConstrainSyn)},
  { 73, 85, -1, sizeof(::Sdc::SdcClockClass)},
  { 91, 98, -1, sizeof(::Sdc::SdcGenrateClockClass)},
  { 99, 109, -1, sizeof(::Sdc::SdcClockSyn)},
  { 113, -1, -1, sizeof(::Sdc::SdcAllClocksClass)},
  { 120, -1, -1, sizeof(::Sdc::SdcClockGroupClass)},
  { 127, 135, -1, sizeof(::Sdc::SdcClockGroupsClass)},
  { 137, 144, -1, sizeof(::Sdc::SdcCollectionTypeEnum)},
  { 145, 154, -1, sizeof(::Sdc::SdcCollectionClass)},
  { 157, 165, -1, sizeof(::Sdc::SdcTimingDerateClass)},
  { 167, 176, -1, sizeof(::Sdc::SdcTimingDRCClass)},
  { 179, 186, -1, sizeof(::Sdc::SdcSetMaxTransitionClass)},
  { 187, 194, -1, sizeof(::Sdc::SdcSetMaxCapacitanceClass)},
  { 195, 206, -1, sizeof(::Sdc::SdcTimingDRCSyn)},
  { 210, 219, -1, sizeof(::Sdc::SdcSetClockLatencyClass)},
  { 222, 231, -1, sizeof(::Sdc::SdcSetClockUncertaintyClass)},
  { 234, -1, -1, sizeof(::Sdc::SdcExceptionClass)},
  { 243, 251, -1, sizeof(::Sdc::SdcMulticyclePathClass)},
  { 253, 262, -1, sizeof(::Sdc::SdcExceptionSyn)},
  { 265, 285, -1, sizeof(::Sdc::SdcCommandObjSyn)},
  { 298, 314, -1, sizeof(::Sdc::SdcConstrainClass)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Sdc::_SdcCommandObjClass_default_instance_._instance,
  &::Sdc::_SdcIOConstrainClass_default_instance_._instance,
  &::Sdc::_SdcSetInputTransitionClass_default_instance_._instance,
  &::Sdc::_SdcSetIODelayClass_default_instance_._instance,
  &::Sdc::_SdcSetLoadClass_default_instance_._instance,
  &::Sdc::_SdcIOConstrainSyn_default_instance_._instance,
  &::Sdc::_SdcClockClass_default_instance_._instance,
  &::Sdc::_SdcGenrateClockClass_default_instance_._instance,
  &::Sdc::_SdcClockSyn_default_instance_._instance,
  &::Sdc::_SdcAllClocksClass_default_instance_._instance,
  &::Sdc::_SdcClockGroupClass_default_instance_._instance,
  &::Sdc::_SdcClockGroupsClass_default_instance_._instance,
  &::Sdc::_SdcCollectionTypeEnum_default_instance_._instance,
  &::Sdc::_SdcCollectionClass_default_instance_._instance,
  &::Sdc::_SdcTimingDerateClass_default_instance_._instance,
  &::Sdc::_SdcTimingDRCClass_default_instance_._instance,
  &::Sdc::_SdcSetMaxTransitionClass_default_instance_._instance,
  &::Sdc::_SdcSetMaxCapacitanceClass_default_instance_._instance,
  &::Sdc::_SdcTimingDRCSyn_default_instance_._instance,
  &::Sdc::_SdcSetClockLatencyClass_default_instance_._instance,
  &::Sdc::_SdcSetClockUncertaintyClass_default_instance_._instance,
  &::Sdc::_SdcExceptionClass_default_instance_._instance,
  &::Sdc::_SdcMulticyclePathClass_default_instance_._instance,
  &::Sdc::_SdcExceptionSyn_default_instance_._instance,
  &::Sdc::_SdcCommandObjSyn_default_instance_._instance,
  &::Sdc::_SdcConstrainClass_default_instance_._instance,
};

const char descriptor_table_protodef_SdcConstrains_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023SdcConstrains.proto\022\003Sdc\032\021CommonTypes."
  "proto\":\n\022SdcCommandObjClass\022\022\n\n_file_nam"
  "e\030\001 \002(\t\022\020\n\010_line_no\030\002 \002(\r\".\n\023SdcIOConstr"
  "ainClass\022\027\n\017_constrain_name\030\001 \002(\t\"T\n\032Sdc"
  "SetInputTransitionClass\022\014\n\004type\030\001 \002(\r\022\r\n"
  "\005_objs\030\002 \003(\004\022\031\n\021_transition_value\030\003 \002(\001\""
  "\\\n\022SdcSetIODelayClass\022\014\n\004type\030\001 \002(\r\022\023\n\013_"
  "clock_name\030\002 \002(\t\022\024\n\014_delay_value\030\003 \002(\001\022\r"
  "\n\005_objs\030\004 \003(\004\"C\n\017SdcSetLoadClass\022\014\n\004type"
  "\030\001 \002(\r\022\r\n\005_objs\030\002 \003(\004\022\023\n\013_load_value\030\003 \002"
  "(\001\"\327\001\n\021SdcIOConstrainSyn\022\014\n\004type\030\001 \002(\r\022("
  "\n\006parent\030\002 \002(\0132\030.Sdc.SdcIOConstrainClass"
  "\0220\n\005ssitc\030\003 \001(\0132\037.Sdc.SdcSetInputTransit"
  "ionClassH\000\022)\n\006ssiodc\030\004 \001(\0132\027.Sdc.SdcSetI"
  "ODelayClassH\000\022$\n\004sslc\030\005 \001(\0132\024.Sdc.SdcSet"
  "LoadClassH\000B\007\n\005siocs\"\207\001\n\rSdcClockClass\022\023"
  "\n\013_clock_name\030\001 \002(\t\022\017\n\007_period\030\002 \002(\001\022\r\n\005"
  "_objs\030\003 \003(\004\022\016\n\006_edges\030\004 \003(\001\022\026\n\016_is_propa"
  "gated\030\005 \002(\r\022\031\n\021_tracking_comment\030\006 \002(\t\","
  "\n\024SdcGenrateClockClass\022\024\n\014_source_name\030\001"
  " \002(\t\"u\n\013SdcClockSyn\022\n\n\002id\030\001 \002(\004\022\014\n\004type\030"
  "\002 \002(\r\022\"\n\006parent\030\003 \002(\0132\022.Sdc.SdcClockClas"
  "s\022(\n\005child\030\004 \001(\0132\031.Sdc.SdcGenrateClockCl"
  "ass\"$\n\021SdcAllClocksClass\022\017\n\007_clocks\030\001 \003("
  "\004\"*\n\022SdcClockGroupClass\022\024\n\014_clock_group\030"
  "\001 \003(\t\"Z\n\023SdcClockGroupsClass\022.\n\r_clock_g"
  "roups\030\001 \003(\0132\027.Sdc.SdcClockGroupClass\022\023\n\013"
  "_group_name\030\002 \002(\t\"\264\001\n\025SdcCollectionTypeE"
  "num\0225\n\002ct\030\001 \002(\0162).Sdc.SdcCollectionTypeE"
  "num.CollectionType\"d\n\016CollectionType\022\n\n\006"
  "kClock\020\000\022\010\n\004kPin\020\001\022\t\n\005kPort\020\002\022\t\n\005kInst\020\003"
  "\022\010\n\004kNet\020\004\022\014\n\010kNetlist\020\005\022\016\n\nkAllClocks\020\006"
  "\"w\n\022SdcCollectionClass\022(\n\004scte\030\001 \002(\0132\032.S"
  "dc.SdcCollectionTypeEnum\022\030\n\020_collection_"
  "objs\030\002 \003(\004\022\035\n\025_collection_obj_types\030\003 \003("
  "\r\";\n\024SdcTimingDerateClass\022\014\n\004type\030\001 \002(\r\022"
  "\025\n\r_derate_value\030\002 \002(\001\"H\n\021SdcTimingDRCCl"
  "ass\022\020\n\010_drc_val\030\001 \002(\001\022\r\n\005_objs\030\002 \003(\004\022\022\n\n"
  "_obj_types\030\003 \003(\r\"(\n\030SdcSetMaxTransitionC"
  "lass\022\014\n\004type\030\001 \002(\r\")\n\031SdcSetMaxCapacitan"
  "ceClass\022\014\n\004type\030\002 \002(\r\"\262\001\n\017SdcTimingDRCSy"
  "n\022\014\n\004type\030\001 \002(\r\022&\n\006parent\030\002 \002(\0132\026.Sdc.Sd"
  "cTimingDRCClass\022.\n\005ssntc\030\003 \001(\0132\035.Sdc.Sdc"
  "SetMaxTransitionClassH\000\022/\n\005ssncc\030\004 \001(\0132\036"
  ".Sdc.SdcSetMaxCapacitanceClassH\000B\010\n\006stdr"
  "cs\"L\n\027SdcSetClockLatencyClass\022\014\n\004type\030\001 "
  "\002(\r\022\024\n\014_delay_value\030\002 \002(\001\022\r\n\005_objs\030\003 \003(\004"
  "\"V\n\033SdcSetClockUncertaintyClass\022\014\n\004type\030"
  "\001 \002(\r\022\032\n\022_uncertainty_value\030\002 \002(\001\022\r\n\005_ob"
  "js\030\003 \003(\004\"m\n\021SdcExceptionClass\022\023\n\013_prop_f"
  "roms\030\001 \003(\t\022\021\n\t_prop_tos\030\002 \003(\t\0220\n\016_prop_t"
  "hroughs\030\003 \003(\0132\030.Common.Types.StringList\""
  "@\n\026SdcMulticyclePathClass\022\030\n\020_path_multi"
  "plier\030\001 \002(\005\022\014\n\004type\030\002 \002(\r\"s\n\017SdcExceptio"
  "nSyn\022\014\n\004type\030\001 \002(\r\022&\n\006parent\030\002 \002(\0132\026.Sdc"
  ".SdcExceptionClass\022*\n\005child\030\003 \001(\0132\033.Sdc."
  "SdcMulticyclePathClass\"\373\003\n\020SdcCommandObj"
  "Syn\022\n\n\002id\030\001 \002(\004\022\014\n\004type\030\002 \002(\r\022\'\n\006parent\030"
  "\003 \002(\0132\027.Sdc.SdcCommandObjClass\022\'\n\005siocs\030"
  "\004 \001(\0132\026.Sdc.SdcIOConstrainSynH\000\022\037\n\003scs\030\005"
  " \001(\0132\020.Sdc.SdcClockSynH\000\022&\n\004cacc\030\006 \001(\0132\026"
  ".Sdc.SdcAllClocksClassH\000\022(\n\004scgc\030\007 \001(\0132\030"
  ".Sdc.SdcClockGroupsClassH\000\022&\n\003scc\030\010 \001(\0132"
  "\027.Sdc.SdcCollectionClassH\000\022)\n\004stdc\030\t \001(\013"
  "2\031.Sdc.SdcTimingDerateClassH\000\022&\n\006stdrcs\030"
  "\n \001(\0132\024.Sdc.SdcTimingDRCSynH\000\022-\n\005ssclc\030\013"
  " \001(\0132\034.Sdc.SdcSetClockLatencyClassH\000\0221\n\005"
  "sscuc\030\014 \001(\0132 .Sdc.SdcSetClockUncertainty"
  "ClassH\000\022#\n\003ses\030\r \001(\0132\024.Sdc.SdcExceptionS"
  "ynH\000B\006\n\004scos\"\257\002\n\021SdcConstrainClass\022\n\n\002id"
  "\030\001 \002(\004\022.\n\013_sdc_clocks\030\002 \003(\0132\031.Common.Typ"
  "es.StrULongMap\022\033\n\023_sdc_io_constraints\030\003 "
  "\003(\004\022\033\n\023_sdc_timing_derates\030\004 \003(\004\022\030\n\020_sdc"
  "_timing_drcs\030\005 \003(\004\022\033\n\023_sdc_clock_latency"
  "s\030\006 \003(\004\022\037\n\027_sdc_clock_uncertaintys\030\007 \003(\004"
  "\022\031\n\021_sdc_clock_groups\030\010 \003(\004\022\027\n\017_sdc_exce"
  "ptions\030\t \003(\004\022\030\n\020_sdc_collections\030\n \003(\004"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_SdcConstrains_2eproto_deps[1] = {
  &::descriptor_table_CommonTypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_SdcConstrains_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_SdcConstrains_2eproto = {
    false, false, 3078, descriptor_table_protodef_SdcConstrains_2eproto,
    "SdcConstrains.proto",
    &descriptor_table_SdcConstrains_2eproto_once, descriptor_table_SdcConstrains_2eproto_deps, 1, 26,
    schemas, file_default_instances, TableStruct_SdcConstrains_2eproto::offsets,
    file_level_metadata_SdcConstrains_2eproto, file_level_enum_descriptors_SdcConstrains_2eproto,
    file_level_service_descriptors_SdcConstrains_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_SdcConstrains_2eproto_getter() {
  return &descriptor_table_SdcConstrains_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_SdcConstrains_2eproto(&descriptor_table_SdcConstrains_2eproto);
namespace Sdc {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SdcCollectionTypeEnum_CollectionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_SdcConstrains_2eproto);
  return file_level_enum_descriptors_SdcConstrains_2eproto[0];
}
bool SdcCollectionTypeEnum_CollectionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::kClock;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::kPin;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::kPort;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::kInst;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::kNet;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::kNetlist;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::kAllClocks;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::CollectionType_MIN;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::CollectionType_MAX;
constexpr int SdcCollectionTypeEnum::CollectionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SdcCommandObjClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcCommandObjClass>()._impl_._has_bits_);
  static void set_has__file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__line_no(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SdcCommandObjClass::SdcCommandObjClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcCommandObjClass)
}
SdcCommandObjClass::SdcCommandObjClass(const SdcCommandObjClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcCommandObjClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_._line_no_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__file_name()) {
    _this->_impl_._file_name_.Set(from._internal__file_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_._line_no_ = from._impl_._line_no_;
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcCommandObjClass)
}

inline void SdcCommandObjClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._file_name_){}
    , decltype(_impl_._line_no_){0u}
  };
  _impl_._file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SdcCommandObjClass::~SdcCommandObjClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcCommandObjClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcCommandObjClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._file_name_.Destroy();
}

void SdcCommandObjClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcCommandObjClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcCommandObjClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._file_name_.ClearNonDefaultToEmpty();
  }
  _impl_._line_no_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcCommandObjClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _file_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Sdc.SdcCommandObjClass._file_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 _line_no = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__line_no(&has_bits);
          _impl_._line_no_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcCommandObjClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcCommandObjClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _file_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__file_name().data(), static_cast<int>(this->_internal__file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcCommandObjClass._file_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__file_name(), target);
  }

  // required uint32 _line_no = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal__line_no(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcCommandObjClass)
  return target;
}

size_t SdcCommandObjClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcCommandObjClass)
  size_t total_size = 0;

  if (_internal_has__file_name()) {
    // required string _file_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());
  }

  if (_internal_has__line_no()) {
    // required uint32 _line_no = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__line_no());
  }

  return total_size;
}
size_t SdcCommandObjClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcCommandObjClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string _file_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__file_name());

    // required uint32 _line_no = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__line_no());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcCommandObjClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcCommandObjClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcCommandObjClass::GetClassData() const { return &_class_data_; }


void SdcCommandObjClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcCommandObjClass*>(&to_msg);
  auto& from = static_cast<const SdcCommandObjClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcCommandObjClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__file_name(from._internal__file_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._line_no_ = from._impl_._line_no_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcCommandObjClass::CopyFrom(const SdcCommandObjClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcCommandObjClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcCommandObjClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcCommandObjClass::InternalSwap(SdcCommandObjClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._file_name_, lhs_arena,
      &other->_impl_._file_name_, rhs_arena
  );
  swap(_impl_._line_no_, other->_impl_._line_no_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcCommandObjClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[0]);
}

// ===================================================================

class SdcIOConstrainClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcIOConstrainClass>()._impl_._has_bits_);
  static void set_has__constrain_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdcIOConstrainClass::SdcIOConstrainClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcIOConstrainClass)
}
SdcIOConstrainClass::SdcIOConstrainClass(const SdcIOConstrainClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcIOConstrainClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._constrain_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._constrain_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._constrain_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__constrain_name()) {
    _this->_impl_._constrain_name_.Set(from._internal__constrain_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcIOConstrainClass)
}

inline void SdcIOConstrainClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._constrain_name_){}
  };
  _impl_._constrain_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._constrain_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SdcIOConstrainClass::~SdcIOConstrainClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcIOConstrainClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcIOConstrainClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._constrain_name_.Destroy();
}

void SdcIOConstrainClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcIOConstrainClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcIOConstrainClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._constrain_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcIOConstrainClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _constrain_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__constrain_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Sdc.SdcIOConstrainClass._constrain_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcIOConstrainClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcIOConstrainClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _constrain_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__constrain_name().data(), static_cast<int>(this->_internal__constrain_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcIOConstrainClass._constrain_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__constrain_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcIOConstrainClass)
  return target;
}

size_t SdcIOConstrainClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcIOConstrainClass)
  size_t total_size = 0;

  // required string _constrain_name = 1;
  if (_internal_has__constrain_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__constrain_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcIOConstrainClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcIOConstrainClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcIOConstrainClass::GetClassData() const { return &_class_data_; }


void SdcIOConstrainClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcIOConstrainClass*>(&to_msg);
  auto& from = static_cast<const SdcIOConstrainClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcIOConstrainClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__constrain_name()) {
    _this->_internal_set__constrain_name(from._internal__constrain_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcIOConstrainClass::CopyFrom(const SdcIOConstrainClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcIOConstrainClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcIOConstrainClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcIOConstrainClass::InternalSwap(SdcIOConstrainClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._constrain_name_, lhs_arena,
      &other->_impl_._constrain_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcIOConstrainClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[1]);
}

// ===================================================================

class SdcSetInputTransitionClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcSetInputTransitionClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__transition_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SdcSetInputTransitionClass::SdcSetInputTransitionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcSetInputTransitionClass)
}
SdcSetInputTransitionClass::SdcSetInputTransitionClass(const SdcSetInputTransitionClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcSetInputTransitionClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){from._impl_._objs_}
    , decltype(_impl_._transition_value_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._transition_value_, &from._impl_._transition_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_._transition_value_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcSetInputTransitionClass)
}

inline void SdcSetInputTransitionClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){arena}
    , decltype(_impl_._transition_value_){0}
    , decltype(_impl_.type_){0u}
  };
}

SdcSetInputTransitionClass::~SdcSetInputTransitionClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcSetInputTransitionClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcSetInputTransitionClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._objs_.~RepeatedField();
}

void SdcSetInputTransitionClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcSetInputTransitionClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcSetInputTransitionClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._objs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._transition_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_._transition_value_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcSetInputTransitionClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _objs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double _transition_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has__transition_value(&has_bits);
          _impl_._transition_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcSetInputTransitionClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcSetInputTransitionClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // repeated uint64 _objs = 2;
  for (int i = 0, n = this->_internal__objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__objs(i), target);
  }

  // required double _transition_value = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal__transition_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcSetInputTransitionClass)
  return target;
}

size_t SdcSetInputTransitionClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcSetInputTransitionClass)
  size_t total_size = 0;

  if (_internal_has__transition_value()) {
    // required double _transition_value = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcSetInputTransitionClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcSetInputTransitionClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double _transition_value = 3;
    total_size += 1 + 8;

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _objs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__objs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcSetInputTransitionClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcSetInputTransitionClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcSetInputTransitionClass::GetClassData() const { return &_class_data_; }


void SdcSetInputTransitionClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcSetInputTransitionClass*>(&to_msg);
  auto& from = static_cast<const SdcSetInputTransitionClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcSetInputTransitionClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._objs_.MergeFrom(from._impl_._objs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._transition_value_ = from._impl_._transition_value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcSetInputTransitionClass::CopyFrom(const SdcSetInputTransitionClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcSetInputTransitionClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcSetInputTransitionClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcSetInputTransitionClass::InternalSwap(SdcSetInputTransitionClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._objs_.InternalSwap(&other->_impl_._objs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcSetInputTransitionClass, _impl_.type_)
      + sizeof(SdcSetInputTransitionClass::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcSetInputTransitionClass, _impl_._transition_value_)>(
          reinterpret_cast<char*>(&_impl_._transition_value_),
          reinterpret_cast<char*>(&other->_impl_._transition_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcSetInputTransitionClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[2]);
}

// ===================================================================

class SdcSetIODelayClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcSetIODelayClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__clock_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__delay_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

SdcSetIODelayClass::SdcSetIODelayClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcSetIODelayClass)
}
SdcSetIODelayClass::SdcSetIODelayClass(const SdcSetIODelayClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcSetIODelayClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){from._impl_._objs_}
    , decltype(_impl_._clock_name_){}
    , decltype(_impl_._delay_value_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._clock_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__clock_name()) {
    _this->_impl_._clock_name_.Set(from._internal__clock_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._delay_value_, &from._impl_._delay_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_._delay_value_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcSetIODelayClass)
}

inline void SdcSetIODelayClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){arena}
    , decltype(_impl_._clock_name_){}
    , decltype(_impl_._delay_value_){0}
    , decltype(_impl_.type_){0u}
  };
  _impl_._clock_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SdcSetIODelayClass::~SdcSetIODelayClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcSetIODelayClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcSetIODelayClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._objs_.~RepeatedField();
  _impl_._clock_name_.Destroy();
}

void SdcSetIODelayClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcSetIODelayClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcSetIODelayClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._objs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._clock_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_._delay_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_._delay_value_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcSetIODelayClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _clock_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__clock_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Sdc.SdcSetIODelayClass._clock_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required double _delay_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has__delay_value(&has_bits);
          _impl_._delay_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _objs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcSetIODelayClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcSetIODelayClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required string _clock_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__clock_name().data(), static_cast<int>(this->_internal__clock_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcSetIODelayClass._clock_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__clock_name(), target);
  }

  // required double _delay_value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal__delay_value(), target);
  }

  // repeated uint64 _objs = 4;
  for (int i = 0, n = this->_internal__objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__objs(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcSetIODelayClass)
  return target;
}

size_t SdcSetIODelayClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcSetIODelayClass)
  size_t total_size = 0;

  if (_internal_has__clock_name()) {
    // required string _clock_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__clock_name());
  }

  if (_internal_has__delay_value()) {
    // required double _delay_value = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcSetIODelayClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcSetIODelayClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string _clock_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__clock_name());

    // required double _delay_value = 3;
    total_size += 1 + 8;

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _objs = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__objs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcSetIODelayClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcSetIODelayClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcSetIODelayClass::GetClassData() const { return &_class_data_; }


void SdcSetIODelayClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcSetIODelayClass*>(&to_msg);
  auto& from = static_cast<const SdcSetIODelayClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcSetIODelayClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._objs_.MergeFrom(from._impl_._objs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__clock_name(from._internal__clock_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._delay_value_ = from._impl_._delay_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcSetIODelayClass::CopyFrom(const SdcSetIODelayClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcSetIODelayClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcSetIODelayClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcSetIODelayClass::InternalSwap(SdcSetIODelayClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._objs_.InternalSwap(&other->_impl_._objs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._clock_name_, lhs_arena,
      &other->_impl_._clock_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcSetIODelayClass, _impl_.type_)
      + sizeof(SdcSetIODelayClass::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcSetIODelayClass, _impl_._delay_value_)>(
          reinterpret_cast<char*>(&_impl_._delay_value_),
          reinterpret_cast<char*>(&other->_impl_._delay_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcSetIODelayClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[3]);
}

// ===================================================================

class SdcSetLoadClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcSetLoadClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__load_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SdcSetLoadClass::SdcSetLoadClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcSetLoadClass)
}
SdcSetLoadClass::SdcSetLoadClass(const SdcSetLoadClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcSetLoadClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){from._impl_._objs_}
    , decltype(_impl_._load_value_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._load_value_, &from._impl_._load_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_._load_value_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcSetLoadClass)
}

inline void SdcSetLoadClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){arena}
    , decltype(_impl_._load_value_){0}
    , decltype(_impl_.type_){0u}
  };
}

SdcSetLoadClass::~SdcSetLoadClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcSetLoadClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcSetLoadClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._objs_.~RepeatedField();
}

void SdcSetLoadClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcSetLoadClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcSetLoadClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._objs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._load_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_._load_value_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcSetLoadClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _objs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double _load_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has__load_value(&has_bits);
          _impl_._load_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcSetLoadClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcSetLoadClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // repeated uint64 _objs = 2;
  for (int i = 0, n = this->_internal__objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__objs(i), target);
  }

  // required double _load_value = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal__load_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcSetLoadClass)
  return target;
}

size_t SdcSetLoadClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcSetLoadClass)
  size_t total_size = 0;

  if (_internal_has__load_value()) {
    // required double _load_value = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcSetLoadClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcSetLoadClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double _load_value = 3;
    total_size += 1 + 8;

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _objs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__objs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcSetLoadClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcSetLoadClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcSetLoadClass::GetClassData() const { return &_class_data_; }


void SdcSetLoadClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcSetLoadClass*>(&to_msg);
  auto& from = static_cast<const SdcSetLoadClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcSetLoadClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._objs_.MergeFrom(from._impl_._objs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._load_value_ = from._impl_._load_value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcSetLoadClass::CopyFrom(const SdcSetLoadClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcSetLoadClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcSetLoadClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcSetLoadClass::InternalSwap(SdcSetLoadClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._objs_.InternalSwap(&other->_impl_._objs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcSetLoadClass, _impl_.type_)
      + sizeof(SdcSetLoadClass::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcSetLoadClass, _impl_._load_value_)>(
          reinterpret_cast<char*>(&_impl_._load_value_),
          reinterpret_cast<char*>(&other->_impl_._load_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcSetLoadClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[4]);
}

// ===================================================================

class SdcIOConstrainSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcIOConstrainSyn>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Sdc::SdcIOConstrainClass& parent(const SdcIOConstrainSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Sdc::SdcSetInputTransitionClass& ssitc(const SdcIOConstrainSyn* msg);
  static const ::Sdc::SdcSetIODelayClass& ssiodc(const SdcIOConstrainSyn* msg);
  static const ::Sdc::SdcSetLoadClass& sslc(const SdcIOConstrainSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::Sdc::SdcIOConstrainClass&
SdcIOConstrainSyn::_Internal::parent(const SdcIOConstrainSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Sdc::SdcSetInputTransitionClass&
SdcIOConstrainSyn::_Internal::ssitc(const SdcIOConstrainSyn* msg) {
  return *msg->_impl_.siocs_.ssitc_;
}
const ::Sdc::SdcSetIODelayClass&
SdcIOConstrainSyn::_Internal::ssiodc(const SdcIOConstrainSyn* msg) {
  return *msg->_impl_.siocs_.ssiodc_;
}
const ::Sdc::SdcSetLoadClass&
SdcIOConstrainSyn::_Internal::sslc(const SdcIOConstrainSyn* msg) {
  return *msg->_impl_.siocs_.sslc_;
}
void SdcIOConstrainSyn::set_allocated_ssitc(::Sdc::SdcSetInputTransitionClass* ssitc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_siocs();
  if (ssitc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssitc);
    if (message_arena != submessage_arena) {
      ssitc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssitc, submessage_arena);
    }
    set_has_ssitc();
    _impl_.siocs_.ssitc_ = ssitc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcIOConstrainSyn.ssitc)
}
void SdcIOConstrainSyn::set_allocated_ssiodc(::Sdc::SdcSetIODelayClass* ssiodc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_siocs();
  if (ssiodc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssiodc);
    if (message_arena != submessage_arena) {
      ssiodc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssiodc, submessage_arena);
    }
    set_has_ssiodc();
    _impl_.siocs_.ssiodc_ = ssiodc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcIOConstrainSyn.ssiodc)
}
void SdcIOConstrainSyn::set_allocated_sslc(::Sdc::SdcSetLoadClass* sslc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_siocs();
  if (sslc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sslc);
    if (message_arena != submessage_arena) {
      sslc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sslc, submessage_arena);
    }
    set_has_sslc();
    _impl_.siocs_.sslc_ = sslc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcIOConstrainSyn.sslc)
}
SdcIOConstrainSyn::SdcIOConstrainSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcIOConstrainSyn)
}
SdcIOConstrainSyn::SdcIOConstrainSyn(const SdcIOConstrainSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcIOConstrainSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.siocs_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Sdc::SdcIOConstrainClass(*from._impl_.parent_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  clear_has_siocs();
  switch (from.siocs_case()) {
    case kSsitc: {
      _this->_internal_mutable_ssitc()->::Sdc::SdcSetInputTransitionClass::MergeFrom(
          from._internal_ssitc());
      break;
    }
    case kSsiodc: {
      _this->_internal_mutable_ssiodc()->::Sdc::SdcSetIODelayClass::MergeFrom(
          from._internal_ssiodc());
      break;
    }
    case kSslc: {
      _this->_internal_mutable_sslc()->::Sdc::SdcSetLoadClass::MergeFrom(
          from._internal_sslc());
      break;
    }
    case SIOCS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcIOConstrainSyn)
}

inline void SdcIOConstrainSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.siocs_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_siocs();
}

SdcIOConstrainSyn::~SdcIOConstrainSyn() {
  // @@protoc_insertion_point(destructor:Sdc.SdcIOConstrainSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcIOConstrainSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_siocs()) {
    clear_siocs();
  }
}

void SdcIOConstrainSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcIOConstrainSyn::clear_siocs() {
// @@protoc_insertion_point(one_of_clear_start:Sdc.SdcIOConstrainSyn)
  switch (siocs_case()) {
    case kSsitc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.siocs_.ssitc_;
      }
      break;
    }
    case kSsiodc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.siocs_.ssiodc_;
      }
      break;
    }
    case kSslc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.siocs_.sslc_;
      }
      break;
    }
    case SIOCS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SIOCS_NOT_SET;
}


void SdcIOConstrainSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcIOConstrainSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  _impl_.type_ = 0u;
  clear_siocs();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcIOConstrainSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Sdc.SdcIOConstrainClass parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcSetInputTransitionClass ssitc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ssitc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcSetIODelayClass ssiodc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ssiodc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcSetLoadClass sslc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_sslc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcIOConstrainSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcIOConstrainSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required .Sdc.SdcIOConstrainClass parent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (siocs_case()) {
    case kSsitc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::ssitc(this),
          _Internal::ssitc(this).GetCachedSize(), target, stream);
      break;
    }
    case kSsiodc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::ssiodc(this),
          _Internal::ssiodc(this).GetCachedSize(), target, stream);
      break;
    }
    case kSslc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::sslc(this),
          _Internal::sslc(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcIOConstrainSyn)
  return target;
}

size_t SdcIOConstrainSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcIOConstrainSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Sdc.SdcIOConstrainClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcIOConstrainSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcIOConstrainSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .Sdc.SdcIOConstrainClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (siocs_case()) {
    // .Sdc.SdcSetInputTransitionClass ssitc = 3;
    case kSsitc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.siocs_.ssitc_);
      break;
    }
    // .Sdc.SdcSetIODelayClass ssiodc = 4;
    case kSsiodc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.siocs_.ssiodc_);
      break;
    }
    // .Sdc.SdcSetLoadClass sslc = 5;
    case kSslc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.siocs_.sslc_);
      break;
    }
    case SIOCS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcIOConstrainSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcIOConstrainSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcIOConstrainSyn::GetClassData() const { return &_class_data_; }


void SdcIOConstrainSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcIOConstrainSyn*>(&to_msg);
  auto& from = static_cast<const SdcIOConstrainSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcIOConstrainSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Sdc::SdcIOConstrainClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.siocs_case()) {
    case kSsitc: {
      _this->_internal_mutable_ssitc()->::Sdc::SdcSetInputTransitionClass::MergeFrom(
          from._internal_ssitc());
      break;
    }
    case kSsiodc: {
      _this->_internal_mutable_ssiodc()->::Sdc::SdcSetIODelayClass::MergeFrom(
          from._internal_ssiodc());
      break;
    }
    case kSslc: {
      _this->_internal_mutable_sslc()->::Sdc::SdcSetLoadClass::MergeFrom(
          from._internal_sslc());
      break;
    }
    case SIOCS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcIOConstrainSyn::CopyFrom(const SdcIOConstrainSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcIOConstrainSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcIOConstrainSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (siocs_case()) {
    case kSsitc: {
      if (_internal_has_ssitc()) {
        if (!_impl_.siocs_.ssitc_->IsInitialized()) return false;
      }
      break;
    }
    case kSsiodc: {
      if (_internal_has_ssiodc()) {
        if (!_impl_.siocs_.ssiodc_->IsInitialized()) return false;
      }
      break;
    }
    case kSslc: {
      if (_internal_has_sslc()) {
        if (!_impl_.siocs_.sslc_->IsInitialized()) return false;
      }
      break;
    }
    case SIOCS_NOT_SET: {
      break;
    }
  }
  return true;
}

void SdcIOConstrainSyn::InternalSwap(SdcIOConstrainSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcIOConstrainSyn, _impl_.type_)
      + sizeof(SdcIOConstrainSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcIOConstrainSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.siocs_, other->_impl_.siocs_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcIOConstrainSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[5]);
}

// ===================================================================

class SdcClockClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcClockClass>()._impl_._has_bits_);
  static void set_has__clock_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__period(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__is_propagated(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__tracking_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

SdcClockClass::SdcClockClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcClockClass)
}
SdcClockClass::SdcClockClass(const SdcClockClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcClockClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){from._impl_._objs_}
    , decltype(_impl_._edges_){from._impl_._edges_}
    , decltype(_impl_._clock_name_){}
    , decltype(_impl_._tracking_comment_){}
    , decltype(_impl_._period_){}
    , decltype(_impl_._is_propagated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._clock_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__clock_name()) {
    _this->_impl_._clock_name_.Set(from._internal__clock_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_._tracking_comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._tracking_comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__tracking_comment()) {
    _this->_impl_._tracking_comment_.Set(from._internal__tracking_comment(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._period_, &from._impl_._period_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._is_propagated_) -
    reinterpret_cast<char*>(&_impl_._period_)) + sizeof(_impl_._is_propagated_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcClockClass)
}

inline void SdcClockClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){arena}
    , decltype(_impl_._edges_){arena}
    , decltype(_impl_._clock_name_){}
    , decltype(_impl_._tracking_comment_){}
    , decltype(_impl_._period_){0}
    , decltype(_impl_._is_propagated_){0u}
  };
  _impl_._clock_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_._tracking_comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._tracking_comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SdcClockClass::~SdcClockClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcClockClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcClockClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._objs_.~RepeatedField();
  _impl_._edges_.~RepeatedField();
  _impl_._clock_name_.Destroy();
  _impl_._tracking_comment_.Destroy();
}

void SdcClockClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcClockClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcClockClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._objs_.Clear();
  _impl_._edges_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._clock_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_._tracking_comment_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_._period_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._is_propagated_) -
        reinterpret_cast<char*>(&_impl_._period_)) + sizeof(_impl_._is_propagated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcClockClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _clock_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__clock_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Sdc.SdcClockClass._clock_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required double _period = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has__period(&has_bits);
          _impl_._period_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _objs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double _edges = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__edges(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<33>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable__edges(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _is_propagated = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__is_propagated(&has_bits);
          _impl_._is_propagated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _tracking_comment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable__tracking_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Sdc.SdcClockClass._tracking_comment");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcClockClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcClockClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _clock_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__clock_name().data(), static_cast<int>(this->_internal__clock_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcClockClass._clock_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__clock_name(), target);
  }

  // required double _period = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal__period(), target);
  }

  // repeated uint64 _objs = 3;
  for (int i = 0, n = this->_internal__objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__objs(i), target);
  }

  // repeated double _edges = 4;
  for (int i = 0, n = this->_internal__edges_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal__edges(i), target);
  }

  // required uint32 _is_propagated = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal__is_propagated(), target);
  }

  // required string _tracking_comment = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__tracking_comment().data(), static_cast<int>(this->_internal__tracking_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcClockClass._tracking_comment");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal__tracking_comment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcClockClass)
  return target;
}

size_t SdcClockClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcClockClass)
  size_t total_size = 0;

  if (_internal_has__clock_name()) {
    // required string _clock_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__clock_name());
  }

  if (_internal_has__tracking_comment()) {
    // required string _tracking_comment = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__tracking_comment());
  }

  if (_internal_has__period()) {
    // required double _period = 2;
    total_size += 1 + 8;
  }

  if (_internal_has__is_propagated()) {
    // required uint32 _is_propagated = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__is_propagated());
  }

  return total_size;
}
size_t SdcClockClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcClockClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string _clock_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__clock_name());

    // required string _tracking_comment = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__tracking_comment());

    // required double _period = 2;
    total_size += 1 + 8;

    // required uint32 _is_propagated = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__is_propagated());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _objs = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__objs_size());
    total_size += data_size;
  }

  // repeated double _edges = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal__edges_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__edges_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcClockClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcClockClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcClockClass::GetClassData() const { return &_class_data_; }


void SdcClockClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcClockClass*>(&to_msg);
  auto& from = static_cast<const SdcClockClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcClockClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._objs_.MergeFrom(from._impl_._objs_);
  _this->_impl_._edges_.MergeFrom(from._impl_._edges_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__clock_name(from._internal__clock_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set__tracking_comment(from._internal__tracking_comment());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._period_ = from._impl_._period_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._is_propagated_ = from._impl_._is_propagated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcClockClass::CopyFrom(const SdcClockClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcClockClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcClockClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcClockClass::InternalSwap(SdcClockClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._objs_.InternalSwap(&other->_impl_._objs_);
  _impl_._edges_.InternalSwap(&other->_impl_._edges_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._clock_name_, lhs_arena,
      &other->_impl_._clock_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._tracking_comment_, lhs_arena,
      &other->_impl_._tracking_comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcClockClass, _impl_._is_propagated_)
      + sizeof(SdcClockClass::_impl_._is_propagated_)
      - PROTOBUF_FIELD_OFFSET(SdcClockClass, _impl_._period_)>(
          reinterpret_cast<char*>(&_impl_._period_),
          reinterpret_cast<char*>(&other->_impl_._period_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcClockClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[6]);
}

// ===================================================================

class SdcGenrateClockClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcGenrateClockClass>()._impl_._has_bits_);
  static void set_has__source_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdcGenrateClockClass::SdcGenrateClockClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcGenrateClockClass)
}
SdcGenrateClockClass::SdcGenrateClockClass(const SdcGenrateClockClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcGenrateClockClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._source_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._source_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._source_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__source_name()) {
    _this->_impl_._source_name_.Set(from._internal__source_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcGenrateClockClass)
}

inline void SdcGenrateClockClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._source_name_){}
  };
  _impl_._source_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._source_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SdcGenrateClockClass::~SdcGenrateClockClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcGenrateClockClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcGenrateClockClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._source_name_.Destroy();
}

void SdcGenrateClockClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcGenrateClockClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcGenrateClockClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._source_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcGenrateClockClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string _source_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable__source_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Sdc.SdcGenrateClockClass._source_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcGenrateClockClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcGenrateClockClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string _source_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__source_name().data(), static_cast<int>(this->_internal__source_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcGenrateClockClass._source_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal__source_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcGenrateClockClass)
  return target;
}

size_t SdcGenrateClockClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcGenrateClockClass)
  size_t total_size = 0;

  // required string _source_name = 1;
  if (_internal_has__source_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__source_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcGenrateClockClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcGenrateClockClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcGenrateClockClass::GetClassData() const { return &_class_data_; }


void SdcGenrateClockClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcGenrateClockClass*>(&to_msg);
  auto& from = static_cast<const SdcGenrateClockClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcGenrateClockClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__source_name()) {
    _this->_internal_set__source_name(from._internal__source_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcGenrateClockClass::CopyFrom(const SdcGenrateClockClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcGenrateClockClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcGenrateClockClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcGenrateClockClass::InternalSwap(SdcGenrateClockClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._source_name_, lhs_arena,
      &other->_impl_._source_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcGenrateClockClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[7]);
}

// ===================================================================

class SdcClockSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcClockSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::Sdc::SdcClockClass& parent(const SdcClockSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Sdc::SdcGenrateClockClass& child(const SdcClockSyn* msg);
  static void set_has_child(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000d) ^ 0x0000000d) != 0;
  }
};

const ::Sdc::SdcClockClass&
SdcClockSyn::_Internal::parent(const SdcClockSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Sdc::SdcGenrateClockClass&
SdcClockSyn::_Internal::child(const SdcClockSyn* msg) {
  return *msg->_impl_.child_;
}
SdcClockSyn::SdcClockSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcClockSyn)
}
SdcClockSyn::SdcClockSyn(const SdcClockSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcClockSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.child_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Sdc::SdcClockClass(*from._impl_.parent_);
  }
  if (from._internal_has_child()) {
    _this->_impl_.child_ = new ::Sdc::SdcGenrateClockClass(*from._impl_.child_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcClockSyn)
}

inline void SdcClockSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.child_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
  };
}

SdcClockSyn::~SdcClockSyn() {
  // @@protoc_insertion_point(destructor:Sdc.SdcClockSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcClockSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.child_;
}

void SdcClockSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcClockSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcClockSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.child_ != nullptr);
      _impl_.child_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcClockSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Sdc.SdcClockClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Sdc.SdcGenrateClockClass child = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_child(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcClockSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcClockSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  // required .Sdc.SdcClockClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .Sdc.SdcGenrateClockClass child = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::child(this),
        _Internal::child(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcClockSyn)
  return target;
}

size_t SdcClockSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcClockSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Sdc.SdcClockClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_type()) {
    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcClockSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcClockSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000d) ^ 0x0000000d) == 0) {  // All required fields are present.
    // required .Sdc.SdcClockClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Sdc.SdcGenrateClockClass child = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.child_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcClockSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcClockSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcClockSyn::GetClassData() const { return &_class_data_; }


void SdcClockSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcClockSyn*>(&to_msg);
  auto& from = static_cast<const SdcClockSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcClockSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Sdc::SdcClockClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_child()->::Sdc::SdcGenrateClockClass::MergeFrom(
          from._internal_child());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcClockSyn::CopyFrom(const SdcClockSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcClockSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcClockSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  if (_internal_has_child()) {
    if (!_impl_.child_->IsInitialized()) return false;
  }
  return true;
}

void SdcClockSyn::InternalSwap(SdcClockSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcClockSyn, _impl_.type_)
      + sizeof(SdcClockSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcClockSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcClockSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[8]);
}

// ===================================================================

class SdcAllClocksClass::_Internal {
 public:
};

SdcAllClocksClass::SdcAllClocksClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcAllClocksClass)
}
SdcAllClocksClass::SdcAllClocksClass(const SdcAllClocksClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcAllClocksClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._clocks_){from._impl_._clocks_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcAllClocksClass)
}

inline void SdcAllClocksClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._clocks_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SdcAllClocksClass::~SdcAllClocksClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcAllClocksClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcAllClocksClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._clocks_.~RepeatedField();
}

void SdcAllClocksClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcAllClocksClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcAllClocksClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._clocks_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcAllClocksClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 _clocks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__clocks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__clocks(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcAllClocksClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcAllClocksClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 _clocks = 1;
  for (int i = 0, n = this->_internal__clocks_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__clocks(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcAllClocksClass)
  return target;
}

size_t SdcAllClocksClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcAllClocksClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _clocks = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._clocks_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__clocks_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcAllClocksClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcAllClocksClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcAllClocksClass::GetClassData() const { return &_class_data_; }


void SdcAllClocksClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcAllClocksClass*>(&to_msg);
  auto& from = static_cast<const SdcAllClocksClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcAllClocksClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._clocks_.MergeFrom(from._impl_._clocks_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcAllClocksClass::CopyFrom(const SdcAllClocksClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcAllClocksClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcAllClocksClass::IsInitialized() const {
  return true;
}

void SdcAllClocksClass::InternalSwap(SdcAllClocksClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._clocks_.InternalSwap(&other->_impl_._clocks_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcAllClocksClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[9]);
}

// ===================================================================

class SdcClockGroupClass::_Internal {
 public:
};

SdcClockGroupClass::SdcClockGroupClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcClockGroupClass)
}
SdcClockGroupClass::SdcClockGroupClass(const SdcClockGroupClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcClockGroupClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._clock_group_){from._impl_._clock_group_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcClockGroupClass)
}

inline void SdcClockGroupClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._clock_group_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SdcClockGroupClass::~SdcClockGroupClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcClockGroupClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcClockGroupClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._clock_group_.~RepeatedPtrField();
}

void SdcClockGroupClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcClockGroupClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcClockGroupClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._clock_group_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcClockGroupClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string _clock_group = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add__clock_group();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "Sdc.SdcClockGroupClass._clock_group");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcClockGroupClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcClockGroupClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string _clock_group = 1;
  for (int i = 0, n = this->_internal__clock_group_size(); i < n; i++) {
    const auto& s = this->_internal__clock_group(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcClockGroupClass._clock_group");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcClockGroupClass)
  return target;
}

size_t SdcClockGroupClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcClockGroupClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string _clock_group = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_._clock_group_.size());
  for (int i = 0, n = _impl_._clock_group_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_._clock_group_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcClockGroupClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcClockGroupClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcClockGroupClass::GetClassData() const { return &_class_data_; }


void SdcClockGroupClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcClockGroupClass*>(&to_msg);
  auto& from = static_cast<const SdcClockGroupClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcClockGroupClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._clock_group_.MergeFrom(from._impl_._clock_group_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcClockGroupClass::CopyFrom(const SdcClockGroupClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcClockGroupClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcClockGroupClass::IsInitialized() const {
  return true;
}

void SdcClockGroupClass::InternalSwap(SdcClockGroupClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._clock_group_.InternalSwap(&other->_impl_._clock_group_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcClockGroupClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[10]);
}

// ===================================================================

class SdcClockGroupsClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcClockGroupsClass>()._impl_._has_bits_);
  static void set_has__group_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdcClockGroupsClass::SdcClockGroupsClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcClockGroupsClass)
}
SdcClockGroupsClass::SdcClockGroupsClass(const SdcClockGroupsClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcClockGroupsClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._clock_groups_){from._impl_._clock_groups_}
    , decltype(_impl_._group_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__group_name()) {
    _this->_impl_._group_name_.Set(from._internal__group_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcClockGroupsClass)
}

inline void SdcClockGroupsClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._clock_groups_){arena}
    , decltype(_impl_._group_name_){}
  };
  _impl_._group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SdcClockGroupsClass::~SdcClockGroupsClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcClockGroupsClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcClockGroupsClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._clock_groups_.~RepeatedPtrField();
  _impl_._group_name_.Destroy();
}

void SdcClockGroupsClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcClockGroupsClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcClockGroupsClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._clock_groups_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_._group_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcClockGroupsClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Sdc.SdcClockGroupClass _clock_groups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__clock_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required string _group_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__group_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Sdc.SdcClockGroupsClass._group_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcClockGroupsClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcClockGroupsClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Sdc.SdcClockGroupClass _clock_groups = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__clock_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal__clock_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required string _group_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__group_name().data(), static_cast<int>(this->_internal__group_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcClockGroupsClass._group_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__group_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcClockGroupsClass)
  return target;
}

size_t SdcClockGroupsClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcClockGroupsClass)
  size_t total_size = 0;

  // required string _group_name = 2;
  if (_internal_has__group_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__group_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Sdc.SdcClockGroupClass _clock_groups = 1;
  total_size += 1UL * this->_internal__clock_groups_size();
  for (const auto& msg : this->_impl_._clock_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcClockGroupsClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcClockGroupsClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcClockGroupsClass::GetClassData() const { return &_class_data_; }


void SdcClockGroupsClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcClockGroupsClass*>(&to_msg);
  auto& from = static_cast<const SdcClockGroupsClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcClockGroupsClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._clock_groups_.MergeFrom(from._impl_._clock_groups_);
  if (from._internal_has__group_name()) {
    _this->_internal_set__group_name(from._internal__group_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcClockGroupsClass::CopyFrom(const SdcClockGroupsClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcClockGroupsClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcClockGroupsClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcClockGroupsClass::InternalSwap(SdcClockGroupsClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._clock_groups_.InternalSwap(&other->_impl_._clock_groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._group_name_, lhs_arena,
      &other->_impl_._group_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcClockGroupsClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[11]);
}

// ===================================================================

class SdcCollectionTypeEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcCollectionTypeEnum>()._impl_._has_bits_);
  static void set_has_ct(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdcCollectionTypeEnum::SdcCollectionTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcCollectionTypeEnum)
}
SdcCollectionTypeEnum::SdcCollectionTypeEnum(const SdcCollectionTypeEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcCollectionTypeEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ct_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ct_ = from._impl_.ct_;
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcCollectionTypeEnum)
}

inline void SdcCollectionTypeEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ct_){0}
  };
}

SdcCollectionTypeEnum::~SdcCollectionTypeEnum() {
  // @@protoc_insertion_point(destructor:Sdc.SdcCollectionTypeEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcCollectionTypeEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SdcCollectionTypeEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcCollectionTypeEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcCollectionTypeEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ct_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcCollectionTypeEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Sdc.SdcCollectionTypeEnum.CollectionType ct = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Sdc::SdcCollectionTypeEnum_CollectionType_IsValid(val))) {
            _internal_set_ct(static_cast<::Sdc::SdcCollectionTypeEnum_CollectionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcCollectionTypeEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcCollectionTypeEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Sdc.SdcCollectionTypeEnum.CollectionType ct = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ct(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcCollectionTypeEnum)
  return target;
}

size_t SdcCollectionTypeEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcCollectionTypeEnum)
  size_t total_size = 0;

  // required .Sdc.SdcCollectionTypeEnum.CollectionType ct = 1;
  if (_internal_has_ct()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_ct());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcCollectionTypeEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcCollectionTypeEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcCollectionTypeEnum::GetClassData() const { return &_class_data_; }


void SdcCollectionTypeEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcCollectionTypeEnum*>(&to_msg);
  auto& from = static_cast<const SdcCollectionTypeEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcCollectionTypeEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ct()) {
    _this->_internal_set_ct(from._internal_ct());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcCollectionTypeEnum::CopyFrom(const SdcCollectionTypeEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcCollectionTypeEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcCollectionTypeEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcCollectionTypeEnum::InternalSwap(SdcCollectionTypeEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ct_, other->_impl_.ct_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcCollectionTypeEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[12]);
}

// ===================================================================

class SdcCollectionClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcCollectionClass>()._impl_._has_bits_);
  static const ::Sdc::SdcCollectionTypeEnum& scte(const SdcCollectionClass* msg);
  static void set_has_scte(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::Sdc::SdcCollectionTypeEnum&
SdcCollectionClass::_Internal::scte(const SdcCollectionClass* msg) {
  return *msg->_impl_.scte_;
}
SdcCollectionClass::SdcCollectionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcCollectionClass)
}
SdcCollectionClass::SdcCollectionClass(const SdcCollectionClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcCollectionClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._collection_objs_){from._impl_._collection_objs_}
    , decltype(_impl_._collection_obj_types_){from._impl_._collection_obj_types_}
    , decltype(_impl_.scte_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_scte()) {
    _this->_impl_.scte_ = new ::Sdc::SdcCollectionTypeEnum(*from._impl_.scte_);
  }
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcCollectionClass)
}

inline void SdcCollectionClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._collection_objs_){arena}
    , decltype(_impl_._collection_obj_types_){arena}
    , decltype(_impl_.scte_){nullptr}
  };
}

SdcCollectionClass::~SdcCollectionClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcCollectionClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcCollectionClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._collection_objs_.~RepeatedField();
  _impl_._collection_obj_types_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.scte_;
}

void SdcCollectionClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcCollectionClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcCollectionClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._collection_objs_.Clear();
  _impl_._collection_obj_types_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.scte_ != nullptr);
    _impl_.scte_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcCollectionClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Sdc.SdcCollectionTypeEnum scte = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_scte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _collection_objs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__collection_objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__collection_objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 _collection_obj_types = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__collection_obj_types(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable__collection_obj_types(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcCollectionClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcCollectionClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Sdc.SdcCollectionTypeEnum scte = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::scte(this),
        _Internal::scte(this).GetCachedSize(), target, stream);
  }

  // repeated uint64 _collection_objs = 2;
  for (int i = 0, n = this->_internal__collection_objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__collection_objs(i), target);
  }

  // repeated uint32 _collection_obj_types = 3;
  for (int i = 0, n = this->_internal__collection_obj_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal__collection_obj_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcCollectionClass)
  return target;
}

size_t SdcCollectionClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcCollectionClass)
  size_t total_size = 0;

  // required .Sdc.SdcCollectionTypeEnum scte = 1;
  if (_internal_has_scte()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scte_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _collection_objs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._collection_objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__collection_objs_size());
    total_size += data_size;
  }

  // repeated uint32 _collection_obj_types = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_._collection_obj_types_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__collection_obj_types_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcCollectionClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcCollectionClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcCollectionClass::GetClassData() const { return &_class_data_; }


void SdcCollectionClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcCollectionClass*>(&to_msg);
  auto& from = static_cast<const SdcCollectionClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcCollectionClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._collection_objs_.MergeFrom(from._impl_._collection_objs_);
  _this->_impl_._collection_obj_types_.MergeFrom(from._impl_._collection_obj_types_);
  if (from._internal_has_scte()) {
    _this->_internal_mutable_scte()->::Sdc::SdcCollectionTypeEnum::MergeFrom(
        from._internal_scte());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcCollectionClass::CopyFrom(const SdcCollectionClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcCollectionClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcCollectionClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_scte()) {
    if (!_impl_.scte_->IsInitialized()) return false;
  }
  return true;
}

void SdcCollectionClass::InternalSwap(SdcCollectionClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._collection_objs_.InternalSwap(&other->_impl_._collection_objs_);
  _impl_._collection_obj_types_.InternalSwap(&other->_impl_._collection_obj_types_);
  swap(_impl_.scte_, other->_impl_.scte_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcCollectionClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[13]);
}

// ===================================================================

class SdcTimingDerateClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcTimingDerateClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__derate_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SdcTimingDerateClass::SdcTimingDerateClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcTimingDerateClass)
}
SdcTimingDerateClass::SdcTimingDerateClass(const SdcTimingDerateClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcTimingDerateClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._derate_value_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._derate_value_, &from._impl_._derate_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_._derate_value_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcTimingDerateClass)
}

inline void SdcTimingDerateClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._derate_value_){0}
    , decltype(_impl_.type_){0u}
  };
}

SdcTimingDerateClass::~SdcTimingDerateClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcTimingDerateClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcTimingDerateClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SdcTimingDerateClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcTimingDerateClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcTimingDerateClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._derate_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_._derate_value_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcTimingDerateClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double _derate_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has__derate_value(&has_bits);
          _impl_._derate_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcTimingDerateClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcTimingDerateClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required double _derate_value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal__derate_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcTimingDerateClass)
  return target;
}

size_t SdcTimingDerateClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcTimingDerateClass)
  size_t total_size = 0;

  if (_internal_has__derate_value()) {
    // required double _derate_value = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcTimingDerateClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcTimingDerateClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double _derate_value = 2;
    total_size += 1 + 8;

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcTimingDerateClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcTimingDerateClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcTimingDerateClass::GetClassData() const { return &_class_data_; }


void SdcTimingDerateClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcTimingDerateClass*>(&to_msg);
  auto& from = static_cast<const SdcTimingDerateClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcTimingDerateClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._derate_value_ = from._impl_._derate_value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcTimingDerateClass::CopyFrom(const SdcTimingDerateClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcTimingDerateClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcTimingDerateClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcTimingDerateClass::InternalSwap(SdcTimingDerateClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcTimingDerateClass, _impl_.type_)
      + sizeof(SdcTimingDerateClass::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcTimingDerateClass, _impl_._derate_value_)>(
          reinterpret_cast<char*>(&_impl_._derate_value_),
          reinterpret_cast<char*>(&other->_impl_._derate_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcTimingDerateClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[14]);
}

// ===================================================================

class SdcTimingDRCClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcTimingDRCClass>()._impl_._has_bits_);
  static void set_has__drc_val(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdcTimingDRCClass::SdcTimingDRCClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcTimingDRCClass)
}
SdcTimingDRCClass::SdcTimingDRCClass(const SdcTimingDRCClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcTimingDRCClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){from._impl_._objs_}
    , decltype(_impl_._obj_types_){from._impl_._obj_types_}
    , decltype(_impl_._drc_val_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._drc_val_ = from._impl_._drc_val_;
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcTimingDRCClass)
}

inline void SdcTimingDRCClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){arena}
    , decltype(_impl_._obj_types_){arena}
    , decltype(_impl_._drc_val_){0}
  };
}

SdcTimingDRCClass::~SdcTimingDRCClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcTimingDRCClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcTimingDRCClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._objs_.~RepeatedField();
  _impl_._obj_types_.~RepeatedField();
}

void SdcTimingDRCClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcTimingDRCClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcTimingDRCClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._objs_.Clear();
  _impl_._obj_types_.Clear();
  _impl_._drc_val_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcTimingDRCClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double _drc_val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has__drc_val(&has_bits);
          _impl_._drc_val_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _objs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 _obj_types = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__obj_types(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable__obj_types(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcTimingDRCClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcTimingDRCClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double _drc_val = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal__drc_val(), target);
  }

  // repeated uint64 _objs = 2;
  for (int i = 0, n = this->_internal__objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__objs(i), target);
  }

  // repeated uint32 _obj_types = 3;
  for (int i = 0, n = this->_internal__obj_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal__obj_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcTimingDRCClass)
  return target;
}

size_t SdcTimingDRCClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcTimingDRCClass)
  size_t total_size = 0;

  // required double _drc_val = 1;
  if (_internal_has__drc_val()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _objs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__objs_size());
    total_size += data_size;
  }

  // repeated uint32 _obj_types = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_._obj_types_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__obj_types_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcTimingDRCClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcTimingDRCClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcTimingDRCClass::GetClassData() const { return &_class_data_; }


void SdcTimingDRCClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcTimingDRCClass*>(&to_msg);
  auto& from = static_cast<const SdcTimingDRCClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcTimingDRCClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._objs_.MergeFrom(from._impl_._objs_);
  _this->_impl_._obj_types_.MergeFrom(from._impl_._obj_types_);
  if (from._internal_has__drc_val()) {
    _this->_internal_set__drc_val(from._internal__drc_val());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcTimingDRCClass::CopyFrom(const SdcTimingDRCClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcTimingDRCClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcTimingDRCClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcTimingDRCClass::InternalSwap(SdcTimingDRCClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._objs_.InternalSwap(&other->_impl_._objs_);
  _impl_._obj_types_.InternalSwap(&other->_impl_._obj_types_);
  swap(_impl_._drc_val_, other->_impl_._drc_val_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcTimingDRCClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[15]);
}

// ===================================================================

class SdcSetMaxTransitionClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcSetMaxTransitionClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdcSetMaxTransitionClass::SdcSetMaxTransitionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcSetMaxTransitionClass)
}
SdcSetMaxTransitionClass::SdcSetMaxTransitionClass(const SdcSetMaxTransitionClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcSetMaxTransitionClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcSetMaxTransitionClass)
}

inline void SdcSetMaxTransitionClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0u}
  };
}

SdcSetMaxTransitionClass::~SdcSetMaxTransitionClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcSetMaxTransitionClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcSetMaxTransitionClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SdcSetMaxTransitionClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcSetMaxTransitionClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcSetMaxTransitionClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcSetMaxTransitionClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcSetMaxTransitionClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcSetMaxTransitionClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcSetMaxTransitionClass)
  return target;
}

size_t SdcSetMaxTransitionClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcSetMaxTransitionClass)
  size_t total_size = 0;

  // required uint32 type = 1;
  if (_internal_has_type()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcSetMaxTransitionClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcSetMaxTransitionClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcSetMaxTransitionClass::GetClassData() const { return &_class_data_; }


void SdcSetMaxTransitionClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcSetMaxTransitionClass*>(&to_msg);
  auto& from = static_cast<const SdcSetMaxTransitionClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcSetMaxTransitionClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcSetMaxTransitionClass::CopyFrom(const SdcSetMaxTransitionClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcSetMaxTransitionClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcSetMaxTransitionClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcSetMaxTransitionClass::InternalSwap(SdcSetMaxTransitionClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcSetMaxTransitionClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[16]);
}

// ===================================================================

class SdcSetMaxCapacitanceClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcSetMaxCapacitanceClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdcSetMaxCapacitanceClass::SdcSetMaxCapacitanceClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcSetMaxCapacitanceClass)
}
SdcSetMaxCapacitanceClass::SdcSetMaxCapacitanceClass(const SdcSetMaxCapacitanceClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcSetMaxCapacitanceClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcSetMaxCapacitanceClass)
}

inline void SdcSetMaxCapacitanceClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0u}
  };
}

SdcSetMaxCapacitanceClass::~SdcSetMaxCapacitanceClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcSetMaxCapacitanceClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcSetMaxCapacitanceClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SdcSetMaxCapacitanceClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcSetMaxCapacitanceClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcSetMaxCapacitanceClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcSetMaxCapacitanceClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcSetMaxCapacitanceClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcSetMaxCapacitanceClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcSetMaxCapacitanceClass)
  return target;
}

size_t SdcSetMaxCapacitanceClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcSetMaxCapacitanceClass)
  size_t total_size = 0;

  // required uint32 type = 2;
  if (_internal_has_type()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcSetMaxCapacitanceClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcSetMaxCapacitanceClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcSetMaxCapacitanceClass::GetClassData() const { return &_class_data_; }


void SdcSetMaxCapacitanceClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcSetMaxCapacitanceClass*>(&to_msg);
  auto& from = static_cast<const SdcSetMaxCapacitanceClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcSetMaxCapacitanceClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcSetMaxCapacitanceClass::CopyFrom(const SdcSetMaxCapacitanceClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcSetMaxCapacitanceClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcSetMaxCapacitanceClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcSetMaxCapacitanceClass::InternalSwap(SdcSetMaxCapacitanceClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcSetMaxCapacitanceClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[17]);
}

// ===================================================================

class SdcTimingDRCSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcTimingDRCSyn>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Sdc::SdcTimingDRCClass& parent(const SdcTimingDRCSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Sdc::SdcSetMaxTransitionClass& ssntc(const SdcTimingDRCSyn* msg);
  static const ::Sdc::SdcSetMaxCapacitanceClass& ssncc(const SdcTimingDRCSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::Sdc::SdcTimingDRCClass&
SdcTimingDRCSyn::_Internal::parent(const SdcTimingDRCSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Sdc::SdcSetMaxTransitionClass&
SdcTimingDRCSyn::_Internal::ssntc(const SdcTimingDRCSyn* msg) {
  return *msg->_impl_.stdrcs_.ssntc_;
}
const ::Sdc::SdcSetMaxCapacitanceClass&
SdcTimingDRCSyn::_Internal::ssncc(const SdcTimingDRCSyn* msg) {
  return *msg->_impl_.stdrcs_.ssncc_;
}
void SdcTimingDRCSyn::set_allocated_ssntc(::Sdc::SdcSetMaxTransitionClass* ssntc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_stdrcs();
  if (ssntc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssntc);
    if (message_arena != submessage_arena) {
      ssntc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssntc, submessage_arena);
    }
    set_has_ssntc();
    _impl_.stdrcs_.ssntc_ = ssntc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcTimingDRCSyn.ssntc)
}
void SdcTimingDRCSyn::set_allocated_ssncc(::Sdc::SdcSetMaxCapacitanceClass* ssncc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_stdrcs();
  if (ssncc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssncc);
    if (message_arena != submessage_arena) {
      ssncc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssncc, submessage_arena);
    }
    set_has_ssncc();
    _impl_.stdrcs_.ssncc_ = ssncc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcTimingDRCSyn.ssncc)
}
SdcTimingDRCSyn::SdcTimingDRCSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcTimingDRCSyn)
}
SdcTimingDRCSyn::SdcTimingDRCSyn(const SdcTimingDRCSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcTimingDRCSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.stdrcs_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Sdc::SdcTimingDRCClass(*from._impl_.parent_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  clear_has_stdrcs();
  switch (from.stdrcs_case()) {
    case kSsntc: {
      _this->_internal_mutable_ssntc()->::Sdc::SdcSetMaxTransitionClass::MergeFrom(
          from._internal_ssntc());
      break;
    }
    case kSsncc: {
      _this->_internal_mutable_ssncc()->::Sdc::SdcSetMaxCapacitanceClass::MergeFrom(
          from._internal_ssncc());
      break;
    }
    case STDRCS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcTimingDRCSyn)
}

inline void SdcTimingDRCSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.stdrcs_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_stdrcs();
}

SdcTimingDRCSyn::~SdcTimingDRCSyn() {
  // @@protoc_insertion_point(destructor:Sdc.SdcTimingDRCSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcTimingDRCSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_stdrcs()) {
    clear_stdrcs();
  }
}

void SdcTimingDRCSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcTimingDRCSyn::clear_stdrcs() {
// @@protoc_insertion_point(one_of_clear_start:Sdc.SdcTimingDRCSyn)
  switch (stdrcs_case()) {
    case kSsntc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.stdrcs_.ssntc_;
      }
      break;
    }
    case kSsncc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.stdrcs_.ssncc_;
      }
      break;
    }
    case STDRCS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = STDRCS_NOT_SET;
}


void SdcTimingDRCSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcTimingDRCSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  _impl_.type_ = 0u;
  clear_stdrcs();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcTimingDRCSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Sdc.SdcTimingDRCClass parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcSetMaxTransitionClass ssntc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ssntc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcSetMaxCapacitanceClass ssncc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ssncc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcTimingDRCSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcTimingDRCSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required .Sdc.SdcTimingDRCClass parent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (stdrcs_case()) {
    case kSsntc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::ssntc(this),
          _Internal::ssntc(this).GetCachedSize(), target, stream);
      break;
    }
    case kSsncc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::ssncc(this),
          _Internal::ssncc(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcTimingDRCSyn)
  return target;
}

size_t SdcTimingDRCSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcTimingDRCSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Sdc.SdcTimingDRCClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcTimingDRCSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcTimingDRCSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .Sdc.SdcTimingDRCClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (stdrcs_case()) {
    // .Sdc.SdcSetMaxTransitionClass ssntc = 3;
    case kSsntc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stdrcs_.ssntc_);
      break;
    }
    // .Sdc.SdcSetMaxCapacitanceClass ssncc = 4;
    case kSsncc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stdrcs_.ssncc_);
      break;
    }
    case STDRCS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcTimingDRCSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcTimingDRCSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcTimingDRCSyn::GetClassData() const { return &_class_data_; }


void SdcTimingDRCSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcTimingDRCSyn*>(&to_msg);
  auto& from = static_cast<const SdcTimingDRCSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcTimingDRCSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Sdc::SdcTimingDRCClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.stdrcs_case()) {
    case kSsntc: {
      _this->_internal_mutable_ssntc()->::Sdc::SdcSetMaxTransitionClass::MergeFrom(
          from._internal_ssntc());
      break;
    }
    case kSsncc: {
      _this->_internal_mutable_ssncc()->::Sdc::SdcSetMaxCapacitanceClass::MergeFrom(
          from._internal_ssncc());
      break;
    }
    case STDRCS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcTimingDRCSyn::CopyFrom(const SdcTimingDRCSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcTimingDRCSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcTimingDRCSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (stdrcs_case()) {
    case kSsntc: {
      if (_internal_has_ssntc()) {
        if (!_impl_.stdrcs_.ssntc_->IsInitialized()) return false;
      }
      break;
    }
    case kSsncc: {
      if (_internal_has_ssncc()) {
        if (!_impl_.stdrcs_.ssncc_->IsInitialized()) return false;
      }
      break;
    }
    case STDRCS_NOT_SET: {
      break;
    }
  }
  return true;
}

void SdcTimingDRCSyn::InternalSwap(SdcTimingDRCSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcTimingDRCSyn, _impl_.type_)
      + sizeof(SdcTimingDRCSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcTimingDRCSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.stdrcs_, other->_impl_.stdrcs_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcTimingDRCSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[18]);
}

// ===================================================================

class SdcSetClockLatencyClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcSetClockLatencyClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__delay_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SdcSetClockLatencyClass::SdcSetClockLatencyClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcSetClockLatencyClass)
}
SdcSetClockLatencyClass::SdcSetClockLatencyClass(const SdcSetClockLatencyClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcSetClockLatencyClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){from._impl_._objs_}
    , decltype(_impl_._delay_value_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._delay_value_, &from._impl_._delay_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_._delay_value_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcSetClockLatencyClass)
}

inline void SdcSetClockLatencyClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){arena}
    , decltype(_impl_._delay_value_){0}
    , decltype(_impl_.type_){0u}
  };
}

SdcSetClockLatencyClass::~SdcSetClockLatencyClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcSetClockLatencyClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcSetClockLatencyClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._objs_.~RepeatedField();
}

void SdcSetClockLatencyClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcSetClockLatencyClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcSetClockLatencyClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._objs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._delay_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_._delay_value_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcSetClockLatencyClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double _delay_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has__delay_value(&has_bits);
          _impl_._delay_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _objs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcSetClockLatencyClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcSetClockLatencyClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required double _delay_value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal__delay_value(), target);
  }

  // repeated uint64 _objs = 3;
  for (int i = 0, n = this->_internal__objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__objs(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcSetClockLatencyClass)
  return target;
}

size_t SdcSetClockLatencyClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcSetClockLatencyClass)
  size_t total_size = 0;

  if (_internal_has__delay_value()) {
    // required double _delay_value = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcSetClockLatencyClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcSetClockLatencyClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double _delay_value = 2;
    total_size += 1 + 8;

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _objs = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__objs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcSetClockLatencyClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcSetClockLatencyClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcSetClockLatencyClass::GetClassData() const { return &_class_data_; }


void SdcSetClockLatencyClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcSetClockLatencyClass*>(&to_msg);
  auto& from = static_cast<const SdcSetClockLatencyClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcSetClockLatencyClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._objs_.MergeFrom(from._impl_._objs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._delay_value_ = from._impl_._delay_value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcSetClockLatencyClass::CopyFrom(const SdcSetClockLatencyClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcSetClockLatencyClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcSetClockLatencyClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcSetClockLatencyClass::InternalSwap(SdcSetClockLatencyClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._objs_.InternalSwap(&other->_impl_._objs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcSetClockLatencyClass, _impl_.type_)
      + sizeof(SdcSetClockLatencyClass::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcSetClockLatencyClass, _impl_._delay_value_)>(
          reinterpret_cast<char*>(&_impl_._delay_value_),
          reinterpret_cast<char*>(&other->_impl_._delay_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcSetClockLatencyClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[19]);
}

// ===================================================================

class SdcSetClockUncertaintyClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcSetClockUncertaintyClass>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__uncertainty_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SdcSetClockUncertaintyClass::SdcSetClockUncertaintyClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcSetClockUncertaintyClass)
}
SdcSetClockUncertaintyClass::SdcSetClockUncertaintyClass(const SdcSetClockUncertaintyClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcSetClockUncertaintyClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){from._impl_._objs_}
    , decltype(_impl_._uncertainty_value_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._uncertainty_value_, &from._impl_._uncertainty_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_._uncertainty_value_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcSetClockUncertaintyClass)
}

inline void SdcSetClockUncertaintyClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._objs_){arena}
    , decltype(_impl_._uncertainty_value_){0}
    , decltype(_impl_.type_){0u}
  };
}

SdcSetClockUncertaintyClass::~SdcSetClockUncertaintyClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcSetClockUncertaintyClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcSetClockUncertaintyClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._objs_.~RepeatedField();
}

void SdcSetClockUncertaintyClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcSetClockUncertaintyClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcSetClockUncertaintyClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._objs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._uncertainty_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_._uncertainty_value_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcSetClockUncertaintyClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double _uncertainty_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has__uncertainty_value(&has_bits);
          _impl_._uncertainty_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _objs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__objs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__objs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcSetClockUncertaintyClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcSetClockUncertaintyClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required double _uncertainty_value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal__uncertainty_value(), target);
  }

  // repeated uint64 _objs = 3;
  for (int i = 0, n = this->_internal__objs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__objs(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcSetClockUncertaintyClass)
  return target;
}

size_t SdcSetClockUncertaintyClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcSetClockUncertaintyClass)
  size_t total_size = 0;

  if (_internal_has__uncertainty_value()) {
    // required double _uncertainty_value = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcSetClockUncertaintyClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcSetClockUncertaintyClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double _uncertainty_value = 2;
    total_size += 1 + 8;

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _objs = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._objs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__objs_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcSetClockUncertaintyClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcSetClockUncertaintyClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcSetClockUncertaintyClass::GetClassData() const { return &_class_data_; }


void SdcSetClockUncertaintyClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcSetClockUncertaintyClass*>(&to_msg);
  auto& from = static_cast<const SdcSetClockUncertaintyClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcSetClockUncertaintyClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._objs_.MergeFrom(from._impl_._objs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._uncertainty_value_ = from._impl_._uncertainty_value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcSetClockUncertaintyClass::CopyFrom(const SdcSetClockUncertaintyClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcSetClockUncertaintyClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcSetClockUncertaintyClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcSetClockUncertaintyClass::InternalSwap(SdcSetClockUncertaintyClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._objs_.InternalSwap(&other->_impl_._objs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcSetClockUncertaintyClass, _impl_.type_)
      + sizeof(SdcSetClockUncertaintyClass::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcSetClockUncertaintyClass, _impl_._uncertainty_value_)>(
          reinterpret_cast<char*>(&_impl_._uncertainty_value_),
          reinterpret_cast<char*>(&other->_impl_._uncertainty_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcSetClockUncertaintyClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[20]);
}

// ===================================================================

class SdcExceptionClass::_Internal {
 public:
};

void SdcExceptionClass::clear__prop_throughs() {
  _impl_._prop_throughs_.Clear();
}
SdcExceptionClass::SdcExceptionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcExceptionClass)
}
SdcExceptionClass::SdcExceptionClass(const SdcExceptionClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcExceptionClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._prop_froms_){from._impl_._prop_froms_}
    , decltype(_impl_._prop_tos_){from._impl_._prop_tos_}
    , decltype(_impl_._prop_throughs_){from._impl_._prop_throughs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcExceptionClass)
}

inline void SdcExceptionClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._prop_froms_){arena}
    , decltype(_impl_._prop_tos_){arena}
    , decltype(_impl_._prop_throughs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SdcExceptionClass::~SdcExceptionClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcExceptionClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcExceptionClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._prop_froms_.~RepeatedPtrField();
  _impl_._prop_tos_.~RepeatedPtrField();
  _impl_._prop_throughs_.~RepeatedPtrField();
}

void SdcExceptionClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcExceptionClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcExceptionClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._prop_froms_.Clear();
  _impl_._prop_tos_.Clear();
  _impl_._prop_throughs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcExceptionClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string _prop_froms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add__prop_froms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "Sdc.SdcExceptionClass._prop_froms");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string _prop_tos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add__prop_tos();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "Sdc.SdcExceptionClass._prop_tos");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.StringList _prop_throughs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__prop_throughs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcExceptionClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcExceptionClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string _prop_froms = 1;
  for (int i = 0, n = this->_internal__prop_froms_size(); i < n; i++) {
    const auto& s = this->_internal__prop_froms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcExceptionClass._prop_froms");
    target = stream->WriteString(1, s, target);
  }

  // repeated string _prop_tos = 2;
  for (int i = 0, n = this->_internal__prop_tos_size(); i < n; i++) {
    const auto& s = this->_internal__prop_tos(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Sdc.SdcExceptionClass._prop_tos");
    target = stream->WriteString(2, s, target);
  }

  // repeated .Common.Types.StringList _prop_throughs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__prop_throughs_size()); i < n; i++) {
    const auto& repfield = this->_internal__prop_throughs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcExceptionClass)
  return target;
}

size_t SdcExceptionClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcExceptionClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string _prop_froms = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_._prop_froms_.size());
  for (int i = 0, n = _impl_._prop_froms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_._prop_froms_.Get(i));
  }

  // repeated string _prop_tos = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_._prop_tos_.size());
  for (int i = 0, n = _impl_._prop_tos_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_._prop_tos_.Get(i));
  }

  // repeated .Common.Types.StringList _prop_throughs = 3;
  total_size += 1UL * this->_internal__prop_throughs_size();
  for (const auto& msg : this->_impl_._prop_throughs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcExceptionClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcExceptionClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcExceptionClass::GetClassData() const { return &_class_data_; }


void SdcExceptionClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcExceptionClass*>(&to_msg);
  auto& from = static_cast<const SdcExceptionClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcExceptionClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._prop_froms_.MergeFrom(from._impl_._prop_froms_);
  _this->_impl_._prop_tos_.MergeFrom(from._impl_._prop_tos_);
  _this->_impl_._prop_throughs_.MergeFrom(from._impl_._prop_throughs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcExceptionClass::CopyFrom(const SdcExceptionClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcExceptionClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcExceptionClass::IsInitialized() const {
  return true;
}

void SdcExceptionClass::InternalSwap(SdcExceptionClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._prop_froms_.InternalSwap(&other->_impl_._prop_froms_);
  _impl_._prop_tos_.InternalSwap(&other->_impl_._prop_tos_);
  _impl_._prop_throughs_.InternalSwap(&other->_impl_._prop_throughs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcExceptionClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[21]);
}

// ===================================================================

class SdcMulticyclePathClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcMulticyclePathClass>()._impl_._has_bits_);
  static void set_has__path_multiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SdcMulticyclePathClass::SdcMulticyclePathClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcMulticyclePathClass)
}
SdcMulticyclePathClass::SdcMulticyclePathClass(const SdcMulticyclePathClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcMulticyclePathClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._path_multiplier_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._path_multiplier_, &from._impl_._path_multiplier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_._path_multiplier_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcMulticyclePathClass)
}

inline void SdcMulticyclePathClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._path_multiplier_){0}
    , decltype(_impl_.type_){0u}
  };
}

SdcMulticyclePathClass::~SdcMulticyclePathClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcMulticyclePathClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcMulticyclePathClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SdcMulticyclePathClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcMulticyclePathClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcMulticyclePathClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._path_multiplier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_._path_multiplier_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcMulticyclePathClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _path_multiplier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__path_multiplier(&has_bits);
          _impl_._path_multiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcMulticyclePathClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcMulticyclePathClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _path_multiplier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal__path_multiplier(), target);
  }

  // required uint32 type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcMulticyclePathClass)
  return target;
}

size_t SdcMulticyclePathClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcMulticyclePathClass)
  size_t total_size = 0;

  if (_internal_has__path_multiplier()) {
    // required int32 _path_multiplier = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__path_multiplier());
  }

  if (_internal_has_type()) {
    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcMulticyclePathClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcMulticyclePathClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 _path_multiplier = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__path_multiplier());

    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcMulticyclePathClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcMulticyclePathClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcMulticyclePathClass::GetClassData() const { return &_class_data_; }


void SdcMulticyclePathClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcMulticyclePathClass*>(&to_msg);
  auto& from = static_cast<const SdcMulticyclePathClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcMulticyclePathClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._path_multiplier_ = from._impl_._path_multiplier_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcMulticyclePathClass::CopyFrom(const SdcMulticyclePathClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcMulticyclePathClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcMulticyclePathClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdcMulticyclePathClass::InternalSwap(SdcMulticyclePathClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcMulticyclePathClass, _impl_.type_)
      + sizeof(SdcMulticyclePathClass::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcMulticyclePathClass, _impl_._path_multiplier_)>(
          reinterpret_cast<char*>(&_impl_._path_multiplier_),
          reinterpret_cast<char*>(&other->_impl_._path_multiplier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcMulticyclePathClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[22]);
}

// ===================================================================

class SdcExceptionSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcExceptionSyn>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Sdc::SdcExceptionClass& parent(const SdcExceptionSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Sdc::SdcMulticyclePathClass& child(const SdcExceptionSyn* msg);
  static void set_has_child(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::Sdc::SdcExceptionClass&
SdcExceptionSyn::_Internal::parent(const SdcExceptionSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Sdc::SdcMulticyclePathClass&
SdcExceptionSyn::_Internal::child(const SdcExceptionSyn* msg) {
  return *msg->_impl_.child_;
}
SdcExceptionSyn::SdcExceptionSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcExceptionSyn)
}
SdcExceptionSyn::SdcExceptionSyn(const SdcExceptionSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcExceptionSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.child_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Sdc::SdcExceptionClass(*from._impl_.parent_);
  }
  if (from._internal_has_child()) {
    _this->_impl_.child_ = new ::Sdc::SdcMulticyclePathClass(*from._impl_.child_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcExceptionSyn)
}

inline void SdcExceptionSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.child_){nullptr}
    , decltype(_impl_.type_){0u}
  };
}

SdcExceptionSyn::~SdcExceptionSyn() {
  // @@protoc_insertion_point(destructor:Sdc.SdcExceptionSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcExceptionSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.child_;
}

void SdcExceptionSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcExceptionSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcExceptionSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.child_ != nullptr);
      _impl_.child_->Clear();
    }
  }
  _impl_.type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcExceptionSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Sdc.SdcExceptionClass parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Sdc.SdcMulticyclePathClass child = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_child(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcExceptionSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcExceptionSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // required .Sdc.SdcExceptionClass parent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .Sdc.SdcMulticyclePathClass child = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::child(this),
        _Internal::child(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcExceptionSyn)
  return target;
}

size_t SdcExceptionSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcExceptionSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Sdc.SdcExceptionClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_type()) {
    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcExceptionSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcExceptionSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .Sdc.SdcExceptionClass parent = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint32 type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Sdc.SdcMulticyclePathClass child = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.child_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcExceptionSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcExceptionSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcExceptionSyn::GetClassData() const { return &_class_data_; }


void SdcExceptionSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcExceptionSyn*>(&to_msg);
  auto& from = static_cast<const SdcExceptionSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcExceptionSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Sdc::SdcExceptionClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_child()->::Sdc::SdcMulticyclePathClass::MergeFrom(
          from._internal_child());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcExceptionSyn::CopyFrom(const SdcExceptionSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcExceptionSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcExceptionSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_child()) {
    if (!_impl_.child_->IsInitialized()) return false;
  }
  return true;
}

void SdcExceptionSyn::InternalSwap(SdcExceptionSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcExceptionSyn, _impl_.type_)
      + sizeof(SdcExceptionSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcExceptionSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcExceptionSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[23]);
}

// ===================================================================

class SdcCommandObjSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcCommandObjSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Sdc::SdcCommandObjClass& parent(const SdcCommandObjSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Sdc::SdcIOConstrainSyn& siocs(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcClockSyn& scs(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcAllClocksClass& cacc(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcClockGroupsClass& scgc(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcCollectionClass& scc(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcTimingDerateClass& stdc(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcTimingDRCSyn& stdrcs(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcSetClockLatencyClass& ssclc(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcSetClockUncertaintyClass& sscuc(const SdcCommandObjSyn* msg);
  static const ::Sdc::SdcExceptionSyn& ses(const SdcCommandObjSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Sdc::SdcCommandObjClass&
SdcCommandObjSyn::_Internal::parent(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::Sdc::SdcIOConstrainSyn&
SdcCommandObjSyn::_Internal::siocs(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.siocs_;
}
const ::Sdc::SdcClockSyn&
SdcCommandObjSyn::_Internal::scs(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.scs_;
}
const ::Sdc::SdcAllClocksClass&
SdcCommandObjSyn::_Internal::cacc(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.cacc_;
}
const ::Sdc::SdcClockGroupsClass&
SdcCommandObjSyn::_Internal::scgc(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.scgc_;
}
const ::Sdc::SdcCollectionClass&
SdcCommandObjSyn::_Internal::scc(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.scc_;
}
const ::Sdc::SdcTimingDerateClass&
SdcCommandObjSyn::_Internal::stdc(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.stdc_;
}
const ::Sdc::SdcTimingDRCSyn&
SdcCommandObjSyn::_Internal::stdrcs(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.stdrcs_;
}
const ::Sdc::SdcSetClockLatencyClass&
SdcCommandObjSyn::_Internal::ssclc(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.ssclc_;
}
const ::Sdc::SdcSetClockUncertaintyClass&
SdcCommandObjSyn::_Internal::sscuc(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.sscuc_;
}
const ::Sdc::SdcExceptionSyn&
SdcCommandObjSyn::_Internal::ses(const SdcCommandObjSyn* msg) {
  return *msg->_impl_.scos_.ses_;
}
void SdcCommandObjSyn::set_allocated_siocs(::Sdc::SdcIOConstrainSyn* siocs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (siocs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(siocs);
    if (message_arena != submessage_arena) {
      siocs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, siocs, submessage_arena);
    }
    set_has_siocs();
    _impl_.scos_.siocs_ = siocs;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.siocs)
}
void SdcCommandObjSyn::set_allocated_scs(::Sdc::SdcClockSyn* scs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (scs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scs);
    if (message_arena != submessage_arena) {
      scs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scs, submessage_arena);
    }
    set_has_scs();
    _impl_.scos_.scs_ = scs;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.scs)
}
void SdcCommandObjSyn::set_allocated_cacc(::Sdc::SdcAllClocksClass* cacc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (cacc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cacc);
    if (message_arena != submessage_arena) {
      cacc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cacc, submessage_arena);
    }
    set_has_cacc();
    _impl_.scos_.cacc_ = cacc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.cacc)
}
void SdcCommandObjSyn::set_allocated_scgc(::Sdc::SdcClockGroupsClass* scgc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (scgc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scgc);
    if (message_arena != submessage_arena) {
      scgc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scgc, submessage_arena);
    }
    set_has_scgc();
    _impl_.scos_.scgc_ = scgc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.scgc)
}
void SdcCommandObjSyn::set_allocated_scc(::Sdc::SdcCollectionClass* scc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (scc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scc);
    if (message_arena != submessage_arena) {
      scc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scc, submessage_arena);
    }
    set_has_scc();
    _impl_.scos_.scc_ = scc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.scc)
}
void SdcCommandObjSyn::set_allocated_stdc(::Sdc::SdcTimingDerateClass* stdc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (stdc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stdc);
    if (message_arena != submessage_arena) {
      stdc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stdc, submessage_arena);
    }
    set_has_stdc();
    _impl_.scos_.stdc_ = stdc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.stdc)
}
void SdcCommandObjSyn::set_allocated_stdrcs(::Sdc::SdcTimingDRCSyn* stdrcs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (stdrcs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stdrcs);
    if (message_arena != submessage_arena) {
      stdrcs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stdrcs, submessage_arena);
    }
    set_has_stdrcs();
    _impl_.scos_.stdrcs_ = stdrcs;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.stdrcs)
}
void SdcCommandObjSyn::set_allocated_ssclc(::Sdc::SdcSetClockLatencyClass* ssclc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (ssclc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssclc);
    if (message_arena != submessage_arena) {
      ssclc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssclc, submessage_arena);
    }
    set_has_ssclc();
    _impl_.scos_.ssclc_ = ssclc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.ssclc)
}
void SdcCommandObjSyn::set_allocated_sscuc(::Sdc::SdcSetClockUncertaintyClass* sscuc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (sscuc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sscuc);
    if (message_arena != submessage_arena) {
      sscuc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sscuc, submessage_arena);
    }
    set_has_sscuc();
    _impl_.scos_.sscuc_ = sscuc;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.sscuc)
}
void SdcCommandObjSyn::set_allocated_ses(::Sdc::SdcExceptionSyn* ses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_scos();
  if (ses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ses);
    if (message_arena != submessage_arena) {
      ses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ses, submessage_arena);
    }
    set_has_ses();
    _impl_.scos_.ses_ = ses;
  }
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.ses)
}
SdcCommandObjSyn::SdcCommandObjSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcCommandObjSyn)
}
SdcCommandObjSyn::SdcCommandObjSyn(const SdcCommandObjSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcCommandObjSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.scos_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::Sdc::SdcCommandObjClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  clear_has_scos();
  switch (from.scos_case()) {
    case kSiocs: {
      _this->_internal_mutable_siocs()->::Sdc::SdcIOConstrainSyn::MergeFrom(
          from._internal_siocs());
      break;
    }
    case kScs: {
      _this->_internal_mutable_scs()->::Sdc::SdcClockSyn::MergeFrom(
          from._internal_scs());
      break;
    }
    case kCacc: {
      _this->_internal_mutable_cacc()->::Sdc::SdcAllClocksClass::MergeFrom(
          from._internal_cacc());
      break;
    }
    case kScgc: {
      _this->_internal_mutable_scgc()->::Sdc::SdcClockGroupsClass::MergeFrom(
          from._internal_scgc());
      break;
    }
    case kScc: {
      _this->_internal_mutable_scc()->::Sdc::SdcCollectionClass::MergeFrom(
          from._internal_scc());
      break;
    }
    case kStdc: {
      _this->_internal_mutable_stdc()->::Sdc::SdcTimingDerateClass::MergeFrom(
          from._internal_stdc());
      break;
    }
    case kStdrcs: {
      _this->_internal_mutable_stdrcs()->::Sdc::SdcTimingDRCSyn::MergeFrom(
          from._internal_stdrcs());
      break;
    }
    case kSsclc: {
      _this->_internal_mutable_ssclc()->::Sdc::SdcSetClockLatencyClass::MergeFrom(
          from._internal_ssclc());
      break;
    }
    case kSscuc: {
      _this->_internal_mutable_sscuc()->::Sdc::SdcSetClockUncertaintyClass::MergeFrom(
          from._internal_sscuc());
      break;
    }
    case kSes: {
      _this->_internal_mutable_ses()->::Sdc::SdcExceptionSyn::MergeFrom(
          from._internal_ses());
      break;
    }
    case SCOS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcCommandObjSyn)
}

inline void SdcCommandObjSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.scos_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_scos();
}

SdcCommandObjSyn::~SdcCommandObjSyn() {
  // @@protoc_insertion_point(destructor:Sdc.SdcCommandObjSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcCommandObjSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_scos()) {
    clear_scos();
  }
}

void SdcCommandObjSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcCommandObjSyn::clear_scos() {
// @@protoc_insertion_point(one_of_clear_start:Sdc.SdcCommandObjSyn)
  switch (scos_case()) {
    case kSiocs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.siocs_;
      }
      break;
    }
    case kScs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.scs_;
      }
      break;
    }
    case kCacc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.cacc_;
      }
      break;
    }
    case kScgc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.scgc_;
      }
      break;
    }
    case kScc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.scc_;
      }
      break;
    }
    case kStdc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.stdc_;
      }
      break;
    }
    case kStdrcs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.stdrcs_;
      }
      break;
    }
    case kSsclc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.ssclc_;
      }
      break;
    }
    case kSscuc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.sscuc_;
      }
      break;
    }
    case kSes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.scos_.ses_;
      }
      break;
    }
    case SCOS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SCOS_NOT_SET;
}


void SdcCommandObjSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcCommandObjSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  clear_scos();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcCommandObjSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Sdc.SdcCommandObjClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcIOConstrainSyn siocs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_siocs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcClockSyn scs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_scs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcAllClocksClass cacc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_cacc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcClockGroupsClass scgc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_scgc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcCollectionClass scc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_scc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcTimingDerateClass stdc = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_stdc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcTimingDRCSyn stdrcs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_stdrcs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcSetClockLatencyClass ssclc = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_ssclc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcSetClockUncertaintyClass sscuc = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_sscuc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Sdc.SdcExceptionSyn ses = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_ses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcCommandObjSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcCommandObjSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  // required .Sdc.SdcCommandObjClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (scos_case()) {
    case kSiocs: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::siocs(this),
          _Internal::siocs(this).GetCachedSize(), target, stream);
      break;
    }
    case kScs: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::scs(this),
          _Internal::scs(this).GetCachedSize(), target, stream);
      break;
    }
    case kCacc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::cacc(this),
          _Internal::cacc(this).GetCachedSize(), target, stream);
      break;
    }
    case kScgc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::scgc(this),
          _Internal::scgc(this).GetCachedSize(), target, stream);
      break;
    }
    case kScc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::scc(this),
          _Internal::scc(this).GetCachedSize(), target, stream);
      break;
    }
    case kStdc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::stdc(this),
          _Internal::stdc(this).GetCachedSize(), target, stream);
      break;
    }
    case kStdrcs: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::stdrcs(this),
          _Internal::stdrcs(this).GetCachedSize(), target, stream);
      break;
    }
    case kSsclc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::ssclc(this),
          _Internal::ssclc(this).GetCachedSize(), target, stream);
      break;
    }
    case kSscuc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::sscuc(this),
          _Internal::sscuc(this).GetCachedSize(), target, stream);
      break;
    }
    case kSes: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::ses(this),
          _Internal::ses(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcCommandObjSyn)
  return target;
}

size_t SdcCommandObjSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sdc.SdcCommandObjSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .Sdc.SdcCommandObjClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_type()) {
    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t SdcCommandObjSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcCommandObjSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Sdc.SdcCommandObjClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (scos_case()) {
    // .Sdc.SdcIOConstrainSyn siocs = 4;
    case kSiocs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.siocs_);
      break;
    }
    // .Sdc.SdcClockSyn scs = 5;
    case kScs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.scs_);
      break;
    }
    // .Sdc.SdcAllClocksClass cacc = 6;
    case kCacc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.cacc_);
      break;
    }
    // .Sdc.SdcClockGroupsClass scgc = 7;
    case kScgc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.scgc_);
      break;
    }
    // .Sdc.SdcCollectionClass scc = 8;
    case kScc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.scc_);
      break;
    }
    // .Sdc.SdcTimingDerateClass stdc = 9;
    case kStdc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.stdc_);
      break;
    }
    // .Sdc.SdcTimingDRCSyn stdrcs = 10;
    case kStdrcs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.stdrcs_);
      break;
    }
    // .Sdc.SdcSetClockLatencyClass ssclc = 11;
    case kSsclc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.ssclc_);
      break;
    }
    // .Sdc.SdcSetClockUncertaintyClass sscuc = 12;
    case kSscuc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.sscuc_);
      break;
    }
    // .Sdc.SdcExceptionSyn ses = 13;
    case kSes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scos_.ses_);
      break;
    }
    case SCOS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcCommandObjSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcCommandObjSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcCommandObjSyn::GetClassData() const { return &_class_data_; }


void SdcCommandObjSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcCommandObjSyn*>(&to_msg);
  auto& from = static_cast<const SdcCommandObjSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcCommandObjSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::Sdc::SdcCommandObjClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.scos_case()) {
    case kSiocs: {
      _this->_internal_mutable_siocs()->::Sdc::SdcIOConstrainSyn::MergeFrom(
          from._internal_siocs());
      break;
    }
    case kScs: {
      _this->_internal_mutable_scs()->::Sdc::SdcClockSyn::MergeFrom(
          from._internal_scs());
      break;
    }
    case kCacc: {
      _this->_internal_mutable_cacc()->::Sdc::SdcAllClocksClass::MergeFrom(
          from._internal_cacc());
      break;
    }
    case kScgc: {
      _this->_internal_mutable_scgc()->::Sdc::SdcClockGroupsClass::MergeFrom(
          from._internal_scgc());
      break;
    }
    case kScc: {
      _this->_internal_mutable_scc()->::Sdc::SdcCollectionClass::MergeFrom(
          from._internal_scc());
      break;
    }
    case kStdc: {
      _this->_internal_mutable_stdc()->::Sdc::SdcTimingDerateClass::MergeFrom(
          from._internal_stdc());
      break;
    }
    case kStdrcs: {
      _this->_internal_mutable_stdrcs()->::Sdc::SdcTimingDRCSyn::MergeFrom(
          from._internal_stdrcs());
      break;
    }
    case kSsclc: {
      _this->_internal_mutable_ssclc()->::Sdc::SdcSetClockLatencyClass::MergeFrom(
          from._internal_ssclc());
      break;
    }
    case kSscuc: {
      _this->_internal_mutable_sscuc()->::Sdc::SdcSetClockUncertaintyClass::MergeFrom(
          from._internal_sscuc());
      break;
    }
    case kSes: {
      _this->_internal_mutable_ses()->::Sdc::SdcExceptionSyn::MergeFrom(
          from._internal_ses());
      break;
    }
    case SCOS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcCommandObjSyn::CopyFrom(const SdcCommandObjSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcCommandObjSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcCommandObjSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (scos_case()) {
    case kSiocs: {
      if (_internal_has_siocs()) {
        if (!_impl_.scos_.siocs_->IsInitialized()) return false;
      }
      break;
    }
    case kScs: {
      if (_internal_has_scs()) {
        if (!_impl_.scos_.scs_->IsInitialized()) return false;
      }
      break;
    }
    case kCacc: {
      break;
    }
    case kScgc: {
      if (_internal_has_scgc()) {
        if (!_impl_.scos_.scgc_->IsInitialized()) return false;
      }
      break;
    }
    case kScc: {
      if (_internal_has_scc()) {
        if (!_impl_.scos_.scc_->IsInitialized()) return false;
      }
      break;
    }
    case kStdc: {
      if (_internal_has_stdc()) {
        if (!_impl_.scos_.stdc_->IsInitialized()) return false;
      }
      break;
    }
    case kStdrcs: {
      if (_internal_has_stdrcs()) {
        if (!_impl_.scos_.stdrcs_->IsInitialized()) return false;
      }
      break;
    }
    case kSsclc: {
      if (_internal_has_ssclc()) {
        if (!_impl_.scos_.ssclc_->IsInitialized()) return false;
      }
      break;
    }
    case kSscuc: {
      if (_internal_has_sscuc()) {
        if (!_impl_.scos_.sscuc_->IsInitialized()) return false;
      }
      break;
    }
    case kSes: {
      if (_internal_has_ses()) {
        if (!_impl_.scos_.ses_->IsInitialized()) return false;
      }
      break;
    }
    case SCOS_NOT_SET: {
      break;
    }
  }
  return true;
}

void SdcCommandObjSyn::InternalSwap(SdcCommandObjSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SdcCommandObjSyn, _impl_.type_)
      + sizeof(SdcCommandObjSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SdcCommandObjSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.scos_, other->_impl_.scos_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcCommandObjSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[24]);
}

// ===================================================================

class SdcConstrainClass::_Internal {
 public:
  using HasBits = decltype(std::declval<SdcConstrainClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void SdcConstrainClass::clear__sdc_clocks() {
  _impl_._sdc_clocks_.Clear();
}
SdcConstrainClass::SdcConstrainClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Sdc.SdcConstrainClass)
}
SdcConstrainClass::SdcConstrainClass(const SdcConstrainClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdcConstrainClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._sdc_clocks_){from._impl_._sdc_clocks_}
    , decltype(_impl_._sdc_io_constraints_){from._impl_._sdc_io_constraints_}
    , decltype(_impl_._sdc_timing_derates_){from._impl_._sdc_timing_derates_}
    , decltype(_impl_._sdc_timing_drcs_){from._impl_._sdc_timing_drcs_}
    , decltype(_impl_._sdc_clock_latencys_){from._impl_._sdc_clock_latencys_}
    , decltype(_impl_._sdc_clock_uncertaintys_){from._impl_._sdc_clock_uncertaintys_}
    , decltype(_impl_._sdc_clock_groups_){from._impl_._sdc_clock_groups_}
    , decltype(_impl_._sdc_exceptions_){from._impl_._sdc_exceptions_}
    , decltype(_impl_._sdc_collections_){from._impl_._sdc_collections_}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Sdc.SdcConstrainClass)
}

inline void SdcConstrainClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._sdc_clocks_){arena}
    , decltype(_impl_._sdc_io_constraints_){arena}
    , decltype(_impl_._sdc_timing_derates_){arena}
    , decltype(_impl_._sdc_timing_drcs_){arena}
    , decltype(_impl_._sdc_clock_latencys_){arena}
    , decltype(_impl_._sdc_clock_uncertaintys_){arena}
    , decltype(_impl_._sdc_clock_groups_){arena}
    , decltype(_impl_._sdc_exceptions_){arena}
    , decltype(_impl_._sdc_collections_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
  };
}

SdcConstrainClass::~SdcConstrainClass() {
  // @@protoc_insertion_point(destructor:Sdc.SdcConstrainClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdcConstrainClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._sdc_clocks_.~RepeatedPtrField();
  _impl_._sdc_io_constraints_.~RepeatedField();
  _impl_._sdc_timing_derates_.~RepeatedField();
  _impl_._sdc_timing_drcs_.~RepeatedField();
  _impl_._sdc_clock_latencys_.~RepeatedField();
  _impl_._sdc_clock_uncertaintys_.~RepeatedField();
  _impl_._sdc_clock_groups_.~RepeatedField();
  _impl_._sdc_exceptions_.~RepeatedField();
  _impl_._sdc_collections_.~RepeatedField();
}

void SdcConstrainClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdcConstrainClass::Clear() {
// @@protoc_insertion_point(message_clear_start:Sdc.SdcConstrainClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._sdc_clocks_.Clear();
  _impl_._sdc_io_constraints_.Clear();
  _impl_._sdc_timing_derates_.Clear();
  _impl_._sdc_timing_drcs_.Clear();
  _impl_._sdc_clock_latencys_.Clear();
  _impl_._sdc_clock_uncertaintys_.Clear();
  _impl_._sdc_clock_groups_.Clear();
  _impl_._sdc_exceptions_.Clear();
  _impl_._sdc_collections_.Clear();
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdcConstrainClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.StrULongMap _sdc_clocks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__sdc_clocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_io_constraints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_io_constraints(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_io_constraints(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_timing_derates = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_timing_derates(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_timing_derates(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_timing_drcs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_timing_drcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_timing_drcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_clock_latencys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_clock_latencys(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_clock_latencys(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_clock_uncertaintys = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_clock_uncertaintys(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_clock_uncertaintys(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_clock_groups = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_clock_groups(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_clock_groups(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_exceptions = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_exceptions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<uint8_t>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_exceptions(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _sdc_collections = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__sdc_collections(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<80>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__sdc_collections(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdcConstrainClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sdc.SdcConstrainClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // repeated .Common.Types.StrULongMap _sdc_clocks = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__sdc_clocks_size()); i < n; i++) {
    const auto& repfield = this->_internal__sdc_clocks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint64 _sdc_io_constraints = 3;
  for (int i = 0, n = this->_internal__sdc_io_constraints_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__sdc_io_constraints(i), target);
  }

  // repeated uint64 _sdc_timing_derates = 4;
  for (int i = 0, n = this->_internal__sdc_timing_derates_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__sdc_timing_derates(i), target);
  }

  // repeated uint64 _sdc_timing_drcs = 5;
  for (int i = 0, n = this->_internal__sdc_timing_drcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__sdc_timing_drcs(i), target);
  }

  // repeated uint64 _sdc_clock_latencys = 6;
  for (int i = 0, n = this->_internal__sdc_clock_latencys_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal__sdc_clock_latencys(i), target);
  }

  // repeated uint64 _sdc_clock_uncertaintys = 7;
  for (int i = 0, n = this->_internal__sdc_clock_uncertaintys_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal__sdc_clock_uncertaintys(i), target);
  }

  // repeated uint64 _sdc_clock_groups = 8;
  for (int i = 0, n = this->_internal__sdc_clock_groups_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal__sdc_clock_groups(i), target);
  }

  // repeated uint64 _sdc_exceptions = 9;
  for (int i = 0, n = this->_internal__sdc_exceptions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal__sdc_exceptions(i), target);
  }

  // repeated uint64 _sdc_collections = 10;
  for (int i = 0, n = this->_internal__sdc_collections_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal__sdc_collections(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sdc.SdcConstrainClass)
  return target;
}

size_t SdcConstrainClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sdc.SdcConstrainClass)
  size_t total_size = 0;

  // required uint64 id = 1;
  if (_internal_has_id()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Common.Types.StrULongMap _sdc_clocks = 2;
  total_size += 1UL * this->_internal__sdc_clocks_size();
  for (const auto& msg : this->_impl_._sdc_clocks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint64 _sdc_io_constraints = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_io_constraints_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_io_constraints_size());
    total_size += data_size;
  }

  // repeated uint64 _sdc_timing_derates = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_timing_derates_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_timing_derates_size());
    total_size += data_size;
  }

  // repeated uint64 _sdc_timing_drcs = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_timing_drcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_timing_drcs_size());
    total_size += data_size;
  }

  // repeated uint64 _sdc_clock_latencys = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_clock_latencys_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_clock_latencys_size());
    total_size += data_size;
  }

  // repeated uint64 _sdc_clock_uncertaintys = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_clock_uncertaintys_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_clock_uncertaintys_size());
    total_size += data_size;
  }

  // repeated uint64 _sdc_clock_groups = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_clock_groups_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_clock_groups_size());
    total_size += data_size;
  }

  // repeated uint64 _sdc_exceptions = 9;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_exceptions_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_exceptions_size());
    total_size += data_size;
  }

  // repeated uint64 _sdc_collections = 10;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._sdc_collections_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__sdc_collections_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdcConstrainClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdcConstrainClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdcConstrainClass::GetClassData() const { return &_class_data_; }


void SdcConstrainClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdcConstrainClass*>(&to_msg);
  auto& from = static_cast<const SdcConstrainClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Sdc.SdcConstrainClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._sdc_clocks_.MergeFrom(from._impl_._sdc_clocks_);
  _this->_impl_._sdc_io_constraints_.MergeFrom(from._impl_._sdc_io_constraints_);
  _this->_impl_._sdc_timing_derates_.MergeFrom(from._impl_._sdc_timing_derates_);
  _this->_impl_._sdc_timing_drcs_.MergeFrom(from._impl_._sdc_timing_drcs_);
  _this->_impl_._sdc_clock_latencys_.MergeFrom(from._impl_._sdc_clock_latencys_);
  _this->_impl_._sdc_clock_uncertaintys_.MergeFrom(from._impl_._sdc_clock_uncertaintys_);
  _this->_impl_._sdc_clock_groups_.MergeFrom(from._impl_._sdc_clock_groups_);
  _this->_impl_._sdc_exceptions_.MergeFrom(from._impl_._sdc_exceptions_);
  _this->_impl_._sdc_collections_.MergeFrom(from._impl_._sdc_collections_);
  if (from._internal_has_id()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdcConstrainClass::CopyFrom(const SdcConstrainClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sdc.SdcConstrainClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdcConstrainClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_._sdc_clocks_))
    return false;
  return true;
}

void SdcConstrainClass::InternalSwap(SdcConstrainClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._sdc_clocks_.InternalSwap(&other->_impl_._sdc_clocks_);
  _impl_._sdc_io_constraints_.InternalSwap(&other->_impl_._sdc_io_constraints_);
  _impl_._sdc_timing_derates_.InternalSwap(&other->_impl_._sdc_timing_derates_);
  _impl_._sdc_timing_drcs_.InternalSwap(&other->_impl_._sdc_timing_drcs_);
  _impl_._sdc_clock_latencys_.InternalSwap(&other->_impl_._sdc_clock_latencys_);
  _impl_._sdc_clock_uncertaintys_.InternalSwap(&other->_impl_._sdc_clock_uncertaintys_);
  _impl_._sdc_clock_groups_.InternalSwap(&other->_impl_._sdc_clock_groups_);
  _impl_._sdc_exceptions_.InternalSwap(&other->_impl_._sdc_exceptions_);
  _impl_._sdc_collections_.InternalSwap(&other->_impl_._sdc_collections_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdcConstrainClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_SdcConstrains_2eproto_getter, &descriptor_table_SdcConstrains_2eproto_once,
      file_level_metadata_SdcConstrains_2eproto[25]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Sdc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Sdc::SdcCommandObjClass*
Arena::CreateMaybeMessage< ::Sdc::SdcCommandObjClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcCommandObjClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcIOConstrainClass*
Arena::CreateMaybeMessage< ::Sdc::SdcIOConstrainClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcIOConstrainClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcSetInputTransitionClass*
Arena::CreateMaybeMessage< ::Sdc::SdcSetInputTransitionClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcSetInputTransitionClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcSetIODelayClass*
Arena::CreateMaybeMessage< ::Sdc::SdcSetIODelayClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcSetIODelayClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcSetLoadClass*
Arena::CreateMaybeMessage< ::Sdc::SdcSetLoadClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcSetLoadClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcIOConstrainSyn*
Arena::CreateMaybeMessage< ::Sdc::SdcIOConstrainSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcIOConstrainSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcClockClass*
Arena::CreateMaybeMessage< ::Sdc::SdcClockClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcClockClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcGenrateClockClass*
Arena::CreateMaybeMessage< ::Sdc::SdcGenrateClockClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcGenrateClockClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcClockSyn*
Arena::CreateMaybeMessage< ::Sdc::SdcClockSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcClockSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcAllClocksClass*
Arena::CreateMaybeMessage< ::Sdc::SdcAllClocksClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcAllClocksClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcClockGroupClass*
Arena::CreateMaybeMessage< ::Sdc::SdcClockGroupClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcClockGroupClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcClockGroupsClass*
Arena::CreateMaybeMessage< ::Sdc::SdcClockGroupsClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcClockGroupsClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcCollectionTypeEnum*
Arena::CreateMaybeMessage< ::Sdc::SdcCollectionTypeEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcCollectionTypeEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcCollectionClass*
Arena::CreateMaybeMessage< ::Sdc::SdcCollectionClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcCollectionClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcTimingDerateClass*
Arena::CreateMaybeMessage< ::Sdc::SdcTimingDerateClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcTimingDerateClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcTimingDRCClass*
Arena::CreateMaybeMessage< ::Sdc::SdcTimingDRCClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcTimingDRCClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcSetMaxTransitionClass*
Arena::CreateMaybeMessage< ::Sdc::SdcSetMaxTransitionClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcSetMaxTransitionClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcSetMaxCapacitanceClass*
Arena::CreateMaybeMessage< ::Sdc::SdcSetMaxCapacitanceClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcSetMaxCapacitanceClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcTimingDRCSyn*
Arena::CreateMaybeMessage< ::Sdc::SdcTimingDRCSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcTimingDRCSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcSetClockLatencyClass*
Arena::CreateMaybeMessage< ::Sdc::SdcSetClockLatencyClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcSetClockLatencyClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcSetClockUncertaintyClass*
Arena::CreateMaybeMessage< ::Sdc::SdcSetClockUncertaintyClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcSetClockUncertaintyClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcExceptionClass*
Arena::CreateMaybeMessage< ::Sdc::SdcExceptionClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcExceptionClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcMulticyclePathClass*
Arena::CreateMaybeMessage< ::Sdc::SdcMulticyclePathClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcMulticyclePathClass >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcExceptionSyn*
Arena::CreateMaybeMessage< ::Sdc::SdcExceptionSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcExceptionSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcCommandObjSyn*
Arena::CreateMaybeMessage< ::Sdc::SdcCommandObjSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcCommandObjSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::Sdc::SdcConstrainClass*
Arena::CreateMaybeMessage< ::Sdc::SdcConstrainClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sdc::SdcConstrainClass >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
