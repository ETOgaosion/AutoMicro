// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StaStructure.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_StaStructure_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_StaStructure_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommonTypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_StaStructure_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_StaStructure_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_StaStructure_2eproto;
namespace StaStructure {
class ClockTypeEnum;
struct ClockTypeEnumDefaultTypeInternal;
extern ClockTypeEnumDefaultTypeInternal _ClockTypeEnum_default_instance_;
class StaArcClass;
struct StaArcClassDefaultTypeInternal;
extern StaArcClassDefaultTypeInternal _StaArcClass_default_instance_;
class StaArcDelayDataClass;
struct StaArcDelayDataClassDefaultTypeInternal;
extern StaArcDelayDataClassDefaultTypeInternal _StaArcDelayDataClass_default_instance_;
class StaArcSyn;
struct StaArcSynDefaultTypeInternal;
extern StaArcSynDefaultTypeInternal _StaArcSyn_default_instance_;
class StaClockClass;
struct StaClockClassDefaultTypeInternal;
extern StaClockClassDefaultTypeInternal _StaClockClass_default_instance_;
class StaClockDataClass;
struct StaClockDataClassDefaultTypeInternal;
extern StaClockDataClassDefaultTypeInternal _StaClockDataClass_default_instance_;
class StaDataBucketClass;
struct StaDataBucketClassDefaultTypeInternal;
extern StaDataBucketClassDefaultTypeInternal _StaDataBucketClass_default_instance_;
class StaDataClass;
struct StaDataClassDefaultTypeInternal;
extern StaDataClassDefaultTypeInternal _StaDataClass_default_instance_;
class StaDataSyn;
struct StaDataSynDefaultTypeInternal;
extern StaDataSynDefaultTypeInternal _StaDataSyn_default_instance_;
class StaGraphClass;
struct StaGraphClassDefaultTypeInternal;
extern StaGraphClassDefaultTypeInternal _StaGraphClass_default_instance_;
class StaInstArcClass;
struct StaInstArcClassDefaultTypeInternal;
extern StaInstArcClassDefaultTypeInternal _StaInstArcClass_default_instance_;
class StaNetArcClass;
struct StaNetArcClassDefaultTypeInternal;
extern StaNetArcClassDefaultTypeInternal _StaNetArcClass_default_instance_;
class StaPathDelayDataClass;
struct StaPathDelayDataClassDefaultTypeInternal;
extern StaPathDelayDataClassDefaultTypeInternal _StaPathDelayDataClass_default_instance_;
class StaSlewDataClass;
struct StaSlewDataClassDefaultTypeInternal;
extern StaSlewDataClassDefaultTypeInternal _StaSlewDataClass_default_instance_;
class StaVertexClass;
struct StaVertexClassDefaultTypeInternal;
extern StaVertexClassDefaultTypeInternal _StaVertexClass_default_instance_;
class StaWaveFormClass;
struct StaWaveFormClassDefaultTypeInternal;
extern StaWaveFormClassDefaultTypeInternal _StaWaveFormClass_default_instance_;
}  // namespace StaStructure
PROTOBUF_NAMESPACE_OPEN
template<> ::StaStructure::ClockTypeEnum* Arena::CreateMaybeMessage<::StaStructure::ClockTypeEnum>(Arena*);
template<> ::StaStructure::StaArcClass* Arena::CreateMaybeMessage<::StaStructure::StaArcClass>(Arena*);
template<> ::StaStructure::StaArcDelayDataClass* Arena::CreateMaybeMessage<::StaStructure::StaArcDelayDataClass>(Arena*);
template<> ::StaStructure::StaArcSyn* Arena::CreateMaybeMessage<::StaStructure::StaArcSyn>(Arena*);
template<> ::StaStructure::StaClockClass* Arena::CreateMaybeMessage<::StaStructure::StaClockClass>(Arena*);
template<> ::StaStructure::StaClockDataClass* Arena::CreateMaybeMessage<::StaStructure::StaClockDataClass>(Arena*);
template<> ::StaStructure::StaDataBucketClass* Arena::CreateMaybeMessage<::StaStructure::StaDataBucketClass>(Arena*);
template<> ::StaStructure::StaDataClass* Arena::CreateMaybeMessage<::StaStructure::StaDataClass>(Arena*);
template<> ::StaStructure::StaDataSyn* Arena::CreateMaybeMessage<::StaStructure::StaDataSyn>(Arena*);
template<> ::StaStructure::StaGraphClass* Arena::CreateMaybeMessage<::StaStructure::StaGraphClass>(Arena*);
template<> ::StaStructure::StaInstArcClass* Arena::CreateMaybeMessage<::StaStructure::StaInstArcClass>(Arena*);
template<> ::StaStructure::StaNetArcClass* Arena::CreateMaybeMessage<::StaStructure::StaNetArcClass>(Arena*);
template<> ::StaStructure::StaPathDelayDataClass* Arena::CreateMaybeMessage<::StaStructure::StaPathDelayDataClass>(Arena*);
template<> ::StaStructure::StaSlewDataClass* Arena::CreateMaybeMessage<::StaStructure::StaSlewDataClass>(Arena*);
template<> ::StaStructure::StaVertexClass* Arena::CreateMaybeMessage<::StaStructure::StaVertexClass>(Arena*);
template<> ::StaStructure::StaWaveFormClass* Arena::CreateMaybeMessage<::StaStructure::StaWaveFormClass>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace StaStructure {

enum ClockTypeEnum_ClockType : int {
  ClockTypeEnum_ClockType_kIdeal = 0,
  ClockTypeEnum_ClockType_kPropageted = 1
};
bool ClockTypeEnum_ClockType_IsValid(int value);
constexpr ClockTypeEnum_ClockType ClockTypeEnum_ClockType_ClockType_MIN = ClockTypeEnum_ClockType_kIdeal;
constexpr ClockTypeEnum_ClockType ClockTypeEnum_ClockType_ClockType_MAX = ClockTypeEnum_ClockType_kPropageted;
constexpr int ClockTypeEnum_ClockType_ClockType_ARRAYSIZE = ClockTypeEnum_ClockType_ClockType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClockTypeEnum_ClockType_descriptor();
template<typename T>
inline const std::string& ClockTypeEnum_ClockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClockTypeEnum_ClockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClockTypeEnum_ClockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClockTypeEnum_ClockType_descriptor(), enum_t_value);
}
inline bool ClockTypeEnum_ClockType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClockTypeEnum_ClockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClockTypeEnum_ClockType>(
    ClockTypeEnum_ClockType_descriptor(), name, value);
}
// ===================================================================

class ClockTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.ClockTypeEnum) */ {
 public:
  inline ClockTypeEnum() : ClockTypeEnum(nullptr) {}
  ~ClockTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR ClockTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClockTypeEnum(const ClockTypeEnum& from);
  ClockTypeEnum(ClockTypeEnum&& from) noexcept
    : ClockTypeEnum() {
    *this = ::std::move(from);
  }

  inline ClockTypeEnum& operator=(const ClockTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClockTypeEnum& operator=(ClockTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClockTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClockTypeEnum* internal_default_instance() {
    return reinterpret_cast<const ClockTypeEnum*>(
               &_ClockTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClockTypeEnum& a, ClockTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(ClockTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClockTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClockTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClockTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClockTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClockTypeEnum& from) {
    ClockTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClockTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.ClockTypeEnum";
  }
  protected:
  explicit ClockTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClockTypeEnum_ClockType ClockType;
  static constexpr ClockType kIdeal =
    ClockTypeEnum_ClockType_kIdeal;
  static constexpr ClockType kPropageted =
    ClockTypeEnum_ClockType_kPropageted;
  static inline bool ClockType_IsValid(int value) {
    return ClockTypeEnum_ClockType_IsValid(value);
  }
  static constexpr ClockType ClockType_MIN =
    ClockTypeEnum_ClockType_ClockType_MIN;
  static constexpr ClockType ClockType_MAX =
    ClockTypeEnum_ClockType_ClockType_MAX;
  static constexpr int ClockType_ARRAYSIZE =
    ClockTypeEnum_ClockType_ClockType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ClockType_descriptor() {
    return ClockTypeEnum_ClockType_descriptor();
  }
  template<typename T>
  static inline const std::string& ClockType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ClockType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ClockType_Name.");
    return ClockTypeEnum_ClockType_Name(enum_t_value);
  }
  static inline bool ClockType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ClockType* value) {
    return ClockTypeEnum_ClockType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCtFieldNumber = 1,
  };
  // required .StaStructure.ClockTypeEnum.ClockType ct = 1;
  bool has_ct() const;
  private:
  bool _internal_has_ct() const;
  public:
  void clear_ct();
  ::StaStructure::ClockTypeEnum_ClockType ct() const;
  void set_ct(::StaStructure::ClockTypeEnum_ClockType value);
  private:
  ::StaStructure::ClockTypeEnum_ClockType _internal_ct() const;
  void _internal_set_ct(::StaStructure::ClockTypeEnum_ClockType value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.ClockTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int ct_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaWaveFormClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaWaveFormClass) */ {
 public:
  inline StaWaveFormClass() : StaWaveFormClass(nullptr) {}
  ~StaWaveFormClass() override;
  explicit PROTOBUF_CONSTEXPR StaWaveFormClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaWaveFormClass(const StaWaveFormClass& from);
  StaWaveFormClass(StaWaveFormClass&& from) noexcept
    : StaWaveFormClass() {
    *this = ::std::move(from);
  }

  inline StaWaveFormClass& operator=(const StaWaveFormClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaWaveFormClass& operator=(StaWaveFormClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaWaveFormClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaWaveFormClass* internal_default_instance() {
    return reinterpret_cast<const StaWaveFormClass*>(
               &_StaWaveFormClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StaWaveFormClass& a, StaWaveFormClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaWaveFormClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaWaveFormClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaWaveFormClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaWaveFormClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaWaveFormClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaWaveFormClass& from) {
    StaWaveFormClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaWaveFormClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaWaveFormClass";
  }
  protected:
  explicit StaWaveFormClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaveEdgesFieldNumber = 1,
  };
  // repeated int32 _wave_edges = 1;
  int _wave_edges_size() const;
  private:
  int _internal__wave_edges_size() const;
  public:
  void clear__wave_edges();
  private:
  int32_t _internal__wave_edges(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal__wave_edges() const;
  void _internal_add__wave_edges(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable__wave_edges();
  public:
  int32_t _wave_edges(int index) const;
  void set__wave_edges(int index, int32_t value);
  void add__wave_edges(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _wave_edges() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable__wave_edges();

  // @@protoc_insertion_point(class_scope:StaStructure.StaWaveFormClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > _wave_edges_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaClockClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaClockClass) */ {
 public:
  inline StaClockClass() : StaClockClass(nullptr) {}
  ~StaClockClass() override;
  explicit PROTOBUF_CONSTEXPR StaClockClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaClockClass(const StaClockClass& from);
  StaClockClass(StaClockClass&& from) noexcept
    : StaClockClass() {
    *this = ::std::move(from);
  }

  inline StaClockClass& operator=(const StaClockClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaClockClass& operator=(StaClockClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaClockClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaClockClass* internal_default_instance() {
    return reinterpret_cast<const StaClockClass*>(
               &_StaClockClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StaClockClass& a, StaClockClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaClockClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaClockClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaClockClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaClockClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaClockClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaClockClass& from) {
    StaClockClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaClockClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaClockClass";
  }
  protected:
  explicit StaClockClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClockVertexesFieldNumber = 3,
    kClockNameFieldNumber = 2,
    kClockTypeFieldNumber = 4,
    kWaveFormFieldNumber = 7,
    kIdFieldNumber = 1,
    kIdealNetworkLatencyFieldNumber = 5,
    kPeriodFieldNumber = 6,
  };
  // repeated uint64 _clock_vertexes = 3;
  int _clock_vertexes_size() const;
  private:
  int _internal__clock_vertexes_size() const;
  public:
  void clear__clock_vertexes();
  private:
  uint64_t _internal__clock_vertexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__clock_vertexes() const;
  void _internal_add__clock_vertexes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__clock_vertexes();
  public:
  uint64_t _clock_vertexes(int index) const;
  void set__clock_vertexes(int index, uint64_t value);
  void add__clock_vertexes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _clock_vertexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__clock_vertexes();

  // required string _clock_name = 2;
  bool has__clock_name() const;
  private:
  bool _internal_has__clock_name() const;
  public:
  void clear__clock_name();
  const std::string& _clock_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__clock_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__clock_name();
  PROTOBUF_NODISCARD std::string* release__clock_name();
  void set_allocated__clock_name(std::string* _clock_name);
  private:
  const std::string& _internal__clock_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__clock_name(const std::string& value);
  std::string* _internal_mutable__clock_name();
  public:

  // required .StaStructure.ClockTypeEnum _clock_type = 4;
  bool has__clock_type() const;
  private:
  bool _internal_has__clock_type() const;
  public:
  void clear__clock_type();
  const ::StaStructure::ClockTypeEnum& _clock_type() const;
  PROTOBUF_NODISCARD ::StaStructure::ClockTypeEnum* release__clock_type();
  ::StaStructure::ClockTypeEnum* mutable__clock_type();
  void set_allocated__clock_type(::StaStructure::ClockTypeEnum* _clock_type);
  private:
  const ::StaStructure::ClockTypeEnum& _internal__clock_type() const;
  ::StaStructure::ClockTypeEnum* _internal_mutable__clock_type();
  public:
  void unsafe_arena_set_allocated__clock_type(
      ::StaStructure::ClockTypeEnum* _clock_type);
  ::StaStructure::ClockTypeEnum* unsafe_arena_release__clock_type();

  // required .StaStructure.StaWaveFormClass _wave_form = 7;
  bool has__wave_form() const;
  private:
  bool _internal_has__wave_form() const;
  public:
  void clear__wave_form();
  const ::StaStructure::StaWaveFormClass& _wave_form() const;
  PROTOBUF_NODISCARD ::StaStructure::StaWaveFormClass* release__wave_form();
  ::StaStructure::StaWaveFormClass* mutable__wave_form();
  void set_allocated__wave_form(::StaStructure::StaWaveFormClass* _wave_form);
  private:
  const ::StaStructure::StaWaveFormClass& _internal__wave_form() const;
  ::StaStructure::StaWaveFormClass* _internal_mutable__wave_form();
  public:
  void unsafe_arena_set_allocated__wave_form(
      ::StaStructure::StaWaveFormClass* _wave_form);
  ::StaStructure::StaWaveFormClass* unsafe_arena_release__wave_form();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional int32 _ideal_network_latency = 5;
  bool has__ideal_network_latency() const;
  private:
  bool _internal_has__ideal_network_latency() const;
  public:
  void clear__ideal_network_latency();
  int32_t _ideal_network_latency() const;
  void set__ideal_network_latency(int32_t value);
  private:
  int32_t _internal__ideal_network_latency() const;
  void _internal_set__ideal_network_latency(int32_t value);
  public:

  // required int32 _period = 6;
  bool has__period() const;
  private:
  bool _internal_has__period() const;
  public:
  void clear__period();
  int32_t _period() const;
  void set__period(int32_t value);
  private:
  int32_t _internal__period() const;
  void _internal_set__period(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaClockClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _clock_vertexes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _clock_name_;
    ::StaStructure::ClockTypeEnum* _clock_type_;
    ::StaStructure::StaWaveFormClass* _wave_form_;
    uint64_t id_;
    int32_t _ideal_network_latency_;
    int32_t _period_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaDataClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaDataClass) */ {
 public:
  inline StaDataClass() : StaDataClass(nullptr) {}
  ~StaDataClass() override;
  explicit PROTOBUF_CONSTEXPR StaDataClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaDataClass(const StaDataClass& from);
  StaDataClass(StaDataClass&& from) noexcept
    : StaDataClass() {
    *this = ::std::move(from);
  }

  inline StaDataClass& operator=(const StaDataClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaDataClass& operator=(StaDataClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaDataClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaDataClass* internal_default_instance() {
    return reinterpret_cast<const StaDataClass*>(
               &_StaDataClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StaDataClass& a, StaDataClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaDataClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaDataClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaDataClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaDataClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaDataClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaDataClass& from) {
    StaDataClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaDataClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaDataClass";
  }
  protected:
  explicit StaDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelayTypeFieldNumber = 1,
    kTransTypeFieldNumber = 2,
    kOwnVertexFieldNumber = 3,
    kFwdFieldNumber = 4,
    kBwdFieldNumber = 5,
  };
  // required .Common.Types.AnalysisModeEnum _delay_type = 1;
  bool has__delay_type() const;
  private:
  bool _internal_has__delay_type() const;
  public:
  void clear__delay_type();
  const ::Common::Types::AnalysisModeEnum& _delay_type() const;
  PROTOBUF_NODISCARD ::Common::Types::AnalysisModeEnum* release__delay_type();
  ::Common::Types::AnalysisModeEnum* mutable__delay_type();
  void set_allocated__delay_type(::Common::Types::AnalysisModeEnum* _delay_type);
  private:
  const ::Common::Types::AnalysisModeEnum& _internal__delay_type() const;
  ::Common::Types::AnalysisModeEnum* _internal_mutable__delay_type();
  public:
  void unsafe_arena_set_allocated__delay_type(
      ::Common::Types::AnalysisModeEnum* _delay_type);
  ::Common::Types::AnalysisModeEnum* unsafe_arena_release__delay_type();

  // required .Common.Types.TransTypeEnum _trans_type = 2;
  bool has__trans_type() const;
  private:
  bool _internal_has__trans_type() const;
  public:
  void clear__trans_type();
  const ::Common::Types::TransTypeEnum& _trans_type() const;
  PROTOBUF_NODISCARD ::Common::Types::TransTypeEnum* release__trans_type();
  ::Common::Types::TransTypeEnum* mutable__trans_type();
  void set_allocated__trans_type(::Common::Types::TransTypeEnum* _trans_type);
  private:
  const ::Common::Types::TransTypeEnum& _internal__trans_type() const;
  ::Common::Types::TransTypeEnum* _internal_mutable__trans_type();
  public:
  void unsafe_arena_set_allocated__trans_type(
      ::Common::Types::TransTypeEnum* _trans_type);
  ::Common::Types::TransTypeEnum* unsafe_arena_release__trans_type();

  // required uint64 _own_vertex = 3;
  bool has__own_vertex() const;
  private:
  bool _internal_has__own_vertex() const;
  public:
  void clear__own_vertex();
  uint64_t _own_vertex() const;
  void set__own_vertex(uint64_t value);
  private:
  uint64_t _internal__own_vertex() const;
  void _internal_set__own_vertex(uint64_t value);
  public:

  // required uint64 _fwd = 4;
  bool has__fwd() const;
  private:
  bool _internal_has__fwd() const;
  public:
  void clear__fwd();
  uint64_t _fwd() const;
  void set__fwd(uint64_t value);
  private:
  uint64_t _internal__fwd() const;
  void _internal_set__fwd(uint64_t value);
  public:

  // required uint64 _bwd = 5;
  bool has__bwd() const;
  private:
  bool _internal_has__bwd() const;
  public:
  void clear__bwd();
  uint64_t _bwd() const;
  void set__bwd(uint64_t value);
  private:
  uint64_t _internal__bwd() const;
  void _internal_set__bwd(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaDataClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Common::Types::AnalysisModeEnum* _delay_type_;
    ::Common::Types::TransTypeEnum* _trans_type_;
    uint64_t _own_vertex_;
    uint64_t _fwd_;
    uint64_t _bwd_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaSlewDataClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaSlewDataClass) */ {
 public:
  inline StaSlewDataClass() : StaSlewDataClass(nullptr) {}
  ~StaSlewDataClass() override;
  explicit PROTOBUF_CONSTEXPR StaSlewDataClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaSlewDataClass(const StaSlewDataClass& from);
  StaSlewDataClass(StaSlewDataClass&& from) noexcept
    : StaSlewDataClass() {
    *this = ::std::move(from);
  }

  inline StaSlewDataClass& operator=(const StaSlewDataClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaSlewDataClass& operator=(StaSlewDataClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaSlewDataClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaSlewDataClass* internal_default_instance() {
    return reinterpret_cast<const StaSlewDataClass*>(
               &_StaSlewDataClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StaSlewDataClass& a, StaSlewDataClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaSlewDataClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaSlewDataClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaSlewDataClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaSlewDataClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaSlewDataClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaSlewDataClass& from) {
    StaSlewDataClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaSlewDataClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaSlewDataClass";
  }
  protected:
  explicit StaSlewDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputCurrentDataFieldNumber = 2,
    kSlewFieldNumber = 1,
  };
  // optional uint64 _output_current_data = 2;
  bool has__output_current_data() const;
  private:
  bool _internal_has__output_current_data() const;
  public:
  void clear__output_current_data();
  uint64_t _output_current_data() const;
  void set__output_current_data(uint64_t value);
  private:
  uint64_t _internal__output_current_data() const;
  void _internal_set__output_current_data(uint64_t value);
  public:

  // required int32 _slew = 1;
  bool has__slew() const;
  private:
  bool _internal_has__slew() const;
  public:
  void clear__slew();
  int32_t _slew() const;
  void set__slew(int32_t value);
  private:
  int32_t _internal__slew() const;
  void _internal_set__slew(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaSlewDataClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t _output_current_data_;
    int32_t _slew_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaArcDelayDataClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaArcDelayDataClass) */ {
 public:
  inline StaArcDelayDataClass() : StaArcDelayDataClass(nullptr) {}
  ~StaArcDelayDataClass() override;
  explicit PROTOBUF_CONSTEXPR StaArcDelayDataClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaArcDelayDataClass(const StaArcDelayDataClass& from);
  StaArcDelayDataClass(StaArcDelayDataClass&& from) noexcept
    : StaArcDelayDataClass() {
    *this = ::std::move(from);
  }

  inline StaArcDelayDataClass& operator=(const StaArcDelayDataClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaArcDelayDataClass& operator=(StaArcDelayDataClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaArcDelayDataClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaArcDelayDataClass* internal_default_instance() {
    return reinterpret_cast<const StaArcDelayDataClass*>(
               &_StaArcDelayDataClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StaArcDelayDataClass& a, StaArcDelayDataClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaArcDelayDataClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaArcDelayDataClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaArcDelayDataClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaArcDelayDataClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaArcDelayDataClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaArcDelayDataClass& from) {
    StaArcDelayDataClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaArcDelayDataClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaArcDelayDataClass";
  }
  protected:
  explicit StaArcDelayDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnArcFieldNumber = 2,
    kArcDelayFieldNumber = 1,
  };
  // required uint64 _own_arc = 2;
  bool has__own_arc() const;
  private:
  bool _internal_has__own_arc() const;
  public:
  void clear__own_arc();
  uint64_t _own_arc() const;
  void set__own_arc(uint64_t value);
  private:
  uint64_t _internal__own_arc() const;
  void _internal_set__own_arc(uint64_t value);
  public:

  // required int32 _arc_delay = 1;
  bool has__arc_delay() const;
  private:
  bool _internal_has__arc_delay() const;
  public:
  void clear__arc_delay();
  int32_t _arc_delay() const;
  void set__arc_delay(int32_t value);
  private:
  int32_t _internal__arc_delay() const;
  void _internal_set__arc_delay(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaArcDelayDataClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t _own_arc_;
    int32_t _arc_delay_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaPathDelayDataClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaPathDelayDataClass) */ {
 public:
  inline StaPathDelayDataClass() : StaPathDelayDataClass(nullptr) {}
  ~StaPathDelayDataClass() override;
  explicit PROTOBUF_CONSTEXPR StaPathDelayDataClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaPathDelayDataClass(const StaPathDelayDataClass& from);
  StaPathDelayDataClass(StaPathDelayDataClass&& from) noexcept
    : StaPathDelayDataClass() {
    *this = ::std::move(from);
  }

  inline StaPathDelayDataClass& operator=(const StaPathDelayDataClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaPathDelayDataClass& operator=(StaPathDelayDataClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaPathDelayDataClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaPathDelayDataClass* internal_default_instance() {
    return reinterpret_cast<const StaPathDelayDataClass*>(
               &_StaPathDelayDataClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StaPathDelayDataClass& a, StaPathDelayDataClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaPathDelayDataClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaPathDelayDataClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaPathDelayDataClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaPathDelayDataClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaPathDelayDataClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaPathDelayDataClass& from) {
    StaPathDelayDataClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaPathDelayDataClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaPathDelayDataClass";
  }
  protected:
  explicit StaPathDelayDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArriveTimeFieldNumber = 1,
    kLaunchClockDataFieldNumber = 3,
    kReqTimeFieldNumber = 2,
  };
  // required int64 _arrive_time = 1;
  bool has__arrive_time() const;
  private:
  bool _internal_has__arrive_time() const;
  public:
  void clear__arrive_time();
  int64_t _arrive_time() const;
  void set__arrive_time(int64_t value);
  private:
  int64_t _internal__arrive_time() const;
  void _internal_set__arrive_time(int64_t value);
  public:

  // required uint64 _launch_clock_data = 3;
  bool has__launch_clock_data() const;
  private:
  bool _internal_has__launch_clock_data() const;
  public:
  void clear__launch_clock_data();
  uint64_t _launch_clock_data() const;
  void set__launch_clock_data(uint64_t value);
  private:
  uint64_t _internal__launch_clock_data() const;
  void _internal_set__launch_clock_data(uint64_t value);
  public:

  // optional int32 _req_time = 2;
  bool has__req_time() const;
  private:
  bool _internal_has__req_time() const;
  public:
  void clear__req_time();
  int32_t _req_time() const;
  void set__req_time(int32_t value);
  private:
  int32_t _internal__req_time() const;
  void _internal_set__req_time(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaPathDelayDataClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t _arrive_time_;
    uint64_t _launch_clock_data_;
    int32_t _req_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaClockDataClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaClockDataClass) */ {
 public:
  inline StaClockDataClass() : StaClockDataClass(nullptr) {}
  ~StaClockDataClass() override;
  explicit PROTOBUF_CONSTEXPR StaClockDataClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaClockDataClass(const StaClockDataClass& from);
  StaClockDataClass(StaClockDataClass&& from) noexcept
    : StaClockDataClass() {
    *this = ::std::move(from);
  }

  inline StaClockDataClass& operator=(const StaClockDataClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaClockDataClass& operator=(StaClockDataClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaClockDataClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaClockDataClass* internal_default_instance() {
    return reinterpret_cast<const StaClockDataClass*>(
               &_StaClockDataClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StaClockDataClass& a, StaClockDataClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaClockDataClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaClockDataClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaClockDataClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaClockDataClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaClockDataClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaClockDataClass& from) {
    StaClockDataClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaClockDataClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaClockDataClass";
  }
  protected:
  explicit StaClockDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClockWaveTypeFieldNumber = 3,
    kArriveTimeFieldNumber = 1,
    kPropClockFieldNumber = 2,
  };
  // required .Common.Types.TransTypeEnum _clock_wave_type = 3;
  bool has__clock_wave_type() const;
  private:
  bool _internal_has__clock_wave_type() const;
  public:
  void clear__clock_wave_type();
  const ::Common::Types::TransTypeEnum& _clock_wave_type() const;
  PROTOBUF_NODISCARD ::Common::Types::TransTypeEnum* release__clock_wave_type();
  ::Common::Types::TransTypeEnum* mutable__clock_wave_type();
  void set_allocated__clock_wave_type(::Common::Types::TransTypeEnum* _clock_wave_type);
  private:
  const ::Common::Types::TransTypeEnum& _internal__clock_wave_type() const;
  ::Common::Types::TransTypeEnum* _internal_mutable__clock_wave_type();
  public:
  void unsafe_arena_set_allocated__clock_wave_type(
      ::Common::Types::TransTypeEnum* _clock_wave_type);
  ::Common::Types::TransTypeEnum* unsafe_arena_release__clock_wave_type();

  // required int64 _arrive_time = 1;
  bool has__arrive_time() const;
  private:
  bool _internal_has__arrive_time() const;
  public:
  void clear__arrive_time();
  int64_t _arrive_time() const;
  void set__arrive_time(int64_t value);
  private:
  int64_t _internal__arrive_time() const;
  void _internal_set__arrive_time(int64_t value);
  public:

  // required uint64 _prop_clock = 2;
  bool has__prop_clock() const;
  private:
  bool _internal_has__prop_clock() const;
  public:
  void clear__prop_clock();
  uint64_t _prop_clock() const;
  void set__prop_clock(uint64_t value);
  private:
  uint64_t _internal__prop_clock() const;
  void _internal_set__prop_clock(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaClockDataClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Common::Types::TransTypeEnum* _clock_wave_type_;
    int64_t _arrive_time_;
    uint64_t _prop_clock_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaDataSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaDataSyn) */ {
 public:
  inline StaDataSyn() : StaDataSyn(nullptr) {}
  ~StaDataSyn() override;
  explicit PROTOBUF_CONSTEXPR StaDataSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaDataSyn(const StaDataSyn& from);
  StaDataSyn(StaDataSyn&& from) noexcept
    : StaDataSyn() {
    *this = ::std::move(from);
  }

  inline StaDataSyn& operator=(const StaDataSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaDataSyn& operator=(StaDataSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaDataSyn& default_instance() {
    return *internal_default_instance();
  }
  enum SdsCase {
    kSsdc = 4,
    kSaddc = 5,
    kSpddc = 6,
    kScdc = 7,
    SDS_NOT_SET = 0,
  };

  static inline const StaDataSyn* internal_default_instance() {
    return reinterpret_cast<const StaDataSyn*>(
               &_StaDataSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StaDataSyn& a, StaDataSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(StaDataSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaDataSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaDataSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaDataSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaDataSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaDataSyn& from) {
    StaDataSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaDataSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaDataSyn";
  }
  protected:
  explicit StaDataSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kSsdcFieldNumber = 4,
    kSaddcFieldNumber = 5,
    kSpddcFieldNumber = 6,
    kScdcFieldNumber = 7,
  };
  // required .StaStructure.StaDataClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::StaStructure::StaDataClass& parent() const;
  PROTOBUF_NODISCARD ::StaStructure::StaDataClass* release_parent();
  ::StaStructure::StaDataClass* mutable_parent();
  void set_allocated_parent(::StaStructure::StaDataClass* parent);
  private:
  const ::StaStructure::StaDataClass& _internal_parent() const;
  ::StaStructure::StaDataClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::StaStructure::StaDataClass* parent);
  ::StaStructure::StaDataClass* unsafe_arena_release_parent();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .StaStructure.StaSlewDataClass ssdc = 4;
  bool has_ssdc() const;
  private:
  bool _internal_has_ssdc() const;
  public:
  void clear_ssdc();
  const ::StaStructure::StaSlewDataClass& ssdc() const;
  PROTOBUF_NODISCARD ::StaStructure::StaSlewDataClass* release_ssdc();
  ::StaStructure::StaSlewDataClass* mutable_ssdc();
  void set_allocated_ssdc(::StaStructure::StaSlewDataClass* ssdc);
  private:
  const ::StaStructure::StaSlewDataClass& _internal_ssdc() const;
  ::StaStructure::StaSlewDataClass* _internal_mutable_ssdc();
  public:
  void unsafe_arena_set_allocated_ssdc(
      ::StaStructure::StaSlewDataClass* ssdc);
  ::StaStructure::StaSlewDataClass* unsafe_arena_release_ssdc();

  // .StaStructure.StaArcDelayDataClass saddc = 5;
  bool has_saddc() const;
  private:
  bool _internal_has_saddc() const;
  public:
  void clear_saddc();
  const ::StaStructure::StaArcDelayDataClass& saddc() const;
  PROTOBUF_NODISCARD ::StaStructure::StaArcDelayDataClass* release_saddc();
  ::StaStructure::StaArcDelayDataClass* mutable_saddc();
  void set_allocated_saddc(::StaStructure::StaArcDelayDataClass* saddc);
  private:
  const ::StaStructure::StaArcDelayDataClass& _internal_saddc() const;
  ::StaStructure::StaArcDelayDataClass* _internal_mutable_saddc();
  public:
  void unsafe_arena_set_allocated_saddc(
      ::StaStructure::StaArcDelayDataClass* saddc);
  ::StaStructure::StaArcDelayDataClass* unsafe_arena_release_saddc();

  // .StaStructure.StaPathDelayDataClass spddc = 6;
  bool has_spddc() const;
  private:
  bool _internal_has_spddc() const;
  public:
  void clear_spddc();
  const ::StaStructure::StaPathDelayDataClass& spddc() const;
  PROTOBUF_NODISCARD ::StaStructure::StaPathDelayDataClass* release_spddc();
  ::StaStructure::StaPathDelayDataClass* mutable_spddc();
  void set_allocated_spddc(::StaStructure::StaPathDelayDataClass* spddc);
  private:
  const ::StaStructure::StaPathDelayDataClass& _internal_spddc() const;
  ::StaStructure::StaPathDelayDataClass* _internal_mutable_spddc();
  public:
  void unsafe_arena_set_allocated_spddc(
      ::StaStructure::StaPathDelayDataClass* spddc);
  ::StaStructure::StaPathDelayDataClass* unsafe_arena_release_spddc();

  // .StaStructure.StaClockDataClass scdc = 7;
  bool has_scdc() const;
  private:
  bool _internal_has_scdc() const;
  public:
  void clear_scdc();
  const ::StaStructure::StaClockDataClass& scdc() const;
  PROTOBUF_NODISCARD ::StaStructure::StaClockDataClass* release_scdc();
  ::StaStructure::StaClockDataClass* mutable_scdc();
  void set_allocated_scdc(::StaStructure::StaClockDataClass* scdc);
  private:
  const ::StaStructure::StaClockDataClass& _internal_scdc() const;
  ::StaStructure::StaClockDataClass* _internal_mutable_scdc();
  public:
  void unsafe_arena_set_allocated_scdc(
      ::StaStructure::StaClockDataClass* scdc);
  ::StaStructure::StaClockDataClass* unsafe_arena_release_scdc();

  void clear_sds();
  SdsCase sds_case() const;
  // @@protoc_insertion_point(class_scope:StaStructure.StaDataSyn)
 private:
  class _Internal;
  void set_has_ssdc();
  void set_has_saddc();
  void set_has_spddc();
  void set_has_scdc();

  inline bool has_sds() const;
  inline void clear_has_sds();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::StaStructure::StaDataClass* parent_;
    uint64_t id_;
    uint32_t type_;
    union SdsUnion {
      constexpr SdsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::StaStructure::StaSlewDataClass* ssdc_;
      ::StaStructure::StaArcDelayDataClass* saddc_;
      ::StaStructure::StaPathDelayDataClass* spddc_;
      ::StaStructure::StaClockDataClass* scdc_;
    } sds_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaDataBucketClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaDataBucketClass) */ {
 public:
  inline StaDataBucketClass() : StaDataBucketClass(nullptr) {}
  ~StaDataBucketClass() override;
  explicit PROTOBUF_CONSTEXPR StaDataBucketClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaDataBucketClass(const StaDataBucketClass& from);
  StaDataBucketClass(StaDataBucketClass&& from) noexcept
    : StaDataBucketClass() {
    *this = ::std::move(from);
  }

  inline StaDataBucketClass& operator=(const StaDataBucketClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaDataBucketClass& operator=(StaDataBucketClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaDataBucketClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaDataBucketClass* internal_default_instance() {
    return reinterpret_cast<const StaDataBucketClass*>(
               &_StaDataBucketClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StaDataBucketClass& a, StaDataBucketClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaDataBucketClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaDataBucketClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaDataBucketClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaDataBucketClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaDataBucketClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaDataBucketClass& from) {
    StaDataBucketClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaDataBucketClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaDataBucketClass";
  }
  protected:
  explicit StaDataBucketClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 2,
    kIdFieldNumber = 1,
    kNWorstFieldNumber = 3,
    kCountFieldNumber = 4,
    kNextFieldNumber = 5,
  };
  // repeated uint64 _data_list = 2;
  int _data_list_size() const;
  private:
  int _internal__data_list_size() const;
  public:
  void clear__data_list();
  private:
  uint64_t _internal__data_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__data_list() const;
  void _internal_add__data_list(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__data_list();
  public:
  uint64_t _data_list(int index) const;
  void set__data_list(int index, uint64_t value);
  void add__data_list(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _data_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__data_list();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 _n_worst = 3;
  bool has__n_worst() const;
  private:
  bool _internal_has__n_worst() const;
  public:
  void clear__n_worst();
  uint32_t _n_worst() const;
  void set__n_worst(uint32_t value);
  private:
  uint32_t _internal__n_worst() const;
  void _internal_set__n_worst(uint32_t value);
  public:

  // required uint32 _count = 4;
  bool has__count() const;
  private:
  bool _internal_has__count() const;
  public:
  void clear__count();
  uint32_t _count() const;
  void set__count(uint32_t value);
  private:
  uint32_t _internal__count() const;
  void _internal_set__count(uint32_t value);
  public:

  // required uint64 _next = 5;
  bool has__next() const;
  private:
  bool _internal_has__next() const;
  public:
  void clear__next();
  uint64_t _next() const;
  void set__next(uint64_t value);
  private:
  uint64_t _internal__next() const;
  void _internal_set__next(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaDataBucketClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _data_list_;
    uint64_t id_;
    uint32_t _n_worst_;
    uint32_t _count_;
    uint64_t _next_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaArcClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaArcClass) */ {
 public:
  inline StaArcClass() : StaArcClass(nullptr) {}
  ~StaArcClass() override;
  explicit PROTOBUF_CONSTEXPR StaArcClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaArcClass(const StaArcClass& from);
  StaArcClass(StaArcClass&& from) noexcept
    : StaArcClass() {
    *this = ::std::move(from);
  }

  inline StaArcClass& operator=(const StaArcClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaArcClass& operator=(StaArcClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaArcClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaArcClass* internal_default_instance() {
    return reinterpret_cast<const StaArcClass*>(
               &_StaArcClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StaArcClass& a, StaArcClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaArcClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaArcClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaArcClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaArcClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaArcClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaArcClass& from) {
    StaArcClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaArcClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaArcClass";
  }
  protected:
  explicit StaArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kSnkFieldNumber = 2,
    kArcDelayBucketFieldNumber = 3,
    kIsLoopDisableFieldNumber = 4,
  };
  // required uint64 _src = 1;
  bool has__src() const;
  private:
  bool _internal_has__src() const;
  public:
  void clear__src();
  uint64_t _src() const;
  void set__src(uint64_t value);
  private:
  uint64_t _internal__src() const;
  void _internal_set__src(uint64_t value);
  public:

  // required uint64 _snk = 2;
  bool has__snk() const;
  private:
  bool _internal_has__snk() const;
  public:
  void clear__snk();
  uint64_t _snk() const;
  void set__snk(uint64_t value);
  private:
  uint64_t _internal__snk() const;
  void _internal_set__snk(uint64_t value);
  public:

  // optional uint64 _arc_delay_bucket = 3;
  bool has__arc_delay_bucket() const;
  private:
  bool _internal_has__arc_delay_bucket() const;
  public:
  void clear__arc_delay_bucket();
  uint64_t _arc_delay_bucket() const;
  void set__arc_delay_bucket(uint64_t value);
  private:
  uint64_t _internal__arc_delay_bucket() const;
  void _internal_set__arc_delay_bucket(uint64_t value);
  public:

  // required bool _is_loop_disable = 4;
  bool has__is_loop_disable() const;
  private:
  bool _internal_has__is_loop_disable() const;
  public:
  void clear__is_loop_disable();
  bool _is_loop_disable() const;
  void set__is_loop_disable(bool value);
  private:
  bool _internal__is_loop_disable() const;
  void _internal_set__is_loop_disable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaArcClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t _src_;
    uint64_t _snk_;
    uint64_t _arc_delay_bucket_;
    bool _is_loop_disable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaNetArcClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaNetArcClass) */ {
 public:
  inline StaNetArcClass() : StaNetArcClass(nullptr) {}
  ~StaNetArcClass() override;
  explicit PROTOBUF_CONSTEXPR StaNetArcClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaNetArcClass(const StaNetArcClass& from);
  StaNetArcClass(StaNetArcClass&& from) noexcept
    : StaNetArcClass() {
    *this = ::std::move(from);
  }

  inline StaNetArcClass& operator=(const StaNetArcClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaNetArcClass& operator=(StaNetArcClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaNetArcClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaNetArcClass* internal_default_instance() {
    return reinterpret_cast<const StaNetArcClass*>(
               &_StaNetArcClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StaNetArcClass& a, StaNetArcClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaNetArcClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaNetArcClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaNetArcClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaNetArcClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaNetArcClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaNetArcClass& from) {
    StaNetArcClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaNetArcClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaNetArcClass";
  }
  protected:
  explicit StaNetArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
  };
  // required uint64 _net = 1;
  bool has__net() const;
  private:
  bool _internal_has__net() const;
  public:
  void clear__net();
  uint64_t _net() const;
  void set__net(uint64_t value);
  private:
  uint64_t _internal__net() const;
  void _internal_set__net(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaNetArcClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t _net_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaInstArcClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaInstArcClass) */ {
 public:
  inline StaInstArcClass() : StaInstArcClass(nullptr) {}
  ~StaInstArcClass() override;
  explicit PROTOBUF_CONSTEXPR StaInstArcClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaInstArcClass(const StaInstArcClass& from);
  StaInstArcClass(StaInstArcClass&& from) noexcept
    : StaInstArcClass() {
    *this = ::std::move(from);
  }

  inline StaInstArcClass& operator=(const StaInstArcClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaInstArcClass& operator=(StaInstArcClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaInstArcClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaInstArcClass* internal_default_instance() {
    return reinterpret_cast<const StaInstArcClass*>(
               &_StaInstArcClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StaInstArcClass& a, StaInstArcClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaInstArcClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaInstArcClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaInstArcClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaInstArcClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaInstArcClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaInstArcClass& from) {
    StaInstArcClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaInstArcClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaInstArcClass";
  }
  protected:
  explicit StaInstArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArcFieldNumber = 1,
    kInstFieldNumber = 2,
  };
  // required uint64 _arc = 1;
  bool has__arc() const;
  private:
  bool _internal_has__arc() const;
  public:
  void clear__arc();
  uint64_t _arc() const;
  void set__arc(uint64_t value);
  private:
  uint64_t _internal__arc() const;
  void _internal_set__arc(uint64_t value);
  public:

  // required uint64 _inst = 2;
  bool has__inst() const;
  private:
  bool _internal_has__inst() const;
  public:
  void clear__inst();
  uint64_t _inst() const;
  void set__inst(uint64_t value);
  private:
  uint64_t _internal__inst() const;
  void _internal_set__inst(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaInstArcClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t _arc_;
    uint64_t _inst_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaArcSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaArcSyn) */ {
 public:
  inline StaArcSyn() : StaArcSyn(nullptr) {}
  ~StaArcSyn() override;
  explicit PROTOBUF_CONSTEXPR StaArcSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaArcSyn(const StaArcSyn& from);
  StaArcSyn(StaArcSyn&& from) noexcept
    : StaArcSyn() {
    *this = ::std::move(from);
  }

  inline StaArcSyn& operator=(const StaArcSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaArcSyn& operator=(StaArcSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaArcSyn& default_instance() {
    return *internal_default_instance();
  }
  enum SasCase {
    kSnac = 4,
    kSiac = 5,
    SAS_NOT_SET = 0,
  };

  static inline const StaArcSyn* internal_default_instance() {
    return reinterpret_cast<const StaArcSyn*>(
               &_StaArcSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StaArcSyn& a, StaArcSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(StaArcSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaArcSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaArcSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaArcSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaArcSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaArcSyn& from) {
    StaArcSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaArcSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaArcSyn";
  }
  protected:
  explicit StaArcSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kSnacFieldNumber = 4,
    kSiacFieldNumber = 5,
  };
  // required .StaStructure.StaArcClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::StaStructure::StaArcClass& parent() const;
  PROTOBUF_NODISCARD ::StaStructure::StaArcClass* release_parent();
  ::StaStructure::StaArcClass* mutable_parent();
  void set_allocated_parent(::StaStructure::StaArcClass* parent);
  private:
  const ::StaStructure::StaArcClass& _internal_parent() const;
  ::StaStructure::StaArcClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::StaStructure::StaArcClass* parent);
  ::StaStructure::StaArcClass* unsafe_arena_release_parent();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .StaStructure.StaNetArcClass snac = 4;
  bool has_snac() const;
  private:
  bool _internal_has_snac() const;
  public:
  void clear_snac();
  const ::StaStructure::StaNetArcClass& snac() const;
  PROTOBUF_NODISCARD ::StaStructure::StaNetArcClass* release_snac();
  ::StaStructure::StaNetArcClass* mutable_snac();
  void set_allocated_snac(::StaStructure::StaNetArcClass* snac);
  private:
  const ::StaStructure::StaNetArcClass& _internal_snac() const;
  ::StaStructure::StaNetArcClass* _internal_mutable_snac();
  public:
  void unsafe_arena_set_allocated_snac(
      ::StaStructure::StaNetArcClass* snac);
  ::StaStructure::StaNetArcClass* unsafe_arena_release_snac();

  // .StaStructure.StaInstArcClass siac = 5;
  bool has_siac() const;
  private:
  bool _internal_has_siac() const;
  public:
  void clear_siac();
  const ::StaStructure::StaInstArcClass& siac() const;
  PROTOBUF_NODISCARD ::StaStructure::StaInstArcClass* release_siac();
  ::StaStructure::StaInstArcClass* mutable_siac();
  void set_allocated_siac(::StaStructure::StaInstArcClass* siac);
  private:
  const ::StaStructure::StaInstArcClass& _internal_siac() const;
  ::StaStructure::StaInstArcClass* _internal_mutable_siac();
  public:
  void unsafe_arena_set_allocated_siac(
      ::StaStructure::StaInstArcClass* siac);
  ::StaStructure::StaInstArcClass* unsafe_arena_release_siac();

  void clear_sas();
  SasCase sas_case() const;
  // @@protoc_insertion_point(class_scope:StaStructure.StaArcSyn)
 private:
  class _Internal;
  void set_has_snac();
  void set_has_siac();

  inline bool has_sas() const;
  inline void clear_has_sas();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::StaStructure::StaArcClass* parent_;
    uint64_t id_;
    uint32_t type_;
    union SasUnion {
      constexpr SasUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::StaStructure::StaNetArcClass* snac_;
      ::StaStructure::StaInstArcClass* siac_;
    } sas_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaVertexClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaVertexClass) */ {
 public:
  inline StaVertexClass() : StaVertexClass(nullptr) {}
  ~StaVertexClass() override;
  explicit PROTOBUF_CONSTEXPR StaVertexClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaVertexClass(const StaVertexClass& from);
  StaVertexClass(StaVertexClass&& from) noexcept
    : StaVertexClass() {
    *this = ::std::move(from);
  }

  inline StaVertexClass& operator=(const StaVertexClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaVertexClass& operator=(StaVertexClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaVertexClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaVertexClass* internal_default_instance() {
    return reinterpret_cast<const StaVertexClass*>(
               &_StaVertexClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StaVertexClass& a, StaVertexClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaVertexClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaVertexClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaVertexClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaVertexClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaVertexClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaVertexClass& from) {
    StaVertexClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaVertexClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaVertexClass";
  }
  protected:
  explicit StaVertexClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcArcsFieldNumber = 7,
    kSnkArcsFieldNumber = 8,
    kMaxCapFieldNumber = 12,
    kMaxSlewFieldNumber = 13,
    kIdFieldNumber = 1,
    kObjFieldNumber = 2,
    kSlewBucketFieldNumber = 9,
    kControlBitsFieldNumber = 3,
    kTypeBitsFieldNumber = 15,
    kClockBucketFieldNumber = 10,
    kPathDelayBucketFieldNumber = 11,
    kMaxFanoutFieldNumber = 14,
  };
  // repeated uint64 _src_arcs = 7;
  int _src_arcs_size() const;
  private:
  int _internal__src_arcs_size() const;
  public:
  void clear__src_arcs();
  private:
  uint64_t _internal__src_arcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__src_arcs() const;
  void _internal_add__src_arcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__src_arcs();
  public:
  uint64_t _src_arcs(int index) const;
  void set__src_arcs(int index, uint64_t value);
  void add__src_arcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _src_arcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__src_arcs();

  // repeated uint64 _snk_arcs = 8;
  int _snk_arcs_size() const;
  private:
  int _internal__snk_arcs_size() const;
  public:
  void clear__snk_arcs();
  private:
  uint64_t _internal__snk_arcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__snk_arcs() const;
  void _internal_add__snk_arcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__snk_arcs();
  public:
  uint64_t _snk_arcs(int index) const;
  void set__snk_arcs(int index, uint64_t value);
  void add__snk_arcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _snk_arcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__snk_arcs();

  // repeated .Common.Types.OptionalDouble _max_cap = 12;
  int _max_cap_size() const;
  private:
  int _internal__max_cap_size() const;
  public:
  void clear__max_cap();
  ::Common::Types::OptionalDouble* mutable__max_cap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >*
      mutable__max_cap();
  private:
  const ::Common::Types::OptionalDouble& _internal__max_cap(int index) const;
  ::Common::Types::OptionalDouble* _internal_add__max_cap();
  public:
  const ::Common::Types::OptionalDouble& _max_cap(int index) const;
  ::Common::Types::OptionalDouble* add__max_cap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >&
      _max_cap() const;

  // repeated .Common.Types.OptionalDouble _max_slew = 13;
  int _max_slew_size() const;
  private:
  int _internal__max_slew_size() const;
  public:
  void clear__max_slew();
  ::Common::Types::OptionalDouble* mutable__max_slew(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >*
      mutable__max_slew();
  private:
  const ::Common::Types::OptionalDouble& _internal__max_slew(int index) const;
  ::Common::Types::OptionalDouble* _internal_add__max_slew();
  public:
  const ::Common::Types::OptionalDouble& _max_slew(int index) const;
  ::Common::Types::OptionalDouble* add__max_slew();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >&
      _max_slew() const;

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint64 _obj = 2;
  bool has__obj() const;
  private:
  bool _internal_has__obj() const;
  public:
  void clear__obj();
  uint64_t _obj() const;
  void set__obj(uint64_t value);
  private:
  uint64_t _internal__obj() const;
  void _internal_set__obj(uint64_t value);
  public:

  // optional uint64 _slew_bucket = 9;
  bool has__slew_bucket() const;
  private:
  bool _internal_has__slew_bucket() const;
  public:
  void clear__slew_bucket();
  uint64_t _slew_bucket() const;
  void set__slew_bucket(uint64_t value);
  private:
  uint64_t _internal__slew_bucket() const;
  void _internal_set__slew_bucket(uint64_t value);
  public:

  // required uint32 control_bits = 3;
  bool has_control_bits() const;
  private:
  bool _internal_has_control_bits() const;
  public:
  void clear_control_bits();
  uint32_t control_bits() const;
  void set_control_bits(uint32_t value);
  private:
  uint32_t _internal_control_bits() const;
  void _internal_set_control_bits(uint32_t value);
  public:

  // required uint32 type_bits = 15;
  bool has_type_bits() const;
  private:
  bool _internal_has_type_bits() const;
  public:
  void clear_type_bits();
  uint32_t type_bits() const;
  void set_type_bits(uint32_t value);
  private:
  uint32_t _internal_type_bits() const;
  void _internal_set_type_bits(uint32_t value);
  public:

  // optional uint64 _clock_bucket = 10;
  bool has__clock_bucket() const;
  private:
  bool _internal_has__clock_bucket() const;
  public:
  void clear__clock_bucket();
  uint64_t _clock_bucket() const;
  void set__clock_bucket(uint64_t value);
  private:
  uint64_t _internal__clock_bucket() const;
  void _internal_set__clock_bucket(uint64_t value);
  public:

  // optional uint64 _path_delay_bucket = 11;
  bool has__path_delay_bucket() const;
  private:
  bool _internal_has__path_delay_bucket() const;
  public:
  void clear__path_delay_bucket();
  uint64_t _path_delay_bucket() const;
  void set__path_delay_bucket(uint64_t value);
  private:
  uint64_t _internal__path_delay_bucket() const;
  void _internal_set__path_delay_bucket(uint64_t value);
  public:

  // optional double _max_fanout = 14;
  bool has__max_fanout() const;
  private:
  bool _internal_has__max_fanout() const;
  public:
  void clear__max_fanout();
  double _max_fanout() const;
  void set__max_fanout(double value);
  private:
  double _internal__max_fanout() const;
  void _internal_set__max_fanout(double value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaVertexClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _src_arcs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _snk_arcs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble > _max_cap_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble > _max_slew_;
    uint64_t id_;
    uint64_t _obj_;
    uint64_t _slew_bucket_;
    uint32_t control_bits_;
    uint32_t type_bits_;
    uint64_t _clock_bucket_;
    uint64_t _path_delay_bucket_;
    double _max_fanout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// -------------------------------------------------------------------

class StaGraphClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StaStructure.StaGraphClass) */ {
 public:
  inline StaGraphClass() : StaGraphClass(nullptr) {}
  ~StaGraphClass() override;
  explicit PROTOBUF_CONSTEXPR StaGraphClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaGraphClass(const StaGraphClass& from);
  StaGraphClass(StaGraphClass&& from) noexcept
    : StaGraphClass() {
    *this = ::std::move(from);
  }

  inline StaGraphClass& operator=(const StaGraphClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaGraphClass& operator=(StaGraphClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaGraphClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaGraphClass* internal_default_instance() {
    return reinterpret_cast<const StaGraphClass*>(
               &_StaGraphClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StaGraphClass& a, StaGraphClass& b) {
    a.Swap(&b);
  }
  inline void Swap(StaGraphClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaGraphClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaGraphClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaGraphClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaGraphClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaGraphClass& from) {
    StaGraphClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaGraphClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StaStructure.StaGraphClass";
  }
  protected:
  explicit StaGraphClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortVertexesFieldNumber = 3,
    kStartVertexesFieldNumber = 4,
    kEndVertexesFieldNumber = 5,
    kVertexesFieldNumber = 6,
    kArcsFieldNumber = 7,
    kObjVertexPairFieldNumber = 8,
    kMainAssistantPairFieldNumber = 9,
    kIdFieldNumber = 1,
    kNlFieldNumber = 2,
  };
  // repeated uint64 _port_vertexes = 3;
  int _port_vertexes_size() const;
  private:
  int _internal__port_vertexes_size() const;
  public:
  void clear__port_vertexes();
  private:
  uint64_t _internal__port_vertexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__port_vertexes() const;
  void _internal_add__port_vertexes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__port_vertexes();
  public:
  uint64_t _port_vertexes(int index) const;
  void set__port_vertexes(int index, uint64_t value);
  void add__port_vertexes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _port_vertexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__port_vertexes();

  // repeated uint64 _start_vertexes = 4;
  int _start_vertexes_size() const;
  private:
  int _internal__start_vertexes_size() const;
  public:
  void clear__start_vertexes();
  private:
  uint64_t _internal__start_vertexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__start_vertexes() const;
  void _internal_add__start_vertexes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__start_vertexes();
  public:
  uint64_t _start_vertexes(int index) const;
  void set__start_vertexes(int index, uint64_t value);
  void add__start_vertexes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _start_vertexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__start_vertexes();

  // repeated uint64 _end_vertexes = 5;
  int _end_vertexes_size() const;
  private:
  int _internal__end_vertexes_size() const;
  public:
  void clear__end_vertexes();
  private:
  uint64_t _internal__end_vertexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__end_vertexes() const;
  void _internal_add__end_vertexes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__end_vertexes();
  public:
  uint64_t _end_vertexes(int index) const;
  void set__end_vertexes(int index, uint64_t value);
  void add__end_vertexes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _end_vertexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__end_vertexes();

  // repeated uint64 _vertexes = 6;
  int _vertexes_size() const;
  private:
  int _internal__vertexes_size() const;
  public:
  void clear__vertexes();
  private:
  uint64_t _internal__vertexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__vertexes() const;
  void _internal_add__vertexes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__vertexes();
  public:
  uint64_t _vertexes(int index) const;
  void set__vertexes(int index, uint64_t value);
  void add__vertexes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _vertexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__vertexes();

  // repeated uint64 _arcs = 7;
  int _arcs_size() const;
  private:
  int _internal__arcs_size() const;
  public:
  void clear__arcs();
  private:
  uint64_t _internal__arcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__arcs() const;
  void _internal_add__arcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__arcs();
  public:
  uint64_t _arcs(int index) const;
  void set__arcs(int index, uint64_t value);
  void add__arcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _arcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__arcs();

  // repeated .Common.Types.ULongPair obj_vertex_pair = 8;
  int obj_vertex_pair_size() const;
  private:
  int _internal_obj_vertex_pair_size() const;
  public:
  void clear_obj_vertex_pair();
  ::Common::Types::ULongPair* mutable_obj_vertex_pair(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >*
      mutable_obj_vertex_pair();
  private:
  const ::Common::Types::ULongPair& _internal_obj_vertex_pair(int index) const;
  ::Common::Types::ULongPair* _internal_add_obj_vertex_pair();
  public:
  const ::Common::Types::ULongPair& obj_vertex_pair(int index) const;
  ::Common::Types::ULongPair* add_obj_vertex_pair();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >&
      obj_vertex_pair() const;

  // repeated .Common.Types.ULongPair main_assistant_pair = 9;
  int main_assistant_pair_size() const;
  private:
  int _internal_main_assistant_pair_size() const;
  public:
  void clear_main_assistant_pair();
  ::Common::Types::ULongPair* mutable_main_assistant_pair(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >*
      mutable_main_assistant_pair();
  private:
  const ::Common::Types::ULongPair& _internal_main_assistant_pair(int index) const;
  ::Common::Types::ULongPair* _internal_add_main_assistant_pair();
  public:
  const ::Common::Types::ULongPair& main_assistant_pair(int index) const;
  ::Common::Types::ULongPair* add_main_assistant_pair();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >&
      main_assistant_pair() const;

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint64 _nl = 2;
  bool has__nl() const;
  private:
  bool _internal_has__nl() const;
  public:
  void clear__nl();
  uint64_t _nl() const;
  void set__nl(uint64_t value);
  private:
  uint64_t _internal__nl() const;
  void _internal_set__nl(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StaStructure.StaGraphClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _port_vertexes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _start_vertexes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _end_vertexes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _vertexes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _arcs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair > obj_vertex_pair_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair > main_assistant_pair_;
    uint64_t id_;
    uint64_t _nl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_StaStructure_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClockTypeEnum

// required .StaStructure.ClockTypeEnum.ClockType ct = 1;
inline bool ClockTypeEnum::_internal_has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClockTypeEnum::has_ct() const {
  return _internal_has_ct();
}
inline void ClockTypeEnum::clear_ct() {
  _impl_.ct_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::StaStructure::ClockTypeEnum_ClockType ClockTypeEnum::_internal_ct() const {
  return static_cast< ::StaStructure::ClockTypeEnum_ClockType >(_impl_.ct_);
}
inline ::StaStructure::ClockTypeEnum_ClockType ClockTypeEnum::ct() const {
  // @@protoc_insertion_point(field_get:StaStructure.ClockTypeEnum.ct)
  return _internal_ct();
}
inline void ClockTypeEnum::_internal_set_ct(::StaStructure::ClockTypeEnum_ClockType value) {
  assert(::StaStructure::ClockTypeEnum_ClockType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ct_ = value;
}
inline void ClockTypeEnum::set_ct(::StaStructure::ClockTypeEnum_ClockType value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:StaStructure.ClockTypeEnum.ct)
}

// -------------------------------------------------------------------

// StaWaveFormClass

// repeated int32 _wave_edges = 1;
inline int StaWaveFormClass::_internal__wave_edges_size() const {
  return _impl_._wave_edges_.size();
}
inline int StaWaveFormClass::_wave_edges_size() const {
  return _internal__wave_edges_size();
}
inline void StaWaveFormClass::clear__wave_edges() {
  _impl_._wave_edges_.Clear();
}
inline int32_t StaWaveFormClass::_internal__wave_edges(int index) const {
  return _impl_._wave_edges_.Get(index);
}
inline int32_t StaWaveFormClass::_wave_edges(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaWaveFormClass._wave_edges)
  return _internal__wave_edges(index);
}
inline void StaWaveFormClass::set__wave_edges(int index, int32_t value) {
  _impl_._wave_edges_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaWaveFormClass._wave_edges)
}
inline void StaWaveFormClass::_internal_add__wave_edges(int32_t value) {
  _impl_._wave_edges_.Add(value);
}
inline void StaWaveFormClass::add__wave_edges(int32_t value) {
  _internal_add__wave_edges(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaWaveFormClass._wave_edges)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
StaWaveFormClass::_internal__wave_edges() const {
  return _impl_._wave_edges_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
StaWaveFormClass::_wave_edges() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaWaveFormClass._wave_edges)
  return _internal__wave_edges();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
StaWaveFormClass::_internal_mutable__wave_edges() {
  return &_impl_._wave_edges_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
StaWaveFormClass::mutable__wave_edges() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaWaveFormClass._wave_edges)
  return _internal_mutable__wave_edges();
}

// -------------------------------------------------------------------

// StaClockClass

// required uint64 id = 1;
inline bool StaClockClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StaClockClass::has_id() const {
  return _internal_has_id();
}
inline void StaClockClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t StaClockClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t StaClockClass::id() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockClass.id)
  return _internal_id();
}
inline void StaClockClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.id_ = value;
}
inline void StaClockClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaClockClass.id)
}

// required string _clock_name = 2;
inline bool StaClockClass::_internal_has__clock_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaClockClass::has__clock_name() const {
  return _internal_has__clock_name();
}
inline void StaClockClass::clear__clock_name() {
  _impl_._clock_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StaClockClass::_clock_name() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockClass._clock_name)
  return _internal__clock_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StaClockClass::set__clock_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._clock_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StaStructure.StaClockClass._clock_name)
}
inline std::string* StaClockClass::mutable__clock_name() {
  std::string* _s = _internal_mutable__clock_name();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaClockClass._clock_name)
  return _s;
}
inline const std::string& StaClockClass::_internal__clock_name() const {
  return _impl_._clock_name_.Get();
}
inline void StaClockClass::_internal_set__clock_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._clock_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StaClockClass::_internal_mutable__clock_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._clock_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StaClockClass::release__clock_name() {
  // @@protoc_insertion_point(field_release:StaStructure.StaClockClass._clock_name)
  if (!_internal_has__clock_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._clock_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._clock_name_.IsDefault()) {
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StaClockClass::set_allocated__clock_name(std::string* _clock_name) {
  if (_clock_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._clock_name_.SetAllocated(_clock_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._clock_name_.IsDefault()) {
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaClockClass._clock_name)
}

// repeated uint64 _clock_vertexes = 3;
inline int StaClockClass::_internal__clock_vertexes_size() const {
  return _impl_._clock_vertexes_.size();
}
inline int StaClockClass::_clock_vertexes_size() const {
  return _internal__clock_vertexes_size();
}
inline void StaClockClass::clear__clock_vertexes() {
  _impl_._clock_vertexes_.Clear();
}
inline uint64_t StaClockClass::_internal__clock_vertexes(int index) const {
  return _impl_._clock_vertexes_.Get(index);
}
inline uint64_t StaClockClass::_clock_vertexes(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockClass._clock_vertexes)
  return _internal__clock_vertexes(index);
}
inline void StaClockClass::set__clock_vertexes(int index, uint64_t value) {
  _impl_._clock_vertexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaClockClass._clock_vertexes)
}
inline void StaClockClass::_internal_add__clock_vertexes(uint64_t value) {
  _impl_._clock_vertexes_.Add(value);
}
inline void StaClockClass::add__clock_vertexes(uint64_t value) {
  _internal_add__clock_vertexes(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaClockClass._clock_vertexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaClockClass::_internal__clock_vertexes() const {
  return _impl_._clock_vertexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaClockClass::_clock_vertexes() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaClockClass._clock_vertexes)
  return _internal__clock_vertexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaClockClass::_internal_mutable__clock_vertexes() {
  return &_impl_._clock_vertexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaClockClass::mutable__clock_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaClockClass._clock_vertexes)
  return _internal_mutable__clock_vertexes();
}

// required .StaStructure.ClockTypeEnum _clock_type = 4;
inline bool StaClockClass::_internal_has__clock_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._clock_type_ != nullptr);
  return value;
}
inline bool StaClockClass::has__clock_type() const {
  return _internal_has__clock_type();
}
inline void StaClockClass::clear__clock_type() {
  if (_impl_._clock_type_ != nullptr) _impl_._clock_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::StaStructure::ClockTypeEnum& StaClockClass::_internal__clock_type() const {
  const ::StaStructure::ClockTypeEnum* p = _impl_._clock_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::StaStructure::ClockTypeEnum&>(
      ::StaStructure::_ClockTypeEnum_default_instance_);
}
inline const ::StaStructure::ClockTypeEnum& StaClockClass::_clock_type() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockClass._clock_type)
  return _internal__clock_type();
}
inline void StaClockClass::unsafe_arena_set_allocated__clock_type(
    ::StaStructure::ClockTypeEnum* _clock_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._clock_type_);
  }
  _impl_._clock_type_ = _clock_type;
  if (_clock_type) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaClockClass._clock_type)
}
inline ::StaStructure::ClockTypeEnum* StaClockClass::release__clock_type() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::StaStructure::ClockTypeEnum* temp = _impl_._clock_type_;
  _impl_._clock_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StaStructure::ClockTypeEnum* StaClockClass::unsafe_arena_release__clock_type() {
  // @@protoc_insertion_point(field_release:StaStructure.StaClockClass._clock_type)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::StaStructure::ClockTypeEnum* temp = _impl_._clock_type_;
  _impl_._clock_type_ = nullptr;
  return temp;
}
inline ::StaStructure::ClockTypeEnum* StaClockClass::_internal_mutable__clock_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_._clock_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::StaStructure::ClockTypeEnum>(GetArenaForAllocation());
    _impl_._clock_type_ = p;
  }
  return _impl_._clock_type_;
}
inline ::StaStructure::ClockTypeEnum* StaClockClass::mutable__clock_type() {
  ::StaStructure::ClockTypeEnum* _msg = _internal_mutable__clock_type();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaClockClass._clock_type)
  return _msg;
}
inline void StaClockClass::set_allocated__clock_type(::StaStructure::ClockTypeEnum* _clock_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._clock_type_;
  }
  if (_clock_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_clock_type);
    if (message_arena != submessage_arena) {
      _clock_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _clock_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._clock_type_ = _clock_type;
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaClockClass._clock_type)
}

// optional int32 _ideal_network_latency = 5;
inline bool StaClockClass::_internal_has__ideal_network_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StaClockClass::has__ideal_network_latency() const {
  return _internal_has__ideal_network_latency();
}
inline void StaClockClass::clear__ideal_network_latency() {
  _impl_._ideal_network_latency_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t StaClockClass::_internal__ideal_network_latency() const {
  return _impl_._ideal_network_latency_;
}
inline int32_t StaClockClass::_ideal_network_latency() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockClass._ideal_network_latency)
  return _internal__ideal_network_latency();
}
inline void StaClockClass::_internal_set__ideal_network_latency(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._ideal_network_latency_ = value;
}
inline void StaClockClass::set__ideal_network_latency(int32_t value) {
  _internal_set__ideal_network_latency(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaClockClass._ideal_network_latency)
}

// required int32 _period = 6;
inline bool StaClockClass::_internal_has__period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StaClockClass::has__period() const {
  return _internal_has__period();
}
inline void StaClockClass::clear__period() {
  _impl_._period_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t StaClockClass::_internal__period() const {
  return _impl_._period_;
}
inline int32_t StaClockClass::_period() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockClass._period)
  return _internal__period();
}
inline void StaClockClass::_internal_set__period(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_._period_ = value;
}
inline void StaClockClass::set__period(int32_t value) {
  _internal_set__period(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaClockClass._period)
}

// required .StaStructure.StaWaveFormClass _wave_form = 7;
inline bool StaClockClass::_internal_has__wave_form() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._wave_form_ != nullptr);
  return value;
}
inline bool StaClockClass::has__wave_form() const {
  return _internal_has__wave_form();
}
inline void StaClockClass::clear__wave_form() {
  if (_impl_._wave_form_ != nullptr) _impl_._wave_form_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::StaStructure::StaWaveFormClass& StaClockClass::_internal__wave_form() const {
  const ::StaStructure::StaWaveFormClass* p = _impl_._wave_form_;
  return p != nullptr ? *p : reinterpret_cast<const ::StaStructure::StaWaveFormClass&>(
      ::StaStructure::_StaWaveFormClass_default_instance_);
}
inline const ::StaStructure::StaWaveFormClass& StaClockClass::_wave_form() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockClass._wave_form)
  return _internal__wave_form();
}
inline void StaClockClass::unsafe_arena_set_allocated__wave_form(
    ::StaStructure::StaWaveFormClass* _wave_form) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._wave_form_);
  }
  _impl_._wave_form_ = _wave_form;
  if (_wave_form) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaClockClass._wave_form)
}
inline ::StaStructure::StaWaveFormClass* StaClockClass::release__wave_form() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::StaStructure::StaWaveFormClass* temp = _impl_._wave_form_;
  _impl_._wave_form_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StaStructure::StaWaveFormClass* StaClockClass::unsafe_arena_release__wave_form() {
  // @@protoc_insertion_point(field_release:StaStructure.StaClockClass._wave_form)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::StaStructure::StaWaveFormClass* temp = _impl_._wave_form_;
  _impl_._wave_form_ = nullptr;
  return temp;
}
inline ::StaStructure::StaWaveFormClass* StaClockClass::_internal_mutable__wave_form() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_._wave_form_ == nullptr) {
    auto* p = CreateMaybeMessage<::StaStructure::StaWaveFormClass>(GetArenaForAllocation());
    _impl_._wave_form_ = p;
  }
  return _impl_._wave_form_;
}
inline ::StaStructure::StaWaveFormClass* StaClockClass::mutable__wave_form() {
  ::StaStructure::StaWaveFormClass* _msg = _internal_mutable__wave_form();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaClockClass._wave_form)
  return _msg;
}
inline void StaClockClass::set_allocated__wave_form(::StaStructure::StaWaveFormClass* _wave_form) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._wave_form_;
  }
  if (_wave_form) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_wave_form);
    if (message_arena != submessage_arena) {
      _wave_form = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _wave_form, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_._wave_form_ = _wave_form;
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaClockClass._wave_form)
}

// -------------------------------------------------------------------

// StaDataClass

// required .Common.Types.AnalysisModeEnum _delay_type = 1;
inline bool StaDataClass::_internal_has__delay_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._delay_type_ != nullptr);
  return value;
}
inline bool StaDataClass::has__delay_type() const {
  return _internal_has__delay_type();
}
inline const ::Common::Types::AnalysisModeEnum& StaDataClass::_internal__delay_type() const {
  const ::Common::Types::AnalysisModeEnum* p = _impl_._delay_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::AnalysisModeEnum&>(
      ::Common::Types::_AnalysisModeEnum_default_instance_);
}
inline const ::Common::Types::AnalysisModeEnum& StaDataClass::_delay_type() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataClass._delay_type)
  return _internal__delay_type();
}
inline void StaDataClass::unsafe_arena_set_allocated__delay_type(
    ::Common::Types::AnalysisModeEnum* _delay_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._delay_type_);
  }
  _impl_._delay_type_ = _delay_type;
  if (_delay_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaDataClass._delay_type)
}
inline ::Common::Types::AnalysisModeEnum* StaDataClass::release__delay_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::AnalysisModeEnum* temp = _impl_._delay_type_;
  _impl_._delay_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::AnalysisModeEnum* StaDataClass::unsafe_arena_release__delay_type() {
  // @@protoc_insertion_point(field_release:StaStructure.StaDataClass._delay_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::AnalysisModeEnum* temp = _impl_._delay_type_;
  _impl_._delay_type_ = nullptr;
  return temp;
}
inline ::Common::Types::AnalysisModeEnum* StaDataClass::_internal_mutable__delay_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_._delay_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::AnalysisModeEnum>(GetArenaForAllocation());
    _impl_._delay_type_ = p;
  }
  return _impl_._delay_type_;
}
inline ::Common::Types::AnalysisModeEnum* StaDataClass::mutable__delay_type() {
  ::Common::Types::AnalysisModeEnum* _msg = _internal_mutable__delay_type();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaDataClass._delay_type)
  return _msg;
}
inline void StaDataClass::set_allocated__delay_type(::Common::Types::AnalysisModeEnum* _delay_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._delay_type_);
  }
  if (_delay_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_delay_type));
    if (message_arena != submessage_arena) {
      _delay_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _delay_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._delay_type_ = _delay_type;
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaDataClass._delay_type)
}

// required .Common.Types.TransTypeEnum _trans_type = 2;
inline bool StaDataClass::_internal_has__trans_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._trans_type_ != nullptr);
  return value;
}
inline bool StaDataClass::has__trans_type() const {
  return _internal_has__trans_type();
}
inline const ::Common::Types::TransTypeEnum& StaDataClass::_internal__trans_type() const {
  const ::Common::Types::TransTypeEnum* p = _impl_._trans_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::TransTypeEnum&>(
      ::Common::Types::_TransTypeEnum_default_instance_);
}
inline const ::Common::Types::TransTypeEnum& StaDataClass::_trans_type() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataClass._trans_type)
  return _internal__trans_type();
}
inline void StaDataClass::unsafe_arena_set_allocated__trans_type(
    ::Common::Types::TransTypeEnum* _trans_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._trans_type_);
  }
  _impl_._trans_type_ = _trans_type;
  if (_trans_type) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaDataClass._trans_type)
}
inline ::Common::Types::TransTypeEnum* StaDataClass::release__trans_type() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Common::Types::TransTypeEnum* temp = _impl_._trans_type_;
  _impl_._trans_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::TransTypeEnum* StaDataClass::unsafe_arena_release__trans_type() {
  // @@protoc_insertion_point(field_release:StaStructure.StaDataClass._trans_type)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Common::Types::TransTypeEnum* temp = _impl_._trans_type_;
  _impl_._trans_type_ = nullptr;
  return temp;
}
inline ::Common::Types::TransTypeEnum* StaDataClass::_internal_mutable__trans_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_._trans_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::TransTypeEnum>(GetArenaForAllocation());
    _impl_._trans_type_ = p;
  }
  return _impl_._trans_type_;
}
inline ::Common::Types::TransTypeEnum* StaDataClass::mutable__trans_type() {
  ::Common::Types::TransTypeEnum* _msg = _internal_mutable__trans_type();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaDataClass._trans_type)
  return _msg;
}
inline void StaDataClass::set_allocated__trans_type(::Common::Types::TransTypeEnum* _trans_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._trans_type_);
  }
  if (_trans_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_trans_type));
    if (message_arena != submessage_arena) {
      _trans_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _trans_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._trans_type_ = _trans_type;
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaDataClass._trans_type)
}

// required uint64 _own_vertex = 3;
inline bool StaDataClass::_internal_has__own_vertex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaDataClass::has__own_vertex() const {
  return _internal_has__own_vertex();
}
inline void StaDataClass::clear__own_vertex() {
  _impl_._own_vertex_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t StaDataClass::_internal__own_vertex() const {
  return _impl_._own_vertex_;
}
inline uint64_t StaDataClass::_own_vertex() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataClass._own_vertex)
  return _internal__own_vertex();
}
inline void StaDataClass::_internal_set__own_vertex(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._own_vertex_ = value;
}
inline void StaDataClass::set__own_vertex(uint64_t value) {
  _internal_set__own_vertex(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataClass._own_vertex)
}

// required uint64 _fwd = 4;
inline bool StaDataClass::_internal_has__fwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StaDataClass::has__fwd() const {
  return _internal_has__fwd();
}
inline void StaDataClass::clear__fwd() {
  _impl_._fwd_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t StaDataClass::_internal__fwd() const {
  return _impl_._fwd_;
}
inline uint64_t StaDataClass::_fwd() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataClass._fwd)
  return _internal__fwd();
}
inline void StaDataClass::_internal_set__fwd(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._fwd_ = value;
}
inline void StaDataClass::set__fwd(uint64_t value) {
  _internal_set__fwd(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataClass._fwd)
}

// required uint64 _bwd = 5;
inline bool StaDataClass::_internal_has__bwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StaDataClass::has__bwd() const {
  return _internal_has__bwd();
}
inline void StaDataClass::clear__bwd() {
  _impl_._bwd_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t StaDataClass::_internal__bwd() const {
  return _impl_._bwd_;
}
inline uint64_t StaDataClass::_bwd() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataClass._bwd)
  return _internal__bwd();
}
inline void StaDataClass::_internal_set__bwd(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._bwd_ = value;
}
inline void StaDataClass::set__bwd(uint64_t value) {
  _internal_set__bwd(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataClass._bwd)
}

// -------------------------------------------------------------------

// StaSlewDataClass

// required int32 _slew = 1;
inline bool StaSlewDataClass::_internal_has__slew() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaSlewDataClass::has__slew() const {
  return _internal_has__slew();
}
inline void StaSlewDataClass::clear__slew() {
  _impl_._slew_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t StaSlewDataClass::_internal__slew() const {
  return _impl_._slew_;
}
inline int32_t StaSlewDataClass::_slew() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaSlewDataClass._slew)
  return _internal__slew();
}
inline void StaSlewDataClass::_internal_set__slew(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._slew_ = value;
}
inline void StaSlewDataClass::set__slew(int32_t value) {
  _internal_set__slew(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaSlewDataClass._slew)
}

// optional uint64 _output_current_data = 2;
inline bool StaSlewDataClass::_internal_has__output_current_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaSlewDataClass::has__output_current_data() const {
  return _internal_has__output_current_data();
}
inline void StaSlewDataClass::clear__output_current_data() {
  _impl_._output_current_data_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaSlewDataClass::_internal__output_current_data() const {
  return _impl_._output_current_data_;
}
inline uint64_t StaSlewDataClass::_output_current_data() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaSlewDataClass._output_current_data)
  return _internal__output_current_data();
}
inline void StaSlewDataClass::_internal_set__output_current_data(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._output_current_data_ = value;
}
inline void StaSlewDataClass::set__output_current_data(uint64_t value) {
  _internal_set__output_current_data(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaSlewDataClass._output_current_data)
}

// -------------------------------------------------------------------

// StaArcDelayDataClass

// required int32 _arc_delay = 1;
inline bool StaArcDelayDataClass::_internal_has__arc_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaArcDelayDataClass::has__arc_delay() const {
  return _internal_has__arc_delay();
}
inline void StaArcDelayDataClass::clear__arc_delay() {
  _impl_._arc_delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t StaArcDelayDataClass::_internal__arc_delay() const {
  return _impl_._arc_delay_;
}
inline int32_t StaArcDelayDataClass::_arc_delay() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcDelayDataClass._arc_delay)
  return _internal__arc_delay();
}
inline void StaArcDelayDataClass::_internal_set__arc_delay(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._arc_delay_ = value;
}
inline void StaArcDelayDataClass::set__arc_delay(int32_t value) {
  _internal_set__arc_delay(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcDelayDataClass._arc_delay)
}

// required uint64 _own_arc = 2;
inline bool StaArcDelayDataClass::_internal_has__own_arc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaArcDelayDataClass::has__own_arc() const {
  return _internal_has__own_arc();
}
inline void StaArcDelayDataClass::clear__own_arc() {
  _impl_._own_arc_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaArcDelayDataClass::_internal__own_arc() const {
  return _impl_._own_arc_;
}
inline uint64_t StaArcDelayDataClass::_own_arc() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcDelayDataClass._own_arc)
  return _internal__own_arc();
}
inline void StaArcDelayDataClass::_internal_set__own_arc(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._own_arc_ = value;
}
inline void StaArcDelayDataClass::set__own_arc(uint64_t value) {
  _internal_set__own_arc(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcDelayDataClass._own_arc)
}

// -------------------------------------------------------------------

// StaPathDelayDataClass

// required int64 _arrive_time = 1;
inline bool StaPathDelayDataClass::_internal_has__arrive_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaPathDelayDataClass::has__arrive_time() const {
  return _internal_has__arrive_time();
}
inline void StaPathDelayDataClass::clear__arrive_time() {
  _impl_._arrive_time_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t StaPathDelayDataClass::_internal__arrive_time() const {
  return _impl_._arrive_time_;
}
inline int64_t StaPathDelayDataClass::_arrive_time() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaPathDelayDataClass._arrive_time)
  return _internal__arrive_time();
}
inline void StaPathDelayDataClass::_internal_set__arrive_time(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._arrive_time_ = value;
}
inline void StaPathDelayDataClass::set__arrive_time(int64_t value) {
  _internal_set__arrive_time(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaPathDelayDataClass._arrive_time)
}

// optional int32 _req_time = 2;
inline bool StaPathDelayDataClass::_internal_has__req_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaPathDelayDataClass::has__req_time() const {
  return _internal_has__req_time();
}
inline void StaPathDelayDataClass::clear__req_time() {
  _impl_._req_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t StaPathDelayDataClass::_internal__req_time() const {
  return _impl_._req_time_;
}
inline int32_t StaPathDelayDataClass::_req_time() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaPathDelayDataClass._req_time)
  return _internal__req_time();
}
inline void StaPathDelayDataClass::_internal_set__req_time(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._req_time_ = value;
}
inline void StaPathDelayDataClass::set__req_time(int32_t value) {
  _internal_set__req_time(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaPathDelayDataClass._req_time)
}

// required uint64 _launch_clock_data = 3;
inline bool StaPathDelayDataClass::_internal_has__launch_clock_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaPathDelayDataClass::has__launch_clock_data() const {
  return _internal_has__launch_clock_data();
}
inline void StaPathDelayDataClass::clear__launch_clock_data() {
  _impl_._launch_clock_data_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StaPathDelayDataClass::_internal__launch_clock_data() const {
  return _impl_._launch_clock_data_;
}
inline uint64_t StaPathDelayDataClass::_launch_clock_data() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaPathDelayDataClass._launch_clock_data)
  return _internal__launch_clock_data();
}
inline void StaPathDelayDataClass::_internal_set__launch_clock_data(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._launch_clock_data_ = value;
}
inline void StaPathDelayDataClass::set__launch_clock_data(uint64_t value) {
  _internal_set__launch_clock_data(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaPathDelayDataClass._launch_clock_data)
}

// -------------------------------------------------------------------

// StaClockDataClass

// required int64 _arrive_time = 1;
inline bool StaClockDataClass::_internal_has__arrive_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaClockDataClass::has__arrive_time() const {
  return _internal_has__arrive_time();
}
inline void StaClockDataClass::clear__arrive_time() {
  _impl_._arrive_time_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t StaClockDataClass::_internal__arrive_time() const {
  return _impl_._arrive_time_;
}
inline int64_t StaClockDataClass::_arrive_time() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockDataClass._arrive_time)
  return _internal__arrive_time();
}
inline void StaClockDataClass::_internal_set__arrive_time(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._arrive_time_ = value;
}
inline void StaClockDataClass::set__arrive_time(int64_t value) {
  _internal_set__arrive_time(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaClockDataClass._arrive_time)
}

// required uint64 _prop_clock = 2;
inline bool StaClockDataClass::_internal_has__prop_clock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaClockDataClass::has__prop_clock() const {
  return _internal_has__prop_clock();
}
inline void StaClockDataClass::clear__prop_clock() {
  _impl_._prop_clock_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t StaClockDataClass::_internal__prop_clock() const {
  return _impl_._prop_clock_;
}
inline uint64_t StaClockDataClass::_prop_clock() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockDataClass._prop_clock)
  return _internal__prop_clock();
}
inline void StaClockDataClass::_internal_set__prop_clock(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._prop_clock_ = value;
}
inline void StaClockDataClass::set__prop_clock(uint64_t value) {
  _internal_set__prop_clock(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaClockDataClass._prop_clock)
}

// required .Common.Types.TransTypeEnum _clock_wave_type = 3;
inline bool StaClockDataClass::_internal_has__clock_wave_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._clock_wave_type_ != nullptr);
  return value;
}
inline bool StaClockDataClass::has__clock_wave_type() const {
  return _internal_has__clock_wave_type();
}
inline const ::Common::Types::TransTypeEnum& StaClockDataClass::_internal__clock_wave_type() const {
  const ::Common::Types::TransTypeEnum* p = _impl_._clock_wave_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::TransTypeEnum&>(
      ::Common::Types::_TransTypeEnum_default_instance_);
}
inline const ::Common::Types::TransTypeEnum& StaClockDataClass::_clock_wave_type() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaClockDataClass._clock_wave_type)
  return _internal__clock_wave_type();
}
inline void StaClockDataClass::unsafe_arena_set_allocated__clock_wave_type(
    ::Common::Types::TransTypeEnum* _clock_wave_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._clock_wave_type_);
  }
  _impl_._clock_wave_type_ = _clock_wave_type;
  if (_clock_wave_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaClockDataClass._clock_wave_type)
}
inline ::Common::Types::TransTypeEnum* StaClockDataClass::release__clock_wave_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::TransTypeEnum* temp = _impl_._clock_wave_type_;
  _impl_._clock_wave_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::TransTypeEnum* StaClockDataClass::unsafe_arena_release__clock_wave_type() {
  // @@protoc_insertion_point(field_release:StaStructure.StaClockDataClass._clock_wave_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::TransTypeEnum* temp = _impl_._clock_wave_type_;
  _impl_._clock_wave_type_ = nullptr;
  return temp;
}
inline ::Common::Types::TransTypeEnum* StaClockDataClass::_internal_mutable__clock_wave_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_._clock_wave_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::TransTypeEnum>(GetArenaForAllocation());
    _impl_._clock_wave_type_ = p;
  }
  return _impl_._clock_wave_type_;
}
inline ::Common::Types::TransTypeEnum* StaClockDataClass::mutable__clock_wave_type() {
  ::Common::Types::TransTypeEnum* _msg = _internal_mutable__clock_wave_type();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaClockDataClass._clock_wave_type)
  return _msg;
}
inline void StaClockDataClass::set_allocated__clock_wave_type(::Common::Types::TransTypeEnum* _clock_wave_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._clock_wave_type_);
  }
  if (_clock_wave_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_clock_wave_type));
    if (message_arena != submessage_arena) {
      _clock_wave_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _clock_wave_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._clock_wave_type_ = _clock_wave_type;
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaClockDataClass._clock_wave_type)
}

// -------------------------------------------------------------------

// StaDataSyn

// required uint64 id = 1;
inline bool StaDataSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaDataSyn::has_id() const {
  return _internal_has_id();
}
inline void StaDataSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StaDataSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t StaDataSyn::id() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataSyn.id)
  return _internal_id();
}
inline void StaDataSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void StaDataSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataSyn.id)
}

// required uint32 type = 2;
inline bool StaDataSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaDataSyn::has_type() const {
  return _internal_has_type();
}
inline void StaDataSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StaDataSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t StaDataSyn::type() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataSyn.type)
  return _internal_type();
}
inline void StaDataSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void StaDataSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataSyn.type)
}

// required .StaStructure.StaDataClass parent = 3;
inline bool StaDataSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool StaDataSyn::has_parent() const {
  return _internal_has_parent();
}
inline void StaDataSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::StaStructure::StaDataClass& StaDataSyn::_internal_parent() const {
  const ::StaStructure::StaDataClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::StaStructure::StaDataClass&>(
      ::StaStructure::_StaDataClass_default_instance_);
}
inline const ::StaStructure::StaDataClass& StaDataSyn::parent() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataSyn.parent)
  return _internal_parent();
}
inline void StaDataSyn::unsafe_arena_set_allocated_parent(
    ::StaStructure::StaDataClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaDataSyn.parent)
}
inline ::StaStructure::StaDataClass* StaDataSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::StaStructure::StaDataClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StaStructure::StaDataClass* StaDataSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:StaStructure.StaDataSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::StaStructure::StaDataClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::StaStructure::StaDataClass* StaDataSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::StaStructure::StaDataClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::StaStructure::StaDataClass* StaDataSyn::mutable_parent() {
  ::StaStructure::StaDataClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaDataSyn.parent)
  return _msg;
}
inline void StaDataSyn::set_allocated_parent(::StaStructure::StaDataClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaDataSyn.parent)
}

// .StaStructure.StaSlewDataClass ssdc = 4;
inline bool StaDataSyn::_internal_has_ssdc() const {
  return sds_case() == kSsdc;
}
inline bool StaDataSyn::has_ssdc() const {
  return _internal_has_ssdc();
}
inline void StaDataSyn::set_has_ssdc() {
  _impl_._oneof_case_[0] = kSsdc;
}
inline void StaDataSyn::clear_ssdc() {
  if (_internal_has_ssdc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sds_.ssdc_;
    }
    clear_has_sds();
  }
}
inline ::StaStructure::StaSlewDataClass* StaDataSyn::release_ssdc() {
  // @@protoc_insertion_point(field_release:StaStructure.StaDataSyn.ssdc)
  if (_internal_has_ssdc()) {
    clear_has_sds();
    ::StaStructure::StaSlewDataClass* temp = _impl_.sds_.ssdc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sds_.ssdc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StaStructure::StaSlewDataClass& StaDataSyn::_internal_ssdc() const {
  return _internal_has_ssdc()
      ? *_impl_.sds_.ssdc_
      : reinterpret_cast< ::StaStructure::StaSlewDataClass&>(::StaStructure::_StaSlewDataClass_default_instance_);
}
inline const ::StaStructure::StaSlewDataClass& StaDataSyn::ssdc() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataSyn.ssdc)
  return _internal_ssdc();
}
inline ::StaStructure::StaSlewDataClass* StaDataSyn::unsafe_arena_release_ssdc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StaStructure.StaDataSyn.ssdc)
  if (_internal_has_ssdc()) {
    clear_has_sds();
    ::StaStructure::StaSlewDataClass* temp = _impl_.sds_.ssdc_;
    _impl_.sds_.ssdc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StaDataSyn::unsafe_arena_set_allocated_ssdc(::StaStructure::StaSlewDataClass* ssdc) {
  clear_sds();
  if (ssdc) {
    set_has_ssdc();
    _impl_.sds_.ssdc_ = ssdc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaDataSyn.ssdc)
}
inline ::StaStructure::StaSlewDataClass* StaDataSyn::_internal_mutable_ssdc() {
  if (!_internal_has_ssdc()) {
    clear_sds();
    set_has_ssdc();
    _impl_.sds_.ssdc_ = CreateMaybeMessage< ::StaStructure::StaSlewDataClass >(GetArenaForAllocation());
  }
  return _impl_.sds_.ssdc_;
}
inline ::StaStructure::StaSlewDataClass* StaDataSyn::mutable_ssdc() {
  ::StaStructure::StaSlewDataClass* _msg = _internal_mutable_ssdc();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaDataSyn.ssdc)
  return _msg;
}

// .StaStructure.StaArcDelayDataClass saddc = 5;
inline bool StaDataSyn::_internal_has_saddc() const {
  return sds_case() == kSaddc;
}
inline bool StaDataSyn::has_saddc() const {
  return _internal_has_saddc();
}
inline void StaDataSyn::set_has_saddc() {
  _impl_._oneof_case_[0] = kSaddc;
}
inline void StaDataSyn::clear_saddc() {
  if (_internal_has_saddc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sds_.saddc_;
    }
    clear_has_sds();
  }
}
inline ::StaStructure::StaArcDelayDataClass* StaDataSyn::release_saddc() {
  // @@protoc_insertion_point(field_release:StaStructure.StaDataSyn.saddc)
  if (_internal_has_saddc()) {
    clear_has_sds();
    ::StaStructure::StaArcDelayDataClass* temp = _impl_.sds_.saddc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sds_.saddc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StaStructure::StaArcDelayDataClass& StaDataSyn::_internal_saddc() const {
  return _internal_has_saddc()
      ? *_impl_.sds_.saddc_
      : reinterpret_cast< ::StaStructure::StaArcDelayDataClass&>(::StaStructure::_StaArcDelayDataClass_default_instance_);
}
inline const ::StaStructure::StaArcDelayDataClass& StaDataSyn::saddc() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataSyn.saddc)
  return _internal_saddc();
}
inline ::StaStructure::StaArcDelayDataClass* StaDataSyn::unsafe_arena_release_saddc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StaStructure.StaDataSyn.saddc)
  if (_internal_has_saddc()) {
    clear_has_sds();
    ::StaStructure::StaArcDelayDataClass* temp = _impl_.sds_.saddc_;
    _impl_.sds_.saddc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StaDataSyn::unsafe_arena_set_allocated_saddc(::StaStructure::StaArcDelayDataClass* saddc) {
  clear_sds();
  if (saddc) {
    set_has_saddc();
    _impl_.sds_.saddc_ = saddc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaDataSyn.saddc)
}
inline ::StaStructure::StaArcDelayDataClass* StaDataSyn::_internal_mutable_saddc() {
  if (!_internal_has_saddc()) {
    clear_sds();
    set_has_saddc();
    _impl_.sds_.saddc_ = CreateMaybeMessage< ::StaStructure::StaArcDelayDataClass >(GetArenaForAllocation());
  }
  return _impl_.sds_.saddc_;
}
inline ::StaStructure::StaArcDelayDataClass* StaDataSyn::mutable_saddc() {
  ::StaStructure::StaArcDelayDataClass* _msg = _internal_mutable_saddc();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaDataSyn.saddc)
  return _msg;
}

// .StaStructure.StaPathDelayDataClass spddc = 6;
inline bool StaDataSyn::_internal_has_spddc() const {
  return sds_case() == kSpddc;
}
inline bool StaDataSyn::has_spddc() const {
  return _internal_has_spddc();
}
inline void StaDataSyn::set_has_spddc() {
  _impl_._oneof_case_[0] = kSpddc;
}
inline void StaDataSyn::clear_spddc() {
  if (_internal_has_spddc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sds_.spddc_;
    }
    clear_has_sds();
  }
}
inline ::StaStructure::StaPathDelayDataClass* StaDataSyn::release_spddc() {
  // @@protoc_insertion_point(field_release:StaStructure.StaDataSyn.spddc)
  if (_internal_has_spddc()) {
    clear_has_sds();
    ::StaStructure::StaPathDelayDataClass* temp = _impl_.sds_.spddc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sds_.spddc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StaStructure::StaPathDelayDataClass& StaDataSyn::_internal_spddc() const {
  return _internal_has_spddc()
      ? *_impl_.sds_.spddc_
      : reinterpret_cast< ::StaStructure::StaPathDelayDataClass&>(::StaStructure::_StaPathDelayDataClass_default_instance_);
}
inline const ::StaStructure::StaPathDelayDataClass& StaDataSyn::spddc() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataSyn.spddc)
  return _internal_spddc();
}
inline ::StaStructure::StaPathDelayDataClass* StaDataSyn::unsafe_arena_release_spddc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StaStructure.StaDataSyn.spddc)
  if (_internal_has_spddc()) {
    clear_has_sds();
    ::StaStructure::StaPathDelayDataClass* temp = _impl_.sds_.spddc_;
    _impl_.sds_.spddc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StaDataSyn::unsafe_arena_set_allocated_spddc(::StaStructure::StaPathDelayDataClass* spddc) {
  clear_sds();
  if (spddc) {
    set_has_spddc();
    _impl_.sds_.spddc_ = spddc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaDataSyn.spddc)
}
inline ::StaStructure::StaPathDelayDataClass* StaDataSyn::_internal_mutable_spddc() {
  if (!_internal_has_spddc()) {
    clear_sds();
    set_has_spddc();
    _impl_.sds_.spddc_ = CreateMaybeMessage< ::StaStructure::StaPathDelayDataClass >(GetArenaForAllocation());
  }
  return _impl_.sds_.spddc_;
}
inline ::StaStructure::StaPathDelayDataClass* StaDataSyn::mutable_spddc() {
  ::StaStructure::StaPathDelayDataClass* _msg = _internal_mutable_spddc();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaDataSyn.spddc)
  return _msg;
}

// .StaStructure.StaClockDataClass scdc = 7;
inline bool StaDataSyn::_internal_has_scdc() const {
  return sds_case() == kScdc;
}
inline bool StaDataSyn::has_scdc() const {
  return _internal_has_scdc();
}
inline void StaDataSyn::set_has_scdc() {
  _impl_._oneof_case_[0] = kScdc;
}
inline void StaDataSyn::clear_scdc() {
  if (_internal_has_scdc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sds_.scdc_;
    }
    clear_has_sds();
  }
}
inline ::StaStructure::StaClockDataClass* StaDataSyn::release_scdc() {
  // @@protoc_insertion_point(field_release:StaStructure.StaDataSyn.scdc)
  if (_internal_has_scdc()) {
    clear_has_sds();
    ::StaStructure::StaClockDataClass* temp = _impl_.sds_.scdc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sds_.scdc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StaStructure::StaClockDataClass& StaDataSyn::_internal_scdc() const {
  return _internal_has_scdc()
      ? *_impl_.sds_.scdc_
      : reinterpret_cast< ::StaStructure::StaClockDataClass&>(::StaStructure::_StaClockDataClass_default_instance_);
}
inline const ::StaStructure::StaClockDataClass& StaDataSyn::scdc() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataSyn.scdc)
  return _internal_scdc();
}
inline ::StaStructure::StaClockDataClass* StaDataSyn::unsafe_arena_release_scdc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StaStructure.StaDataSyn.scdc)
  if (_internal_has_scdc()) {
    clear_has_sds();
    ::StaStructure::StaClockDataClass* temp = _impl_.sds_.scdc_;
    _impl_.sds_.scdc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StaDataSyn::unsafe_arena_set_allocated_scdc(::StaStructure::StaClockDataClass* scdc) {
  clear_sds();
  if (scdc) {
    set_has_scdc();
    _impl_.sds_.scdc_ = scdc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaDataSyn.scdc)
}
inline ::StaStructure::StaClockDataClass* StaDataSyn::_internal_mutable_scdc() {
  if (!_internal_has_scdc()) {
    clear_sds();
    set_has_scdc();
    _impl_.sds_.scdc_ = CreateMaybeMessage< ::StaStructure::StaClockDataClass >(GetArenaForAllocation());
  }
  return _impl_.sds_.scdc_;
}
inline ::StaStructure::StaClockDataClass* StaDataSyn::mutable_scdc() {
  ::StaStructure::StaClockDataClass* _msg = _internal_mutable_scdc();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaDataSyn.scdc)
  return _msg;
}

inline bool StaDataSyn::has_sds() const {
  return sds_case() != SDS_NOT_SET;
}
inline void StaDataSyn::clear_has_sds() {
  _impl_._oneof_case_[0] = SDS_NOT_SET;
}
inline StaDataSyn::SdsCase StaDataSyn::sds_case() const {
  return StaDataSyn::SdsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StaDataBucketClass

// required uint64 id = 1;
inline bool StaDataBucketClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaDataBucketClass::has_id() const {
  return _internal_has_id();
}
inline void StaDataBucketClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaDataBucketClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t StaDataBucketClass::id() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataBucketClass.id)
  return _internal_id();
}
inline void StaDataBucketClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void StaDataBucketClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataBucketClass.id)
}

// repeated uint64 _data_list = 2;
inline int StaDataBucketClass::_internal__data_list_size() const {
  return _impl_._data_list_.size();
}
inline int StaDataBucketClass::_data_list_size() const {
  return _internal__data_list_size();
}
inline void StaDataBucketClass::clear__data_list() {
  _impl_._data_list_.Clear();
}
inline uint64_t StaDataBucketClass::_internal__data_list(int index) const {
  return _impl_._data_list_.Get(index);
}
inline uint64_t StaDataBucketClass::_data_list(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataBucketClass._data_list)
  return _internal__data_list(index);
}
inline void StaDataBucketClass::set__data_list(int index, uint64_t value) {
  _impl_._data_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataBucketClass._data_list)
}
inline void StaDataBucketClass::_internal_add__data_list(uint64_t value) {
  _impl_._data_list_.Add(value);
}
inline void StaDataBucketClass::add__data_list(uint64_t value) {
  _internal_add__data_list(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaDataBucketClass._data_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaDataBucketClass::_internal__data_list() const {
  return _impl_._data_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaDataBucketClass::_data_list() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaDataBucketClass._data_list)
  return _internal__data_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaDataBucketClass::_internal_mutable__data_list() {
  return &_impl_._data_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaDataBucketClass::mutable__data_list() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaDataBucketClass._data_list)
  return _internal_mutable__data_list();
}

// required uint32 _n_worst = 3;
inline bool StaDataBucketClass::_internal_has__n_worst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaDataBucketClass::has__n_worst() const {
  return _internal_has__n_worst();
}
inline void StaDataBucketClass::clear__n_worst() {
  _impl_._n_worst_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StaDataBucketClass::_internal__n_worst() const {
  return _impl_._n_worst_;
}
inline uint32_t StaDataBucketClass::_n_worst() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataBucketClass._n_worst)
  return _internal__n_worst();
}
inline void StaDataBucketClass::_internal_set__n_worst(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._n_worst_ = value;
}
inline void StaDataBucketClass::set__n_worst(uint32_t value) {
  _internal_set__n_worst(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataBucketClass._n_worst)
}

// required uint32 _count = 4;
inline bool StaDataBucketClass::_internal_has__count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaDataBucketClass::has__count() const {
  return _internal_has__count();
}
inline void StaDataBucketClass::clear__count() {
  _impl_._count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StaDataBucketClass::_internal__count() const {
  return _impl_._count_;
}
inline uint32_t StaDataBucketClass::_count() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataBucketClass._count)
  return _internal__count();
}
inline void StaDataBucketClass::_internal_set__count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._count_ = value;
}
inline void StaDataBucketClass::set__count(uint32_t value) {
  _internal_set__count(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataBucketClass._count)
}

// required uint64 _next = 5;
inline bool StaDataBucketClass::_internal_has__next() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StaDataBucketClass::has__next() const {
  return _internal_has__next();
}
inline void StaDataBucketClass::clear__next() {
  _impl_._next_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t StaDataBucketClass::_internal__next() const {
  return _impl_._next_;
}
inline uint64_t StaDataBucketClass::_next() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaDataBucketClass._next)
  return _internal__next();
}
inline void StaDataBucketClass::_internal_set__next(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._next_ = value;
}
inline void StaDataBucketClass::set__next(uint64_t value) {
  _internal_set__next(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaDataBucketClass._next)
}

// -------------------------------------------------------------------

// StaArcClass

// required uint64 _src = 1;
inline bool StaArcClass::_internal_has__src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaArcClass::has__src() const {
  return _internal_has__src();
}
inline void StaArcClass::clear__src() {
  _impl_._src_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaArcClass::_internal__src() const {
  return _impl_._src_;
}
inline uint64_t StaArcClass::_src() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcClass._src)
  return _internal__src();
}
inline void StaArcClass::_internal_set__src(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._src_ = value;
}
inline void StaArcClass::set__src(uint64_t value) {
  _internal_set__src(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcClass._src)
}

// required uint64 _snk = 2;
inline bool StaArcClass::_internal_has__snk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaArcClass::has__snk() const {
  return _internal_has__snk();
}
inline void StaArcClass::clear__snk() {
  _impl_._snk_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StaArcClass::_internal__snk() const {
  return _impl_._snk_;
}
inline uint64_t StaArcClass::_snk() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcClass._snk)
  return _internal__snk();
}
inline void StaArcClass::_internal_set__snk(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._snk_ = value;
}
inline void StaArcClass::set__snk(uint64_t value) {
  _internal_set__snk(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcClass._snk)
}

// optional uint64 _arc_delay_bucket = 3;
inline bool StaArcClass::_internal_has__arc_delay_bucket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaArcClass::has__arc_delay_bucket() const {
  return _internal_has__arc_delay_bucket();
}
inline void StaArcClass::clear__arc_delay_bucket() {
  _impl_._arc_delay_bucket_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t StaArcClass::_internal__arc_delay_bucket() const {
  return _impl_._arc_delay_bucket_;
}
inline uint64_t StaArcClass::_arc_delay_bucket() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcClass._arc_delay_bucket)
  return _internal__arc_delay_bucket();
}
inline void StaArcClass::_internal_set__arc_delay_bucket(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._arc_delay_bucket_ = value;
}
inline void StaArcClass::set__arc_delay_bucket(uint64_t value) {
  _internal_set__arc_delay_bucket(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcClass._arc_delay_bucket)
}

// required bool _is_loop_disable = 4;
inline bool StaArcClass::_internal_has__is_loop_disable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StaArcClass::has__is_loop_disable() const {
  return _internal_has__is_loop_disable();
}
inline void StaArcClass::clear__is_loop_disable() {
  _impl_._is_loop_disable_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool StaArcClass::_internal__is_loop_disable() const {
  return _impl_._is_loop_disable_;
}
inline bool StaArcClass::_is_loop_disable() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcClass._is_loop_disable)
  return _internal__is_loop_disable();
}
inline void StaArcClass::_internal_set__is_loop_disable(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._is_loop_disable_ = value;
}
inline void StaArcClass::set__is_loop_disable(bool value) {
  _internal_set__is_loop_disable(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcClass._is_loop_disable)
}

// -------------------------------------------------------------------

// StaNetArcClass

// required uint64 _net = 1;
inline bool StaNetArcClass::_internal_has__net() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaNetArcClass::has__net() const {
  return _internal_has__net();
}
inline void StaNetArcClass::clear__net() {
  _impl_._net_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaNetArcClass::_internal__net() const {
  return _impl_._net_;
}
inline uint64_t StaNetArcClass::_net() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaNetArcClass._net)
  return _internal__net();
}
inline void StaNetArcClass::_internal_set__net(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._net_ = value;
}
inline void StaNetArcClass::set__net(uint64_t value) {
  _internal_set__net(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaNetArcClass._net)
}

// -------------------------------------------------------------------

// StaInstArcClass

// required uint64 _arc = 1;
inline bool StaInstArcClass::_internal_has__arc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaInstArcClass::has__arc() const {
  return _internal_has__arc();
}
inline void StaInstArcClass::clear__arc() {
  _impl_._arc_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaInstArcClass::_internal__arc() const {
  return _impl_._arc_;
}
inline uint64_t StaInstArcClass::_arc() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaInstArcClass._arc)
  return _internal__arc();
}
inline void StaInstArcClass::_internal_set__arc(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._arc_ = value;
}
inline void StaInstArcClass::set__arc(uint64_t value) {
  _internal_set__arc(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaInstArcClass._arc)
}

// required uint64 _inst = 2;
inline bool StaInstArcClass::_internal_has__inst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaInstArcClass::has__inst() const {
  return _internal_has__inst();
}
inline void StaInstArcClass::clear__inst() {
  _impl_._inst_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StaInstArcClass::_internal__inst() const {
  return _impl_._inst_;
}
inline uint64_t StaInstArcClass::_inst() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaInstArcClass._inst)
  return _internal__inst();
}
inline void StaInstArcClass::_internal_set__inst(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._inst_ = value;
}
inline void StaInstArcClass::set__inst(uint64_t value) {
  _internal_set__inst(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaInstArcClass._inst)
}

// -------------------------------------------------------------------

// StaArcSyn

// required uint64 id = 1;
inline bool StaArcSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaArcSyn::has_id() const {
  return _internal_has_id();
}
inline void StaArcSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StaArcSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t StaArcSyn::id() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcSyn.id)
  return _internal_id();
}
inline void StaArcSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void StaArcSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcSyn.id)
}

// required uint32 type = 2;
inline bool StaArcSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaArcSyn::has_type() const {
  return _internal_has_type();
}
inline void StaArcSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StaArcSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t StaArcSyn::type() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcSyn.type)
  return _internal_type();
}
inline void StaArcSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void StaArcSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaArcSyn.type)
}

// required .StaStructure.StaArcClass parent = 3;
inline bool StaArcSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool StaArcSyn::has_parent() const {
  return _internal_has_parent();
}
inline void StaArcSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::StaStructure::StaArcClass& StaArcSyn::_internal_parent() const {
  const ::StaStructure::StaArcClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::StaStructure::StaArcClass&>(
      ::StaStructure::_StaArcClass_default_instance_);
}
inline const ::StaStructure::StaArcClass& StaArcSyn::parent() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcSyn.parent)
  return _internal_parent();
}
inline void StaArcSyn::unsafe_arena_set_allocated_parent(
    ::StaStructure::StaArcClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaArcSyn.parent)
}
inline ::StaStructure::StaArcClass* StaArcSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::StaStructure::StaArcClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StaStructure::StaArcClass* StaArcSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:StaStructure.StaArcSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::StaStructure::StaArcClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::StaStructure::StaArcClass* StaArcSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::StaStructure::StaArcClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::StaStructure::StaArcClass* StaArcSyn::mutable_parent() {
  ::StaStructure::StaArcClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaArcSyn.parent)
  return _msg;
}
inline void StaArcSyn::set_allocated_parent(::StaStructure::StaArcClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaArcSyn.parent)
}

// .StaStructure.StaNetArcClass snac = 4;
inline bool StaArcSyn::_internal_has_snac() const {
  return sas_case() == kSnac;
}
inline bool StaArcSyn::has_snac() const {
  return _internal_has_snac();
}
inline void StaArcSyn::set_has_snac() {
  _impl_._oneof_case_[0] = kSnac;
}
inline void StaArcSyn::clear_snac() {
  if (_internal_has_snac()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sas_.snac_;
    }
    clear_has_sas();
  }
}
inline ::StaStructure::StaNetArcClass* StaArcSyn::release_snac() {
  // @@protoc_insertion_point(field_release:StaStructure.StaArcSyn.snac)
  if (_internal_has_snac()) {
    clear_has_sas();
    ::StaStructure::StaNetArcClass* temp = _impl_.sas_.snac_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sas_.snac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StaStructure::StaNetArcClass& StaArcSyn::_internal_snac() const {
  return _internal_has_snac()
      ? *_impl_.sas_.snac_
      : reinterpret_cast< ::StaStructure::StaNetArcClass&>(::StaStructure::_StaNetArcClass_default_instance_);
}
inline const ::StaStructure::StaNetArcClass& StaArcSyn::snac() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcSyn.snac)
  return _internal_snac();
}
inline ::StaStructure::StaNetArcClass* StaArcSyn::unsafe_arena_release_snac() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StaStructure.StaArcSyn.snac)
  if (_internal_has_snac()) {
    clear_has_sas();
    ::StaStructure::StaNetArcClass* temp = _impl_.sas_.snac_;
    _impl_.sas_.snac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StaArcSyn::unsafe_arena_set_allocated_snac(::StaStructure::StaNetArcClass* snac) {
  clear_sas();
  if (snac) {
    set_has_snac();
    _impl_.sas_.snac_ = snac;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaArcSyn.snac)
}
inline ::StaStructure::StaNetArcClass* StaArcSyn::_internal_mutable_snac() {
  if (!_internal_has_snac()) {
    clear_sas();
    set_has_snac();
    _impl_.sas_.snac_ = CreateMaybeMessage< ::StaStructure::StaNetArcClass >(GetArenaForAllocation());
  }
  return _impl_.sas_.snac_;
}
inline ::StaStructure::StaNetArcClass* StaArcSyn::mutable_snac() {
  ::StaStructure::StaNetArcClass* _msg = _internal_mutable_snac();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaArcSyn.snac)
  return _msg;
}

// .StaStructure.StaInstArcClass siac = 5;
inline bool StaArcSyn::_internal_has_siac() const {
  return sas_case() == kSiac;
}
inline bool StaArcSyn::has_siac() const {
  return _internal_has_siac();
}
inline void StaArcSyn::set_has_siac() {
  _impl_._oneof_case_[0] = kSiac;
}
inline void StaArcSyn::clear_siac() {
  if (_internal_has_siac()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sas_.siac_;
    }
    clear_has_sas();
  }
}
inline ::StaStructure::StaInstArcClass* StaArcSyn::release_siac() {
  // @@protoc_insertion_point(field_release:StaStructure.StaArcSyn.siac)
  if (_internal_has_siac()) {
    clear_has_sas();
    ::StaStructure::StaInstArcClass* temp = _impl_.sas_.siac_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sas_.siac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StaStructure::StaInstArcClass& StaArcSyn::_internal_siac() const {
  return _internal_has_siac()
      ? *_impl_.sas_.siac_
      : reinterpret_cast< ::StaStructure::StaInstArcClass&>(::StaStructure::_StaInstArcClass_default_instance_);
}
inline const ::StaStructure::StaInstArcClass& StaArcSyn::siac() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaArcSyn.siac)
  return _internal_siac();
}
inline ::StaStructure::StaInstArcClass* StaArcSyn::unsafe_arena_release_siac() {
  // @@protoc_insertion_point(field_unsafe_arena_release:StaStructure.StaArcSyn.siac)
  if (_internal_has_siac()) {
    clear_has_sas();
    ::StaStructure::StaInstArcClass* temp = _impl_.sas_.siac_;
    _impl_.sas_.siac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StaArcSyn::unsafe_arena_set_allocated_siac(::StaStructure::StaInstArcClass* siac) {
  clear_sas();
  if (siac) {
    set_has_siac();
    _impl_.sas_.siac_ = siac;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StaStructure.StaArcSyn.siac)
}
inline ::StaStructure::StaInstArcClass* StaArcSyn::_internal_mutable_siac() {
  if (!_internal_has_siac()) {
    clear_sas();
    set_has_siac();
    _impl_.sas_.siac_ = CreateMaybeMessage< ::StaStructure::StaInstArcClass >(GetArenaForAllocation());
  }
  return _impl_.sas_.siac_;
}
inline ::StaStructure::StaInstArcClass* StaArcSyn::mutable_siac() {
  ::StaStructure::StaInstArcClass* _msg = _internal_mutable_siac();
  // @@protoc_insertion_point(field_mutable:StaStructure.StaArcSyn.siac)
  return _msg;
}

inline bool StaArcSyn::has_sas() const {
  return sas_case() != SAS_NOT_SET;
}
inline void StaArcSyn::clear_has_sas() {
  _impl_._oneof_case_[0] = SAS_NOT_SET;
}
inline StaArcSyn::SasCase StaArcSyn::sas_case() const {
  return StaArcSyn::SasCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StaVertexClass

// required uint64 id = 1;
inline bool StaVertexClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaVertexClass::has_id() const {
  return _internal_has_id();
}
inline void StaVertexClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaVertexClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t StaVertexClass::id() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass.id)
  return _internal_id();
}
inline void StaVertexClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void StaVertexClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass.id)
}

// required uint64 _obj = 2;
inline bool StaVertexClass::_internal_has__obj() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaVertexClass::has__obj() const {
  return _internal_has__obj();
}
inline void StaVertexClass::clear__obj() {
  _impl_._obj_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StaVertexClass::_internal__obj() const {
  return _impl_._obj_;
}
inline uint64_t StaVertexClass::_obj() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._obj)
  return _internal__obj();
}
inline void StaVertexClass::_internal_set__obj(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._obj_ = value;
}
inline void StaVertexClass::set__obj(uint64_t value) {
  _internal_set__obj(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass._obj)
}

// required uint32 control_bits = 3;
inline bool StaVertexClass::_internal_has_control_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StaVertexClass::has_control_bits() const {
  return _internal_has_control_bits();
}
inline void StaVertexClass::clear_control_bits() {
  _impl_.control_bits_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t StaVertexClass::_internal_control_bits() const {
  return _impl_.control_bits_;
}
inline uint32_t StaVertexClass::control_bits() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass.control_bits)
  return _internal_control_bits();
}
inline void StaVertexClass::_internal_set_control_bits(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.control_bits_ = value;
}
inline void StaVertexClass::set_control_bits(uint32_t value) {
  _internal_set_control_bits(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass.control_bits)
}

// repeated uint64 _src_arcs = 7;
inline int StaVertexClass::_internal__src_arcs_size() const {
  return _impl_._src_arcs_.size();
}
inline int StaVertexClass::_src_arcs_size() const {
  return _internal__src_arcs_size();
}
inline void StaVertexClass::clear__src_arcs() {
  _impl_._src_arcs_.Clear();
}
inline uint64_t StaVertexClass::_internal__src_arcs(int index) const {
  return _impl_._src_arcs_.Get(index);
}
inline uint64_t StaVertexClass::_src_arcs(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._src_arcs)
  return _internal__src_arcs(index);
}
inline void StaVertexClass::set__src_arcs(int index, uint64_t value) {
  _impl_._src_arcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass._src_arcs)
}
inline void StaVertexClass::_internal_add__src_arcs(uint64_t value) {
  _impl_._src_arcs_.Add(value);
}
inline void StaVertexClass::add__src_arcs(uint64_t value) {
  _internal_add__src_arcs(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaVertexClass._src_arcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaVertexClass::_internal__src_arcs() const {
  return _impl_._src_arcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaVertexClass::_src_arcs() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaVertexClass._src_arcs)
  return _internal__src_arcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaVertexClass::_internal_mutable__src_arcs() {
  return &_impl_._src_arcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaVertexClass::mutable__src_arcs() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaVertexClass._src_arcs)
  return _internal_mutable__src_arcs();
}

// repeated uint64 _snk_arcs = 8;
inline int StaVertexClass::_internal__snk_arcs_size() const {
  return _impl_._snk_arcs_.size();
}
inline int StaVertexClass::_snk_arcs_size() const {
  return _internal__snk_arcs_size();
}
inline void StaVertexClass::clear__snk_arcs() {
  _impl_._snk_arcs_.Clear();
}
inline uint64_t StaVertexClass::_internal__snk_arcs(int index) const {
  return _impl_._snk_arcs_.Get(index);
}
inline uint64_t StaVertexClass::_snk_arcs(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._snk_arcs)
  return _internal__snk_arcs(index);
}
inline void StaVertexClass::set__snk_arcs(int index, uint64_t value) {
  _impl_._snk_arcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass._snk_arcs)
}
inline void StaVertexClass::_internal_add__snk_arcs(uint64_t value) {
  _impl_._snk_arcs_.Add(value);
}
inline void StaVertexClass::add__snk_arcs(uint64_t value) {
  _internal_add__snk_arcs(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaVertexClass._snk_arcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaVertexClass::_internal__snk_arcs() const {
  return _impl_._snk_arcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaVertexClass::_snk_arcs() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaVertexClass._snk_arcs)
  return _internal__snk_arcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaVertexClass::_internal_mutable__snk_arcs() {
  return &_impl_._snk_arcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaVertexClass::mutable__snk_arcs() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaVertexClass._snk_arcs)
  return _internal_mutable__snk_arcs();
}

// optional uint64 _slew_bucket = 9;
inline bool StaVertexClass::_internal_has__slew_bucket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StaVertexClass::has__slew_bucket() const {
  return _internal_has__slew_bucket();
}
inline void StaVertexClass::clear__slew_bucket() {
  _impl_._slew_bucket_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t StaVertexClass::_internal__slew_bucket() const {
  return _impl_._slew_bucket_;
}
inline uint64_t StaVertexClass::_slew_bucket() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._slew_bucket)
  return _internal__slew_bucket();
}
inline void StaVertexClass::_internal_set__slew_bucket(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._slew_bucket_ = value;
}
inline void StaVertexClass::set__slew_bucket(uint64_t value) {
  _internal_set__slew_bucket(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass._slew_bucket)
}

// optional uint64 _clock_bucket = 10;
inline bool StaVertexClass::_internal_has__clock_bucket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StaVertexClass::has__clock_bucket() const {
  return _internal_has__clock_bucket();
}
inline void StaVertexClass::clear__clock_bucket() {
  _impl_._clock_bucket_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t StaVertexClass::_internal__clock_bucket() const {
  return _impl_._clock_bucket_;
}
inline uint64_t StaVertexClass::_clock_bucket() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._clock_bucket)
  return _internal__clock_bucket();
}
inline void StaVertexClass::_internal_set__clock_bucket(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_._clock_bucket_ = value;
}
inline void StaVertexClass::set__clock_bucket(uint64_t value) {
  _internal_set__clock_bucket(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass._clock_bucket)
}

// optional uint64 _path_delay_bucket = 11;
inline bool StaVertexClass::_internal_has__path_delay_bucket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StaVertexClass::has__path_delay_bucket() const {
  return _internal_has__path_delay_bucket();
}
inline void StaVertexClass::clear__path_delay_bucket() {
  _impl_._path_delay_bucket_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t StaVertexClass::_internal__path_delay_bucket() const {
  return _impl_._path_delay_bucket_;
}
inline uint64_t StaVertexClass::_path_delay_bucket() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._path_delay_bucket)
  return _internal__path_delay_bucket();
}
inline void StaVertexClass::_internal_set__path_delay_bucket(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_._path_delay_bucket_ = value;
}
inline void StaVertexClass::set__path_delay_bucket(uint64_t value) {
  _internal_set__path_delay_bucket(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass._path_delay_bucket)
}

// repeated .Common.Types.OptionalDouble _max_cap = 12;
inline int StaVertexClass::_internal__max_cap_size() const {
  return _impl_._max_cap_.size();
}
inline int StaVertexClass::_max_cap_size() const {
  return _internal__max_cap_size();
}
inline ::Common::Types::OptionalDouble* StaVertexClass::mutable__max_cap(int index) {
  // @@protoc_insertion_point(field_mutable:StaStructure.StaVertexClass._max_cap)
  return _impl_._max_cap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >*
StaVertexClass::mutable__max_cap() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaVertexClass._max_cap)
  return &_impl_._max_cap_;
}
inline const ::Common::Types::OptionalDouble& StaVertexClass::_internal__max_cap(int index) const {
  return _impl_._max_cap_.Get(index);
}
inline const ::Common::Types::OptionalDouble& StaVertexClass::_max_cap(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._max_cap)
  return _internal__max_cap(index);
}
inline ::Common::Types::OptionalDouble* StaVertexClass::_internal_add__max_cap() {
  return _impl_._max_cap_.Add();
}
inline ::Common::Types::OptionalDouble* StaVertexClass::add__max_cap() {
  ::Common::Types::OptionalDouble* _add = _internal_add__max_cap();
  // @@protoc_insertion_point(field_add:StaStructure.StaVertexClass._max_cap)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >&
StaVertexClass::_max_cap() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaVertexClass._max_cap)
  return _impl_._max_cap_;
}

// repeated .Common.Types.OptionalDouble _max_slew = 13;
inline int StaVertexClass::_internal__max_slew_size() const {
  return _impl_._max_slew_.size();
}
inline int StaVertexClass::_max_slew_size() const {
  return _internal__max_slew_size();
}
inline ::Common::Types::OptionalDouble* StaVertexClass::mutable__max_slew(int index) {
  // @@protoc_insertion_point(field_mutable:StaStructure.StaVertexClass._max_slew)
  return _impl_._max_slew_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >*
StaVertexClass::mutable__max_slew() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaVertexClass._max_slew)
  return &_impl_._max_slew_;
}
inline const ::Common::Types::OptionalDouble& StaVertexClass::_internal__max_slew(int index) const {
  return _impl_._max_slew_.Get(index);
}
inline const ::Common::Types::OptionalDouble& StaVertexClass::_max_slew(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._max_slew)
  return _internal__max_slew(index);
}
inline ::Common::Types::OptionalDouble* StaVertexClass::_internal_add__max_slew() {
  return _impl_._max_slew_.Add();
}
inline ::Common::Types::OptionalDouble* StaVertexClass::add__max_slew() {
  ::Common::Types::OptionalDouble* _add = _internal_add__max_slew();
  // @@protoc_insertion_point(field_add:StaStructure.StaVertexClass._max_slew)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::OptionalDouble >&
StaVertexClass::_max_slew() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaVertexClass._max_slew)
  return _impl_._max_slew_;
}

// optional double _max_fanout = 14;
inline bool StaVertexClass::_internal_has__max_fanout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StaVertexClass::has__max_fanout() const {
  return _internal_has__max_fanout();
}
inline void StaVertexClass::clear__max_fanout() {
  _impl_._max_fanout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double StaVertexClass::_internal__max_fanout() const {
  return _impl_._max_fanout_;
}
inline double StaVertexClass::_max_fanout() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass._max_fanout)
  return _internal__max_fanout();
}
inline void StaVertexClass::_internal_set__max_fanout(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_._max_fanout_ = value;
}
inline void StaVertexClass::set__max_fanout(double value) {
  _internal_set__max_fanout(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass._max_fanout)
}

// required uint32 type_bits = 15;
inline bool StaVertexClass::_internal_has_type_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StaVertexClass::has_type_bits() const {
  return _internal_has_type_bits();
}
inline void StaVertexClass::clear_type_bits() {
  _impl_.type_bits_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t StaVertexClass::_internal_type_bits() const {
  return _impl_.type_bits_;
}
inline uint32_t StaVertexClass::type_bits() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaVertexClass.type_bits)
  return _internal_type_bits();
}
inline void StaVertexClass::_internal_set_type_bits(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_bits_ = value;
}
inline void StaVertexClass::set_type_bits(uint32_t value) {
  _internal_set_type_bits(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaVertexClass.type_bits)
}

// -------------------------------------------------------------------

// StaGraphClass

// required uint64 id = 1;
inline bool StaGraphClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaGraphClass::has_id() const {
  return _internal_has_id();
}
inline void StaGraphClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t StaGraphClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t StaGraphClass::id() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass.id)
  return _internal_id();
}
inline void StaGraphClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void StaGraphClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaGraphClass.id)
}

// required uint64 _nl = 2;
inline bool StaGraphClass::_internal_has__nl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StaGraphClass::has__nl() const {
  return _internal_has__nl();
}
inline void StaGraphClass::clear__nl() {
  _impl_._nl_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StaGraphClass::_internal__nl() const {
  return _impl_._nl_;
}
inline uint64_t StaGraphClass::_nl() const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass._nl)
  return _internal__nl();
}
inline void StaGraphClass::_internal_set__nl(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._nl_ = value;
}
inline void StaGraphClass::set__nl(uint64_t value) {
  _internal_set__nl(value);
  // @@protoc_insertion_point(field_set:StaStructure.StaGraphClass._nl)
}

// repeated uint64 _port_vertexes = 3;
inline int StaGraphClass::_internal__port_vertexes_size() const {
  return _impl_._port_vertexes_.size();
}
inline int StaGraphClass::_port_vertexes_size() const {
  return _internal__port_vertexes_size();
}
inline void StaGraphClass::clear__port_vertexes() {
  _impl_._port_vertexes_.Clear();
}
inline uint64_t StaGraphClass::_internal__port_vertexes(int index) const {
  return _impl_._port_vertexes_.Get(index);
}
inline uint64_t StaGraphClass::_port_vertexes(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass._port_vertexes)
  return _internal__port_vertexes(index);
}
inline void StaGraphClass::set__port_vertexes(int index, uint64_t value) {
  _impl_._port_vertexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaGraphClass._port_vertexes)
}
inline void StaGraphClass::_internal_add__port_vertexes(uint64_t value) {
  _impl_._port_vertexes_.Add(value);
}
inline void StaGraphClass::add__port_vertexes(uint64_t value) {
  _internal_add__port_vertexes(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaGraphClass._port_vertexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_internal__port_vertexes() const {
  return _impl_._port_vertexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_port_vertexes() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaGraphClass._port_vertexes)
  return _internal__port_vertexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::_internal_mutable__port_vertexes() {
  return &_impl_._port_vertexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::mutable__port_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaGraphClass._port_vertexes)
  return _internal_mutable__port_vertexes();
}

// repeated uint64 _start_vertexes = 4;
inline int StaGraphClass::_internal__start_vertexes_size() const {
  return _impl_._start_vertexes_.size();
}
inline int StaGraphClass::_start_vertexes_size() const {
  return _internal__start_vertexes_size();
}
inline void StaGraphClass::clear__start_vertexes() {
  _impl_._start_vertexes_.Clear();
}
inline uint64_t StaGraphClass::_internal__start_vertexes(int index) const {
  return _impl_._start_vertexes_.Get(index);
}
inline uint64_t StaGraphClass::_start_vertexes(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass._start_vertexes)
  return _internal__start_vertexes(index);
}
inline void StaGraphClass::set__start_vertexes(int index, uint64_t value) {
  _impl_._start_vertexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaGraphClass._start_vertexes)
}
inline void StaGraphClass::_internal_add__start_vertexes(uint64_t value) {
  _impl_._start_vertexes_.Add(value);
}
inline void StaGraphClass::add__start_vertexes(uint64_t value) {
  _internal_add__start_vertexes(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaGraphClass._start_vertexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_internal__start_vertexes() const {
  return _impl_._start_vertexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_start_vertexes() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaGraphClass._start_vertexes)
  return _internal__start_vertexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::_internal_mutable__start_vertexes() {
  return &_impl_._start_vertexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::mutable__start_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaGraphClass._start_vertexes)
  return _internal_mutable__start_vertexes();
}

// repeated uint64 _end_vertexes = 5;
inline int StaGraphClass::_internal__end_vertexes_size() const {
  return _impl_._end_vertexes_.size();
}
inline int StaGraphClass::_end_vertexes_size() const {
  return _internal__end_vertexes_size();
}
inline void StaGraphClass::clear__end_vertexes() {
  _impl_._end_vertexes_.Clear();
}
inline uint64_t StaGraphClass::_internal__end_vertexes(int index) const {
  return _impl_._end_vertexes_.Get(index);
}
inline uint64_t StaGraphClass::_end_vertexes(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass._end_vertexes)
  return _internal__end_vertexes(index);
}
inline void StaGraphClass::set__end_vertexes(int index, uint64_t value) {
  _impl_._end_vertexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaGraphClass._end_vertexes)
}
inline void StaGraphClass::_internal_add__end_vertexes(uint64_t value) {
  _impl_._end_vertexes_.Add(value);
}
inline void StaGraphClass::add__end_vertexes(uint64_t value) {
  _internal_add__end_vertexes(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaGraphClass._end_vertexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_internal__end_vertexes() const {
  return _impl_._end_vertexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_end_vertexes() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaGraphClass._end_vertexes)
  return _internal__end_vertexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::_internal_mutable__end_vertexes() {
  return &_impl_._end_vertexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::mutable__end_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaGraphClass._end_vertexes)
  return _internal_mutable__end_vertexes();
}

// repeated uint64 _vertexes = 6;
inline int StaGraphClass::_internal__vertexes_size() const {
  return _impl_._vertexes_.size();
}
inline int StaGraphClass::_vertexes_size() const {
  return _internal__vertexes_size();
}
inline void StaGraphClass::clear__vertexes() {
  _impl_._vertexes_.Clear();
}
inline uint64_t StaGraphClass::_internal__vertexes(int index) const {
  return _impl_._vertexes_.Get(index);
}
inline uint64_t StaGraphClass::_vertexes(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass._vertexes)
  return _internal__vertexes(index);
}
inline void StaGraphClass::set__vertexes(int index, uint64_t value) {
  _impl_._vertexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaGraphClass._vertexes)
}
inline void StaGraphClass::_internal_add__vertexes(uint64_t value) {
  _impl_._vertexes_.Add(value);
}
inline void StaGraphClass::add__vertexes(uint64_t value) {
  _internal_add__vertexes(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaGraphClass._vertexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_internal__vertexes() const {
  return _impl_._vertexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_vertexes() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaGraphClass._vertexes)
  return _internal__vertexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::_internal_mutable__vertexes() {
  return &_impl_._vertexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::mutable__vertexes() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaGraphClass._vertexes)
  return _internal_mutable__vertexes();
}

// repeated uint64 _arcs = 7;
inline int StaGraphClass::_internal__arcs_size() const {
  return _impl_._arcs_.size();
}
inline int StaGraphClass::_arcs_size() const {
  return _internal__arcs_size();
}
inline void StaGraphClass::clear__arcs() {
  _impl_._arcs_.Clear();
}
inline uint64_t StaGraphClass::_internal__arcs(int index) const {
  return _impl_._arcs_.Get(index);
}
inline uint64_t StaGraphClass::_arcs(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass._arcs)
  return _internal__arcs(index);
}
inline void StaGraphClass::set__arcs(int index, uint64_t value) {
  _impl_._arcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:StaStructure.StaGraphClass._arcs)
}
inline void StaGraphClass::_internal_add__arcs(uint64_t value) {
  _impl_._arcs_.Add(value);
}
inline void StaGraphClass::add__arcs(uint64_t value) {
  _internal_add__arcs(value);
  // @@protoc_insertion_point(field_add:StaStructure.StaGraphClass._arcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_internal__arcs() const {
  return _impl_._arcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
StaGraphClass::_arcs() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaGraphClass._arcs)
  return _internal__arcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::_internal_mutable__arcs() {
  return &_impl_._arcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
StaGraphClass::mutable__arcs() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaGraphClass._arcs)
  return _internal_mutable__arcs();
}

// repeated .Common.Types.ULongPair obj_vertex_pair = 8;
inline int StaGraphClass::_internal_obj_vertex_pair_size() const {
  return _impl_.obj_vertex_pair_.size();
}
inline int StaGraphClass::obj_vertex_pair_size() const {
  return _internal_obj_vertex_pair_size();
}
inline ::Common::Types::ULongPair* StaGraphClass::mutable_obj_vertex_pair(int index) {
  // @@protoc_insertion_point(field_mutable:StaStructure.StaGraphClass.obj_vertex_pair)
  return _impl_.obj_vertex_pair_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >*
StaGraphClass::mutable_obj_vertex_pair() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaGraphClass.obj_vertex_pair)
  return &_impl_.obj_vertex_pair_;
}
inline const ::Common::Types::ULongPair& StaGraphClass::_internal_obj_vertex_pair(int index) const {
  return _impl_.obj_vertex_pair_.Get(index);
}
inline const ::Common::Types::ULongPair& StaGraphClass::obj_vertex_pair(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass.obj_vertex_pair)
  return _internal_obj_vertex_pair(index);
}
inline ::Common::Types::ULongPair* StaGraphClass::_internal_add_obj_vertex_pair() {
  return _impl_.obj_vertex_pair_.Add();
}
inline ::Common::Types::ULongPair* StaGraphClass::add_obj_vertex_pair() {
  ::Common::Types::ULongPair* _add = _internal_add_obj_vertex_pair();
  // @@protoc_insertion_point(field_add:StaStructure.StaGraphClass.obj_vertex_pair)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >&
StaGraphClass::obj_vertex_pair() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaGraphClass.obj_vertex_pair)
  return _impl_.obj_vertex_pair_;
}

// repeated .Common.Types.ULongPair main_assistant_pair = 9;
inline int StaGraphClass::_internal_main_assistant_pair_size() const {
  return _impl_.main_assistant_pair_.size();
}
inline int StaGraphClass::main_assistant_pair_size() const {
  return _internal_main_assistant_pair_size();
}
inline ::Common::Types::ULongPair* StaGraphClass::mutable_main_assistant_pair(int index) {
  // @@protoc_insertion_point(field_mutable:StaStructure.StaGraphClass.main_assistant_pair)
  return _impl_.main_assistant_pair_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >*
StaGraphClass::mutable_main_assistant_pair() {
  // @@protoc_insertion_point(field_mutable_list:StaStructure.StaGraphClass.main_assistant_pair)
  return &_impl_.main_assistant_pair_;
}
inline const ::Common::Types::ULongPair& StaGraphClass::_internal_main_assistant_pair(int index) const {
  return _impl_.main_assistant_pair_.Get(index);
}
inline const ::Common::Types::ULongPair& StaGraphClass::main_assistant_pair(int index) const {
  // @@protoc_insertion_point(field_get:StaStructure.StaGraphClass.main_assistant_pair)
  return _internal_main_assistant_pair(index);
}
inline ::Common::Types::ULongPair* StaGraphClass::_internal_add_main_assistant_pair() {
  return _impl_.main_assistant_pair_.Add();
}
inline ::Common::Types::ULongPair* StaGraphClass::add_main_assistant_pair() {
  ::Common::Types::ULongPair* _add = _internal_add_main_assistant_pair();
  // @@protoc_insertion_point(field_add:StaStructure.StaGraphClass.main_assistant_pair)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::ULongPair >&
StaGraphClass::main_assistant_pair() const {
  // @@protoc_insertion_point(field_list:StaStructure.StaGraphClass.main_assistant_pair)
  return _impl_.main_assistant_pair_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace StaStructure

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::StaStructure::ClockTypeEnum_ClockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StaStructure::ClockTypeEnum_ClockType>() {
  return ::StaStructure::ClockTypeEnum_ClockType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_StaStructure_2eproto
