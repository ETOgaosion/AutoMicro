// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommonTypes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_CommonTypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_CommonTypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_CommonTypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_CommonTypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_CommonTypes_2eproto;
namespace Common {
namespace Types {
class AnalysisModeEnum;
struct AnalysisModeEnumDefaultTypeInternal;
extern AnalysisModeEnumDefaultTypeInternal _AnalysisModeEnum_default_instance_;
class BoolMsg;
struct BoolMsgDefaultTypeInternal;
extern BoolMsgDefaultTypeInternal _BoolMsg_default_instance_;
class BytesList;
struct BytesListDefaultTypeInternal;
extern BytesListDefaultTypeInternal _BytesList_default_instance_;
class BytesListWithStartEnd;
struct BytesListWithStartEndDefaultTypeInternal;
extern BytesListWithStartEndDefaultTypeInternal _BytesListWithStartEnd_default_instance_;
class CapacitiveUnitEnum;
struct CapacitiveUnitEnumDefaultTypeInternal;
extern CapacitiveUnitEnumDefaultTypeInternal _CapacitiveUnitEnum_default_instance_;
class DoubleList;
struct DoubleListDefaultTypeInternal;
extern DoubleListDefaultTypeInternal _DoubleList_default_instance_;
class DoubleMatrix;
struct DoubleMatrixDefaultTypeInternal;
extern DoubleMatrixDefaultTypeInternal _DoubleMatrix_default_instance_;
class DoubleMatrixTuple;
struct DoubleMatrixTupleDefaultTypeInternal;
extern DoubleMatrixTupleDefaultTypeInternal _DoubleMatrixTuple_default_instance_;
class DoubleMsg;
struct DoubleMsgDefaultTypeInternal;
extern DoubleMsgDefaultTypeInternal _DoubleMsg_default_instance_;
class DoubleOrStr;
struct DoubleOrStrDefaultTypeInternal;
extern DoubleOrStrDefaultTypeInternal _DoubleOrStr_default_instance_;
class EmptyMsg;
struct EmptyMsgDefaultTypeInternal;
extern EmptyMsgDefaultTypeInternal _EmptyMsg_default_instance_;
class FloatMsg;
struct FloatMsgDefaultTypeInternal;
extern FloatMsgDefaultTypeInternal _FloatMsg_default_instance_;
class IntMsg;
struct IntMsgDefaultTypeInternal;
extern IntMsgDefaultTypeInternal _IntMsg_default_instance_;
class IntPair;
struct IntPairDefaultTypeInternal;
extern IntPairDefaultTypeInternal _IntPair_default_instance_;
class LongMsg;
struct LongMsgDefaultTypeInternal;
extern LongMsgDefaultTypeInternal _LongMsg_default_instance_;
class ModeTransPairClass;
struct ModeTransPairClassDefaultTypeInternal;
extern ModeTransPairClassDefaultTypeInternal _ModeTransPairClass_default_instance_;
class ModeTransPairMapDouble;
struct ModeTransPairMapDoubleDefaultTypeInternal;
extern ModeTransPairMapDoubleDefaultTypeInternal _ModeTransPairMapDouble_default_instance_;
class OptionalDouble;
struct OptionalDoubleDefaultTypeInternal;
extern OptionalDoubleDefaultTypeInternal _OptionalDouble_default_instance_;
class ResistanceUnitEnum;
struct ResistanceUnitEnumDefaultTypeInternal;
extern ResistanceUnitEnumDefaultTypeInternal _ResistanceUnitEnum_default_instance_;
class StrIntPair;
struct StrIntPairDefaultTypeInternal;
extern StrIntPairDefaultTypeInternal _StrIntPair_default_instance_;
class StrStrIntSet;
struct StrStrIntSetDefaultTypeInternal;
extern StrStrIntSetDefaultTypeInternal _StrStrIntSet_default_instance_;
class StrULongMap;
struct StrULongMapDefaultTypeInternal;
extern StrULongMapDefaultTypeInternal _StrULongMap_default_instance_;
class StringList;
struct StringListDefaultTypeInternal;
extern StringListDefaultTypeInternal _StringList_default_instance_;
class StringMsg;
struct StringMsgDefaultTypeInternal;
extern StringMsgDefaultTypeInternal _StringMsg_default_instance_;
class TransTypeEnum;
struct TransTypeEnumDefaultTypeInternal;
extern TransTypeEnumDefaultTypeInternal _TransTypeEnum_default_instance_;
class UIntMsg;
struct UIntMsgDefaultTypeInternal;
extern UIntMsgDefaultTypeInternal _UIntMsg_default_instance_;
class ULongDoublePair;
struct ULongDoublePairDefaultTypeInternal;
extern ULongDoublePairDefaultTypeInternal _ULongDoublePair_default_instance_;
class ULongList;
struct ULongListDefaultTypeInternal;
extern ULongListDefaultTypeInternal _ULongList_default_instance_;
class ULongMsg;
struct ULongMsgDefaultTypeInternal;
extern ULongMsgDefaultTypeInternal _ULongMsg_default_instance_;
class ULongPair;
struct ULongPairDefaultTypeInternal;
extern ULongPairDefaultTypeInternal _ULongPair_default_instance_;
class ULongUintPair;
struct ULongUintPairDefaultTypeInternal;
extern ULongUintPairDefaultTypeInternal _ULongUintPair_default_instance_;
}  // namespace Types
}  // namespace Common
PROTOBUF_NAMESPACE_OPEN
template<> ::Common::Types::AnalysisModeEnum* Arena::CreateMaybeMessage<::Common::Types::AnalysisModeEnum>(Arena*);
template<> ::Common::Types::BoolMsg* Arena::CreateMaybeMessage<::Common::Types::BoolMsg>(Arena*);
template<> ::Common::Types::BytesList* Arena::CreateMaybeMessage<::Common::Types::BytesList>(Arena*);
template<> ::Common::Types::BytesListWithStartEnd* Arena::CreateMaybeMessage<::Common::Types::BytesListWithStartEnd>(Arena*);
template<> ::Common::Types::CapacitiveUnitEnum* Arena::CreateMaybeMessage<::Common::Types::CapacitiveUnitEnum>(Arena*);
template<> ::Common::Types::DoubleList* Arena::CreateMaybeMessage<::Common::Types::DoubleList>(Arena*);
template<> ::Common::Types::DoubleMatrix* Arena::CreateMaybeMessage<::Common::Types::DoubleMatrix>(Arena*);
template<> ::Common::Types::DoubleMatrixTuple* Arena::CreateMaybeMessage<::Common::Types::DoubleMatrixTuple>(Arena*);
template<> ::Common::Types::DoubleMsg* Arena::CreateMaybeMessage<::Common::Types::DoubleMsg>(Arena*);
template<> ::Common::Types::DoubleOrStr* Arena::CreateMaybeMessage<::Common::Types::DoubleOrStr>(Arena*);
template<> ::Common::Types::EmptyMsg* Arena::CreateMaybeMessage<::Common::Types::EmptyMsg>(Arena*);
template<> ::Common::Types::FloatMsg* Arena::CreateMaybeMessage<::Common::Types::FloatMsg>(Arena*);
template<> ::Common::Types::IntMsg* Arena::CreateMaybeMessage<::Common::Types::IntMsg>(Arena*);
template<> ::Common::Types::IntPair* Arena::CreateMaybeMessage<::Common::Types::IntPair>(Arena*);
template<> ::Common::Types::LongMsg* Arena::CreateMaybeMessage<::Common::Types::LongMsg>(Arena*);
template<> ::Common::Types::ModeTransPairClass* Arena::CreateMaybeMessage<::Common::Types::ModeTransPairClass>(Arena*);
template<> ::Common::Types::ModeTransPairMapDouble* Arena::CreateMaybeMessage<::Common::Types::ModeTransPairMapDouble>(Arena*);
template<> ::Common::Types::OptionalDouble* Arena::CreateMaybeMessage<::Common::Types::OptionalDouble>(Arena*);
template<> ::Common::Types::ResistanceUnitEnum* Arena::CreateMaybeMessage<::Common::Types::ResistanceUnitEnum>(Arena*);
template<> ::Common::Types::StrIntPair* Arena::CreateMaybeMessage<::Common::Types::StrIntPair>(Arena*);
template<> ::Common::Types::StrStrIntSet* Arena::CreateMaybeMessage<::Common::Types::StrStrIntSet>(Arena*);
template<> ::Common::Types::StrULongMap* Arena::CreateMaybeMessage<::Common::Types::StrULongMap>(Arena*);
template<> ::Common::Types::StringList* Arena::CreateMaybeMessage<::Common::Types::StringList>(Arena*);
template<> ::Common::Types::StringMsg* Arena::CreateMaybeMessage<::Common::Types::StringMsg>(Arena*);
template<> ::Common::Types::TransTypeEnum* Arena::CreateMaybeMessage<::Common::Types::TransTypeEnum>(Arena*);
template<> ::Common::Types::UIntMsg* Arena::CreateMaybeMessage<::Common::Types::UIntMsg>(Arena*);
template<> ::Common::Types::ULongDoublePair* Arena::CreateMaybeMessage<::Common::Types::ULongDoublePair>(Arena*);
template<> ::Common::Types::ULongList* Arena::CreateMaybeMessage<::Common::Types::ULongList>(Arena*);
template<> ::Common::Types::ULongMsg* Arena::CreateMaybeMessage<::Common::Types::ULongMsg>(Arena*);
template<> ::Common::Types::ULongPair* Arena::CreateMaybeMessage<::Common::Types::ULongPair>(Arena*);
template<> ::Common::Types::ULongUintPair* Arena::CreateMaybeMessage<::Common::Types::ULongUintPair>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Common {
namespace Types {

enum AnalysisModeEnum_AnalysisMode : int {
  AnalysisModeEnum_AnalysisMode_kMax = 1,
  AnalysisModeEnum_AnalysisMode_kMin = 2,
  AnalysisModeEnum_AnalysisMode_kMaxMin = 3
};
bool AnalysisModeEnum_AnalysisMode_IsValid(int value);
constexpr AnalysisModeEnum_AnalysisMode AnalysisModeEnum_AnalysisMode_AnalysisMode_MIN = AnalysisModeEnum_AnalysisMode_kMax;
constexpr AnalysisModeEnum_AnalysisMode AnalysisModeEnum_AnalysisMode_AnalysisMode_MAX = AnalysisModeEnum_AnalysisMode_kMaxMin;
constexpr int AnalysisModeEnum_AnalysisMode_AnalysisMode_ARRAYSIZE = AnalysisModeEnum_AnalysisMode_AnalysisMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnalysisModeEnum_AnalysisMode_descriptor();
template<typename T>
inline const std::string& AnalysisModeEnum_AnalysisMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnalysisModeEnum_AnalysisMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnalysisModeEnum_AnalysisMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AnalysisModeEnum_AnalysisMode_descriptor(), enum_t_value);
}
inline bool AnalysisModeEnum_AnalysisMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnalysisModeEnum_AnalysisMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AnalysisModeEnum_AnalysisMode>(
    AnalysisModeEnum_AnalysisMode_descriptor(), name, value);
}
enum TransTypeEnum_TransType : int {
  TransTypeEnum_TransType_kRise = 1,
  TransTypeEnum_TransType_kFall = 2
};
bool TransTypeEnum_TransType_IsValid(int value);
constexpr TransTypeEnum_TransType TransTypeEnum_TransType_TransType_MIN = TransTypeEnum_TransType_kRise;
constexpr TransTypeEnum_TransType TransTypeEnum_TransType_TransType_MAX = TransTypeEnum_TransType_kFall;
constexpr int TransTypeEnum_TransType_TransType_ARRAYSIZE = TransTypeEnum_TransType_TransType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransTypeEnum_TransType_descriptor();
template<typename T>
inline const std::string& TransTypeEnum_TransType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransTypeEnum_TransType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransTypeEnum_TransType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransTypeEnum_TransType_descriptor(), enum_t_value);
}
inline bool TransTypeEnum_TransType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransTypeEnum_TransType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransTypeEnum_TransType>(
    TransTypeEnum_TransType_descriptor(), name, value);
}
enum CapacitiveUnitEnum_CapacitiveUnit : int {
  CapacitiveUnitEnum_CapacitiveUnit_kPF = 0,
  CapacitiveUnitEnum_CapacitiveUnit_kFF = 1
};
bool CapacitiveUnitEnum_CapacitiveUnit_IsValid(int value);
constexpr CapacitiveUnitEnum_CapacitiveUnit CapacitiveUnitEnum_CapacitiveUnit_CapacitiveUnit_MIN = CapacitiveUnitEnum_CapacitiveUnit_kPF;
constexpr CapacitiveUnitEnum_CapacitiveUnit CapacitiveUnitEnum_CapacitiveUnit_CapacitiveUnit_MAX = CapacitiveUnitEnum_CapacitiveUnit_kFF;
constexpr int CapacitiveUnitEnum_CapacitiveUnit_CapacitiveUnit_ARRAYSIZE = CapacitiveUnitEnum_CapacitiveUnit_CapacitiveUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CapacitiveUnitEnum_CapacitiveUnit_descriptor();
template<typename T>
inline const std::string& CapacitiveUnitEnum_CapacitiveUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CapacitiveUnitEnum_CapacitiveUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CapacitiveUnitEnum_CapacitiveUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CapacitiveUnitEnum_CapacitiveUnit_descriptor(), enum_t_value);
}
inline bool CapacitiveUnitEnum_CapacitiveUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CapacitiveUnitEnum_CapacitiveUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CapacitiveUnitEnum_CapacitiveUnit>(
    CapacitiveUnitEnum_CapacitiveUnit_descriptor(), name, value);
}
enum ResistanceUnitEnum_ResistanceUnit : int {
  ResistanceUnitEnum_ResistanceUnit_kOHM = 0,
  ResistanceUnitEnum_ResistanceUnit_kkOHM = 1
};
bool ResistanceUnitEnum_ResistanceUnit_IsValid(int value);
constexpr ResistanceUnitEnum_ResistanceUnit ResistanceUnitEnum_ResistanceUnit_ResistanceUnit_MIN = ResistanceUnitEnum_ResistanceUnit_kOHM;
constexpr ResistanceUnitEnum_ResistanceUnit ResistanceUnitEnum_ResistanceUnit_ResistanceUnit_MAX = ResistanceUnitEnum_ResistanceUnit_kkOHM;
constexpr int ResistanceUnitEnum_ResistanceUnit_ResistanceUnit_ARRAYSIZE = ResistanceUnitEnum_ResistanceUnit_ResistanceUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResistanceUnitEnum_ResistanceUnit_descriptor();
template<typename T>
inline const std::string& ResistanceUnitEnum_ResistanceUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResistanceUnitEnum_ResistanceUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResistanceUnitEnum_ResistanceUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResistanceUnitEnum_ResistanceUnit_descriptor(), enum_t_value);
}
inline bool ResistanceUnitEnum_ResistanceUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResistanceUnitEnum_ResistanceUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResistanceUnitEnum_ResistanceUnit>(
    ResistanceUnitEnum_ResistanceUnit_descriptor(), name, value);
}
// ===================================================================

class EmptyMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.EmptyMsg) */ {
 public:
  inline EmptyMsg() : EmptyMsg(nullptr) {}
  ~EmptyMsg() override;
  explicit PROTOBUF_CONSTEXPR EmptyMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyMsg(const EmptyMsg& from);
  EmptyMsg(EmptyMsg&& from) noexcept
    : EmptyMsg() {
    *this = ::std::move(from);
  }

  inline EmptyMsg& operator=(const EmptyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyMsg& operator=(EmptyMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyMsg* internal_default_instance() {
    return reinterpret_cast<const EmptyMsg*>(
               &_EmptyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EmptyMsg& a, EmptyMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyMsg& from) {
    EmptyMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.EmptyMsg";
  }
  protected:
  explicit EmptyMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEFieldNumber = 1,
  };
  // required .google.protobuf.Empty e = 1;
  bool has_e() const;
  private:
  bool _internal_has_e() const;
  public:
  void clear_e();
  const ::PROTOBUF_NAMESPACE_ID::Empty& e() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_e();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_e();
  void set_allocated_e(::PROTOBUF_NAMESPACE_ID::Empty* e);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_e() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_e();
  public:
  void unsafe_arena_set_allocated_e(
      ::PROTOBUF_NAMESPACE_ID::Empty* e);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_e();

  // @@protoc_insertion_point(class_scope:Common.Types.EmptyMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Empty* e_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class IntMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.IntMsg) */ {
 public:
  inline IntMsg() : IntMsg(nullptr) {}
  ~IntMsg() override;
  explicit PROTOBUF_CONSTEXPR IntMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntMsg(const IntMsg& from);
  IntMsg(IntMsg&& from) noexcept
    : IntMsg() {
    *this = ::std::move(from);
  }

  inline IntMsg& operator=(const IntMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntMsg& operator=(IntMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntMsg* internal_default_instance() {
    return reinterpret_cast<const IntMsg*>(
               &_IntMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IntMsg& a, IntMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(IntMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntMsg& from) {
    IntMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.IntMsg";
  }
  protected:
  explicit IntMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIFieldNumber = 1,
  };
  // required int32 i = 1;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int32_t i() const;
  void set_i(int32_t value);
  private:
  int32_t _internal_i() const;
  void _internal_set_i(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.IntMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t i_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class LongMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.LongMsg) */ {
 public:
  inline LongMsg() : LongMsg(nullptr) {}
  ~LongMsg() override;
  explicit PROTOBUF_CONSTEXPR LongMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongMsg(const LongMsg& from);
  LongMsg(LongMsg&& from) noexcept
    : LongMsg() {
    *this = ::std::move(from);
  }

  inline LongMsg& operator=(const LongMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongMsg& operator=(LongMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongMsg* internal_default_instance() {
    return reinterpret_cast<const LongMsg*>(
               &_LongMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LongMsg& a, LongMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(LongMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongMsg& from) {
    LongMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.LongMsg";
  }
  protected:
  explicit LongMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLFieldNumber = 1,
  };
  // required int64 l = 1;
  bool has_l() const;
  private:
  bool _internal_has_l() const;
  public:
  void clear_l();
  int64_t l() const;
  void set_l(int64_t value);
  private:
  int64_t _internal_l() const;
  void _internal_set_l(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.LongMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t l_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class UIntMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.UIntMsg) */ {
 public:
  inline UIntMsg() : UIntMsg(nullptr) {}
  ~UIntMsg() override;
  explicit PROTOBUF_CONSTEXPR UIntMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UIntMsg(const UIntMsg& from);
  UIntMsg(UIntMsg&& from) noexcept
    : UIntMsg() {
    *this = ::std::move(from);
  }

  inline UIntMsg& operator=(const UIntMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIntMsg& operator=(UIntMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIntMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIntMsg* internal_default_instance() {
    return reinterpret_cast<const UIntMsg*>(
               &_UIntMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UIntMsg& a, UIntMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(UIntMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIntMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIntMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIntMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UIntMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UIntMsg& from) {
    UIntMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIntMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.UIntMsg";
  }
  protected:
  explicit UIntMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUiFieldNumber = 1,
  };
  // required uint32 ui = 1;
  bool has_ui() const;
  private:
  bool _internal_has_ui() const;
  public:
  void clear_ui();
  uint32_t ui() const;
  void set_ui(uint32_t value);
  private:
  uint32_t _internal_ui() const;
  void _internal_set_ui(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.UIntMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t ui_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ULongMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ULongMsg) */ {
 public:
  inline ULongMsg() : ULongMsg(nullptr) {}
  ~ULongMsg() override;
  explicit PROTOBUF_CONSTEXPR ULongMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ULongMsg(const ULongMsg& from);
  ULongMsg(ULongMsg&& from) noexcept
    : ULongMsg() {
    *this = ::std::move(from);
  }

  inline ULongMsg& operator=(const ULongMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ULongMsg& operator=(ULongMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ULongMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ULongMsg* internal_default_instance() {
    return reinterpret_cast<const ULongMsg*>(
               &_ULongMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ULongMsg& a, ULongMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ULongMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ULongMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ULongMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ULongMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ULongMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ULongMsg& from) {
    ULongMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ULongMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ULongMsg";
  }
  protected:
  explicit ULongMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUlFieldNumber = 1,
  };
  // required uint64 ul = 1;
  bool has_ul() const;
  private:
  bool _internal_has_ul() const;
  public:
  void clear_ul();
  uint64_t ul() const;
  void set_ul(uint64_t value);
  private:
  uint64_t _internal_ul() const;
  void _internal_set_ul(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.ULongMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t ul_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class FloatMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.FloatMsg) */ {
 public:
  inline FloatMsg() : FloatMsg(nullptr) {}
  ~FloatMsg() override;
  explicit PROTOBUF_CONSTEXPR FloatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatMsg(const FloatMsg& from);
  FloatMsg(FloatMsg&& from) noexcept
    : FloatMsg() {
    *this = ::std::move(from);
  }

  inline FloatMsg& operator=(const FloatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatMsg& operator=(FloatMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatMsg* internal_default_instance() {
    return reinterpret_cast<const FloatMsg*>(
               &_FloatMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FloatMsg& a, FloatMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FloatMsg& from) {
    FloatMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.FloatMsg";
  }
  protected:
  explicit FloatMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFFieldNumber = 1,
  };
  // required float f = 1;
  bool has_f() const;
  private:
  bool _internal_has_f() const;
  public:
  void clear_f();
  float f() const;
  void set_f(float value);
  private:
  float _internal_f() const;
  void _internal_set_f(float value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.FloatMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float f_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.DoubleMsg) */ {
 public:
  inline DoubleMsg() : DoubleMsg(nullptr) {}
  ~DoubleMsg() override;
  explicit PROTOBUF_CONSTEXPR DoubleMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleMsg(const DoubleMsg& from);
  DoubleMsg(DoubleMsg&& from) noexcept
    : DoubleMsg() {
    *this = ::std::move(from);
  }

  inline DoubleMsg& operator=(const DoubleMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleMsg& operator=(DoubleMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleMsg* internal_default_instance() {
    return reinterpret_cast<const DoubleMsg*>(
               &_DoubleMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DoubleMsg& a, DoubleMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleMsg& from) {
    DoubleMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.DoubleMsg";
  }
  protected:
  explicit DoubleMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDFieldNumber = 1,
  };
  // required double d = 1;
  bool has_d() const;
  private:
  bool _internal_has_d() const;
  public:
  void clear_d();
  double d() const;
  void set_d(double value);
  private:
  double _internal_d() const;
  void _internal_set_d(double value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.DoubleMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double d_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class BoolMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.BoolMsg) */ {
 public:
  inline BoolMsg() : BoolMsg(nullptr) {}
  ~BoolMsg() override;
  explicit PROTOBUF_CONSTEXPR BoolMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolMsg(const BoolMsg& from);
  BoolMsg(BoolMsg&& from) noexcept
    : BoolMsg() {
    *this = ::std::move(from);
  }

  inline BoolMsg& operator=(const BoolMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolMsg& operator=(BoolMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolMsg* internal_default_instance() {
    return reinterpret_cast<const BoolMsg*>(
               &_BoolMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BoolMsg& a, BoolMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolMsg& from) {
    BoolMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.BoolMsg";
  }
  protected:
  explicit BoolMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBFieldNumber = 1,
  };
  // required bool b = 1;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  bool b() const;
  void set_b(bool value);
  private:
  bool _internal_b() const;
  void _internal_set_b(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.BoolMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool b_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class StringMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.StringMsg) */ {
 public:
  inline StringMsg() : StringMsg(nullptr) {}
  ~StringMsg() override;
  explicit PROTOBUF_CONSTEXPR StringMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringMsg(const StringMsg& from);
  StringMsg(StringMsg&& from) noexcept
    : StringMsg() {
    *this = ::std::move(from);
  }

  inline StringMsg& operator=(const StringMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMsg& operator=(StringMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringMsg* internal_default_instance() {
    return reinterpret_cast<const StringMsg*>(
               &_StringMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StringMsg& a, StringMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(StringMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringMsg& from) {
    StringMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.StringMsg";
  }
  protected:
  explicit StringMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
  };
  // required string s = 1;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.StringMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class IntPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.IntPair) */ {
 public:
  inline IntPair() : IntPair(nullptr) {}
  ~IntPair() override;
  explicit PROTOBUF_CONSTEXPR IntPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntPair(const IntPair& from);
  IntPair(IntPair&& from) noexcept
    : IntPair() {
    *this = ::std::move(from);
  }

  inline IntPair& operator=(const IntPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntPair& operator=(IntPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntPair* internal_default_instance() {
    return reinterpret_cast<const IntPair*>(
               &_IntPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IntPair& a, IntPair& b) {
    a.Swap(&b);
  }
  inline void Swap(IntPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntPair& from) {
    IntPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.IntPair";
  }
  protected:
  explicit IntPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // required int32 first = 1;
  bool has_first() const;
  private:
  bool _internal_has_first() const;
  public:
  void clear_first();
  int32_t first() const;
  void set_first(int32_t value);
  private:
  int32_t _internal_first() const;
  void _internal_set_first(int32_t value);
  public:

  // required int32 second = 2;
  bool has_second() const;
  private:
  bool _internal_has_second() const;
  public:
  void clear_second();
  int32_t second() const;
  void set_second(int32_t value);
  private:
  int32_t _internal_second() const;
  void _internal_set_second(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.IntPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t first_;
    int32_t second_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.DoubleList) */ {
 public:
  inline DoubleList() : DoubleList(nullptr) {}
  ~DoubleList() override;
  explicit PROTOBUF_CONSTEXPR DoubleList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleList(const DoubleList& from);
  DoubleList(DoubleList&& from) noexcept
    : DoubleList() {
    *this = ::std::move(from);
  }

  inline DoubleList& operator=(const DoubleList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleList& operator=(DoubleList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleList* internal_default_instance() {
    return reinterpret_cast<const DoubleList*>(
               &_DoubleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DoubleList& a, DoubleList& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleList& from) {
    DoubleList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.DoubleList";
  }
  protected:
  explicit DoubleList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDFieldNumber = 1,
  };
  // repeated double d = 1;
  int d_size() const;
  private:
  int _internal_d_size() const;
  public:
  void clear_d();
  private:
  double _internal_d(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_d() const;
  void _internal_add_d(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_d();
  public:
  double d(int index) const;
  void set_d(int index, double value);
  void add_d(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      d() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_d();

  // @@protoc_insertion_point(class_scope:Common.Types.DoubleList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > d_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleMatrix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.DoubleMatrix) */ {
 public:
  inline DoubleMatrix() : DoubleMatrix(nullptr) {}
  ~DoubleMatrix() override;
  explicit PROTOBUF_CONSTEXPR DoubleMatrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleMatrix(const DoubleMatrix& from);
  DoubleMatrix(DoubleMatrix&& from) noexcept
    : DoubleMatrix() {
    *this = ::std::move(from);
  }

  inline DoubleMatrix& operator=(const DoubleMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleMatrix& operator=(DoubleMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleMatrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleMatrix* internal_default_instance() {
    return reinterpret_cast<const DoubleMatrix*>(
               &_DoubleMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DoubleMatrix& a, DoubleMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleMatrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleMatrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleMatrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleMatrix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleMatrix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleMatrix& from) {
    DoubleMatrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleMatrix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.DoubleMatrix";
  }
  protected:
  explicit DoubleMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDlFieldNumber = 1,
  };
  // repeated .Common.Types.DoubleList dl = 1;
  int dl_size() const;
  private:
  int _internal_dl_size() const;
  public:
  void clear_dl();
  ::Common::Types::DoubleList* mutable_dl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleList >*
      mutable_dl();
  private:
  const ::Common::Types::DoubleList& _internal_dl(int index) const;
  ::Common::Types::DoubleList* _internal_add_dl();
  public:
  const ::Common::Types::DoubleList& dl(int index) const;
  ::Common::Types::DoubleList* add_dl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleList >&
      dl() const;

  // @@protoc_insertion_point(class_scope:Common.Types.DoubleMatrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleList > dl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleMatrixTuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.DoubleMatrixTuple) */ {
 public:
  inline DoubleMatrixTuple() : DoubleMatrixTuple(nullptr) {}
  ~DoubleMatrixTuple() override;
  explicit PROTOBUF_CONSTEXPR DoubleMatrixTuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleMatrixTuple(const DoubleMatrixTuple& from);
  DoubleMatrixTuple(DoubleMatrixTuple&& from) noexcept
    : DoubleMatrixTuple() {
    *this = ::std::move(from);
  }

  inline DoubleMatrixTuple& operator=(const DoubleMatrixTuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleMatrixTuple& operator=(DoubleMatrixTuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleMatrixTuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleMatrixTuple* internal_default_instance() {
    return reinterpret_cast<const DoubleMatrixTuple*>(
               &_DoubleMatrixTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DoubleMatrixTuple& a, DoubleMatrixTuple& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleMatrixTuple* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleMatrixTuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleMatrixTuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleMatrixTuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleMatrixTuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleMatrixTuple& from) {
    DoubleMatrixTuple::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleMatrixTuple* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.DoubleMatrixTuple";
  }
  protected:
  explicit DoubleMatrixTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDmFieldNumber = 1,
  };
  // repeated .Common.Types.DoubleMatrix dm = 1;
  int dm_size() const;
  private:
  int _internal_dm_size() const;
  public:
  void clear_dm();
  ::Common::Types::DoubleMatrix* mutable_dm(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleMatrix >*
      mutable_dm();
  private:
  const ::Common::Types::DoubleMatrix& _internal_dm(int index) const;
  ::Common::Types::DoubleMatrix* _internal_add_dm();
  public:
  const ::Common::Types::DoubleMatrix& dm(int index) const;
  ::Common::Types::DoubleMatrix* add_dm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleMatrix >&
      dm() const;

  // @@protoc_insertion_point(class_scope:Common.Types.DoubleMatrixTuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleMatrix > dm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ULongPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ULongPair) */ {
 public:
  inline ULongPair() : ULongPair(nullptr) {}
  ~ULongPair() override;
  explicit PROTOBUF_CONSTEXPR ULongPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ULongPair(const ULongPair& from);
  ULongPair(ULongPair&& from) noexcept
    : ULongPair() {
    *this = ::std::move(from);
  }

  inline ULongPair& operator=(const ULongPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline ULongPair& operator=(ULongPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ULongPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const ULongPair* internal_default_instance() {
    return reinterpret_cast<const ULongPair*>(
               &_ULongPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ULongPair& a, ULongPair& b) {
    a.Swap(&b);
  }
  inline void Swap(ULongPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ULongPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ULongPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ULongPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ULongPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ULongPair& from) {
    ULongPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ULongPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ULongPair";
  }
  protected:
  explicit ULongPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // required uint64 first = 1;
  bool has_first() const;
  private:
  bool _internal_has_first() const;
  public:
  void clear_first();
  uint64_t first() const;
  void set_first(uint64_t value);
  private:
  uint64_t _internal_first() const;
  void _internal_set_first(uint64_t value);
  public:

  // required uint64 second = 2;
  bool has_second() const;
  private:
  bool _internal_has_second() const;
  public:
  void clear_second();
  uint64_t second() const;
  void set_second(uint64_t value);
  private:
  uint64_t _internal_second() const;
  void _internal_set_second(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.ULongPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t first_;
    uint64_t second_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ULongList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ULongList) */ {
 public:
  inline ULongList() : ULongList(nullptr) {}
  ~ULongList() override;
  explicit PROTOBUF_CONSTEXPR ULongList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ULongList(const ULongList& from);
  ULongList(ULongList&& from) noexcept
    : ULongList() {
    *this = ::std::move(from);
  }

  inline ULongList& operator=(const ULongList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ULongList& operator=(ULongList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ULongList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ULongList* internal_default_instance() {
    return reinterpret_cast<const ULongList*>(
               &_ULongList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ULongList& a, ULongList& b) {
    a.Swap(&b);
  }
  inline void Swap(ULongList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ULongList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ULongList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ULongList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ULongList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ULongList& from) {
    ULongList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ULongList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ULongList";
  }
  protected:
  explicit ULongList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUlFieldNumber = 1,
  };
  // repeated uint64 ul = 1;
  int ul_size() const;
  private:
  int _internal_ul_size() const;
  public:
  void clear_ul();
  private:
  uint64_t _internal_ul(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_ul() const;
  void _internal_add_ul(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_ul();
  public:
  uint64_t ul(int index) const;
  void set_ul(int index, uint64_t value);
  void add_ul(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      ul() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_ul();

  // @@protoc_insertion_point(class_scope:Common.Types.ULongList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > ul_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ULongUintPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ULongUintPair) */ {
 public:
  inline ULongUintPair() : ULongUintPair(nullptr) {}
  ~ULongUintPair() override;
  explicit PROTOBUF_CONSTEXPR ULongUintPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ULongUintPair(const ULongUintPair& from);
  ULongUintPair(ULongUintPair&& from) noexcept
    : ULongUintPair() {
    *this = ::std::move(from);
  }

  inline ULongUintPair& operator=(const ULongUintPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline ULongUintPair& operator=(ULongUintPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ULongUintPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const ULongUintPair* internal_default_instance() {
    return reinterpret_cast<const ULongUintPair*>(
               &_ULongUintPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ULongUintPair& a, ULongUintPair& b) {
    a.Swap(&b);
  }
  inline void Swap(ULongUintPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ULongUintPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ULongUintPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ULongUintPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ULongUintPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ULongUintPair& from) {
    ULongUintPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ULongUintPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ULongUintPair";
  }
  protected:
  explicit ULongUintPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // required uint64 first = 1;
  bool has_first() const;
  private:
  bool _internal_has_first() const;
  public:
  void clear_first();
  uint64_t first() const;
  void set_first(uint64_t value);
  private:
  uint64_t _internal_first() const;
  void _internal_set_first(uint64_t value);
  public:

  // required uint32 second = 2;
  bool has_second() const;
  private:
  bool _internal_has_second() const;
  public:
  void clear_second();
  uint32_t second() const;
  void set_second(uint32_t value);
  private:
  uint32_t _internal_second() const;
  void _internal_set_second(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.ULongUintPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t first_;
    uint32_t second_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ULongDoublePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ULongDoublePair) */ {
 public:
  inline ULongDoublePair() : ULongDoublePair(nullptr) {}
  ~ULongDoublePair() override;
  explicit PROTOBUF_CONSTEXPR ULongDoublePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ULongDoublePair(const ULongDoublePair& from);
  ULongDoublePair(ULongDoublePair&& from) noexcept
    : ULongDoublePair() {
    *this = ::std::move(from);
  }

  inline ULongDoublePair& operator=(const ULongDoublePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline ULongDoublePair& operator=(ULongDoublePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ULongDoublePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const ULongDoublePair* internal_default_instance() {
    return reinterpret_cast<const ULongDoublePair*>(
               &_ULongDoublePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ULongDoublePair& a, ULongDoublePair& b) {
    a.Swap(&b);
  }
  inline void Swap(ULongDoublePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ULongDoublePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ULongDoublePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ULongDoublePair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ULongDoublePair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ULongDoublePair& from) {
    ULongDoublePair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ULongDoublePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ULongDoublePair";
  }
  protected:
  explicit ULongDoublePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // required uint64 first = 1;
  bool has_first() const;
  private:
  bool _internal_has_first() const;
  public:
  void clear_first();
  uint64_t first() const;
  void set_first(uint64_t value);
  private:
  uint64_t _internal_first() const;
  void _internal_set_first(uint64_t value);
  public:

  // required double second = 2;
  bool has_second() const;
  private:
  bool _internal_has_second() const;
  public:
  void clear_second();
  double second() const;
  void set_second(double value);
  private:
  double _internal_second() const;
  void _internal_set_second(double value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.ULongDoublePair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t first_;
    double second_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class OptionalDouble final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.OptionalDouble) */ {
 public:
  inline OptionalDouble() : OptionalDouble(nullptr) {}
  ~OptionalDouble() override;
  explicit PROTOBUF_CONSTEXPR OptionalDouble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptionalDouble(const OptionalDouble& from);
  OptionalDouble(OptionalDouble&& from) noexcept
    : OptionalDouble() {
    *this = ::std::move(from);
  }

  inline OptionalDouble& operator=(const OptionalDouble& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalDouble& operator=(OptionalDouble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalDouble& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionalDouble* internal_default_instance() {
    return reinterpret_cast<const OptionalDouble*>(
               &_OptionalDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(OptionalDouble& a, OptionalDouble& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionalDouble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalDouble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalDouble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptionalDouble>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptionalDouble& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptionalDouble& from) {
    OptionalDouble::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionalDouble* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.OptionalDouble";
  }
  protected:
  explicit OptionalDouble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDFieldNumber = 1,
  };
  // optional double d = 1;
  bool has_d() const;
  private:
  bool _internal_has_d() const;
  public:
  void clear_d();
  double d() const;
  void set_d(double value);
  private:
  double _internal_d() const;
  void _internal_set_d(double value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.OptionalDouble)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double d_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class StrIntPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.StrIntPair) */ {
 public:
  inline StrIntPair() : StrIntPair(nullptr) {}
  ~StrIntPair() override;
  explicit PROTOBUF_CONSTEXPR StrIntPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrIntPair(const StrIntPair& from);
  StrIntPair(StrIntPair&& from) noexcept
    : StrIntPair() {
    *this = ::std::move(from);
  }

  inline StrIntPair& operator=(const StrIntPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrIntPair& operator=(StrIntPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrIntPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrIntPair* internal_default_instance() {
    return reinterpret_cast<const StrIntPair*>(
               &_StrIntPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StrIntPair& a, StrIntPair& b) {
    a.Swap(&b);
  }
  inline void Swap(StrIntPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrIntPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrIntPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrIntPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrIntPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrIntPair& from) {
    StrIntPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrIntPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.StrIntPair";
  }
  protected:
  explicit StrIntPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kIFieldNumber = 2,
  };
  // required string s = 1;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // required int32 i = 2;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int32_t i() const;
  void set_i(int32_t value);
  private:
  int32_t _internal_i() const;
  void _internal_set_i(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.StrIntPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    int32_t i_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleOrStr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.DoubleOrStr) */ {
 public:
  inline DoubleOrStr() : DoubleOrStr(nullptr) {}
  ~DoubleOrStr() override;
  explicit PROTOBUF_CONSTEXPR DoubleOrStr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleOrStr(const DoubleOrStr& from);
  DoubleOrStr(DoubleOrStr&& from) noexcept
    : DoubleOrStr() {
    *this = ::std::move(from);
  }

  inline DoubleOrStr& operator=(const DoubleOrStr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleOrStr& operator=(DoubleOrStr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleOrStr& default_instance() {
    return *internal_default_instance();
  }
  enum SdCase {
    kD = 1,
    kS = 2,
    SD_NOT_SET = 0,
  };

  static inline const DoubleOrStr* internal_default_instance() {
    return reinterpret_cast<const DoubleOrStr*>(
               &_DoubleOrStr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DoubleOrStr& a, DoubleOrStr& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleOrStr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleOrStr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleOrStr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleOrStr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleOrStr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleOrStr& from) {
    DoubleOrStr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleOrStr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.DoubleOrStr";
  }
  protected:
  explicit DoubleOrStr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDFieldNumber = 1,
    kSFieldNumber = 2,
  };
  // double d = 1;
  bool has_d() const;
  private:
  bool _internal_has_d() const;
  public:
  void clear_d();
  double d() const;
  void set_d(double value);
  private:
  double _internal_d() const;
  void _internal_set_d(double value);
  public:

  // string s = 2;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  void clear_sd();
  SdCase sd_case() const;
  // @@protoc_insertion_point(class_scope:Common.Types.DoubleOrStr)
 private:
  class _Internal;
  void set_has_d();
  void set_has_s();

  inline bool has_sd() const;
  inline void clear_has_sd();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SdUnion {
      constexpr SdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double d_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    } sd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class StrStrIntSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.StrStrIntSet) */ {
 public:
  inline StrStrIntSet() : StrStrIntSet(nullptr) {}
  ~StrStrIntSet() override;
  explicit PROTOBUF_CONSTEXPR StrStrIntSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrStrIntSet(const StrStrIntSet& from);
  StrStrIntSet(StrStrIntSet&& from) noexcept
    : StrStrIntSet() {
    *this = ::std::move(from);
  }

  inline StrStrIntSet& operator=(const StrStrIntSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrStrIntSet& operator=(StrStrIntSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrStrIntSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrStrIntSet* internal_default_instance() {
    return reinterpret_cast<const StrStrIntSet*>(
               &_StrStrIntSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StrStrIntSet& a, StrStrIntSet& b) {
    a.Swap(&b);
  }
  inline void Swap(StrStrIntSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrStrIntSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrStrIntSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrStrIntSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrStrIntSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrStrIntSet& from) {
    StrStrIntSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrStrIntSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.StrStrIntSet";
  }
  protected:
  explicit StrStrIntSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kIFieldNumber = 3,
  };
  // required string s1 = 1;
  bool has_s1() const;
  private:
  bool _internal_has_s1() const;
  public:
  void clear_s1();
  const std::string& s1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* s1);
  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(const std::string& value);
  std::string* _internal_mutable_s1();
  public:

  // required string s2 = 2;
  bool has_s2() const;
  private:
  bool _internal_has_s2() const;
  public:
  void clear_s2();
  const std::string& s2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* s2);
  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(const std::string& value);
  std::string* _internal_mutable_s2();
  public:

  // required int32 i = 3;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int32_t i() const;
  void set_i(int32_t value);
  private:
  int32_t _internal_i() const;
  void _internal_set_i(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.StrStrIntSet)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s2_;
    int32_t i_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class StrULongMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.StrULongMap) */ {
 public:
  inline StrULongMap() : StrULongMap(nullptr) {}
  ~StrULongMap() override;
  explicit PROTOBUF_CONSTEXPR StrULongMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrULongMap(const StrULongMap& from);
  StrULongMap(StrULongMap&& from) noexcept
    : StrULongMap() {
    *this = ::std::move(from);
  }

  inline StrULongMap& operator=(const StrULongMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrULongMap& operator=(StrULongMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrULongMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrULongMap* internal_default_instance() {
    return reinterpret_cast<const StrULongMap*>(
               &_StrULongMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StrULongMap& a, StrULongMap& b) {
    a.Swap(&b);
  }
  inline void Swap(StrULongMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrULongMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrULongMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrULongMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrULongMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrULongMap& from) {
    StrULongMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrULongMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.StrULongMap";
  }
  protected:
  explicit StrULongMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kUlFieldNumber = 2,
  };
  // required string s = 1;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // required uint64 ul = 2;
  bool has_ul() const;
  private:
  bool _internal_has_ul() const;
  public:
  void clear_ul();
  uint64_t ul() const;
  void set_ul(uint64_t value);
  private:
  uint64_t _internal_ul() const;
  void _internal_set_ul(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.StrULongMap)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    uint64_t ul_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class StringList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.StringList) */ {
 public:
  inline StringList() : StringList(nullptr) {}
  ~StringList() override;
  explicit PROTOBUF_CONSTEXPR StringList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringList(const StringList& from);
  StringList(StringList&& from) noexcept
    : StringList() {
    *this = ::std::move(from);
  }

  inline StringList& operator=(const StringList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringList& operator=(StringList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringList* internal_default_instance() {
    return reinterpret_cast<const StringList*>(
               &_StringList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StringList& a, StringList& b) {
    a.Swap(&b);
  }
  inline void Swap(StringList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringList& from) {
    StringList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.StringList";
  }
  protected:
  explicit StringList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlFieldNumber = 1,
  };
  // repeated string sl = 1;
  int sl_size() const;
  private:
  int _internal_sl_size() const;
  public:
  void clear_sl();
  const std::string& sl(int index) const;
  std::string* mutable_sl(int index);
  void set_sl(int index, const std::string& value);
  void set_sl(int index, std::string&& value);
  void set_sl(int index, const char* value);
  void set_sl(int index, const char* value, size_t size);
  std::string* add_sl();
  void add_sl(const std::string& value);
  void add_sl(std::string&& value);
  void add_sl(const char* value);
  void add_sl(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sl();
  private:
  const std::string& _internal_sl(int index) const;
  std::string* _internal_add_sl();
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.StringList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class BytesList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.BytesList) */ {
 public:
  inline BytesList() : BytesList(nullptr) {}
  ~BytesList() override;
  explicit PROTOBUF_CONSTEXPR BytesList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BytesList(const BytesList& from);
  BytesList(BytesList&& from) noexcept
    : BytesList() {
    *this = ::std::move(from);
  }

  inline BytesList& operator=(const BytesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesList& operator=(BytesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BytesList* internal_default_instance() {
    return reinterpret_cast<const BytesList*>(
               &_BytesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BytesList& a, BytesList& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BytesList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BytesList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BytesList& from) {
    BytesList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.BytesList";
  }
  protected:
  explicit BytesList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlFieldNumber = 1,
  };
  // repeated bytes bl = 1;
  int bl_size() const;
  private:
  int _internal_bl_size() const;
  public:
  void clear_bl();
  const std::string& bl(int index) const;
  std::string* mutable_bl(int index);
  void set_bl(int index, const std::string& value);
  void set_bl(int index, std::string&& value);
  void set_bl(int index, const char* value);
  void set_bl(int index, const void* value, size_t size);
  std::string* add_bl();
  void add_bl(const std::string& value);
  void add_bl(std::string&& value);
  void add_bl(const char* value);
  void add_bl(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bl();
  private:
  const std::string& _internal_bl(int index) const;
  std::string* _internal_add_bl();
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.BytesList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class BytesListWithStartEnd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.BytesListWithStartEnd) */ {
 public:
  inline BytesListWithStartEnd() : BytesListWithStartEnd(nullptr) {}
  ~BytesListWithStartEnd() override;
  explicit PROTOBUF_CONSTEXPR BytesListWithStartEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BytesListWithStartEnd(const BytesListWithStartEnd& from);
  BytesListWithStartEnd(BytesListWithStartEnd&& from) noexcept
    : BytesListWithStartEnd() {
    *this = ::std::move(from);
  }

  inline BytesListWithStartEnd& operator=(const BytesListWithStartEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesListWithStartEnd& operator=(BytesListWithStartEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesListWithStartEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const BytesListWithStartEnd* internal_default_instance() {
    return reinterpret_cast<const BytesListWithStartEnd*>(
               &_BytesListWithStartEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BytesListWithStartEnd& a, BytesListWithStartEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesListWithStartEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesListWithStartEnd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesListWithStartEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BytesListWithStartEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BytesListWithStartEnd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BytesListWithStartEnd& from) {
    BytesListWithStartEnd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesListWithStartEnd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.BytesListWithStartEnd";
  }
  protected:
  explicit BytesListWithStartEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlFieldNumber = 4,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kCounterFieldNumber = 3,
  };
  // repeated bytes bl = 4;
  int bl_size() const;
  private:
  int _internal_bl_size() const;
  public:
  void clear_bl();
  const std::string& bl(int index) const;
  std::string* mutable_bl(int index);
  void set_bl(int index, const std::string& value);
  void set_bl(int index, std::string&& value);
  void set_bl(int index, const char* value);
  void set_bl(int index, const void* value, size_t size);
  std::string* add_bl();
  void add_bl(const std::string& value);
  void add_bl(std::string&& value);
  void add_bl(const char* value);
  void add_bl(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bl();
  private:
  const std::string& _internal_bl(int index) const;
  std::string* _internal_add_bl();
  public:

  // required uint64 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  uint64_t start() const;
  void set_start(uint64_t value);
  private:
  uint64_t _internal_start() const;
  void _internal_set_start(uint64_t value);
  public:

  // required uint64 end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  uint64_t end() const;
  void set_end(uint64_t value);
  private:
  uint64_t _internal_end() const;
  void _internal_set_end(uint64_t value);
  public:

  // required uint64 counter = 3;
  bool has_counter() const;
  private:
  bool _internal_has_counter() const;
  public:
  void clear_counter();
  uint64_t counter() const;
  void set_counter(uint64_t value);
  private:
  uint64_t _internal_counter() const;
  void _internal_set_counter(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.BytesListWithStartEnd)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bl_;
    uint64_t start_;
    uint64_t end_;
    uint64_t counter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class AnalysisModeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.AnalysisModeEnum) */ {
 public:
  inline AnalysisModeEnum() : AnalysisModeEnum(nullptr) {}
  ~AnalysisModeEnum() override;
  explicit PROTOBUF_CONSTEXPR AnalysisModeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnalysisModeEnum(const AnalysisModeEnum& from);
  AnalysisModeEnum(AnalysisModeEnum&& from) noexcept
    : AnalysisModeEnum() {
    *this = ::std::move(from);
  }

  inline AnalysisModeEnum& operator=(const AnalysisModeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalysisModeEnum& operator=(AnalysisModeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalysisModeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalysisModeEnum* internal_default_instance() {
    return reinterpret_cast<const AnalysisModeEnum*>(
               &_AnalysisModeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AnalysisModeEnum& a, AnalysisModeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalysisModeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalysisModeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalysisModeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalysisModeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnalysisModeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnalysisModeEnum& from) {
    AnalysisModeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalysisModeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.AnalysisModeEnum";
  }
  protected:
  explicit AnalysisModeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AnalysisModeEnum_AnalysisMode AnalysisMode;
  static constexpr AnalysisMode kMax =
    AnalysisModeEnum_AnalysisMode_kMax;
  static constexpr AnalysisMode kMin =
    AnalysisModeEnum_AnalysisMode_kMin;
  static constexpr AnalysisMode kMaxMin =
    AnalysisModeEnum_AnalysisMode_kMaxMin;
  static inline bool AnalysisMode_IsValid(int value) {
    return AnalysisModeEnum_AnalysisMode_IsValid(value);
  }
  static constexpr AnalysisMode AnalysisMode_MIN =
    AnalysisModeEnum_AnalysisMode_AnalysisMode_MIN;
  static constexpr AnalysisMode AnalysisMode_MAX =
    AnalysisModeEnum_AnalysisMode_AnalysisMode_MAX;
  static constexpr int AnalysisMode_ARRAYSIZE =
    AnalysisModeEnum_AnalysisMode_AnalysisMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AnalysisMode_descriptor() {
    return AnalysisModeEnum_AnalysisMode_descriptor();
  }
  template<typename T>
  static inline const std::string& AnalysisMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AnalysisMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AnalysisMode_Name.");
    return AnalysisModeEnum_AnalysisMode_Name(enum_t_value);
  }
  static inline bool AnalysisMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AnalysisMode* value) {
    return AnalysisModeEnum_AnalysisMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAmFieldNumber = 1,
  };
  // required .Common.Types.AnalysisModeEnum.AnalysisMode am = 1;
  bool has_am() const;
  private:
  bool _internal_has_am() const;
  public:
  void clear_am();
  ::Common::Types::AnalysisModeEnum_AnalysisMode am() const;
  void set_am(::Common::Types::AnalysisModeEnum_AnalysisMode value);
  private:
  ::Common::Types::AnalysisModeEnum_AnalysisMode _internal_am() const;
  void _internal_set_am(::Common::Types::AnalysisModeEnum_AnalysisMode value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.AnalysisModeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int am_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class TransTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.TransTypeEnum) */ {
 public:
  inline TransTypeEnum() : TransTypeEnum(nullptr) {}
  ~TransTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR TransTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransTypeEnum(const TransTypeEnum& from);
  TransTypeEnum(TransTypeEnum&& from) noexcept
    : TransTypeEnum() {
    *this = ::std::move(from);
  }

  inline TransTypeEnum& operator=(const TransTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransTypeEnum& operator=(TransTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransTypeEnum* internal_default_instance() {
    return reinterpret_cast<const TransTypeEnum*>(
               &_TransTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TransTypeEnum& a, TransTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(TransTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransTypeEnum& from) {
    TransTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.TransTypeEnum";
  }
  protected:
  explicit TransTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransTypeEnum_TransType TransType;
  static constexpr TransType kRise =
    TransTypeEnum_TransType_kRise;
  static constexpr TransType kFall =
    TransTypeEnum_TransType_kFall;
  static inline bool TransType_IsValid(int value) {
    return TransTypeEnum_TransType_IsValid(value);
  }
  static constexpr TransType TransType_MIN =
    TransTypeEnum_TransType_TransType_MIN;
  static constexpr TransType TransType_MAX =
    TransTypeEnum_TransType_TransType_MAX;
  static constexpr int TransType_ARRAYSIZE =
    TransTypeEnum_TransType_TransType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TransType_descriptor() {
    return TransTypeEnum_TransType_descriptor();
  }
  template<typename T>
  static inline const std::string& TransType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TransType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TransType_Name.");
    return TransTypeEnum_TransType_Name(enum_t_value);
  }
  static inline bool TransType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TransType* value) {
    return TransTypeEnum_TransType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTtFieldNumber = 1,
  };
  // required .Common.Types.TransTypeEnum.TransType tt = 1;
  bool has_tt() const;
  private:
  bool _internal_has_tt() const;
  public:
  void clear_tt();
  ::Common::Types::TransTypeEnum_TransType tt() const;
  void set_tt(::Common::Types::TransTypeEnum_TransType value);
  private:
  ::Common::Types::TransTypeEnum_TransType _internal_tt() const;
  void _internal_set_tt(::Common::Types::TransTypeEnum_TransType value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.TransTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int tt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ModeTransPairClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ModeTransPairClass) */ {
 public:
  inline ModeTransPairClass() : ModeTransPairClass(nullptr) {}
  ~ModeTransPairClass() override;
  explicit PROTOBUF_CONSTEXPR ModeTransPairClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModeTransPairClass(const ModeTransPairClass& from);
  ModeTransPairClass(ModeTransPairClass&& from) noexcept
    : ModeTransPairClass() {
    *this = ::std::move(from);
  }

  inline ModeTransPairClass& operator=(const ModeTransPairClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModeTransPairClass& operator=(ModeTransPairClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModeTransPairClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModeTransPairClass* internal_default_instance() {
    return reinterpret_cast<const ModeTransPairClass*>(
               &_ModeTransPairClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ModeTransPairClass& a, ModeTransPairClass& b) {
    a.Swap(&b);
  }
  inline void Swap(ModeTransPairClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModeTransPairClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModeTransPairClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModeTransPairClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModeTransPairClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModeTransPairClass& from) {
    ModeTransPairClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModeTransPairClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ModeTransPairClass";
  }
  protected:
  explicit ModeTransPairClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmeFieldNumber = 1,
    kTteFieldNumber = 2,
  };
  // required .Common.Types.AnalysisModeEnum ame = 1;
  bool has_ame() const;
  private:
  bool _internal_has_ame() const;
  public:
  void clear_ame();
  const ::Common::Types::AnalysisModeEnum& ame() const;
  PROTOBUF_NODISCARD ::Common::Types::AnalysisModeEnum* release_ame();
  ::Common::Types::AnalysisModeEnum* mutable_ame();
  void set_allocated_ame(::Common::Types::AnalysisModeEnum* ame);
  private:
  const ::Common::Types::AnalysisModeEnum& _internal_ame() const;
  ::Common::Types::AnalysisModeEnum* _internal_mutable_ame();
  public:
  void unsafe_arena_set_allocated_ame(
      ::Common::Types::AnalysisModeEnum* ame);
  ::Common::Types::AnalysisModeEnum* unsafe_arena_release_ame();

  // required .Common.Types.TransTypeEnum tte = 2;
  bool has_tte() const;
  private:
  bool _internal_has_tte() const;
  public:
  void clear_tte();
  const ::Common::Types::TransTypeEnum& tte() const;
  PROTOBUF_NODISCARD ::Common::Types::TransTypeEnum* release_tte();
  ::Common::Types::TransTypeEnum* mutable_tte();
  void set_allocated_tte(::Common::Types::TransTypeEnum* tte);
  private:
  const ::Common::Types::TransTypeEnum& _internal_tte() const;
  ::Common::Types::TransTypeEnum* _internal_mutable_tte();
  public:
  void unsafe_arena_set_allocated_tte(
      ::Common::Types::TransTypeEnum* tte);
  ::Common::Types::TransTypeEnum* unsafe_arena_release_tte();

  // @@protoc_insertion_point(class_scope:Common.Types.ModeTransPairClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Common::Types::AnalysisModeEnum* ame_;
    ::Common::Types::TransTypeEnum* tte_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ModeTransPairMapDouble final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ModeTransPairMapDouble) */ {
 public:
  inline ModeTransPairMapDouble() : ModeTransPairMapDouble(nullptr) {}
  ~ModeTransPairMapDouble() override;
  explicit PROTOBUF_CONSTEXPR ModeTransPairMapDouble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModeTransPairMapDouble(const ModeTransPairMapDouble& from);
  ModeTransPairMapDouble(ModeTransPairMapDouble&& from) noexcept
    : ModeTransPairMapDouble() {
    *this = ::std::move(from);
  }

  inline ModeTransPairMapDouble& operator=(const ModeTransPairMapDouble& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModeTransPairMapDouble& operator=(ModeTransPairMapDouble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModeTransPairMapDouble& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModeTransPairMapDouble* internal_default_instance() {
    return reinterpret_cast<const ModeTransPairMapDouble*>(
               &_ModeTransPairMapDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ModeTransPairMapDouble& a, ModeTransPairMapDouble& b) {
    a.Swap(&b);
  }
  inline void Swap(ModeTransPairMapDouble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModeTransPairMapDouble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModeTransPairMapDouble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModeTransPairMapDouble>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModeTransPairMapDouble& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModeTransPairMapDouble& from) {
    ModeTransPairMapDouble::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModeTransPairMapDouble* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ModeTransPairMapDouble";
  }
  protected:
  explicit ModeTransPairMapDouble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // required .Common.Types.ModeTransPairClass first = 1;
  bool has_first() const;
  private:
  bool _internal_has_first() const;
  public:
  void clear_first();
  const ::Common::Types::ModeTransPairClass& first() const;
  PROTOBUF_NODISCARD ::Common::Types::ModeTransPairClass* release_first();
  ::Common::Types::ModeTransPairClass* mutable_first();
  void set_allocated_first(::Common::Types::ModeTransPairClass* first);
  private:
  const ::Common::Types::ModeTransPairClass& _internal_first() const;
  ::Common::Types::ModeTransPairClass* _internal_mutable_first();
  public:
  void unsafe_arena_set_allocated_first(
      ::Common::Types::ModeTransPairClass* first);
  ::Common::Types::ModeTransPairClass* unsafe_arena_release_first();

  // required double second = 2;
  bool has_second() const;
  private:
  bool _internal_has_second() const;
  public:
  void clear_second();
  double second() const;
  void set_second(double value);
  private:
  double _internal_second() const;
  void _internal_set_second(double value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.ModeTransPairMapDouble)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Common::Types::ModeTransPairClass* first_;
    double second_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class CapacitiveUnitEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.CapacitiveUnitEnum) */ {
 public:
  inline CapacitiveUnitEnum() : CapacitiveUnitEnum(nullptr) {}
  ~CapacitiveUnitEnum() override;
  explicit PROTOBUF_CONSTEXPR CapacitiveUnitEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapacitiveUnitEnum(const CapacitiveUnitEnum& from);
  CapacitiveUnitEnum(CapacitiveUnitEnum&& from) noexcept
    : CapacitiveUnitEnum() {
    *this = ::std::move(from);
  }

  inline CapacitiveUnitEnum& operator=(const CapacitiveUnitEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacitiveUnitEnum& operator=(CapacitiveUnitEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacitiveUnitEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacitiveUnitEnum* internal_default_instance() {
    return reinterpret_cast<const CapacitiveUnitEnum*>(
               &_CapacitiveUnitEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CapacitiveUnitEnum& a, CapacitiveUnitEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(CapacitiveUnitEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacitiveUnitEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacitiveUnitEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapacitiveUnitEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapacitiveUnitEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CapacitiveUnitEnum& from) {
    CapacitiveUnitEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapacitiveUnitEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.CapacitiveUnitEnum";
  }
  protected:
  explicit CapacitiveUnitEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CapacitiveUnitEnum_CapacitiveUnit CapacitiveUnit;
  static constexpr CapacitiveUnit kPF =
    CapacitiveUnitEnum_CapacitiveUnit_kPF;
  static constexpr CapacitiveUnit kFF =
    CapacitiveUnitEnum_CapacitiveUnit_kFF;
  static inline bool CapacitiveUnit_IsValid(int value) {
    return CapacitiveUnitEnum_CapacitiveUnit_IsValid(value);
  }
  static constexpr CapacitiveUnit CapacitiveUnit_MIN =
    CapacitiveUnitEnum_CapacitiveUnit_CapacitiveUnit_MIN;
  static constexpr CapacitiveUnit CapacitiveUnit_MAX =
    CapacitiveUnitEnum_CapacitiveUnit_CapacitiveUnit_MAX;
  static constexpr int CapacitiveUnit_ARRAYSIZE =
    CapacitiveUnitEnum_CapacitiveUnit_CapacitiveUnit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CapacitiveUnit_descriptor() {
    return CapacitiveUnitEnum_CapacitiveUnit_descriptor();
  }
  template<typename T>
  static inline const std::string& CapacitiveUnit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CapacitiveUnit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CapacitiveUnit_Name.");
    return CapacitiveUnitEnum_CapacitiveUnit_Name(enum_t_value);
  }
  static inline bool CapacitiveUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CapacitiveUnit* value) {
    return CapacitiveUnitEnum_CapacitiveUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCuFieldNumber = 1,
  };
  // required .Common.Types.CapacitiveUnitEnum.CapacitiveUnit cu = 1;
  bool has_cu() const;
  private:
  bool _internal_has_cu() const;
  public:
  void clear_cu();
  ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit cu() const;
  void set_cu(::Common::Types::CapacitiveUnitEnum_CapacitiveUnit value);
  private:
  ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit _internal_cu() const;
  void _internal_set_cu(::Common::Types::CapacitiveUnitEnum_CapacitiveUnit value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.CapacitiveUnitEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int cu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// -------------------------------------------------------------------

class ResistanceUnitEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Common.Types.ResistanceUnitEnum) */ {
 public:
  inline ResistanceUnitEnum() : ResistanceUnitEnum(nullptr) {}
  ~ResistanceUnitEnum() override;
  explicit PROTOBUF_CONSTEXPR ResistanceUnitEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResistanceUnitEnum(const ResistanceUnitEnum& from);
  ResistanceUnitEnum(ResistanceUnitEnum&& from) noexcept
    : ResistanceUnitEnum() {
    *this = ::std::move(from);
  }

  inline ResistanceUnitEnum& operator=(const ResistanceUnitEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResistanceUnitEnum& operator=(ResistanceUnitEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResistanceUnitEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResistanceUnitEnum* internal_default_instance() {
    return reinterpret_cast<const ResistanceUnitEnum*>(
               &_ResistanceUnitEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResistanceUnitEnum& a, ResistanceUnitEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(ResistanceUnitEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResistanceUnitEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResistanceUnitEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResistanceUnitEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResistanceUnitEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResistanceUnitEnum& from) {
    ResistanceUnitEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResistanceUnitEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Common.Types.ResistanceUnitEnum";
  }
  protected:
  explicit ResistanceUnitEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResistanceUnitEnum_ResistanceUnit ResistanceUnit;
  static constexpr ResistanceUnit kOHM =
    ResistanceUnitEnum_ResistanceUnit_kOHM;
  static constexpr ResistanceUnit kkOHM =
    ResistanceUnitEnum_ResistanceUnit_kkOHM;
  static inline bool ResistanceUnit_IsValid(int value) {
    return ResistanceUnitEnum_ResistanceUnit_IsValid(value);
  }
  static constexpr ResistanceUnit ResistanceUnit_MIN =
    ResistanceUnitEnum_ResistanceUnit_ResistanceUnit_MIN;
  static constexpr ResistanceUnit ResistanceUnit_MAX =
    ResistanceUnitEnum_ResistanceUnit_ResistanceUnit_MAX;
  static constexpr int ResistanceUnit_ARRAYSIZE =
    ResistanceUnitEnum_ResistanceUnit_ResistanceUnit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResistanceUnit_descriptor() {
    return ResistanceUnitEnum_ResistanceUnit_descriptor();
  }
  template<typename T>
  static inline const std::string& ResistanceUnit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResistanceUnit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResistanceUnit_Name.");
    return ResistanceUnitEnum_ResistanceUnit_Name(enum_t_value);
  }
  static inline bool ResistanceUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResistanceUnit* value) {
    return ResistanceUnitEnum_ResistanceUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRuFieldNumber = 1,
  };
  // required .Common.Types.ResistanceUnitEnum.ResistanceUnit ru = 1;
  bool has_ru() const;
  private:
  bool _internal_has_ru() const;
  public:
  void clear_ru();
  ::Common::Types::ResistanceUnitEnum_ResistanceUnit ru() const;
  void set_ru(::Common::Types::ResistanceUnitEnum_ResistanceUnit value);
  private:
  ::Common::Types::ResistanceUnitEnum_ResistanceUnit _internal_ru() const;
  void _internal_set_ru(::Common::Types::ResistanceUnitEnum_ResistanceUnit value);
  public:

  // @@protoc_insertion_point(class_scope:Common.Types.ResistanceUnitEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int ru_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CommonTypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EmptyMsg

// required .google.protobuf.Empty e = 1;
inline bool EmptyMsg::_internal_has_e() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.e_ != nullptr);
  return value;
}
inline bool EmptyMsg::has_e() const {
  return _internal_has_e();
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& EmptyMsg::_internal_e() const {
  const ::PROTOBUF_NAMESPACE_ID::Empty* p = _impl_.e_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Empty&>(
      ::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& EmptyMsg::e() const {
  // @@protoc_insertion_point(field_get:Common.Types.EmptyMsg.e)
  return _internal_e();
}
inline void EmptyMsg::unsafe_arena_set_allocated_e(
    ::PROTOBUF_NAMESPACE_ID::Empty* e) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e_);
  }
  _impl_.e_ = e;
  if (e) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.Types.EmptyMsg.e)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* EmptyMsg::release_e() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.e_;
  _impl_.e_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* EmptyMsg::unsafe_arena_release_e() {
  // @@protoc_insertion_point(field_release:Common.Types.EmptyMsg.e)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.e_;
  _impl_.e_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* EmptyMsg::_internal_mutable_e() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.e_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Empty>(GetArenaForAllocation());
    _impl_.e_ = p;
  }
  return _impl_.e_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* EmptyMsg::mutable_e() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_e();
  // @@protoc_insertion_point(field_mutable:Common.Types.EmptyMsg.e)
  return _msg;
}
inline void EmptyMsg::set_allocated_e(::PROTOBUF_NAMESPACE_ID::Empty* e) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e_);
  }
  if (e) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(e));
    if (message_arena != submessage_arena) {
      e = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, e, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.e_ = e;
  // @@protoc_insertion_point(field_set_allocated:Common.Types.EmptyMsg.e)
}

// -------------------------------------------------------------------

// IntMsg

// required int32 i = 1;
inline bool IntMsg::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntMsg::has_i() const {
  return _internal_has_i();
}
inline void IntMsg::clear_i() {
  _impl_.i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t IntMsg::_internal_i() const {
  return _impl_.i_;
}
inline int32_t IntMsg::i() const {
  // @@protoc_insertion_point(field_get:Common.Types.IntMsg.i)
  return _internal_i();
}
inline void IntMsg::_internal_set_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.i_ = value;
}
inline void IntMsg::set_i(int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:Common.Types.IntMsg.i)
}

// -------------------------------------------------------------------

// LongMsg

// required int64 l = 1;
inline bool LongMsg::_internal_has_l() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LongMsg::has_l() const {
  return _internal_has_l();
}
inline void LongMsg::clear_l() {
  _impl_.l_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t LongMsg::_internal_l() const {
  return _impl_.l_;
}
inline int64_t LongMsg::l() const {
  // @@protoc_insertion_point(field_get:Common.Types.LongMsg.l)
  return _internal_l();
}
inline void LongMsg::_internal_set_l(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.l_ = value;
}
inline void LongMsg::set_l(int64_t value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:Common.Types.LongMsg.l)
}

// -------------------------------------------------------------------

// UIntMsg

// required uint32 ui = 1;
inline bool UIntMsg::_internal_has_ui() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UIntMsg::has_ui() const {
  return _internal_has_ui();
}
inline void UIntMsg::clear_ui() {
  _impl_.ui_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UIntMsg::_internal_ui() const {
  return _impl_.ui_;
}
inline uint32_t UIntMsg::ui() const {
  // @@protoc_insertion_point(field_get:Common.Types.UIntMsg.ui)
  return _internal_ui();
}
inline void UIntMsg::_internal_set_ui(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ui_ = value;
}
inline void UIntMsg::set_ui(uint32_t value) {
  _internal_set_ui(value);
  // @@protoc_insertion_point(field_set:Common.Types.UIntMsg.ui)
}

// -------------------------------------------------------------------

// ULongMsg

// required uint64 ul = 1;
inline bool ULongMsg::_internal_has_ul() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ULongMsg::has_ul() const {
  return _internal_has_ul();
}
inline void ULongMsg::clear_ul() {
  _impl_.ul_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ULongMsg::_internal_ul() const {
  return _impl_.ul_;
}
inline uint64_t ULongMsg::ul() const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongMsg.ul)
  return _internal_ul();
}
inline void ULongMsg::_internal_set_ul(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ul_ = value;
}
inline void ULongMsg::set_ul(uint64_t value) {
  _internal_set_ul(value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongMsg.ul)
}

// -------------------------------------------------------------------

// FloatMsg

// required float f = 1;
inline bool FloatMsg::_internal_has_f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FloatMsg::has_f() const {
  return _internal_has_f();
}
inline void FloatMsg::clear_f() {
  _impl_.f_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FloatMsg::_internal_f() const {
  return _impl_.f_;
}
inline float FloatMsg::f() const {
  // @@protoc_insertion_point(field_get:Common.Types.FloatMsg.f)
  return _internal_f();
}
inline void FloatMsg::_internal_set_f(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.f_ = value;
}
inline void FloatMsg::set_f(float value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:Common.Types.FloatMsg.f)
}

// -------------------------------------------------------------------

// DoubleMsg

// required double d = 1;
inline bool DoubleMsg::_internal_has_d() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DoubleMsg::has_d() const {
  return _internal_has_d();
}
inline void DoubleMsg::clear_d() {
  _impl_.d_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double DoubleMsg::_internal_d() const {
  return _impl_.d_;
}
inline double DoubleMsg::d() const {
  // @@protoc_insertion_point(field_get:Common.Types.DoubleMsg.d)
  return _internal_d();
}
inline void DoubleMsg::_internal_set_d(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.d_ = value;
}
inline void DoubleMsg::set_d(double value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:Common.Types.DoubleMsg.d)
}

// -------------------------------------------------------------------

// BoolMsg

// required bool b = 1;
inline bool BoolMsg::_internal_has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BoolMsg::has_b() const {
  return _internal_has_b();
}
inline void BoolMsg::clear_b() {
  _impl_.b_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BoolMsg::_internal_b() const {
  return _impl_.b_;
}
inline bool BoolMsg::b() const {
  // @@protoc_insertion_point(field_get:Common.Types.BoolMsg.b)
  return _internal_b();
}
inline void BoolMsg::_internal_set_b(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.b_ = value;
}
inline void BoolMsg::set_b(bool value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:Common.Types.BoolMsg.b)
}

// -------------------------------------------------------------------

// StringMsg

// required string s = 1;
inline bool StringMsg::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StringMsg::has_s() const {
  return _internal_has_s();
}
inline void StringMsg::clear_s() {
  _impl_.s_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringMsg::s() const {
  // @@protoc_insertion_point(field_get:Common.Types.StringMsg.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringMsg::set_s(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Types.StringMsg.s)
}
inline std::string* StringMsg::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:Common.Types.StringMsg.s)
  return _s;
}
inline const std::string& StringMsg::_internal_s() const {
  return _impl_.s_.Get();
}
inline void StringMsg::_internal_set_s(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* StringMsg::_internal_mutable_s() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.s_.Mutable(GetArenaForAllocation());
}
inline std::string* StringMsg::release_s() {
  // @@protoc_insertion_point(field_release:Common.Types.StringMsg.s)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.s_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StringMsg::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Types.StringMsg.s)
}

// -------------------------------------------------------------------

// IntPair

// required int32 first = 1;
inline bool IntPair::_internal_has_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntPair::has_first() const {
  return _internal_has_first();
}
inline void IntPair::clear_first() {
  _impl_.first_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t IntPair::_internal_first() const {
  return _impl_.first_;
}
inline int32_t IntPair::first() const {
  // @@protoc_insertion_point(field_get:Common.Types.IntPair.first)
  return _internal_first();
}
inline void IntPair::_internal_set_first(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.first_ = value;
}
inline void IntPair::set_first(int32_t value) {
  _internal_set_first(value);
  // @@protoc_insertion_point(field_set:Common.Types.IntPair.first)
}

// required int32 second = 2;
inline bool IntPair::_internal_has_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IntPair::has_second() const {
  return _internal_has_second();
}
inline void IntPair::clear_second() {
  _impl_.second_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t IntPair::_internal_second() const {
  return _impl_.second_;
}
inline int32_t IntPair::second() const {
  // @@protoc_insertion_point(field_get:Common.Types.IntPair.second)
  return _internal_second();
}
inline void IntPair::_internal_set_second(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.second_ = value;
}
inline void IntPair::set_second(int32_t value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:Common.Types.IntPair.second)
}

// -------------------------------------------------------------------

// DoubleList

// repeated double d = 1;
inline int DoubleList::_internal_d_size() const {
  return _impl_.d_.size();
}
inline int DoubleList::d_size() const {
  return _internal_d_size();
}
inline void DoubleList::clear_d() {
  _impl_.d_.Clear();
}
inline double DoubleList::_internal_d(int index) const {
  return _impl_.d_.Get(index);
}
inline double DoubleList::d(int index) const {
  // @@protoc_insertion_point(field_get:Common.Types.DoubleList.d)
  return _internal_d(index);
}
inline void DoubleList::set_d(int index, double value) {
  _impl_.d_.Set(index, value);
  // @@protoc_insertion_point(field_set:Common.Types.DoubleList.d)
}
inline void DoubleList::_internal_add_d(double value) {
  _impl_.d_.Add(value);
}
inline void DoubleList::add_d(double value) {
  _internal_add_d(value);
  // @@protoc_insertion_point(field_add:Common.Types.DoubleList.d)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleList::_internal_d() const {
  return _impl_.d_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleList::d() const {
  // @@protoc_insertion_point(field_list:Common.Types.DoubleList.d)
  return _internal_d();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleList::_internal_mutable_d() {
  return &_impl_.d_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleList::mutable_d() {
  // @@protoc_insertion_point(field_mutable_list:Common.Types.DoubleList.d)
  return _internal_mutable_d();
}

// -------------------------------------------------------------------

// DoubleMatrix

// repeated .Common.Types.DoubleList dl = 1;
inline int DoubleMatrix::_internal_dl_size() const {
  return _impl_.dl_.size();
}
inline int DoubleMatrix::dl_size() const {
  return _internal_dl_size();
}
inline void DoubleMatrix::clear_dl() {
  _impl_.dl_.Clear();
}
inline ::Common::Types::DoubleList* DoubleMatrix::mutable_dl(int index) {
  // @@protoc_insertion_point(field_mutable:Common.Types.DoubleMatrix.dl)
  return _impl_.dl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleList >*
DoubleMatrix::mutable_dl() {
  // @@protoc_insertion_point(field_mutable_list:Common.Types.DoubleMatrix.dl)
  return &_impl_.dl_;
}
inline const ::Common::Types::DoubleList& DoubleMatrix::_internal_dl(int index) const {
  return _impl_.dl_.Get(index);
}
inline const ::Common::Types::DoubleList& DoubleMatrix::dl(int index) const {
  // @@protoc_insertion_point(field_get:Common.Types.DoubleMatrix.dl)
  return _internal_dl(index);
}
inline ::Common::Types::DoubleList* DoubleMatrix::_internal_add_dl() {
  return _impl_.dl_.Add();
}
inline ::Common::Types::DoubleList* DoubleMatrix::add_dl() {
  ::Common::Types::DoubleList* _add = _internal_add_dl();
  // @@protoc_insertion_point(field_add:Common.Types.DoubleMatrix.dl)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleList >&
DoubleMatrix::dl() const {
  // @@protoc_insertion_point(field_list:Common.Types.DoubleMatrix.dl)
  return _impl_.dl_;
}

// -------------------------------------------------------------------

// DoubleMatrixTuple

// repeated .Common.Types.DoubleMatrix dm = 1;
inline int DoubleMatrixTuple::_internal_dm_size() const {
  return _impl_.dm_.size();
}
inline int DoubleMatrixTuple::dm_size() const {
  return _internal_dm_size();
}
inline void DoubleMatrixTuple::clear_dm() {
  _impl_.dm_.Clear();
}
inline ::Common::Types::DoubleMatrix* DoubleMatrixTuple::mutable_dm(int index) {
  // @@protoc_insertion_point(field_mutable:Common.Types.DoubleMatrixTuple.dm)
  return _impl_.dm_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleMatrix >*
DoubleMatrixTuple::mutable_dm() {
  // @@protoc_insertion_point(field_mutable_list:Common.Types.DoubleMatrixTuple.dm)
  return &_impl_.dm_;
}
inline const ::Common::Types::DoubleMatrix& DoubleMatrixTuple::_internal_dm(int index) const {
  return _impl_.dm_.Get(index);
}
inline const ::Common::Types::DoubleMatrix& DoubleMatrixTuple::dm(int index) const {
  // @@protoc_insertion_point(field_get:Common.Types.DoubleMatrixTuple.dm)
  return _internal_dm(index);
}
inline ::Common::Types::DoubleMatrix* DoubleMatrixTuple::_internal_add_dm() {
  return _impl_.dm_.Add();
}
inline ::Common::Types::DoubleMatrix* DoubleMatrixTuple::add_dm() {
  ::Common::Types::DoubleMatrix* _add = _internal_add_dm();
  // @@protoc_insertion_point(field_add:Common.Types.DoubleMatrixTuple.dm)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleMatrix >&
DoubleMatrixTuple::dm() const {
  // @@protoc_insertion_point(field_list:Common.Types.DoubleMatrixTuple.dm)
  return _impl_.dm_;
}

// -------------------------------------------------------------------

// ULongPair

// required uint64 first = 1;
inline bool ULongPair::_internal_has_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ULongPair::has_first() const {
  return _internal_has_first();
}
inline void ULongPair::clear_first() {
  _impl_.first_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ULongPair::_internal_first() const {
  return _impl_.first_;
}
inline uint64_t ULongPair::first() const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongPair.first)
  return _internal_first();
}
inline void ULongPair::_internal_set_first(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.first_ = value;
}
inline void ULongPair::set_first(uint64_t value) {
  _internal_set_first(value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongPair.first)
}

// required uint64 second = 2;
inline bool ULongPair::_internal_has_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ULongPair::has_second() const {
  return _internal_has_second();
}
inline void ULongPair::clear_second() {
  _impl_.second_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ULongPair::_internal_second() const {
  return _impl_.second_;
}
inline uint64_t ULongPair::second() const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongPair.second)
  return _internal_second();
}
inline void ULongPair::_internal_set_second(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.second_ = value;
}
inline void ULongPair::set_second(uint64_t value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongPair.second)
}

// -------------------------------------------------------------------

// ULongList

// repeated uint64 ul = 1;
inline int ULongList::_internal_ul_size() const {
  return _impl_.ul_.size();
}
inline int ULongList::ul_size() const {
  return _internal_ul_size();
}
inline void ULongList::clear_ul() {
  _impl_.ul_.Clear();
}
inline uint64_t ULongList::_internal_ul(int index) const {
  return _impl_.ul_.Get(index);
}
inline uint64_t ULongList::ul(int index) const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongList.ul)
  return _internal_ul(index);
}
inline void ULongList::set_ul(int index, uint64_t value) {
  _impl_.ul_.Set(index, value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongList.ul)
}
inline void ULongList::_internal_add_ul(uint64_t value) {
  _impl_.ul_.Add(value);
}
inline void ULongList::add_ul(uint64_t value) {
  _internal_add_ul(value);
  // @@protoc_insertion_point(field_add:Common.Types.ULongList.ul)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ULongList::_internal_ul() const {
  return _impl_.ul_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ULongList::ul() const {
  // @@protoc_insertion_point(field_list:Common.Types.ULongList.ul)
  return _internal_ul();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ULongList::_internal_mutable_ul() {
  return &_impl_.ul_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ULongList::mutable_ul() {
  // @@protoc_insertion_point(field_mutable_list:Common.Types.ULongList.ul)
  return _internal_mutable_ul();
}

// -------------------------------------------------------------------

// ULongUintPair

// required uint64 first = 1;
inline bool ULongUintPair::_internal_has_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ULongUintPair::has_first() const {
  return _internal_has_first();
}
inline void ULongUintPair::clear_first() {
  _impl_.first_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ULongUintPair::_internal_first() const {
  return _impl_.first_;
}
inline uint64_t ULongUintPair::first() const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongUintPair.first)
  return _internal_first();
}
inline void ULongUintPair::_internal_set_first(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.first_ = value;
}
inline void ULongUintPair::set_first(uint64_t value) {
  _internal_set_first(value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongUintPair.first)
}

// required uint32 second = 2;
inline bool ULongUintPair::_internal_has_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ULongUintPair::has_second() const {
  return _internal_has_second();
}
inline void ULongUintPair::clear_second() {
  _impl_.second_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ULongUintPair::_internal_second() const {
  return _impl_.second_;
}
inline uint32_t ULongUintPair::second() const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongUintPair.second)
  return _internal_second();
}
inline void ULongUintPair::_internal_set_second(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.second_ = value;
}
inline void ULongUintPair::set_second(uint32_t value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongUintPair.second)
}

// -------------------------------------------------------------------

// ULongDoublePair

// required uint64 first = 1;
inline bool ULongDoublePair::_internal_has_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ULongDoublePair::has_first() const {
  return _internal_has_first();
}
inline void ULongDoublePair::clear_first() {
  _impl_.first_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ULongDoublePair::_internal_first() const {
  return _impl_.first_;
}
inline uint64_t ULongDoublePair::first() const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongDoublePair.first)
  return _internal_first();
}
inline void ULongDoublePair::_internal_set_first(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.first_ = value;
}
inline void ULongDoublePair::set_first(uint64_t value) {
  _internal_set_first(value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongDoublePair.first)
}

// required double second = 2;
inline bool ULongDoublePair::_internal_has_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ULongDoublePair::has_second() const {
  return _internal_has_second();
}
inline void ULongDoublePair::clear_second() {
  _impl_.second_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ULongDoublePair::_internal_second() const {
  return _impl_.second_;
}
inline double ULongDoublePair::second() const {
  // @@protoc_insertion_point(field_get:Common.Types.ULongDoublePair.second)
  return _internal_second();
}
inline void ULongDoublePair::_internal_set_second(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.second_ = value;
}
inline void ULongDoublePair::set_second(double value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:Common.Types.ULongDoublePair.second)
}

// -------------------------------------------------------------------

// OptionalDouble

// optional double d = 1;
inline bool OptionalDouble::_internal_has_d() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OptionalDouble::has_d() const {
  return _internal_has_d();
}
inline void OptionalDouble::clear_d() {
  _impl_.d_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double OptionalDouble::_internal_d() const {
  return _impl_.d_;
}
inline double OptionalDouble::d() const {
  // @@protoc_insertion_point(field_get:Common.Types.OptionalDouble.d)
  return _internal_d();
}
inline void OptionalDouble::_internal_set_d(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.d_ = value;
}
inline void OptionalDouble::set_d(double value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:Common.Types.OptionalDouble.d)
}

// -------------------------------------------------------------------

// StrIntPair

// required string s = 1;
inline bool StrIntPair::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrIntPair::has_s() const {
  return _internal_has_s();
}
inline void StrIntPair::clear_s() {
  _impl_.s_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StrIntPair::s() const {
  // @@protoc_insertion_point(field_get:Common.Types.StrIntPair.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StrIntPair::set_s(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Types.StrIntPair.s)
}
inline std::string* StrIntPair::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:Common.Types.StrIntPair.s)
  return _s;
}
inline const std::string& StrIntPair::_internal_s() const {
  return _impl_.s_.Get();
}
inline void StrIntPair::_internal_set_s(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* StrIntPair::_internal_mutable_s() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.s_.Mutable(GetArenaForAllocation());
}
inline std::string* StrIntPair::release_s() {
  // @@protoc_insertion_point(field_release:Common.Types.StrIntPair.s)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.s_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StrIntPair::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Types.StrIntPair.s)
}

// required int32 i = 2;
inline bool StrIntPair::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StrIntPair::has_i() const {
  return _internal_has_i();
}
inline void StrIntPair::clear_i() {
  _impl_.i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t StrIntPair::_internal_i() const {
  return _impl_.i_;
}
inline int32_t StrIntPair::i() const {
  // @@protoc_insertion_point(field_get:Common.Types.StrIntPair.i)
  return _internal_i();
}
inline void StrIntPair::_internal_set_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.i_ = value;
}
inline void StrIntPair::set_i(int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:Common.Types.StrIntPair.i)
}

// -------------------------------------------------------------------

// DoubleOrStr

// double d = 1;
inline bool DoubleOrStr::_internal_has_d() const {
  return sd_case() == kD;
}
inline bool DoubleOrStr::has_d() const {
  return _internal_has_d();
}
inline void DoubleOrStr::set_has_d() {
  _impl_._oneof_case_[0] = kD;
}
inline void DoubleOrStr::clear_d() {
  if (_internal_has_d()) {
    _impl_.sd_.d_ = 0;
    clear_has_sd();
  }
}
inline double DoubleOrStr::_internal_d() const {
  if (_internal_has_d()) {
    return _impl_.sd_.d_;
  }
  return 0;
}
inline void DoubleOrStr::_internal_set_d(double value) {
  if (!_internal_has_d()) {
    clear_sd();
    set_has_d();
  }
  _impl_.sd_.d_ = value;
}
inline double DoubleOrStr::d() const {
  // @@protoc_insertion_point(field_get:Common.Types.DoubleOrStr.d)
  return _internal_d();
}
inline void DoubleOrStr::set_d(double value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:Common.Types.DoubleOrStr.d)
}

// string s = 2;
inline bool DoubleOrStr::_internal_has_s() const {
  return sd_case() == kS;
}
inline bool DoubleOrStr::has_s() const {
  return _internal_has_s();
}
inline void DoubleOrStr::set_has_s() {
  _impl_._oneof_case_[0] = kS;
}
inline void DoubleOrStr::clear_s() {
  if (_internal_has_s()) {
    _impl_.sd_.s_.Destroy();
    clear_has_sd();
  }
}
inline const std::string& DoubleOrStr::s() const {
  // @@protoc_insertion_point(field_get:Common.Types.DoubleOrStr.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline void DoubleOrStr::set_s(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_s()) {
    clear_sd();
    set_has_s();
    _impl_.sd_.s_.InitDefault();
  }
  _impl_.sd_.s_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Types.DoubleOrStr.s)
}
inline std::string* DoubleOrStr::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:Common.Types.DoubleOrStr.s)
  return _s;
}
inline const std::string& DoubleOrStr::_internal_s() const {
  if (_internal_has_s()) {
    return _impl_.sd_.s_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DoubleOrStr::_internal_set_s(const std::string& value) {
  if (!_internal_has_s()) {
    clear_sd();
    set_has_s();
    _impl_.sd_.s_.InitDefault();
  }
  _impl_.sd_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* DoubleOrStr::_internal_mutable_s() {
  if (!_internal_has_s()) {
    clear_sd();
    set_has_s();
    _impl_.sd_.s_.InitDefault();
  }
  return _impl_.sd_.s_.Mutable(      GetArenaForAllocation());
}
inline std::string* DoubleOrStr::release_s() {
  // @@protoc_insertion_point(field_release:Common.Types.DoubleOrStr.s)
  if (_internal_has_s()) {
    clear_has_sd();
    return _impl_.sd_.s_.Release();
  } else {
    return nullptr;
  }
}
inline void DoubleOrStr::set_allocated_s(std::string* s) {
  if (has_sd()) {
    clear_sd();
  }
  if (s != nullptr) {
    set_has_s();
    _impl_.sd_.s_.InitAllocated(s, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Common.Types.DoubleOrStr.s)
}

inline bool DoubleOrStr::has_sd() const {
  return sd_case() != SD_NOT_SET;
}
inline void DoubleOrStr::clear_has_sd() {
  _impl_._oneof_case_[0] = SD_NOT_SET;
}
inline DoubleOrStr::SdCase DoubleOrStr::sd_case() const {
  return DoubleOrStr::SdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StrStrIntSet

// required string s1 = 1;
inline bool StrStrIntSet::_internal_has_s1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrStrIntSet::has_s1() const {
  return _internal_has_s1();
}
inline void StrStrIntSet::clear_s1() {
  _impl_.s1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StrStrIntSet::s1() const {
  // @@protoc_insertion_point(field_get:Common.Types.StrStrIntSet.s1)
  return _internal_s1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StrStrIntSet::set_s1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.s1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Types.StrStrIntSet.s1)
}
inline std::string* StrStrIntSet::mutable_s1() {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:Common.Types.StrStrIntSet.s1)
  return _s;
}
inline const std::string& StrStrIntSet::_internal_s1() const {
  return _impl_.s1_.Get();
}
inline void StrStrIntSet::_internal_set_s1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s1_.Set(value, GetArenaForAllocation());
}
inline std::string* StrStrIntSet::_internal_mutable_s1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.s1_.Mutable(GetArenaForAllocation());
}
inline std::string* StrStrIntSet::release_s1() {
  // @@protoc_insertion_point(field_release:Common.Types.StrStrIntSet.s1)
  if (!_internal_has_s1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.s1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s1_.IsDefault()) {
    _impl_.s1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StrStrIntSet::set_allocated_s1(std::string* s1) {
  if (s1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.s1_.SetAllocated(s1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s1_.IsDefault()) {
    _impl_.s1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Types.StrStrIntSet.s1)
}

// required string s2 = 2;
inline bool StrStrIntSet::_internal_has_s2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StrStrIntSet::has_s2() const {
  return _internal_has_s2();
}
inline void StrStrIntSet::clear_s2() {
  _impl_.s2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StrStrIntSet::s2() const {
  // @@protoc_insertion_point(field_get:Common.Types.StrStrIntSet.s2)
  return _internal_s2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StrStrIntSet::set_s2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.s2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Types.StrStrIntSet.s2)
}
inline std::string* StrStrIntSet::mutable_s2() {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:Common.Types.StrStrIntSet.s2)
  return _s;
}
inline const std::string& StrStrIntSet::_internal_s2() const {
  return _impl_.s2_.Get();
}
inline void StrStrIntSet::_internal_set_s2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s2_.Set(value, GetArenaForAllocation());
}
inline std::string* StrStrIntSet::_internal_mutable_s2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.s2_.Mutable(GetArenaForAllocation());
}
inline std::string* StrStrIntSet::release_s2() {
  // @@protoc_insertion_point(field_release:Common.Types.StrStrIntSet.s2)
  if (!_internal_has_s2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.s2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s2_.IsDefault()) {
    _impl_.s2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StrStrIntSet::set_allocated_s2(std::string* s2) {
  if (s2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.s2_.SetAllocated(s2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s2_.IsDefault()) {
    _impl_.s2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Types.StrStrIntSet.s2)
}

// required int32 i = 3;
inline bool StrStrIntSet::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StrStrIntSet::has_i() const {
  return _internal_has_i();
}
inline void StrStrIntSet::clear_i() {
  _impl_.i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t StrStrIntSet::_internal_i() const {
  return _impl_.i_;
}
inline int32_t StrStrIntSet::i() const {
  // @@protoc_insertion_point(field_get:Common.Types.StrStrIntSet.i)
  return _internal_i();
}
inline void StrStrIntSet::_internal_set_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.i_ = value;
}
inline void StrStrIntSet::set_i(int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:Common.Types.StrStrIntSet.i)
}

// -------------------------------------------------------------------

// StrULongMap

// required string s = 1;
inline bool StrULongMap::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrULongMap::has_s() const {
  return _internal_has_s();
}
inline void StrULongMap::clear_s() {
  _impl_.s_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StrULongMap::s() const {
  // @@protoc_insertion_point(field_get:Common.Types.StrULongMap.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StrULongMap::set_s(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Common.Types.StrULongMap.s)
}
inline std::string* StrULongMap::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:Common.Types.StrULongMap.s)
  return _s;
}
inline const std::string& StrULongMap::_internal_s() const {
  return _impl_.s_.Get();
}
inline void StrULongMap::_internal_set_s(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* StrULongMap::_internal_mutable_s() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.s_.Mutable(GetArenaForAllocation());
}
inline std::string* StrULongMap::release_s() {
  // @@protoc_insertion_point(field_release:Common.Types.StrULongMap.s)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.s_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StrULongMap::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Common.Types.StrULongMap.s)
}

// required uint64 ul = 2;
inline bool StrULongMap::_internal_has_ul() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StrULongMap::has_ul() const {
  return _internal_has_ul();
}
inline void StrULongMap::clear_ul() {
  _impl_.ul_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t StrULongMap::_internal_ul() const {
  return _impl_.ul_;
}
inline uint64_t StrULongMap::ul() const {
  // @@protoc_insertion_point(field_get:Common.Types.StrULongMap.ul)
  return _internal_ul();
}
inline void StrULongMap::_internal_set_ul(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ul_ = value;
}
inline void StrULongMap::set_ul(uint64_t value) {
  _internal_set_ul(value);
  // @@protoc_insertion_point(field_set:Common.Types.StrULongMap.ul)
}

// -------------------------------------------------------------------

// StringList

// repeated string sl = 1;
inline int StringList::_internal_sl_size() const {
  return _impl_.sl_.size();
}
inline int StringList::sl_size() const {
  return _internal_sl_size();
}
inline void StringList::clear_sl() {
  _impl_.sl_.Clear();
}
inline std::string* StringList::add_sl() {
  std::string* _s = _internal_add_sl();
  // @@protoc_insertion_point(field_add_mutable:Common.Types.StringList.sl)
  return _s;
}
inline const std::string& StringList::_internal_sl(int index) const {
  return _impl_.sl_.Get(index);
}
inline const std::string& StringList::sl(int index) const {
  // @@protoc_insertion_point(field_get:Common.Types.StringList.sl)
  return _internal_sl(index);
}
inline std::string* StringList::mutable_sl(int index) {
  // @@protoc_insertion_point(field_mutable:Common.Types.StringList.sl)
  return _impl_.sl_.Mutable(index);
}
inline void StringList::set_sl(int index, const std::string& value) {
  _impl_.sl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Common.Types.StringList.sl)
}
inline void StringList::set_sl(int index, std::string&& value) {
  _impl_.sl_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Common.Types.StringList.sl)
}
inline void StringList::set_sl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Common.Types.StringList.sl)
}
inline void StringList::set_sl(int index, const char* value, size_t size) {
  _impl_.sl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Common.Types.StringList.sl)
}
inline std::string* StringList::_internal_add_sl() {
  return _impl_.sl_.Add();
}
inline void StringList::add_sl(const std::string& value) {
  _impl_.sl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Common.Types.StringList.sl)
}
inline void StringList::add_sl(std::string&& value) {
  _impl_.sl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Common.Types.StringList.sl)
}
inline void StringList::add_sl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Common.Types.StringList.sl)
}
inline void StringList::add_sl(const char* value, size_t size) {
  _impl_.sl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Common.Types.StringList.sl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StringList::sl() const {
  // @@protoc_insertion_point(field_list:Common.Types.StringList.sl)
  return _impl_.sl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StringList::mutable_sl() {
  // @@protoc_insertion_point(field_mutable_list:Common.Types.StringList.sl)
  return &_impl_.sl_;
}

// -------------------------------------------------------------------

// BytesList

// repeated bytes bl = 1;
inline int BytesList::_internal_bl_size() const {
  return _impl_.bl_.size();
}
inline int BytesList::bl_size() const {
  return _internal_bl_size();
}
inline void BytesList::clear_bl() {
  _impl_.bl_.Clear();
}
inline std::string* BytesList::add_bl() {
  std::string* _s = _internal_add_bl();
  // @@protoc_insertion_point(field_add_mutable:Common.Types.BytesList.bl)
  return _s;
}
inline const std::string& BytesList::_internal_bl(int index) const {
  return _impl_.bl_.Get(index);
}
inline const std::string& BytesList::bl(int index) const {
  // @@protoc_insertion_point(field_get:Common.Types.BytesList.bl)
  return _internal_bl(index);
}
inline std::string* BytesList::mutable_bl(int index) {
  // @@protoc_insertion_point(field_mutable:Common.Types.BytesList.bl)
  return _impl_.bl_.Mutable(index);
}
inline void BytesList::set_bl(int index, const std::string& value) {
  _impl_.bl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Common.Types.BytesList.bl)
}
inline void BytesList::set_bl(int index, std::string&& value) {
  _impl_.bl_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Common.Types.BytesList.bl)
}
inline void BytesList::set_bl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Common.Types.BytesList.bl)
}
inline void BytesList::set_bl(int index, const void* value, size_t size) {
  _impl_.bl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Common.Types.BytesList.bl)
}
inline std::string* BytesList::_internal_add_bl() {
  return _impl_.bl_.Add();
}
inline void BytesList::add_bl(const std::string& value) {
  _impl_.bl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Common.Types.BytesList.bl)
}
inline void BytesList::add_bl(std::string&& value) {
  _impl_.bl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Common.Types.BytesList.bl)
}
inline void BytesList::add_bl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Common.Types.BytesList.bl)
}
inline void BytesList::add_bl(const void* value, size_t size) {
  _impl_.bl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Common.Types.BytesList.bl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BytesList::bl() const {
  // @@protoc_insertion_point(field_list:Common.Types.BytesList.bl)
  return _impl_.bl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BytesList::mutable_bl() {
  // @@protoc_insertion_point(field_mutable_list:Common.Types.BytesList.bl)
  return &_impl_.bl_;
}

// -------------------------------------------------------------------

// BytesListWithStartEnd

// required uint64 start = 1;
inline bool BytesListWithStartEnd::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BytesListWithStartEnd::has_start() const {
  return _internal_has_start();
}
inline void BytesListWithStartEnd::clear_start() {
  _impl_.start_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t BytesListWithStartEnd::_internal_start() const {
  return _impl_.start_;
}
inline uint64_t BytesListWithStartEnd::start() const {
  // @@protoc_insertion_point(field_get:Common.Types.BytesListWithStartEnd.start)
  return _internal_start();
}
inline void BytesListWithStartEnd::_internal_set_start(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_ = value;
}
inline void BytesListWithStartEnd::set_start(uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:Common.Types.BytesListWithStartEnd.start)
}

// required uint64 end = 2;
inline bool BytesListWithStartEnd::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BytesListWithStartEnd::has_end() const {
  return _internal_has_end();
}
inline void BytesListWithStartEnd::clear_end() {
  _impl_.end_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t BytesListWithStartEnd::_internal_end() const {
  return _impl_.end_;
}
inline uint64_t BytesListWithStartEnd::end() const {
  // @@protoc_insertion_point(field_get:Common.Types.BytesListWithStartEnd.end)
  return _internal_end();
}
inline void BytesListWithStartEnd::_internal_set_end(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}
inline void BytesListWithStartEnd::set_end(uint64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:Common.Types.BytesListWithStartEnd.end)
}

// required uint64 counter = 3;
inline bool BytesListWithStartEnd::_internal_has_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BytesListWithStartEnd::has_counter() const {
  return _internal_has_counter();
}
inline void BytesListWithStartEnd::clear_counter() {
  _impl_.counter_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t BytesListWithStartEnd::_internal_counter() const {
  return _impl_.counter_;
}
inline uint64_t BytesListWithStartEnd::counter() const {
  // @@protoc_insertion_point(field_get:Common.Types.BytesListWithStartEnd.counter)
  return _internal_counter();
}
inline void BytesListWithStartEnd::_internal_set_counter(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.counter_ = value;
}
inline void BytesListWithStartEnd::set_counter(uint64_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:Common.Types.BytesListWithStartEnd.counter)
}

// repeated bytes bl = 4;
inline int BytesListWithStartEnd::_internal_bl_size() const {
  return _impl_.bl_.size();
}
inline int BytesListWithStartEnd::bl_size() const {
  return _internal_bl_size();
}
inline void BytesListWithStartEnd::clear_bl() {
  _impl_.bl_.Clear();
}
inline std::string* BytesListWithStartEnd::add_bl() {
  std::string* _s = _internal_add_bl();
  // @@protoc_insertion_point(field_add_mutable:Common.Types.BytesListWithStartEnd.bl)
  return _s;
}
inline const std::string& BytesListWithStartEnd::_internal_bl(int index) const {
  return _impl_.bl_.Get(index);
}
inline const std::string& BytesListWithStartEnd::bl(int index) const {
  // @@protoc_insertion_point(field_get:Common.Types.BytesListWithStartEnd.bl)
  return _internal_bl(index);
}
inline std::string* BytesListWithStartEnd::mutable_bl(int index) {
  // @@protoc_insertion_point(field_mutable:Common.Types.BytesListWithStartEnd.bl)
  return _impl_.bl_.Mutable(index);
}
inline void BytesListWithStartEnd::set_bl(int index, const std::string& value) {
  _impl_.bl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Common.Types.BytesListWithStartEnd.bl)
}
inline void BytesListWithStartEnd::set_bl(int index, std::string&& value) {
  _impl_.bl_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Common.Types.BytesListWithStartEnd.bl)
}
inline void BytesListWithStartEnd::set_bl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Common.Types.BytesListWithStartEnd.bl)
}
inline void BytesListWithStartEnd::set_bl(int index, const void* value, size_t size) {
  _impl_.bl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Common.Types.BytesListWithStartEnd.bl)
}
inline std::string* BytesListWithStartEnd::_internal_add_bl() {
  return _impl_.bl_.Add();
}
inline void BytesListWithStartEnd::add_bl(const std::string& value) {
  _impl_.bl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Common.Types.BytesListWithStartEnd.bl)
}
inline void BytesListWithStartEnd::add_bl(std::string&& value) {
  _impl_.bl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Common.Types.BytesListWithStartEnd.bl)
}
inline void BytesListWithStartEnd::add_bl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Common.Types.BytesListWithStartEnd.bl)
}
inline void BytesListWithStartEnd::add_bl(const void* value, size_t size) {
  _impl_.bl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Common.Types.BytesListWithStartEnd.bl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BytesListWithStartEnd::bl() const {
  // @@protoc_insertion_point(field_list:Common.Types.BytesListWithStartEnd.bl)
  return _impl_.bl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BytesListWithStartEnd::mutable_bl() {
  // @@protoc_insertion_point(field_mutable_list:Common.Types.BytesListWithStartEnd.bl)
  return &_impl_.bl_;
}

// -------------------------------------------------------------------

// AnalysisModeEnum

// required .Common.Types.AnalysisModeEnum.AnalysisMode am = 1;
inline bool AnalysisModeEnum::_internal_has_am() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AnalysisModeEnum::has_am() const {
  return _internal_has_am();
}
inline void AnalysisModeEnum::clear_am() {
  _impl_.am_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Common::Types::AnalysisModeEnum_AnalysisMode AnalysisModeEnum::_internal_am() const {
  return static_cast< ::Common::Types::AnalysisModeEnum_AnalysisMode >(_impl_.am_);
}
inline ::Common::Types::AnalysisModeEnum_AnalysisMode AnalysisModeEnum::am() const {
  // @@protoc_insertion_point(field_get:Common.Types.AnalysisModeEnum.am)
  return _internal_am();
}
inline void AnalysisModeEnum::_internal_set_am(::Common::Types::AnalysisModeEnum_AnalysisMode value) {
  assert(::Common::Types::AnalysisModeEnum_AnalysisMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.am_ = value;
}
inline void AnalysisModeEnum::set_am(::Common::Types::AnalysisModeEnum_AnalysisMode value) {
  _internal_set_am(value);
  // @@protoc_insertion_point(field_set:Common.Types.AnalysisModeEnum.am)
}

// -------------------------------------------------------------------

// TransTypeEnum

// required .Common.Types.TransTypeEnum.TransType tt = 1;
inline bool TransTypeEnum::_internal_has_tt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransTypeEnum::has_tt() const {
  return _internal_has_tt();
}
inline void TransTypeEnum::clear_tt() {
  _impl_.tt_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Common::Types::TransTypeEnum_TransType TransTypeEnum::_internal_tt() const {
  return static_cast< ::Common::Types::TransTypeEnum_TransType >(_impl_.tt_);
}
inline ::Common::Types::TransTypeEnum_TransType TransTypeEnum::tt() const {
  // @@protoc_insertion_point(field_get:Common.Types.TransTypeEnum.tt)
  return _internal_tt();
}
inline void TransTypeEnum::_internal_set_tt(::Common::Types::TransTypeEnum_TransType value) {
  assert(::Common::Types::TransTypeEnum_TransType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tt_ = value;
}
inline void TransTypeEnum::set_tt(::Common::Types::TransTypeEnum_TransType value) {
  _internal_set_tt(value);
  // @@protoc_insertion_point(field_set:Common.Types.TransTypeEnum.tt)
}

// -------------------------------------------------------------------

// ModeTransPairClass

// required .Common.Types.AnalysisModeEnum ame = 1;
inline bool ModeTransPairClass::_internal_has_ame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ame_ != nullptr);
  return value;
}
inline bool ModeTransPairClass::has_ame() const {
  return _internal_has_ame();
}
inline void ModeTransPairClass::clear_ame() {
  if (_impl_.ame_ != nullptr) _impl_.ame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Common::Types::AnalysisModeEnum& ModeTransPairClass::_internal_ame() const {
  const ::Common::Types::AnalysisModeEnum* p = _impl_.ame_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::AnalysisModeEnum&>(
      ::Common::Types::_AnalysisModeEnum_default_instance_);
}
inline const ::Common::Types::AnalysisModeEnum& ModeTransPairClass::ame() const {
  // @@protoc_insertion_point(field_get:Common.Types.ModeTransPairClass.ame)
  return _internal_ame();
}
inline void ModeTransPairClass::unsafe_arena_set_allocated_ame(
    ::Common::Types::AnalysisModeEnum* ame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ame_);
  }
  _impl_.ame_ = ame;
  if (ame) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.Types.ModeTransPairClass.ame)
}
inline ::Common::Types::AnalysisModeEnum* ModeTransPairClass::release_ame() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::AnalysisModeEnum* temp = _impl_.ame_;
  _impl_.ame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::AnalysisModeEnum* ModeTransPairClass::unsafe_arena_release_ame() {
  // @@protoc_insertion_point(field_release:Common.Types.ModeTransPairClass.ame)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::AnalysisModeEnum* temp = _impl_.ame_;
  _impl_.ame_ = nullptr;
  return temp;
}
inline ::Common::Types::AnalysisModeEnum* ModeTransPairClass::_internal_mutable_ame() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ame_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::AnalysisModeEnum>(GetArenaForAllocation());
    _impl_.ame_ = p;
  }
  return _impl_.ame_;
}
inline ::Common::Types::AnalysisModeEnum* ModeTransPairClass::mutable_ame() {
  ::Common::Types::AnalysisModeEnum* _msg = _internal_mutable_ame();
  // @@protoc_insertion_point(field_mutable:Common.Types.ModeTransPairClass.ame)
  return _msg;
}
inline void ModeTransPairClass::set_allocated_ame(::Common::Types::AnalysisModeEnum* ame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ame_;
  }
  if (ame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ame);
    if (message_arena != submessage_arena) {
      ame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ame, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ame_ = ame;
  // @@protoc_insertion_point(field_set_allocated:Common.Types.ModeTransPairClass.ame)
}

// required .Common.Types.TransTypeEnum tte = 2;
inline bool ModeTransPairClass::_internal_has_tte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tte_ != nullptr);
  return value;
}
inline bool ModeTransPairClass::has_tte() const {
  return _internal_has_tte();
}
inline void ModeTransPairClass::clear_tte() {
  if (_impl_.tte_ != nullptr) _impl_.tte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Common::Types::TransTypeEnum& ModeTransPairClass::_internal_tte() const {
  const ::Common::Types::TransTypeEnum* p = _impl_.tte_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::TransTypeEnum&>(
      ::Common::Types::_TransTypeEnum_default_instance_);
}
inline const ::Common::Types::TransTypeEnum& ModeTransPairClass::tte() const {
  // @@protoc_insertion_point(field_get:Common.Types.ModeTransPairClass.tte)
  return _internal_tte();
}
inline void ModeTransPairClass::unsafe_arena_set_allocated_tte(
    ::Common::Types::TransTypeEnum* tte) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tte_);
  }
  _impl_.tte_ = tte;
  if (tte) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.Types.ModeTransPairClass.tte)
}
inline ::Common::Types::TransTypeEnum* ModeTransPairClass::release_tte() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Common::Types::TransTypeEnum* temp = _impl_.tte_;
  _impl_.tte_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::TransTypeEnum* ModeTransPairClass::unsafe_arena_release_tte() {
  // @@protoc_insertion_point(field_release:Common.Types.ModeTransPairClass.tte)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Common::Types::TransTypeEnum* temp = _impl_.tte_;
  _impl_.tte_ = nullptr;
  return temp;
}
inline ::Common::Types::TransTypeEnum* ModeTransPairClass::_internal_mutable_tte() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tte_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::TransTypeEnum>(GetArenaForAllocation());
    _impl_.tte_ = p;
  }
  return _impl_.tte_;
}
inline ::Common::Types::TransTypeEnum* ModeTransPairClass::mutable_tte() {
  ::Common::Types::TransTypeEnum* _msg = _internal_mutable_tte();
  // @@protoc_insertion_point(field_mutable:Common.Types.ModeTransPairClass.tte)
  return _msg;
}
inline void ModeTransPairClass::set_allocated_tte(::Common::Types::TransTypeEnum* tte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tte_;
  }
  if (tte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tte);
    if (message_arena != submessage_arena) {
      tte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tte, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tte_ = tte;
  // @@protoc_insertion_point(field_set_allocated:Common.Types.ModeTransPairClass.tte)
}

// -------------------------------------------------------------------

// ModeTransPairMapDouble

// required .Common.Types.ModeTransPairClass first = 1;
inline bool ModeTransPairMapDouble::_internal_has_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_ != nullptr);
  return value;
}
inline bool ModeTransPairMapDouble::has_first() const {
  return _internal_has_first();
}
inline void ModeTransPairMapDouble::clear_first() {
  if (_impl_.first_ != nullptr) _impl_.first_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Common::Types::ModeTransPairClass& ModeTransPairMapDouble::_internal_first() const {
  const ::Common::Types::ModeTransPairClass* p = _impl_.first_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::ModeTransPairClass&>(
      ::Common::Types::_ModeTransPairClass_default_instance_);
}
inline const ::Common::Types::ModeTransPairClass& ModeTransPairMapDouble::first() const {
  // @@protoc_insertion_point(field_get:Common.Types.ModeTransPairMapDouble.first)
  return _internal_first();
}
inline void ModeTransPairMapDouble::unsafe_arena_set_allocated_first(
    ::Common::Types::ModeTransPairClass* first) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.first_);
  }
  _impl_.first_ = first;
  if (first) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Common.Types.ModeTransPairMapDouble.first)
}
inline ::Common::Types::ModeTransPairClass* ModeTransPairMapDouble::release_first() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::ModeTransPairClass* temp = _impl_.first_;
  _impl_.first_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::ModeTransPairClass* ModeTransPairMapDouble::unsafe_arena_release_first() {
  // @@protoc_insertion_point(field_release:Common.Types.ModeTransPairMapDouble.first)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Common::Types::ModeTransPairClass* temp = _impl_.first_;
  _impl_.first_ = nullptr;
  return temp;
}
inline ::Common::Types::ModeTransPairClass* ModeTransPairMapDouble::_internal_mutable_first() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.first_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::ModeTransPairClass>(GetArenaForAllocation());
    _impl_.first_ = p;
  }
  return _impl_.first_;
}
inline ::Common::Types::ModeTransPairClass* ModeTransPairMapDouble::mutable_first() {
  ::Common::Types::ModeTransPairClass* _msg = _internal_mutable_first();
  // @@protoc_insertion_point(field_mutable:Common.Types.ModeTransPairMapDouble.first)
  return _msg;
}
inline void ModeTransPairMapDouble::set_allocated_first(::Common::Types::ModeTransPairClass* first) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.first_;
  }
  if (first) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(first);
    if (message_arena != submessage_arena) {
      first = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.first_ = first;
  // @@protoc_insertion_point(field_set_allocated:Common.Types.ModeTransPairMapDouble.first)
}

// required double second = 2;
inline bool ModeTransPairMapDouble::_internal_has_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModeTransPairMapDouble::has_second() const {
  return _internal_has_second();
}
inline void ModeTransPairMapDouble::clear_second() {
  _impl_.second_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ModeTransPairMapDouble::_internal_second() const {
  return _impl_.second_;
}
inline double ModeTransPairMapDouble::second() const {
  // @@protoc_insertion_point(field_get:Common.Types.ModeTransPairMapDouble.second)
  return _internal_second();
}
inline void ModeTransPairMapDouble::_internal_set_second(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.second_ = value;
}
inline void ModeTransPairMapDouble::set_second(double value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:Common.Types.ModeTransPairMapDouble.second)
}

// -------------------------------------------------------------------

// CapacitiveUnitEnum

// required .Common.Types.CapacitiveUnitEnum.CapacitiveUnit cu = 1;
inline bool CapacitiveUnitEnum::_internal_has_cu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CapacitiveUnitEnum::has_cu() const {
  return _internal_has_cu();
}
inline void CapacitiveUnitEnum::clear_cu() {
  _impl_.cu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit CapacitiveUnitEnum::_internal_cu() const {
  return static_cast< ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit >(_impl_.cu_);
}
inline ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit CapacitiveUnitEnum::cu() const {
  // @@protoc_insertion_point(field_get:Common.Types.CapacitiveUnitEnum.cu)
  return _internal_cu();
}
inline void CapacitiveUnitEnum::_internal_set_cu(::Common::Types::CapacitiveUnitEnum_CapacitiveUnit value) {
  assert(::Common::Types::CapacitiveUnitEnum_CapacitiveUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cu_ = value;
}
inline void CapacitiveUnitEnum::set_cu(::Common::Types::CapacitiveUnitEnum_CapacitiveUnit value) {
  _internal_set_cu(value);
  // @@protoc_insertion_point(field_set:Common.Types.CapacitiveUnitEnum.cu)
}

// -------------------------------------------------------------------

// ResistanceUnitEnum

// required .Common.Types.ResistanceUnitEnum.ResistanceUnit ru = 1;
inline bool ResistanceUnitEnum::_internal_has_ru() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResistanceUnitEnum::has_ru() const {
  return _internal_has_ru();
}
inline void ResistanceUnitEnum::clear_ru() {
  _impl_.ru_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Common::Types::ResistanceUnitEnum_ResistanceUnit ResistanceUnitEnum::_internal_ru() const {
  return static_cast< ::Common::Types::ResistanceUnitEnum_ResistanceUnit >(_impl_.ru_);
}
inline ::Common::Types::ResistanceUnitEnum_ResistanceUnit ResistanceUnitEnum::ru() const {
  // @@protoc_insertion_point(field_get:Common.Types.ResistanceUnitEnum.ru)
  return _internal_ru();
}
inline void ResistanceUnitEnum::_internal_set_ru(::Common::Types::ResistanceUnitEnum_ResistanceUnit value) {
  assert(::Common::Types::ResistanceUnitEnum_ResistanceUnit_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ru_ = value;
}
inline void ResistanceUnitEnum::set_ru(::Common::Types::ResistanceUnitEnum_ResistanceUnit value) {
  _internal_set_ru(value);
  // @@protoc_insertion_point(field_set:Common.Types.ResistanceUnitEnum.ru)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Types
}  // namespace Common

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Common::Types::AnalysisModeEnum_AnalysisMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::Types::AnalysisModeEnum_AnalysisMode>() {
  return ::Common::Types::AnalysisModeEnum_AnalysisMode_descriptor();
}
template <> struct is_proto_enum< ::Common::Types::TransTypeEnum_TransType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::Types::TransTypeEnum_TransType>() {
  return ::Common::Types::TransTypeEnum_TransType_descriptor();
}
template <> struct is_proto_enum< ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit>() {
  return ::Common::Types::CapacitiveUnitEnum_CapacitiveUnit_descriptor();
}
template <> struct is_proto_enum< ::Common::Types::ResistanceUnitEnum_ResistanceUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::Types::ResistanceUnitEnum_ResistanceUnit>() {
  return ::Common::Types::ResistanceUnitEnum_ResistanceUnit_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_CommonTypes_2eproto
