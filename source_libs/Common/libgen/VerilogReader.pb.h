// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: VerilogReader.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_VerilogReader_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_VerilogReader_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommonTypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_VerilogReader_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_VerilogReader_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_VerilogReader_2eproto;
namespace VerilogParser {
class BatchRequest;
struct BatchRequestDefaultTypeInternal;
extern BatchRequestDefaultTypeInternal _BatchRequest_default_instance_;
class VerilogChildIDClass;
struct VerilogChildIDClassDefaultTypeInternal;
extern VerilogChildIDClassDefaultTypeInternal _VerilogChildIDClass_default_instance_;
class VerilogConstantExprClass;
struct VerilogConstantExprClassDefaultTypeInternal;
extern VerilogConstantExprClassDefaultTypeInternal _VerilogConstantExprClass_default_instance_;
class VerilogDclClass;
struct VerilogDclClassDefaultTypeInternal;
extern VerilogDclClassDefaultTypeInternal _VerilogDclClass_default_instance_;
class VerilogDclTypeEnum;
struct VerilogDclTypeEnumDefaultTypeInternal;
extern VerilogDclTypeEnumDefaultTypeInternal _VerilogDclTypeEnum_default_instance_;
class VerilogDclsClass;
struct VerilogDclsClassDefaultTypeInternal;
extern VerilogDclsClassDefaultTypeInternal _VerilogDclsClass_default_instance_;
class VerilogIDClass;
struct VerilogIDClassDefaultTypeInternal;
extern VerilogIDClassDefaultTypeInternal _VerilogIDClass_default_instance_;
class VerilogIDSyn;
struct VerilogIDSynDefaultTypeInternal;
extern VerilogIDSynDefaultTypeInternal _VerilogIDSyn_default_instance_;
class VerilogIndexIDClass;
struct VerilogIndexIDClassDefaultTypeInternal;
extern VerilogIndexIDClassDefaultTypeInternal _VerilogIndexIDClass_default_instance_;
class VerilogInstClass;
struct VerilogInstClassDefaultTypeInternal;
extern VerilogInstClassDefaultTypeInternal _VerilogInstClass_default_instance_;
class VerilogMetaData;
struct VerilogMetaDataDefaultTypeInternal;
extern VerilogMetaDataDefaultTypeInternal _VerilogMetaData_default_instance_;
class VerilogModuleClass;
struct VerilogModuleClassDefaultTypeInternal;
extern VerilogModuleClassDefaultTypeInternal _VerilogModuleClass_default_instance_;
class VerilogNetConcatExprClass;
struct VerilogNetConcatExprClassDefaultTypeInternal;
extern VerilogNetConcatExprClassDefaultTypeInternal _VerilogNetConcatExprClass_default_instance_;
class VerilogNetExprClass;
struct VerilogNetExprClassDefaultTypeInternal;
extern VerilogNetExprClassDefaultTypeInternal _VerilogNetExprClass_default_instance_;
class VerilogNetExprSyn;
struct VerilogNetExprSynDefaultTypeInternal;
extern VerilogNetExprSynDefaultTypeInternal _VerilogNetExprSyn_default_instance_;
class VerilogNetIDExprClass;
struct VerilogNetIDExprClassDefaultTypeInternal;
extern VerilogNetIDExprClassDefaultTypeInternal _VerilogNetIDExprClass_default_instance_;
class VerilogPortRefPortConnectClass;
struct VerilogPortRefPortConnectClassDefaultTypeInternal;
extern VerilogPortRefPortConnectClassDefaultTypeInternal _VerilogPortRefPortConnectClass_default_instance_;
class VerilogReaderClass;
struct VerilogReaderClassDefaultTypeInternal;
extern VerilogReaderClassDefaultTypeInternal _VerilogReaderClass_default_instance_;
class VerilogSliceIDClass;
struct VerilogSliceIDClassDefaultTypeInternal;
extern VerilogSliceIDClassDefaultTypeInternal _VerilogSliceIDClass_default_instance_;
class VerilogStmtClass;
struct VerilogStmtClassDefaultTypeInternal;
extern VerilogStmtClassDefaultTypeInternal _VerilogStmtClass_default_instance_;
class VerilogStmtSyn;
struct VerilogStmtSynDefaultTypeInternal;
extern VerilogStmtSynDefaultTypeInternal _VerilogStmtSyn_default_instance_;
class VerilogStmtSynBatch;
struct VerilogStmtSynBatchDefaultTypeInternal;
extern VerilogStmtSynBatchDefaultTypeInternal _VerilogStmtSynBatch_default_instance_;
}  // namespace VerilogParser
PROTOBUF_NAMESPACE_OPEN
template<> ::VerilogParser::BatchRequest* Arena::CreateMaybeMessage<::VerilogParser::BatchRequest>(Arena*);
template<> ::VerilogParser::VerilogChildIDClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogChildIDClass>(Arena*);
template<> ::VerilogParser::VerilogConstantExprClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogConstantExprClass>(Arena*);
template<> ::VerilogParser::VerilogDclClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogDclClass>(Arena*);
template<> ::VerilogParser::VerilogDclTypeEnum* Arena::CreateMaybeMessage<::VerilogParser::VerilogDclTypeEnum>(Arena*);
template<> ::VerilogParser::VerilogDclsClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogDclsClass>(Arena*);
template<> ::VerilogParser::VerilogIDClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogIDClass>(Arena*);
template<> ::VerilogParser::VerilogIDSyn* Arena::CreateMaybeMessage<::VerilogParser::VerilogIDSyn>(Arena*);
template<> ::VerilogParser::VerilogIndexIDClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogIndexIDClass>(Arena*);
template<> ::VerilogParser::VerilogInstClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogInstClass>(Arena*);
template<> ::VerilogParser::VerilogMetaData* Arena::CreateMaybeMessage<::VerilogParser::VerilogMetaData>(Arena*);
template<> ::VerilogParser::VerilogModuleClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogModuleClass>(Arena*);
template<> ::VerilogParser::VerilogNetConcatExprClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogNetConcatExprClass>(Arena*);
template<> ::VerilogParser::VerilogNetExprClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogNetExprClass>(Arena*);
template<> ::VerilogParser::VerilogNetExprSyn* Arena::CreateMaybeMessage<::VerilogParser::VerilogNetExprSyn>(Arena*);
template<> ::VerilogParser::VerilogNetIDExprClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogNetIDExprClass>(Arena*);
template<> ::VerilogParser::VerilogPortRefPortConnectClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogPortRefPortConnectClass>(Arena*);
template<> ::VerilogParser::VerilogReaderClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogReaderClass>(Arena*);
template<> ::VerilogParser::VerilogSliceIDClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogSliceIDClass>(Arena*);
template<> ::VerilogParser::VerilogStmtClass* Arena::CreateMaybeMessage<::VerilogParser::VerilogStmtClass>(Arena*);
template<> ::VerilogParser::VerilogStmtSyn* Arena::CreateMaybeMessage<::VerilogParser::VerilogStmtSyn>(Arena*);
template<> ::VerilogParser::VerilogStmtSynBatch* Arena::CreateMaybeMessage<::VerilogParser::VerilogStmtSynBatch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace VerilogParser {

enum VerilogDclTypeEnum_DclType : int {
  VerilogDclTypeEnum_DclType_kInput = 0,
  VerilogDclTypeEnum_DclType_kInout = 1,
  VerilogDclTypeEnum_DclType_kOutput = 2,
  VerilogDclTypeEnum_DclType_kSupply0 = 3,
  VerilogDclTypeEnum_DclType_kSupply1 = 4,
  VerilogDclTypeEnum_DclType_kTri = 5,
  VerilogDclTypeEnum_DclType_kWand = 6,
  VerilogDclTypeEnum_DclType_kWire = 7,
  VerilogDclTypeEnum_DclType_kWor = 7
};
bool VerilogDclTypeEnum_DclType_IsValid(int value);
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum_DclType_DclType_MIN = VerilogDclTypeEnum_DclType_kInput;
constexpr VerilogDclTypeEnum_DclType VerilogDclTypeEnum_DclType_DclType_MAX = VerilogDclTypeEnum_DclType_kWire;
constexpr int VerilogDclTypeEnum_DclType_DclType_ARRAYSIZE = VerilogDclTypeEnum_DclType_DclType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VerilogDclTypeEnum_DclType_descriptor();
template<typename T>
inline const std::string& VerilogDclTypeEnum_DclType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VerilogDclTypeEnum_DclType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VerilogDclTypeEnum_DclType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VerilogDclTypeEnum_DclType_descriptor(), enum_t_value);
}
inline bool VerilogDclTypeEnum_DclType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VerilogDclTypeEnum_DclType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VerilogDclTypeEnum_DclType>(
    VerilogDclTypeEnum_DclType_descriptor(), name, value);
}
// ===================================================================

class VerilogIDClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogIDClass) */ {
 public:
  inline VerilogIDClass() : VerilogIDClass(nullptr) {}
  ~VerilogIDClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogIDClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogIDClass(const VerilogIDClass& from);
  VerilogIDClass(VerilogIDClass&& from) noexcept
    : VerilogIDClass() {
    *this = ::std::move(from);
  }

  inline VerilogIDClass& operator=(const VerilogIDClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogIDClass& operator=(VerilogIDClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogIDClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogIDClass* internal_default_instance() {
    return reinterpret_cast<const VerilogIDClass*>(
               &_VerilogIDClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VerilogIDClass& a, VerilogIDClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogIDClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogIDClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogIDClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogIDClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogIDClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogIDClass& from) {
    VerilogIDClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogIDClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogIDClass";
  }
  protected:
  explicit VerilogIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required string _id = 1;
  bool has__id() const;
  private:
  bool _internal_has__id() const;
  public:
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogIDClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogIndexIDClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogIndexIDClass) */ {
 public:
  inline VerilogIndexIDClass() : VerilogIndexIDClass(nullptr) {}
  ~VerilogIndexIDClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogIndexIDClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogIndexIDClass(const VerilogIndexIDClass& from);
  VerilogIndexIDClass(VerilogIndexIDClass&& from) noexcept
    : VerilogIndexIDClass() {
    *this = ::std::move(from);
  }

  inline VerilogIndexIDClass& operator=(const VerilogIndexIDClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogIndexIDClass& operator=(VerilogIndexIDClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogIndexIDClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogIndexIDClass* internal_default_instance() {
    return reinterpret_cast<const VerilogIndexIDClass*>(
               &_VerilogIndexIDClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VerilogIndexIDClass& a, VerilogIndexIDClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogIndexIDClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogIndexIDClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogIndexIDClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogIndexIDClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogIndexIDClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogIndexIDClass& from) {
    VerilogIndexIDClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogIndexIDClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogIndexIDClass";
  }
  protected:
  explicit VerilogIndexIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 2,
  };
  // required int32 _index = 2;
  bool has__index() const;
  private:
  bool _internal_has__index() const;
  public:
  void clear__index();
  int32_t _index() const;
  void set__index(int32_t value);
  private:
  int32_t _internal__index() const;
  void _internal_set__index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogIndexIDClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t _index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogSliceIDClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogSliceIDClass) */ {
 public:
  inline VerilogSliceIDClass() : VerilogSliceIDClass(nullptr) {}
  ~VerilogSliceIDClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogSliceIDClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogSliceIDClass(const VerilogSliceIDClass& from);
  VerilogSliceIDClass(VerilogSliceIDClass&& from) noexcept
    : VerilogSliceIDClass() {
    *this = ::std::move(from);
  }

  inline VerilogSliceIDClass& operator=(const VerilogSliceIDClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogSliceIDClass& operator=(VerilogSliceIDClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogSliceIDClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogSliceIDClass* internal_default_instance() {
    return reinterpret_cast<const VerilogSliceIDClass*>(
               &_VerilogSliceIDClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VerilogSliceIDClass& a, VerilogSliceIDClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogSliceIDClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogSliceIDClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogSliceIDClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogSliceIDClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogSliceIDClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogSliceIDClass& from) {
    VerilogSliceIDClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogSliceIDClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogSliceIDClass";
  }
  protected:
  explicit VerilogSliceIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangeFromFieldNumber = 2,
    kRangeToFieldNumber = 3,
  };
  // required int32 _range_from = 2;
  bool has__range_from() const;
  private:
  bool _internal_has__range_from() const;
  public:
  void clear__range_from();
  int32_t _range_from() const;
  void set__range_from(int32_t value);
  private:
  int32_t _internal__range_from() const;
  void _internal_set__range_from(int32_t value);
  public:

  // required int32 _range_to = 3;
  bool has__range_to() const;
  private:
  bool _internal_has__range_to() const;
  public:
  void clear__range_to();
  int32_t _range_to() const;
  void set__range_to(int32_t value);
  private:
  int32_t _internal__range_to() const;
  void _internal_set__range_to(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogSliceIDClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t _range_from_;
    int32_t _range_to_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogChildIDClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogChildIDClass) */ {
 public:
  inline VerilogChildIDClass() : VerilogChildIDClass(nullptr) {}
  ~VerilogChildIDClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogChildIDClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogChildIDClass(const VerilogChildIDClass& from);
  VerilogChildIDClass(VerilogChildIDClass&& from) noexcept
    : VerilogChildIDClass() {
    *this = ::std::move(from);
  }

  inline VerilogChildIDClass& operator=(const VerilogChildIDClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogChildIDClass& operator=(VerilogChildIDClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogChildIDClass& default_instance() {
    return *internal_default_instance();
  }
  enum VidCase {
    kIdx = 1,
    kSid = 2,
    VID_NOT_SET = 0,
  };

  static inline const VerilogChildIDClass* internal_default_instance() {
    return reinterpret_cast<const VerilogChildIDClass*>(
               &_VerilogChildIDClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VerilogChildIDClass& a, VerilogChildIDClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogChildIDClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogChildIDClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogChildIDClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogChildIDClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogChildIDClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogChildIDClass& from) {
    VerilogChildIDClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogChildIDClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogChildIDClass";
  }
  protected:
  explicit VerilogChildIDClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
    kSidFieldNumber = 2,
  };
  // .VerilogParser.VerilogIndexIDClass idx = 1;
  bool has_idx() const;
  private:
  bool _internal_has_idx() const;
  public:
  void clear_idx();
  const ::VerilogParser::VerilogIndexIDClass& idx() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogIndexIDClass* release_idx();
  ::VerilogParser::VerilogIndexIDClass* mutable_idx();
  void set_allocated_idx(::VerilogParser::VerilogIndexIDClass* idx);
  private:
  const ::VerilogParser::VerilogIndexIDClass& _internal_idx() const;
  ::VerilogParser::VerilogIndexIDClass* _internal_mutable_idx();
  public:
  void unsafe_arena_set_allocated_idx(
      ::VerilogParser::VerilogIndexIDClass* idx);
  ::VerilogParser::VerilogIndexIDClass* unsafe_arena_release_idx();

  // .VerilogParser.VerilogSliceIDClass sid = 2;
  bool has_sid() const;
  private:
  bool _internal_has_sid() const;
  public:
  void clear_sid();
  const ::VerilogParser::VerilogSliceIDClass& sid() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogSliceIDClass* release_sid();
  ::VerilogParser::VerilogSliceIDClass* mutable_sid();
  void set_allocated_sid(::VerilogParser::VerilogSliceIDClass* sid);
  private:
  const ::VerilogParser::VerilogSliceIDClass& _internal_sid() const;
  ::VerilogParser::VerilogSliceIDClass* _internal_mutable_sid();
  public:
  void unsafe_arena_set_allocated_sid(
      ::VerilogParser::VerilogSliceIDClass* sid);
  ::VerilogParser::VerilogSliceIDClass* unsafe_arena_release_sid();

  void clear_vid();
  VidCase vid_case() const;
  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogChildIDClass)
 private:
  class _Internal;
  void set_has_idx();
  void set_has_sid();

  inline bool has_vid() const;
  inline void clear_has_vid();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union VidUnion {
      constexpr VidUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::VerilogParser::VerilogIndexIDClass* idx_;
      ::VerilogParser::VerilogSliceIDClass* sid_;
    } vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogIDSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogIDSyn) */ {
 public:
  inline VerilogIDSyn() : VerilogIDSyn(nullptr) {}
  ~VerilogIDSyn() override;
  explicit PROTOBUF_CONSTEXPR VerilogIDSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogIDSyn(const VerilogIDSyn& from);
  VerilogIDSyn(VerilogIDSyn&& from) noexcept
    : VerilogIDSyn() {
    *this = ::std::move(from);
  }

  inline VerilogIDSyn& operator=(const VerilogIDSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogIDSyn& operator=(VerilogIDSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogIDSyn& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogIDSyn* internal_default_instance() {
    return reinterpret_cast<const VerilogIDSyn*>(
               &_VerilogIDSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VerilogIDSyn& a, VerilogIDSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogIDSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogIDSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogIDSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogIDSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogIDSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogIDSyn& from) {
    VerilogIDSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogIDSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogIDSyn";
  }
  protected:
  explicit VerilogIDSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kChildFieldNumber = 4,
    kIdFieldNumber = 1,
    kVidTypeFieldNumber = 2,
  };
  // required .VerilogParser.VerilogIDClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::VerilogParser::VerilogIDClass& parent() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogIDClass* release_parent();
  ::VerilogParser::VerilogIDClass* mutable_parent();
  void set_allocated_parent(::VerilogParser::VerilogIDClass* parent);
  private:
  const ::VerilogParser::VerilogIDClass& _internal_parent() const;
  ::VerilogParser::VerilogIDClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::VerilogParser::VerilogIDClass* parent);
  ::VerilogParser::VerilogIDClass* unsafe_arena_release_parent();

  // optional .VerilogParser.VerilogChildIDClass child = 4;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::VerilogParser::VerilogChildIDClass& child() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogChildIDClass* release_child();
  ::VerilogParser::VerilogChildIDClass* mutable_child();
  void set_allocated_child(::VerilogParser::VerilogChildIDClass* child);
  private:
  const ::VerilogParser::VerilogChildIDClass& _internal_child() const;
  ::VerilogParser::VerilogChildIDClass* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::VerilogParser::VerilogChildIDClass* child);
  ::VerilogParser::VerilogChildIDClass* unsafe_arena_release_child();

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 vid_type = 2;
  bool has_vid_type() const;
  private:
  bool _internal_has_vid_type() const;
  public:
  void clear_vid_type();
  int32_t vid_type() const;
  void set_vid_type(int32_t value);
  private:
  int32_t _internal_vid_type() const;
  void _internal_set_vid_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogIDSyn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::VerilogParser::VerilogIDClass* parent_;
    ::VerilogParser::VerilogChildIDClass* child_;
    int32_t id_;
    int32_t vid_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogNetExprClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogNetExprClass) */ {
 public:
  inline VerilogNetExprClass() : VerilogNetExprClass(nullptr) {}
  ~VerilogNetExprClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogNetExprClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogNetExprClass(const VerilogNetExprClass& from);
  VerilogNetExprClass(VerilogNetExprClass&& from) noexcept
    : VerilogNetExprClass() {
    *this = ::std::move(from);
  }

  inline VerilogNetExprClass& operator=(const VerilogNetExprClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogNetExprClass& operator=(VerilogNetExprClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogNetExprClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogNetExprClass* internal_default_instance() {
    return reinterpret_cast<const VerilogNetExprClass*>(
               &_VerilogNetExprClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VerilogNetExprClass& a, VerilogNetExprClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogNetExprClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogNetExprClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogNetExprClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogNetExprClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogNetExprClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogNetExprClass& from) {
    VerilogNetExprClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogNetExprClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogNetExprClass";
  }
  protected:
  explicit VerilogNetExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineNoFieldNumber = 1,
  };
  // required uint32 _line_no = 1;
  bool has__line_no() const;
  private:
  bool _internal_has__line_no() const;
  public:
  void clear__line_no();
  uint32_t _line_no() const;
  void set__line_no(uint32_t value);
  private:
  uint32_t _internal__line_no() const;
  void _internal_set__line_no(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogNetExprClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _line_no_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogNetIDExprClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogNetIDExprClass) */ {
 public:
  inline VerilogNetIDExprClass() : VerilogNetIDExprClass(nullptr) {}
  ~VerilogNetIDExprClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogNetIDExprClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogNetIDExprClass(const VerilogNetIDExprClass& from);
  VerilogNetIDExprClass(VerilogNetIDExprClass&& from) noexcept
    : VerilogNetIDExprClass() {
    *this = ::std::move(from);
  }

  inline VerilogNetIDExprClass& operator=(const VerilogNetIDExprClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogNetIDExprClass& operator=(VerilogNetIDExprClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogNetIDExprClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogNetIDExprClass* internal_default_instance() {
    return reinterpret_cast<const VerilogNetIDExprClass*>(
               &_VerilogNetIDExprClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VerilogNetIDExprClass& a, VerilogNetIDExprClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogNetIDExprClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogNetIDExprClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogNetIDExprClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogNetIDExprClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogNetIDExprClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogNetIDExprClass& from) {
    VerilogNetIDExprClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogNetIDExprClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogNetIDExprClass";
  }
  protected:
  explicit VerilogNetIDExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerilogIdFieldNumber = 2,
  };
  // required int32 _verilog_id = 2;
  bool has__verilog_id() const;
  private:
  bool _internal_has__verilog_id() const;
  public:
  void clear__verilog_id();
  int32_t _verilog_id() const;
  void set__verilog_id(int32_t value);
  private:
  int32_t _internal__verilog_id() const;
  void _internal_set__verilog_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogNetIDExprClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t _verilog_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogNetConcatExprClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogNetConcatExprClass) */ {
 public:
  inline VerilogNetConcatExprClass() : VerilogNetConcatExprClass(nullptr) {}
  ~VerilogNetConcatExprClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogNetConcatExprClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogNetConcatExprClass(const VerilogNetConcatExprClass& from);
  VerilogNetConcatExprClass(VerilogNetConcatExprClass&& from) noexcept
    : VerilogNetConcatExprClass() {
    *this = ::std::move(from);
  }

  inline VerilogNetConcatExprClass& operator=(const VerilogNetConcatExprClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogNetConcatExprClass& operator=(VerilogNetConcatExprClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogNetConcatExprClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogNetConcatExprClass* internal_default_instance() {
    return reinterpret_cast<const VerilogNetConcatExprClass*>(
               &_VerilogNetConcatExprClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VerilogNetConcatExprClass& a, VerilogNetConcatExprClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogNetConcatExprClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogNetConcatExprClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogNetConcatExprClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogNetConcatExprClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogNetConcatExprClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogNetConcatExprClass& from) {
    VerilogNetConcatExprClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogNetConcatExprClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogNetConcatExprClass";
  }
  protected:
  explicit VerilogNetConcatExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerilogIdConcatFieldNumber = 1,
  };
  // repeated int32 _verilog_id_concat = 1;
  int _verilog_id_concat_size() const;
  private:
  int _internal__verilog_id_concat_size() const;
  public:
  void clear__verilog_id_concat();
  private:
  int32_t _internal__verilog_id_concat(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal__verilog_id_concat() const;
  void _internal_add__verilog_id_concat(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable__verilog_id_concat();
  public:
  int32_t _verilog_id_concat(int index) const;
  void set__verilog_id_concat(int index, int32_t value);
  void add__verilog_id_concat(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _verilog_id_concat() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable__verilog_id_concat();

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogNetConcatExprClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > _verilog_id_concat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogConstantExprClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogConstantExprClass) */ {
 public:
  inline VerilogConstantExprClass() : VerilogConstantExprClass(nullptr) {}
  ~VerilogConstantExprClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogConstantExprClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogConstantExprClass(const VerilogConstantExprClass& from);
  VerilogConstantExprClass(VerilogConstantExprClass&& from) noexcept
    : VerilogConstantExprClass() {
    *this = ::std::move(from);
  }

  inline VerilogConstantExprClass& operator=(const VerilogConstantExprClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogConstantExprClass& operator=(VerilogConstantExprClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogConstantExprClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogConstantExprClass* internal_default_instance() {
    return reinterpret_cast<const VerilogConstantExprClass*>(
               &_VerilogConstantExprClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VerilogConstantExprClass& a, VerilogConstantExprClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogConstantExprClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogConstantExprClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogConstantExprClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogConstantExprClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogConstantExprClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogConstantExprClass& from) {
    VerilogConstantExprClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogConstantExprClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogConstantExprClass";
  }
  protected:
  explicit VerilogConstantExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerilogIdFieldNumber = 1,
  };
  // required int32 _verilog_id = 1;
  bool has__verilog_id() const;
  private:
  bool _internal_has__verilog_id() const;
  public:
  void clear__verilog_id();
  int32_t _verilog_id() const;
  void set__verilog_id(int32_t value);
  private:
  int32_t _internal__verilog_id() const;
  void _internal_set__verilog_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogConstantExprClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t _verilog_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogNetExprSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogNetExprSyn) */ {
 public:
  inline VerilogNetExprSyn() : VerilogNetExprSyn(nullptr) {}
  ~VerilogNetExprSyn() override;
  explicit PROTOBUF_CONSTEXPR VerilogNetExprSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogNetExprSyn(const VerilogNetExprSyn& from);
  VerilogNetExprSyn(VerilogNetExprSyn&& from) noexcept
    : VerilogNetExprSyn() {
    *this = ::std::move(from);
  }

  inline VerilogNetExprSyn& operator=(const VerilogNetExprSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogNetExprSyn& operator=(VerilogNetExprSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogNetExprSyn& default_instance() {
    return *internal_default_instance();
  }
  enum VnesCase {
    kNidec = 4,
    kNcec = 5,
    kCec = 6,
    VNES_NOT_SET = 0,
  };

  static inline const VerilogNetExprSyn* internal_default_instance() {
    return reinterpret_cast<const VerilogNetExprSyn*>(
               &_VerilogNetExprSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VerilogNetExprSyn& a, VerilogNetExprSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogNetExprSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogNetExprSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogNetExprSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogNetExprSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogNetExprSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogNetExprSyn& from) {
    VerilogNetExprSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogNetExprSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogNetExprSyn";
  }
  protected:
  explicit VerilogNetExprSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kVnesTypeFieldNumber = 2,
    kNidecFieldNumber = 4,
    kNcecFieldNumber = 5,
    kCecFieldNumber = 6,
  };
  // required .VerilogParser.VerilogNetExprClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::VerilogParser::VerilogNetExprClass& parent() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogNetExprClass* release_parent();
  ::VerilogParser::VerilogNetExprClass* mutable_parent();
  void set_allocated_parent(::VerilogParser::VerilogNetExprClass* parent);
  private:
  const ::VerilogParser::VerilogNetExprClass& _internal_parent() const;
  ::VerilogParser::VerilogNetExprClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::VerilogParser::VerilogNetExprClass* parent);
  ::VerilogParser::VerilogNetExprClass* unsafe_arena_release_parent();

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 vnes_type = 2;
  bool has_vnes_type() const;
  private:
  bool _internal_has_vnes_type() const;
  public:
  void clear_vnes_type();
  int32_t vnes_type() const;
  void set_vnes_type(int32_t value);
  private:
  int32_t _internal_vnes_type() const;
  void _internal_set_vnes_type(int32_t value);
  public:

  // .VerilogParser.VerilogNetIDExprClass nidec = 4;
  bool has_nidec() const;
  private:
  bool _internal_has_nidec() const;
  public:
  void clear_nidec();
  const ::VerilogParser::VerilogNetIDExprClass& nidec() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogNetIDExprClass* release_nidec();
  ::VerilogParser::VerilogNetIDExprClass* mutable_nidec();
  void set_allocated_nidec(::VerilogParser::VerilogNetIDExprClass* nidec);
  private:
  const ::VerilogParser::VerilogNetIDExprClass& _internal_nidec() const;
  ::VerilogParser::VerilogNetIDExprClass* _internal_mutable_nidec();
  public:
  void unsafe_arena_set_allocated_nidec(
      ::VerilogParser::VerilogNetIDExprClass* nidec);
  ::VerilogParser::VerilogNetIDExprClass* unsafe_arena_release_nidec();

  // .VerilogParser.VerilogNetConcatExprClass ncec = 5;
  bool has_ncec() const;
  private:
  bool _internal_has_ncec() const;
  public:
  void clear_ncec();
  const ::VerilogParser::VerilogNetConcatExprClass& ncec() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogNetConcatExprClass* release_ncec();
  ::VerilogParser::VerilogNetConcatExprClass* mutable_ncec();
  void set_allocated_ncec(::VerilogParser::VerilogNetConcatExprClass* ncec);
  private:
  const ::VerilogParser::VerilogNetConcatExprClass& _internal_ncec() const;
  ::VerilogParser::VerilogNetConcatExprClass* _internal_mutable_ncec();
  public:
  void unsafe_arena_set_allocated_ncec(
      ::VerilogParser::VerilogNetConcatExprClass* ncec);
  ::VerilogParser::VerilogNetConcatExprClass* unsafe_arena_release_ncec();

  // .VerilogParser.VerilogConstantExprClass cec = 6;
  bool has_cec() const;
  private:
  bool _internal_has_cec() const;
  public:
  void clear_cec();
  const ::VerilogParser::VerilogConstantExprClass& cec() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogConstantExprClass* release_cec();
  ::VerilogParser::VerilogConstantExprClass* mutable_cec();
  void set_allocated_cec(::VerilogParser::VerilogConstantExprClass* cec);
  private:
  const ::VerilogParser::VerilogConstantExprClass& _internal_cec() const;
  ::VerilogParser::VerilogConstantExprClass* _internal_mutable_cec();
  public:
  void unsafe_arena_set_allocated_cec(
      ::VerilogParser::VerilogConstantExprClass* cec);
  ::VerilogParser::VerilogConstantExprClass* unsafe_arena_release_cec();

  void clear_vnes();
  VnesCase vnes_case() const;
  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogNetExprSyn)
 private:
  class _Internal;
  void set_has_nidec();
  void set_has_ncec();
  void set_has_cec();

  inline bool has_vnes() const;
  inline void clear_has_vnes();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::VerilogParser::VerilogNetExprClass* parent_;
    int32_t id_;
    int32_t vnes_type_;
    union VnesUnion {
      constexpr VnesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::VerilogParser::VerilogNetIDExprClass* nidec_;
      ::VerilogParser::VerilogNetConcatExprClass* ncec_;
      ::VerilogParser::VerilogConstantExprClass* cec_;
    } vnes_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogPortRefPortConnectClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogPortRefPortConnectClass) */ {
 public:
  inline VerilogPortRefPortConnectClass() : VerilogPortRefPortConnectClass(nullptr) {}
  ~VerilogPortRefPortConnectClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogPortRefPortConnectClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogPortRefPortConnectClass(const VerilogPortRefPortConnectClass& from);
  VerilogPortRefPortConnectClass(VerilogPortRefPortConnectClass&& from) noexcept
    : VerilogPortRefPortConnectClass() {
    *this = ::std::move(from);
  }

  inline VerilogPortRefPortConnectClass& operator=(const VerilogPortRefPortConnectClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogPortRefPortConnectClass& operator=(VerilogPortRefPortConnectClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogPortRefPortConnectClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogPortRefPortConnectClass* internal_default_instance() {
    return reinterpret_cast<const VerilogPortRefPortConnectClass*>(
               &_VerilogPortRefPortConnectClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VerilogPortRefPortConnectClass& a, VerilogPortRefPortConnectClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogPortRefPortConnectClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogPortRefPortConnectClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogPortRefPortConnectClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogPortRefPortConnectClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogPortRefPortConnectClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogPortRefPortConnectClass& from) {
    VerilogPortRefPortConnectClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogPortRefPortConnectClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogPortRefPortConnectClass";
  }
  protected:
  explicit VerilogPortRefPortConnectClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPortIdFieldNumber = 2,
    kNetExprFieldNumber = 3,
  };
  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 _port_id = 2;
  bool has__port_id() const;
  private:
  bool _internal_has__port_id() const;
  public:
  void clear__port_id();
  int32_t _port_id() const;
  void set__port_id(int32_t value);
  private:
  int32_t _internal__port_id() const;
  void _internal_set__port_id(int32_t value);
  public:

  // optional int32 _net_expr = 3;
  bool has__net_expr() const;
  private:
  bool _internal_has__net_expr() const;
  public:
  void clear__net_expr();
  int32_t _net_expr() const;
  void set__net_expr(int32_t value);
  private:
  int32_t _internal__net_expr() const;
  void _internal_set__net_expr(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogPortRefPortConnectClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t id_;
    int32_t _port_id_;
    int32_t _net_expr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogStmtClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogStmtClass) */ {
 public:
  inline VerilogStmtClass() : VerilogStmtClass(nullptr) {}
  ~VerilogStmtClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogStmtClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogStmtClass(const VerilogStmtClass& from);
  VerilogStmtClass(VerilogStmtClass&& from) noexcept
    : VerilogStmtClass() {
    *this = ::std::move(from);
  }

  inline VerilogStmtClass& operator=(const VerilogStmtClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogStmtClass& operator=(VerilogStmtClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogStmtClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogStmtClass* internal_default_instance() {
    return reinterpret_cast<const VerilogStmtClass*>(
               &_VerilogStmtClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VerilogStmtClass& a, VerilogStmtClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogStmtClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogStmtClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogStmtClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogStmtClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogStmtClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogStmtClass& from) {
    VerilogStmtClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogStmtClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogStmtClass";
  }
  protected:
  explicit VerilogStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
  };
  // required int32 _line = 1;
  bool has__line() const;
  private:
  bool _internal_has__line() const;
  public:
  void clear__line();
  int32_t _line() const;
  void set__line(int32_t value);
  private:
  int32_t _internal__line() const;
  void _internal_set__line(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogStmtClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t _line_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogInstClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogInstClass) */ {
 public:
  inline VerilogInstClass() : VerilogInstClass(nullptr) {}
  ~VerilogInstClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogInstClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogInstClass(const VerilogInstClass& from);
  VerilogInstClass(VerilogInstClass&& from) noexcept
    : VerilogInstClass() {
    *this = ::std::move(from);
  }

  inline VerilogInstClass& operator=(const VerilogInstClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogInstClass& operator=(VerilogInstClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogInstClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogInstClass* internal_default_instance() {
    return reinterpret_cast<const VerilogInstClass*>(
               &_VerilogInstClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VerilogInstClass& a, VerilogInstClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogInstClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogInstClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogInstClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogInstClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogInstClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogInstClass& from) {
    VerilogInstClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogInstClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogInstClass";
  }
  protected:
  explicit VerilogInstClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortConnectionsFieldNumber = 3,
    kInstNameFieldNumber = 1,
    kCellNameFieldNumber = 2,
  };
  // repeated int32 _port_connections = 3;
  int _port_connections_size() const;
  private:
  int _internal__port_connections_size() const;
  public:
  void clear__port_connections();
  private:
  int32_t _internal__port_connections(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal__port_connections() const;
  void _internal_add__port_connections(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable__port_connections();
  public:
  int32_t _port_connections(int index) const;
  void set__port_connections(int index, int32_t value);
  void add__port_connections(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _port_connections() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable__port_connections();

  // required string _inst_name = 1;
  bool has__inst_name() const;
  private:
  bool _internal_has__inst_name() const;
  public:
  void clear__inst_name();
  const std::string& _inst_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__inst_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__inst_name();
  PROTOBUF_NODISCARD std::string* release__inst_name();
  void set_allocated__inst_name(std::string* _inst_name);
  private:
  const std::string& _internal__inst_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__inst_name(const std::string& value);
  std::string* _internal_mutable__inst_name();
  public:

  // required string _cell_name = 2;
  bool has__cell_name() const;
  private:
  bool _internal_has__cell_name() const;
  public:
  void clear__cell_name();
  const std::string& _cell_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__cell_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__cell_name();
  PROTOBUF_NODISCARD std::string* release__cell_name();
  void set_allocated__cell_name(std::string* _cell_name);
  private:
  const std::string& _internal__cell_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__cell_name(const std::string& value);
  std::string* _internal_mutable__cell_name();
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogInstClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > _port_connections_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _inst_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _cell_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogDclTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogDclTypeEnum) */ {
 public:
  inline VerilogDclTypeEnum() : VerilogDclTypeEnum(nullptr) {}
  ~VerilogDclTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR VerilogDclTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogDclTypeEnum(const VerilogDclTypeEnum& from);
  VerilogDclTypeEnum(VerilogDclTypeEnum&& from) noexcept
    : VerilogDclTypeEnum() {
    *this = ::std::move(from);
  }

  inline VerilogDclTypeEnum& operator=(const VerilogDclTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogDclTypeEnum& operator=(VerilogDclTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogDclTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogDclTypeEnum* internal_default_instance() {
    return reinterpret_cast<const VerilogDclTypeEnum*>(
               &_VerilogDclTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VerilogDclTypeEnum& a, VerilogDclTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogDclTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogDclTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogDclTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogDclTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogDclTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogDclTypeEnum& from) {
    VerilogDclTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogDclTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogDclTypeEnum";
  }
  protected:
  explicit VerilogDclTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VerilogDclTypeEnum_DclType DclType;
  static constexpr DclType kInput =
    VerilogDclTypeEnum_DclType_kInput;
  static constexpr DclType kInout =
    VerilogDclTypeEnum_DclType_kInout;
  static constexpr DclType kOutput =
    VerilogDclTypeEnum_DclType_kOutput;
  static constexpr DclType kSupply0 =
    VerilogDclTypeEnum_DclType_kSupply0;
  static constexpr DclType kSupply1 =
    VerilogDclTypeEnum_DclType_kSupply1;
  static constexpr DclType kTri =
    VerilogDclTypeEnum_DclType_kTri;
  static constexpr DclType kWand =
    VerilogDclTypeEnum_DclType_kWand;
  static constexpr DclType kWire =
    VerilogDclTypeEnum_DclType_kWire;
  static constexpr DclType kWor =
    VerilogDclTypeEnum_DclType_kWor;
  static inline bool DclType_IsValid(int value) {
    return VerilogDclTypeEnum_DclType_IsValid(value);
  }
  static constexpr DclType DclType_MIN =
    VerilogDclTypeEnum_DclType_DclType_MIN;
  static constexpr DclType DclType_MAX =
    VerilogDclTypeEnum_DclType_DclType_MAX;
  static constexpr int DclType_ARRAYSIZE =
    VerilogDclTypeEnum_DclType_DclType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DclType_descriptor() {
    return VerilogDclTypeEnum_DclType_descriptor();
  }
  template<typename T>
  static inline const std::string& DclType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DclType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DclType_Name.");
    return VerilogDclTypeEnum_DclType_Name(enum_t_value);
  }
  static inline bool DclType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DclType* value) {
    return VerilogDclTypeEnum_DclType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDtFieldNumber = 1,
  };
  // required .VerilogParser.VerilogDclTypeEnum.DclType dt = 1;
  bool has_dt() const;
  private:
  bool _internal_has_dt() const;
  public:
  void clear_dt();
  ::VerilogParser::VerilogDclTypeEnum_DclType dt() const;
  void set_dt(::VerilogParser::VerilogDclTypeEnum_DclType value);
  private:
  ::VerilogParser::VerilogDclTypeEnum_DclType _internal_dt() const;
  void _internal_set_dt(::VerilogParser::VerilogDclTypeEnum_DclType value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogDclTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int dt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogDclClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogDclClass) */ {
 public:
  inline VerilogDclClass() : VerilogDclClass(nullptr) {}
  ~VerilogDclClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogDclClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogDclClass(const VerilogDclClass& from);
  VerilogDclClass(VerilogDclClass&& from) noexcept
    : VerilogDclClass() {
    *this = ::std::move(from);
  }

  inline VerilogDclClass& operator=(const VerilogDclClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogDclClass& operator=(VerilogDclClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogDclClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogDclClass* internal_default_instance() {
    return reinterpret_cast<const VerilogDclClass*>(
               &_VerilogDclClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VerilogDclClass& a, VerilogDclClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogDclClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogDclClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogDclClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogDclClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogDclClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogDclClass& from) {
    VerilogDclClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogDclClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogDclClass";
  }
  protected:
  explicit VerilogDclClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDclNameFieldNumber = 3,
    kDclTypeFieldNumber = 2,
    kRangeFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // required string _dcl_name = 3;
  bool has__dcl_name() const;
  private:
  bool _internal_has__dcl_name() const;
  public:
  void clear__dcl_name();
  const std::string& _dcl_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__dcl_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__dcl_name();
  PROTOBUF_NODISCARD std::string* release__dcl_name();
  void set_allocated__dcl_name(std::string* _dcl_name);
  private:
  const std::string& _internal__dcl_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__dcl_name(const std::string& value);
  std::string* _internal_mutable__dcl_name();
  public:

  // required .VerilogParser.VerilogDclTypeEnum _dcl_type = 2;
  bool has__dcl_type() const;
  private:
  bool _internal_has__dcl_type() const;
  public:
  void clear__dcl_type();
  const ::VerilogParser::VerilogDclTypeEnum& _dcl_type() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogDclTypeEnum* release__dcl_type();
  ::VerilogParser::VerilogDclTypeEnum* mutable__dcl_type();
  void set_allocated__dcl_type(::VerilogParser::VerilogDclTypeEnum* _dcl_type);
  private:
  const ::VerilogParser::VerilogDclTypeEnum& _internal__dcl_type() const;
  ::VerilogParser::VerilogDclTypeEnum* _internal_mutable__dcl_type();
  public:
  void unsafe_arena_set_allocated__dcl_type(
      ::VerilogParser::VerilogDclTypeEnum* _dcl_type);
  ::VerilogParser::VerilogDclTypeEnum* unsafe_arena_release__dcl_type();

  // optional .Common.Types.IntPair _range = 4;
  bool has__range() const;
  private:
  bool _internal_has__range() const;
  public:
  void clear__range();
  const ::Common::Types::IntPair& _range() const;
  PROTOBUF_NODISCARD ::Common::Types::IntPair* release__range();
  ::Common::Types::IntPair* mutable__range();
  void set_allocated__range(::Common::Types::IntPair* _range);
  private:
  const ::Common::Types::IntPair& _internal__range() const;
  ::Common::Types::IntPair* _internal_mutable__range();
  public:
  void unsafe_arena_set_allocated__range(
      ::Common::Types::IntPair* _range);
  ::Common::Types::IntPair* unsafe_arena_release__range();

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogDclClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _dcl_name_;
    ::VerilogParser::VerilogDclTypeEnum* _dcl_type_;
    ::Common::Types::IntPair* _range_;
    int32_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogDclsClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogDclsClass) */ {
 public:
  inline VerilogDclsClass() : VerilogDclsClass(nullptr) {}
  ~VerilogDclsClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogDclsClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogDclsClass(const VerilogDclsClass& from);
  VerilogDclsClass(VerilogDclsClass&& from) noexcept
    : VerilogDclsClass() {
    *this = ::std::move(from);
  }

  inline VerilogDclsClass& operator=(const VerilogDclsClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogDclsClass& operator=(VerilogDclsClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogDclsClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogDclsClass* internal_default_instance() {
    return reinterpret_cast<const VerilogDclsClass*>(
               &_VerilogDclsClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VerilogDclsClass& a, VerilogDclsClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogDclsClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogDclsClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogDclsClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogDclsClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogDclsClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogDclsClass& from) {
    VerilogDclsClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogDclsClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogDclsClass";
  }
  protected:
  explicit VerilogDclsClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerilogDclsFieldNumber = 2,
  };
  // repeated int32 _verilog_dcls = 2;
  int _verilog_dcls_size() const;
  private:
  int _internal__verilog_dcls_size() const;
  public:
  void clear__verilog_dcls();
  private:
  int32_t _internal__verilog_dcls(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal__verilog_dcls() const;
  void _internal_add__verilog_dcls(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable__verilog_dcls();
  public:
  int32_t _verilog_dcls(int index) const;
  void set__verilog_dcls(int index, int32_t value);
  void add__verilog_dcls(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _verilog_dcls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable__verilog_dcls();

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogDclsClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > _verilog_dcls_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogModuleClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogModuleClass) */ {
 public:
  inline VerilogModuleClass() : VerilogModuleClass(nullptr) {}
  ~VerilogModuleClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogModuleClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogModuleClass(const VerilogModuleClass& from);
  VerilogModuleClass(VerilogModuleClass&& from) noexcept
    : VerilogModuleClass() {
    *this = ::std::move(from);
  }

  inline VerilogModuleClass& operator=(const VerilogModuleClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogModuleClass& operator=(VerilogModuleClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogModuleClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogModuleClass* internal_default_instance() {
    return reinterpret_cast<const VerilogModuleClass*>(
               &_VerilogModuleClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VerilogModuleClass& a, VerilogModuleClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogModuleClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogModuleClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogModuleClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogModuleClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogModuleClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogModuleClass& from) {
    VerilogModuleClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogModuleClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogModuleClass";
  }
  protected:
  explicit VerilogModuleClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortListFieldNumber = 2,
    kModuleStmtsFieldNumber = 3,
    kModuleNameFieldNumber = 1,
  };
  // repeated int32 _port_list = 2;
  int _port_list_size() const;
  private:
  int _internal__port_list_size() const;
  public:
  void clear__port_list();
  private:
  int32_t _internal__port_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal__port_list() const;
  void _internal_add__port_list(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable__port_list();
  public:
  int32_t _port_list(int index) const;
  void set__port_list(int index, int32_t value);
  void add__port_list(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _port_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable__port_list();

  // repeated int32 _module_stmts = 3;
  int _module_stmts_size() const;
  private:
  int _internal__module_stmts_size() const;
  public:
  void clear__module_stmts();
  private:
  int32_t _internal__module_stmts(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal__module_stmts() const;
  void _internal_add__module_stmts(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable__module_stmts();
  public:
  int32_t _module_stmts(int index) const;
  void set__module_stmts(int index, int32_t value);
  void add__module_stmts(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _module_stmts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable__module_stmts();

  // required string _module_name = 1;
  bool has__module_name() const;
  private:
  bool _internal_has__module_name() const;
  public:
  void clear__module_name();
  const std::string& _module_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__module_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__module_name();
  PROTOBUF_NODISCARD std::string* release__module_name();
  void set_allocated__module_name(std::string* _module_name);
  private:
  const std::string& _internal__module_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__module_name(const std::string& value);
  std::string* _internal_mutable__module_name();
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogModuleClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > _port_list_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > _module_stmts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _module_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogStmtSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogStmtSyn) */ {
 public:
  inline VerilogStmtSyn() : VerilogStmtSyn(nullptr) {}
  ~VerilogStmtSyn() override;
  explicit PROTOBUF_CONSTEXPR VerilogStmtSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogStmtSyn(const VerilogStmtSyn& from);
  VerilogStmtSyn(VerilogStmtSyn&& from) noexcept
    : VerilogStmtSyn() {
    *this = ::std::move(from);
  }

  inline VerilogStmtSyn& operator=(const VerilogStmtSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogStmtSyn& operator=(VerilogStmtSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogStmtSyn& default_instance() {
    return *internal_default_instance();
  }
  enum VssCase {
    kI = 4,
    kD = 5,
    kDs = 6,
    kM = 7,
    VSS_NOT_SET = 0,
  };

  static inline const VerilogStmtSyn* internal_default_instance() {
    return reinterpret_cast<const VerilogStmtSyn*>(
               &_VerilogStmtSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VerilogStmtSyn& a, VerilogStmtSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogStmtSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogStmtSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogStmtSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogStmtSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogStmtSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogStmtSyn& from) {
    VerilogStmtSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogStmtSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogStmtSyn";
  }
  protected:
  explicit VerilogStmtSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kVssTypeFieldNumber = 2,
    kIFieldNumber = 4,
    kDFieldNumber = 5,
    kDsFieldNumber = 6,
    kMFieldNumber = 7,
  };
  // required .VerilogParser.VerilogStmtClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::VerilogParser::VerilogStmtClass& parent() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogStmtClass* release_parent();
  ::VerilogParser::VerilogStmtClass* mutable_parent();
  void set_allocated_parent(::VerilogParser::VerilogStmtClass* parent);
  private:
  const ::VerilogParser::VerilogStmtClass& _internal_parent() const;
  ::VerilogParser::VerilogStmtClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::VerilogParser::VerilogStmtClass* parent);
  ::VerilogParser::VerilogStmtClass* unsafe_arena_release_parent();

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 vss_type = 2;
  bool has_vss_type() const;
  private:
  bool _internal_has_vss_type() const;
  public:
  void clear_vss_type();
  int32_t vss_type() const;
  void set_vss_type(int32_t value);
  private:
  int32_t _internal_vss_type() const;
  void _internal_set_vss_type(int32_t value);
  public:

  // .VerilogParser.VerilogInstClass i = 4;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  const ::VerilogParser::VerilogInstClass& i() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogInstClass* release_i();
  ::VerilogParser::VerilogInstClass* mutable_i();
  void set_allocated_i(::VerilogParser::VerilogInstClass* i);
  private:
  const ::VerilogParser::VerilogInstClass& _internal_i() const;
  ::VerilogParser::VerilogInstClass* _internal_mutable_i();
  public:
  void unsafe_arena_set_allocated_i(
      ::VerilogParser::VerilogInstClass* i);
  ::VerilogParser::VerilogInstClass* unsafe_arena_release_i();

  // .VerilogParser.VerilogDclClass d = 5;
  bool has_d() const;
  private:
  bool _internal_has_d() const;
  public:
  void clear_d();
  const ::VerilogParser::VerilogDclClass& d() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogDclClass* release_d();
  ::VerilogParser::VerilogDclClass* mutable_d();
  void set_allocated_d(::VerilogParser::VerilogDclClass* d);
  private:
  const ::VerilogParser::VerilogDclClass& _internal_d() const;
  ::VerilogParser::VerilogDclClass* _internal_mutable_d();
  public:
  void unsafe_arena_set_allocated_d(
      ::VerilogParser::VerilogDclClass* d);
  ::VerilogParser::VerilogDclClass* unsafe_arena_release_d();

  // .VerilogParser.VerilogDclsClass ds = 6;
  bool has_ds() const;
  private:
  bool _internal_has_ds() const;
  public:
  void clear_ds();
  const ::VerilogParser::VerilogDclsClass& ds() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogDclsClass* release_ds();
  ::VerilogParser::VerilogDclsClass* mutable_ds();
  void set_allocated_ds(::VerilogParser::VerilogDclsClass* ds);
  private:
  const ::VerilogParser::VerilogDclsClass& _internal_ds() const;
  ::VerilogParser::VerilogDclsClass* _internal_mutable_ds();
  public:
  void unsafe_arena_set_allocated_ds(
      ::VerilogParser::VerilogDclsClass* ds);
  ::VerilogParser::VerilogDclsClass* unsafe_arena_release_ds();

  // .VerilogParser.VerilogModuleClass m = 7;
  bool has_m() const;
  private:
  bool _internal_has_m() const;
  public:
  void clear_m();
  const ::VerilogParser::VerilogModuleClass& m() const;
  PROTOBUF_NODISCARD ::VerilogParser::VerilogModuleClass* release_m();
  ::VerilogParser::VerilogModuleClass* mutable_m();
  void set_allocated_m(::VerilogParser::VerilogModuleClass* m);
  private:
  const ::VerilogParser::VerilogModuleClass& _internal_m() const;
  ::VerilogParser::VerilogModuleClass* _internal_mutable_m();
  public:
  void unsafe_arena_set_allocated_m(
      ::VerilogParser::VerilogModuleClass* m);
  ::VerilogParser::VerilogModuleClass* unsafe_arena_release_m();

  void clear_vss();
  VssCase vss_case() const;
  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogStmtSyn)
 private:
  class _Internal;
  void set_has_i();
  void set_has_d();
  void set_has_ds();
  void set_has_m();

  inline bool has_vss() const;
  inline void clear_has_vss();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::VerilogParser::VerilogStmtClass* parent_;
    int32_t id_;
    int32_t vss_type_;
    union VssUnion {
      constexpr VssUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::VerilogParser::VerilogInstClass* i_;
      ::VerilogParser::VerilogDclClass* d_;
      ::VerilogParser::VerilogDclsClass* ds_;
      ::VerilogParser::VerilogModuleClass* m_;
    } vss_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogReaderClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogReaderClass) */ {
 public:
  inline VerilogReaderClass() : VerilogReaderClass(nullptr) {}
  ~VerilogReaderClass() override;
  explicit PROTOBUF_CONSTEXPR VerilogReaderClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogReaderClass(const VerilogReaderClass& from);
  VerilogReaderClass(VerilogReaderClass&& from) noexcept
    : VerilogReaderClass() {
    *this = ::std::move(from);
  }

  inline VerilogReaderClass& operator=(const VerilogReaderClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogReaderClass& operator=(VerilogReaderClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogReaderClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogReaderClass* internal_default_instance() {
    return reinterpret_cast<const VerilogReaderClass*>(
               &_VerilogReaderClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VerilogReaderClass& a, VerilogReaderClass& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogReaderClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogReaderClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogReaderClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogReaderClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogReaderClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogReaderClass& from) {
    VerilogReaderClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogReaderClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogReaderClass";
  }
  protected:
  explicit VerilogReaderClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerilogModulesFieldNumber = 4,
    kFileNameFieldNumber = 3,
    kIdFieldNumber = 1,
    kMetaDataFieldNumber = 2,
  };
  // repeated int32 _verilog_modules = 4;
  int _verilog_modules_size() const;
  private:
  int _internal__verilog_modules_size() const;
  public:
  void clear__verilog_modules();
  private:
  int32_t _internal__verilog_modules(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal__verilog_modules() const;
  void _internal_add__verilog_modules(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable__verilog_modules();
  public:
  int32_t _verilog_modules(int index) const;
  void set__verilog_modules(int index, int32_t value);
  void add__verilog_modules(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _verilog_modules() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable__verilog_modules();

  // required string _file_name = 3;
  bool has__file_name() const;
  private:
  bool _internal_has__file_name() const;
  public:
  void clear__file_name();
  const std::string& _file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__file_name();
  PROTOBUF_NODISCARD std::string* release__file_name();
  void set_allocated__file_name(std::string* _file_name);
  private:
  const std::string& _internal__file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__file_name(const std::string& value);
  std::string* _internal_mutable__file_name();
  public:

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 meta_data = 2;
  bool has_meta_data() const;
  private:
  bool _internal_has_meta_data() const;
  public:
  void clear_meta_data();
  int32_t meta_data() const;
  void set_meta_data(int32_t value);
  private:
  int32_t _internal_meta_data() const;
  void _internal_set_meta_data(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogReaderClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > _verilog_modules_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _file_name_;
    int32_t id_;
    int32_t meta_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogMetaData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogMetaData) */ {
 public:
  inline VerilogMetaData() : VerilogMetaData(nullptr) {}
  ~VerilogMetaData() override;
  explicit PROTOBUF_CONSTEXPR VerilogMetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogMetaData(const VerilogMetaData& from);
  VerilogMetaData(VerilogMetaData&& from) noexcept
    : VerilogMetaData() {
    *this = ::std::move(from);
  }

  inline VerilogMetaData& operator=(const VerilogMetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogMetaData& operator=(VerilogMetaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogMetaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogMetaData* internal_default_instance() {
    return reinterpret_cast<const VerilogMetaData*>(
               &_VerilogMetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VerilogMetaData& a, VerilogMetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogMetaData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogMetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogMetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogMetaData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogMetaData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogMetaData& from) {
    VerilogMetaData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogMetaData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogMetaData";
  }
  protected:
  explicit VerilogMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kVerilogReaderIdFieldNumber = 2,
  };
  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 verilog_reader_id = 2;
  bool has_verilog_reader_id() const;
  private:
  bool _internal_has_verilog_reader_id() const;
  public:
  void clear_verilog_reader_id();
  int32_t verilog_reader_id() const;
  void set_verilog_reader_id(int32_t value);
  private:
  int32_t _internal_verilog_reader_id() const;
  void _internal_set_verilog_reader_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogMetaData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t id_;
    int32_t verilog_reader_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class BatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.BatchRequest) */ {
 public:
  inline BatchRequest() : BatchRequest(nullptr) {}
  ~BatchRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchRequest(const BatchRequest& from);
  BatchRequest(BatchRequest&& from) noexcept
    : BatchRequest() {
    *this = ::std::move(from);
  }

  inline BatchRequest& operator=(const BatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchRequest& operator=(BatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchRequest* internal_default_instance() {
    return reinterpret_cast<const BatchRequest*>(
               &_BatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BatchRequest& a, BatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchRequest& from) {
    BatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.BatchRequest";
  }
  protected:
  explicit BatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdlFieldNumber = 2,
    kBatchSizeFieldNumber = 1,
  };
  // repeated int32 idl = 2;
  int idl_size() const;
  private:
  int _internal_idl_size() const;
  public:
  void clear_idl();
  private:
  int32_t _internal_idl(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_idl() const;
  void _internal_add_idl(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_idl();
  public:
  int32_t idl(int index) const;
  void set_idl(int index, int32_t value);
  void add_idl(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      idl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_idl();

  // required int32 batch_size = 1;
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.BatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > idl_;
    int32_t batch_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// -------------------------------------------------------------------

class VerilogStmtSynBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VerilogParser.VerilogStmtSynBatch) */ {
 public:
  inline VerilogStmtSynBatch() : VerilogStmtSynBatch(nullptr) {}
  ~VerilogStmtSynBatch() override;
  explicit PROTOBUF_CONSTEXPR VerilogStmtSynBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerilogStmtSynBatch(const VerilogStmtSynBatch& from);
  VerilogStmtSynBatch(VerilogStmtSynBatch&& from) noexcept
    : VerilogStmtSynBatch() {
    *this = ::std::move(from);
  }

  inline VerilogStmtSynBatch& operator=(const VerilogStmtSynBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerilogStmtSynBatch& operator=(VerilogStmtSynBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerilogStmtSynBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerilogStmtSynBatch* internal_default_instance() {
    return reinterpret_cast<const VerilogStmtSynBatch*>(
               &_VerilogStmtSynBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VerilogStmtSynBatch& a, VerilogStmtSynBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(VerilogStmtSynBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerilogStmtSynBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerilogStmtSynBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerilogStmtSynBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerilogStmtSynBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerilogStmtSynBatch& from) {
    VerilogStmtSynBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerilogStmtSynBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VerilogParser.VerilogStmtSynBatch";
  }
  protected:
  explicit VerilogStmtSynBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVsslFieldNumber = 5,
    kIdFieldNumber = 1,
    kSynIdFieldNumber = 2,
    kStartStmtIdFieldNumber = 3,
    kEndStmtIdFieldNumber = 4,
  };
  // repeated bytes vssl = 5;
  int vssl_size() const;
  private:
  int _internal_vssl_size() const;
  public:
  void clear_vssl();
  const std::string& vssl(int index) const;
  std::string* mutable_vssl(int index);
  void set_vssl(int index, const std::string& value);
  void set_vssl(int index, std::string&& value);
  void set_vssl(int index, const char* value);
  void set_vssl(int index, const void* value, size_t size);
  std::string* add_vssl();
  void add_vssl(const std::string& value);
  void add_vssl(std::string&& value);
  void add_vssl(const char* value);
  void add_vssl(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vssl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vssl();
  private:
  const std::string& _internal_vssl(int index) const;
  std::string* _internal_add_vssl();
  public:

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // required int32 syn_id = 2;
  bool has_syn_id() const;
  private:
  bool _internal_has_syn_id() const;
  public:
  void clear_syn_id();
  int32_t syn_id() const;
  void set_syn_id(int32_t value);
  private:
  int32_t _internal_syn_id() const;
  void _internal_set_syn_id(int32_t value);
  public:

  // required int64 start_stmt_id = 3;
  bool has_start_stmt_id() const;
  private:
  bool _internal_has_start_stmt_id() const;
  public:
  void clear_start_stmt_id();
  int64_t start_stmt_id() const;
  void set_start_stmt_id(int64_t value);
  private:
  int64_t _internal_start_stmt_id() const;
  void _internal_set_start_stmt_id(int64_t value);
  public:

  // required int64 end_stmt_id = 4;
  bool has_end_stmt_id() const;
  private:
  bool _internal_has_end_stmt_id() const;
  public:
  void clear_end_stmt_id();
  int64_t end_stmt_id() const;
  void set_end_stmt_id(int64_t value);
  private:
  int64_t _internal_end_stmt_id() const;
  void _internal_set_end_stmt_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:VerilogParser.VerilogStmtSynBatch)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vssl_;
    int32_t id_;
    int32_t syn_id_;
    int64_t start_stmt_id_;
    int64_t end_stmt_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_VerilogReader_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VerilogIDClass

// required string _id = 1;
inline bool VerilogIDClass::_internal_has__id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogIDClass::has__id() const {
  return _internal_has__id();
}
inline void VerilogIDClass::clear__id() {
  _impl_._id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VerilogIDClass::_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogIDClass._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerilogIDClass::set__id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogIDClass._id)
}
inline std::string* VerilogIDClass::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogIDClass._id)
  return _s;
}
inline const std::string& VerilogIDClass::_internal__id() const {
  return _impl_._id_.Get();
}
inline void VerilogIDClass::_internal_set__id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* VerilogIDClass::_internal_mutable__id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* VerilogIDClass::release__id() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogIDClass._id)
  if (!_internal_has__id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerilogIDClass::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogIDClass._id)
}

// -------------------------------------------------------------------

// VerilogIndexIDClass

// required int32 _index = 2;
inline bool VerilogIndexIDClass::_internal_has__index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogIndexIDClass::has__index() const {
  return _internal_has__index();
}
inline void VerilogIndexIDClass::clear__index() {
  _impl_._index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogIndexIDClass::_internal__index() const {
  return _impl_._index_;
}
inline int32_t VerilogIndexIDClass::_index() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogIndexIDClass._index)
  return _internal__index();
}
inline void VerilogIndexIDClass::_internal_set__index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._index_ = value;
}
inline void VerilogIndexIDClass::set__index(int32_t value) {
  _internal_set__index(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogIndexIDClass._index)
}

// -------------------------------------------------------------------

// VerilogSliceIDClass

// required int32 _range_from = 2;
inline bool VerilogSliceIDClass::_internal_has__range_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogSliceIDClass::has__range_from() const {
  return _internal_has__range_from();
}
inline void VerilogSliceIDClass::clear__range_from() {
  _impl_._range_from_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogSliceIDClass::_internal__range_from() const {
  return _impl_._range_from_;
}
inline int32_t VerilogSliceIDClass::_range_from() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogSliceIDClass._range_from)
  return _internal__range_from();
}
inline void VerilogSliceIDClass::_internal_set__range_from(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._range_from_ = value;
}
inline void VerilogSliceIDClass::set__range_from(int32_t value) {
  _internal_set__range_from(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogSliceIDClass._range_from)
}

// required int32 _range_to = 3;
inline bool VerilogSliceIDClass::_internal_has__range_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogSliceIDClass::has__range_to() const {
  return _internal_has__range_to();
}
inline void VerilogSliceIDClass::clear__range_to() {
  _impl_._range_to_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VerilogSliceIDClass::_internal__range_to() const {
  return _impl_._range_to_;
}
inline int32_t VerilogSliceIDClass::_range_to() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogSliceIDClass._range_to)
  return _internal__range_to();
}
inline void VerilogSliceIDClass::_internal_set__range_to(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._range_to_ = value;
}
inline void VerilogSliceIDClass::set__range_to(int32_t value) {
  _internal_set__range_to(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogSliceIDClass._range_to)
}

// -------------------------------------------------------------------

// VerilogChildIDClass

// .VerilogParser.VerilogIndexIDClass idx = 1;
inline bool VerilogChildIDClass::_internal_has_idx() const {
  return vid_case() == kIdx;
}
inline bool VerilogChildIDClass::has_idx() const {
  return _internal_has_idx();
}
inline void VerilogChildIDClass::set_has_idx() {
  _impl_._oneof_case_[0] = kIdx;
}
inline void VerilogChildIDClass::clear_idx() {
  if (_internal_has_idx()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vid_.idx_;
    }
    clear_has_vid();
  }
}
inline ::VerilogParser::VerilogIndexIDClass* VerilogChildIDClass::release_idx() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogChildIDClass.idx)
  if (_internal_has_idx()) {
    clear_has_vid();
    ::VerilogParser::VerilogIndexIDClass* temp = _impl_.vid_.idx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vid_.idx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogIndexIDClass& VerilogChildIDClass::_internal_idx() const {
  return _internal_has_idx()
      ? *_impl_.vid_.idx_
      : reinterpret_cast< ::VerilogParser::VerilogIndexIDClass&>(::VerilogParser::_VerilogIndexIDClass_default_instance_);
}
inline const ::VerilogParser::VerilogIndexIDClass& VerilogChildIDClass::idx() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogChildIDClass.idx)
  return _internal_idx();
}
inline ::VerilogParser::VerilogIndexIDClass* VerilogChildIDClass::unsafe_arena_release_idx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogChildIDClass.idx)
  if (_internal_has_idx()) {
    clear_has_vid();
    ::VerilogParser::VerilogIndexIDClass* temp = _impl_.vid_.idx_;
    _impl_.vid_.idx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogChildIDClass::unsafe_arena_set_allocated_idx(::VerilogParser::VerilogIndexIDClass* idx) {
  clear_vid();
  if (idx) {
    set_has_idx();
    _impl_.vid_.idx_ = idx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogChildIDClass.idx)
}
inline ::VerilogParser::VerilogIndexIDClass* VerilogChildIDClass::_internal_mutable_idx() {
  if (!_internal_has_idx()) {
    clear_vid();
    set_has_idx();
    _impl_.vid_.idx_ = CreateMaybeMessage< ::VerilogParser::VerilogIndexIDClass >(GetArenaForAllocation());
  }
  return _impl_.vid_.idx_;
}
inline ::VerilogParser::VerilogIndexIDClass* VerilogChildIDClass::mutable_idx() {
  ::VerilogParser::VerilogIndexIDClass* _msg = _internal_mutable_idx();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogChildIDClass.idx)
  return _msg;
}

// .VerilogParser.VerilogSliceIDClass sid = 2;
inline bool VerilogChildIDClass::_internal_has_sid() const {
  return vid_case() == kSid;
}
inline bool VerilogChildIDClass::has_sid() const {
  return _internal_has_sid();
}
inline void VerilogChildIDClass::set_has_sid() {
  _impl_._oneof_case_[0] = kSid;
}
inline void VerilogChildIDClass::clear_sid() {
  if (_internal_has_sid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vid_.sid_;
    }
    clear_has_vid();
  }
}
inline ::VerilogParser::VerilogSliceIDClass* VerilogChildIDClass::release_sid() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogChildIDClass.sid)
  if (_internal_has_sid()) {
    clear_has_vid();
    ::VerilogParser::VerilogSliceIDClass* temp = _impl_.vid_.sid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vid_.sid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogSliceIDClass& VerilogChildIDClass::_internal_sid() const {
  return _internal_has_sid()
      ? *_impl_.vid_.sid_
      : reinterpret_cast< ::VerilogParser::VerilogSliceIDClass&>(::VerilogParser::_VerilogSliceIDClass_default_instance_);
}
inline const ::VerilogParser::VerilogSliceIDClass& VerilogChildIDClass::sid() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogChildIDClass.sid)
  return _internal_sid();
}
inline ::VerilogParser::VerilogSliceIDClass* VerilogChildIDClass::unsafe_arena_release_sid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogChildIDClass.sid)
  if (_internal_has_sid()) {
    clear_has_vid();
    ::VerilogParser::VerilogSliceIDClass* temp = _impl_.vid_.sid_;
    _impl_.vid_.sid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogChildIDClass::unsafe_arena_set_allocated_sid(::VerilogParser::VerilogSliceIDClass* sid) {
  clear_vid();
  if (sid) {
    set_has_sid();
    _impl_.vid_.sid_ = sid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogChildIDClass.sid)
}
inline ::VerilogParser::VerilogSliceIDClass* VerilogChildIDClass::_internal_mutable_sid() {
  if (!_internal_has_sid()) {
    clear_vid();
    set_has_sid();
    _impl_.vid_.sid_ = CreateMaybeMessage< ::VerilogParser::VerilogSliceIDClass >(GetArenaForAllocation());
  }
  return _impl_.vid_.sid_;
}
inline ::VerilogParser::VerilogSliceIDClass* VerilogChildIDClass::mutable_sid() {
  ::VerilogParser::VerilogSliceIDClass* _msg = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogChildIDClass.sid)
  return _msg;
}

inline bool VerilogChildIDClass::has_vid() const {
  return vid_case() != VID_NOT_SET;
}
inline void VerilogChildIDClass::clear_has_vid() {
  _impl_._oneof_case_[0] = VID_NOT_SET;
}
inline VerilogChildIDClass::VidCase VerilogChildIDClass::vid_case() const {
  return VerilogChildIDClass::VidCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VerilogIDSyn

// required int32 id = 1;
inline bool VerilogIDSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VerilogIDSyn::has_id() const {
  return _internal_has_id();
}
inline void VerilogIDSyn::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t VerilogIDSyn::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogIDSyn::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogIDSyn.id)
  return _internal_id();
}
inline void VerilogIDSyn::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}
inline void VerilogIDSyn::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogIDSyn.id)
}

// required int32 vid_type = 2;
inline bool VerilogIDSyn::_internal_has_vid_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VerilogIDSyn::has_vid_type() const {
  return _internal_has_vid_type();
}
inline void VerilogIDSyn::clear_vid_type() {
  _impl_.vid_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t VerilogIDSyn::_internal_vid_type() const {
  return _impl_.vid_type_;
}
inline int32_t VerilogIDSyn::vid_type() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogIDSyn.vid_type)
  return _internal_vid_type();
}
inline void VerilogIDSyn::_internal_set_vid_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.vid_type_ = value;
}
inline void VerilogIDSyn::set_vid_type(int32_t value) {
  _internal_set_vid_type(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogIDSyn.vid_type)
}

// required .VerilogParser.VerilogIDClass parent = 3;
inline bool VerilogIDSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool VerilogIDSyn::has_parent() const {
  return _internal_has_parent();
}
inline void VerilogIDSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::VerilogParser::VerilogIDClass& VerilogIDSyn::_internal_parent() const {
  const ::VerilogParser::VerilogIDClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::VerilogParser::VerilogIDClass&>(
      ::VerilogParser::_VerilogIDClass_default_instance_);
}
inline const ::VerilogParser::VerilogIDClass& VerilogIDSyn::parent() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogIDSyn.parent)
  return _internal_parent();
}
inline void VerilogIDSyn::unsafe_arena_set_allocated_parent(
    ::VerilogParser::VerilogIDClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogIDSyn.parent)
}
inline ::VerilogParser::VerilogIDClass* VerilogIDSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::VerilogParser::VerilogIDClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VerilogParser::VerilogIDClass* VerilogIDSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogIDSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::VerilogParser::VerilogIDClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::VerilogParser::VerilogIDClass* VerilogIDSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::VerilogParser::VerilogIDClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::VerilogParser::VerilogIDClass* VerilogIDSyn::mutable_parent() {
  ::VerilogParser::VerilogIDClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogIDSyn.parent)
  return _msg;
}
inline void VerilogIDSyn::set_allocated_parent(::VerilogParser::VerilogIDClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogIDSyn.parent)
}

// optional .VerilogParser.VerilogChildIDClass child = 4;
inline bool VerilogIDSyn::_internal_has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline bool VerilogIDSyn::has_child() const {
  return _internal_has_child();
}
inline void VerilogIDSyn::clear_child() {
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::VerilogParser::VerilogChildIDClass& VerilogIDSyn::_internal_child() const {
  const ::VerilogParser::VerilogChildIDClass* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::VerilogParser::VerilogChildIDClass&>(
      ::VerilogParser::_VerilogChildIDClass_default_instance_);
}
inline const ::VerilogParser::VerilogChildIDClass& VerilogIDSyn::child() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogIDSyn.child)
  return _internal_child();
}
inline void VerilogIDSyn::unsafe_arena_set_allocated_child(
    ::VerilogParser::VerilogChildIDClass* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogIDSyn.child)
}
inline ::VerilogParser::VerilogChildIDClass* VerilogIDSyn::release_child() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::VerilogParser::VerilogChildIDClass* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VerilogParser::VerilogChildIDClass* VerilogIDSyn::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogIDSyn.child)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::VerilogParser::VerilogChildIDClass* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::VerilogParser::VerilogChildIDClass* VerilogIDSyn::_internal_mutable_child() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::VerilogParser::VerilogChildIDClass>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::VerilogParser::VerilogChildIDClass* VerilogIDSyn::mutable_child() {
  ::VerilogParser::VerilogChildIDClass* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogIDSyn.child)
  return _msg;
}
inline void VerilogIDSyn::set_allocated_child(::VerilogParser::VerilogChildIDClass* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogIDSyn.child)
}

// -------------------------------------------------------------------

// VerilogNetExprClass

// required uint32 _line_no = 1;
inline bool VerilogNetExprClass::_internal_has__line_no() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogNetExprClass::has__line_no() const {
  return _internal_has__line_no();
}
inline void VerilogNetExprClass::clear__line_no() {
  _impl_._line_no_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t VerilogNetExprClass::_internal__line_no() const {
  return _impl_._line_no_;
}
inline uint32_t VerilogNetExprClass::_line_no() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetExprClass._line_no)
  return _internal__line_no();
}
inline void VerilogNetExprClass::_internal_set__line_no(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._line_no_ = value;
}
inline void VerilogNetExprClass::set__line_no(uint32_t value) {
  _internal_set__line_no(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogNetExprClass._line_no)
}

// -------------------------------------------------------------------

// VerilogNetIDExprClass

// required int32 _verilog_id = 2;
inline bool VerilogNetIDExprClass::_internal_has__verilog_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogNetIDExprClass::has__verilog_id() const {
  return _internal_has__verilog_id();
}
inline void VerilogNetIDExprClass::clear__verilog_id() {
  _impl_._verilog_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogNetIDExprClass::_internal__verilog_id() const {
  return _impl_._verilog_id_;
}
inline int32_t VerilogNetIDExprClass::_verilog_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetIDExprClass._verilog_id)
  return _internal__verilog_id();
}
inline void VerilogNetIDExprClass::_internal_set__verilog_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._verilog_id_ = value;
}
inline void VerilogNetIDExprClass::set__verilog_id(int32_t value) {
  _internal_set__verilog_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogNetIDExprClass._verilog_id)
}

// -------------------------------------------------------------------

// VerilogNetConcatExprClass

// repeated int32 _verilog_id_concat = 1;
inline int VerilogNetConcatExprClass::_internal__verilog_id_concat_size() const {
  return _impl_._verilog_id_concat_.size();
}
inline int VerilogNetConcatExprClass::_verilog_id_concat_size() const {
  return _internal__verilog_id_concat_size();
}
inline void VerilogNetConcatExprClass::clear__verilog_id_concat() {
  _impl_._verilog_id_concat_.Clear();
}
inline int32_t VerilogNetConcatExprClass::_internal__verilog_id_concat(int index) const {
  return _impl_._verilog_id_concat_.Get(index);
}
inline int32_t VerilogNetConcatExprClass::_verilog_id_concat(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetConcatExprClass._verilog_id_concat)
  return _internal__verilog_id_concat(index);
}
inline void VerilogNetConcatExprClass::set__verilog_id_concat(int index, int32_t value) {
  _impl_._verilog_id_concat_.Set(index, value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogNetConcatExprClass._verilog_id_concat)
}
inline void VerilogNetConcatExprClass::_internal_add__verilog_id_concat(int32_t value) {
  _impl_._verilog_id_concat_.Add(value);
}
inline void VerilogNetConcatExprClass::add__verilog_id_concat(int32_t value) {
  _internal_add__verilog_id_concat(value);
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogNetConcatExprClass._verilog_id_concat)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogNetConcatExprClass::_internal__verilog_id_concat() const {
  return _impl_._verilog_id_concat_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogNetConcatExprClass::_verilog_id_concat() const {
  // @@protoc_insertion_point(field_list:VerilogParser.VerilogNetConcatExprClass._verilog_id_concat)
  return _internal__verilog_id_concat();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogNetConcatExprClass::_internal_mutable__verilog_id_concat() {
  return &_impl_._verilog_id_concat_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogNetConcatExprClass::mutable__verilog_id_concat() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.VerilogNetConcatExprClass._verilog_id_concat)
  return _internal_mutable__verilog_id_concat();
}

// -------------------------------------------------------------------

// VerilogConstantExprClass

// required int32 _verilog_id = 1;
inline bool VerilogConstantExprClass::_internal_has__verilog_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogConstantExprClass::has__verilog_id() const {
  return _internal_has__verilog_id();
}
inline void VerilogConstantExprClass::clear__verilog_id() {
  _impl_._verilog_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogConstantExprClass::_internal__verilog_id() const {
  return _impl_._verilog_id_;
}
inline int32_t VerilogConstantExprClass::_verilog_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogConstantExprClass._verilog_id)
  return _internal__verilog_id();
}
inline void VerilogConstantExprClass::_internal_set__verilog_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._verilog_id_ = value;
}
inline void VerilogConstantExprClass::set__verilog_id(int32_t value) {
  _internal_set__verilog_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogConstantExprClass._verilog_id)
}

// -------------------------------------------------------------------

// VerilogNetExprSyn

// required int32 id = 1;
inline bool VerilogNetExprSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogNetExprSyn::has_id() const {
  return _internal_has_id();
}
inline void VerilogNetExprSyn::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VerilogNetExprSyn::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogNetExprSyn::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetExprSyn.id)
  return _internal_id();
}
inline void VerilogNetExprSyn::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void VerilogNetExprSyn::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogNetExprSyn.id)
}

// required int32 vnes_type = 2;
inline bool VerilogNetExprSyn::_internal_has_vnes_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VerilogNetExprSyn::has_vnes_type() const {
  return _internal_has_vnes_type();
}
inline void VerilogNetExprSyn::clear_vnes_type() {
  _impl_.vnes_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t VerilogNetExprSyn::_internal_vnes_type() const {
  return _impl_.vnes_type_;
}
inline int32_t VerilogNetExprSyn::vnes_type() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetExprSyn.vnes_type)
  return _internal_vnes_type();
}
inline void VerilogNetExprSyn::_internal_set_vnes_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.vnes_type_ = value;
}
inline void VerilogNetExprSyn::set_vnes_type(int32_t value) {
  _internal_set_vnes_type(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogNetExprSyn.vnes_type)
}

// required .VerilogParser.VerilogNetExprClass parent = 3;
inline bool VerilogNetExprSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool VerilogNetExprSyn::has_parent() const {
  return _internal_has_parent();
}
inline void VerilogNetExprSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::VerilogParser::VerilogNetExprClass& VerilogNetExprSyn::_internal_parent() const {
  const ::VerilogParser::VerilogNetExprClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::VerilogParser::VerilogNetExprClass&>(
      ::VerilogParser::_VerilogNetExprClass_default_instance_);
}
inline const ::VerilogParser::VerilogNetExprClass& VerilogNetExprSyn::parent() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetExprSyn.parent)
  return _internal_parent();
}
inline void VerilogNetExprSyn::unsafe_arena_set_allocated_parent(
    ::VerilogParser::VerilogNetExprClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogNetExprSyn.parent)
}
inline ::VerilogParser::VerilogNetExprClass* VerilogNetExprSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::VerilogParser::VerilogNetExprClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VerilogParser::VerilogNetExprClass* VerilogNetExprSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogNetExprSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::VerilogParser::VerilogNetExprClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::VerilogParser::VerilogNetExprClass* VerilogNetExprSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::VerilogParser::VerilogNetExprClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::VerilogParser::VerilogNetExprClass* VerilogNetExprSyn::mutable_parent() {
  ::VerilogParser::VerilogNetExprClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogNetExprSyn.parent)
  return _msg;
}
inline void VerilogNetExprSyn::set_allocated_parent(::VerilogParser::VerilogNetExprClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogNetExprSyn.parent)
}

// .VerilogParser.VerilogNetIDExprClass nidec = 4;
inline bool VerilogNetExprSyn::_internal_has_nidec() const {
  return vnes_case() == kNidec;
}
inline bool VerilogNetExprSyn::has_nidec() const {
  return _internal_has_nidec();
}
inline void VerilogNetExprSyn::set_has_nidec() {
  _impl_._oneof_case_[0] = kNidec;
}
inline void VerilogNetExprSyn::clear_nidec() {
  if (_internal_has_nidec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vnes_.nidec_;
    }
    clear_has_vnes();
  }
}
inline ::VerilogParser::VerilogNetIDExprClass* VerilogNetExprSyn::release_nidec() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogNetExprSyn.nidec)
  if (_internal_has_nidec()) {
    clear_has_vnes();
    ::VerilogParser::VerilogNetIDExprClass* temp = _impl_.vnes_.nidec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vnes_.nidec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogNetIDExprClass& VerilogNetExprSyn::_internal_nidec() const {
  return _internal_has_nidec()
      ? *_impl_.vnes_.nidec_
      : reinterpret_cast< ::VerilogParser::VerilogNetIDExprClass&>(::VerilogParser::_VerilogNetIDExprClass_default_instance_);
}
inline const ::VerilogParser::VerilogNetIDExprClass& VerilogNetExprSyn::nidec() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetExprSyn.nidec)
  return _internal_nidec();
}
inline ::VerilogParser::VerilogNetIDExprClass* VerilogNetExprSyn::unsafe_arena_release_nidec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogNetExprSyn.nidec)
  if (_internal_has_nidec()) {
    clear_has_vnes();
    ::VerilogParser::VerilogNetIDExprClass* temp = _impl_.vnes_.nidec_;
    _impl_.vnes_.nidec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogNetExprSyn::unsafe_arena_set_allocated_nidec(::VerilogParser::VerilogNetIDExprClass* nidec) {
  clear_vnes();
  if (nidec) {
    set_has_nidec();
    _impl_.vnes_.nidec_ = nidec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogNetExprSyn.nidec)
}
inline ::VerilogParser::VerilogNetIDExprClass* VerilogNetExprSyn::_internal_mutable_nidec() {
  if (!_internal_has_nidec()) {
    clear_vnes();
    set_has_nidec();
    _impl_.vnes_.nidec_ = CreateMaybeMessage< ::VerilogParser::VerilogNetIDExprClass >(GetArenaForAllocation());
  }
  return _impl_.vnes_.nidec_;
}
inline ::VerilogParser::VerilogNetIDExprClass* VerilogNetExprSyn::mutable_nidec() {
  ::VerilogParser::VerilogNetIDExprClass* _msg = _internal_mutable_nidec();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogNetExprSyn.nidec)
  return _msg;
}

// .VerilogParser.VerilogNetConcatExprClass ncec = 5;
inline bool VerilogNetExprSyn::_internal_has_ncec() const {
  return vnes_case() == kNcec;
}
inline bool VerilogNetExprSyn::has_ncec() const {
  return _internal_has_ncec();
}
inline void VerilogNetExprSyn::set_has_ncec() {
  _impl_._oneof_case_[0] = kNcec;
}
inline void VerilogNetExprSyn::clear_ncec() {
  if (_internal_has_ncec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vnes_.ncec_;
    }
    clear_has_vnes();
  }
}
inline ::VerilogParser::VerilogNetConcatExprClass* VerilogNetExprSyn::release_ncec() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogNetExprSyn.ncec)
  if (_internal_has_ncec()) {
    clear_has_vnes();
    ::VerilogParser::VerilogNetConcatExprClass* temp = _impl_.vnes_.ncec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vnes_.ncec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogNetConcatExprClass& VerilogNetExprSyn::_internal_ncec() const {
  return _internal_has_ncec()
      ? *_impl_.vnes_.ncec_
      : reinterpret_cast< ::VerilogParser::VerilogNetConcatExprClass&>(::VerilogParser::_VerilogNetConcatExprClass_default_instance_);
}
inline const ::VerilogParser::VerilogNetConcatExprClass& VerilogNetExprSyn::ncec() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetExprSyn.ncec)
  return _internal_ncec();
}
inline ::VerilogParser::VerilogNetConcatExprClass* VerilogNetExprSyn::unsafe_arena_release_ncec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogNetExprSyn.ncec)
  if (_internal_has_ncec()) {
    clear_has_vnes();
    ::VerilogParser::VerilogNetConcatExprClass* temp = _impl_.vnes_.ncec_;
    _impl_.vnes_.ncec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogNetExprSyn::unsafe_arena_set_allocated_ncec(::VerilogParser::VerilogNetConcatExprClass* ncec) {
  clear_vnes();
  if (ncec) {
    set_has_ncec();
    _impl_.vnes_.ncec_ = ncec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogNetExprSyn.ncec)
}
inline ::VerilogParser::VerilogNetConcatExprClass* VerilogNetExprSyn::_internal_mutable_ncec() {
  if (!_internal_has_ncec()) {
    clear_vnes();
    set_has_ncec();
    _impl_.vnes_.ncec_ = CreateMaybeMessage< ::VerilogParser::VerilogNetConcatExprClass >(GetArenaForAllocation());
  }
  return _impl_.vnes_.ncec_;
}
inline ::VerilogParser::VerilogNetConcatExprClass* VerilogNetExprSyn::mutable_ncec() {
  ::VerilogParser::VerilogNetConcatExprClass* _msg = _internal_mutable_ncec();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogNetExprSyn.ncec)
  return _msg;
}

// .VerilogParser.VerilogConstantExprClass cec = 6;
inline bool VerilogNetExprSyn::_internal_has_cec() const {
  return vnes_case() == kCec;
}
inline bool VerilogNetExprSyn::has_cec() const {
  return _internal_has_cec();
}
inline void VerilogNetExprSyn::set_has_cec() {
  _impl_._oneof_case_[0] = kCec;
}
inline void VerilogNetExprSyn::clear_cec() {
  if (_internal_has_cec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vnes_.cec_;
    }
    clear_has_vnes();
  }
}
inline ::VerilogParser::VerilogConstantExprClass* VerilogNetExprSyn::release_cec() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogNetExprSyn.cec)
  if (_internal_has_cec()) {
    clear_has_vnes();
    ::VerilogParser::VerilogConstantExprClass* temp = _impl_.vnes_.cec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vnes_.cec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogConstantExprClass& VerilogNetExprSyn::_internal_cec() const {
  return _internal_has_cec()
      ? *_impl_.vnes_.cec_
      : reinterpret_cast< ::VerilogParser::VerilogConstantExprClass&>(::VerilogParser::_VerilogConstantExprClass_default_instance_);
}
inline const ::VerilogParser::VerilogConstantExprClass& VerilogNetExprSyn::cec() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogNetExprSyn.cec)
  return _internal_cec();
}
inline ::VerilogParser::VerilogConstantExprClass* VerilogNetExprSyn::unsafe_arena_release_cec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogNetExprSyn.cec)
  if (_internal_has_cec()) {
    clear_has_vnes();
    ::VerilogParser::VerilogConstantExprClass* temp = _impl_.vnes_.cec_;
    _impl_.vnes_.cec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogNetExprSyn::unsafe_arena_set_allocated_cec(::VerilogParser::VerilogConstantExprClass* cec) {
  clear_vnes();
  if (cec) {
    set_has_cec();
    _impl_.vnes_.cec_ = cec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogNetExprSyn.cec)
}
inline ::VerilogParser::VerilogConstantExprClass* VerilogNetExprSyn::_internal_mutable_cec() {
  if (!_internal_has_cec()) {
    clear_vnes();
    set_has_cec();
    _impl_.vnes_.cec_ = CreateMaybeMessage< ::VerilogParser::VerilogConstantExprClass >(GetArenaForAllocation());
  }
  return _impl_.vnes_.cec_;
}
inline ::VerilogParser::VerilogConstantExprClass* VerilogNetExprSyn::mutable_cec() {
  ::VerilogParser::VerilogConstantExprClass* _msg = _internal_mutable_cec();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogNetExprSyn.cec)
  return _msg;
}

inline bool VerilogNetExprSyn::has_vnes() const {
  return vnes_case() != VNES_NOT_SET;
}
inline void VerilogNetExprSyn::clear_has_vnes() {
  _impl_._oneof_case_[0] = VNES_NOT_SET;
}
inline VerilogNetExprSyn::VnesCase VerilogNetExprSyn::vnes_case() const {
  return VerilogNetExprSyn::VnesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VerilogPortRefPortConnectClass

// required int32 id = 1;
inline bool VerilogPortRefPortConnectClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogPortRefPortConnectClass::has_id() const {
  return _internal_has_id();
}
inline void VerilogPortRefPortConnectClass::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogPortRefPortConnectClass::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogPortRefPortConnectClass::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogPortRefPortConnectClass.id)
  return _internal_id();
}
inline void VerilogPortRefPortConnectClass::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void VerilogPortRefPortConnectClass::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogPortRefPortConnectClass.id)
}

// required int32 _port_id = 2;
inline bool VerilogPortRefPortConnectClass::_internal_has__port_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogPortRefPortConnectClass::has__port_id() const {
  return _internal_has__port_id();
}
inline void VerilogPortRefPortConnectClass::clear__port_id() {
  _impl_._port_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VerilogPortRefPortConnectClass::_internal__port_id() const {
  return _impl_._port_id_;
}
inline int32_t VerilogPortRefPortConnectClass::_port_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogPortRefPortConnectClass._port_id)
  return _internal__port_id();
}
inline void VerilogPortRefPortConnectClass::_internal_set__port_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._port_id_ = value;
}
inline void VerilogPortRefPortConnectClass::set__port_id(int32_t value) {
  _internal_set__port_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogPortRefPortConnectClass._port_id)
}

// optional int32 _net_expr = 3;
inline bool VerilogPortRefPortConnectClass::_internal_has__net_expr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VerilogPortRefPortConnectClass::has__net_expr() const {
  return _internal_has__net_expr();
}
inline void VerilogPortRefPortConnectClass::clear__net_expr() {
  _impl_._net_expr_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t VerilogPortRefPortConnectClass::_internal__net_expr() const {
  return _impl_._net_expr_;
}
inline int32_t VerilogPortRefPortConnectClass::_net_expr() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogPortRefPortConnectClass._net_expr)
  return _internal__net_expr();
}
inline void VerilogPortRefPortConnectClass::_internal_set__net_expr(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._net_expr_ = value;
}
inline void VerilogPortRefPortConnectClass::set__net_expr(int32_t value) {
  _internal_set__net_expr(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogPortRefPortConnectClass._net_expr)
}

// -------------------------------------------------------------------

// VerilogStmtClass

// required int32 _line = 1;
inline bool VerilogStmtClass::_internal_has__line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogStmtClass::has__line() const {
  return _internal_has__line();
}
inline void VerilogStmtClass::clear__line() {
  _impl_._line_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogStmtClass::_internal__line() const {
  return _impl_._line_;
}
inline int32_t VerilogStmtClass::_line() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtClass._line)
  return _internal__line();
}
inline void VerilogStmtClass::_internal_set__line(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._line_ = value;
}
inline void VerilogStmtClass::set__line(int32_t value) {
  _internal_set__line(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtClass._line)
}

// -------------------------------------------------------------------

// VerilogInstClass

// required string _inst_name = 1;
inline bool VerilogInstClass::_internal_has__inst_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogInstClass::has__inst_name() const {
  return _internal_has__inst_name();
}
inline void VerilogInstClass::clear__inst_name() {
  _impl_._inst_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VerilogInstClass::_inst_name() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogInstClass._inst_name)
  return _internal__inst_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerilogInstClass::set__inst_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._inst_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogInstClass._inst_name)
}
inline std::string* VerilogInstClass::mutable__inst_name() {
  std::string* _s = _internal_mutable__inst_name();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogInstClass._inst_name)
  return _s;
}
inline const std::string& VerilogInstClass::_internal__inst_name() const {
  return _impl_._inst_name_.Get();
}
inline void VerilogInstClass::_internal_set__inst_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._inst_name_.Set(value, GetArenaForAllocation());
}
inline std::string* VerilogInstClass::_internal_mutable__inst_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._inst_name_.Mutable(GetArenaForAllocation());
}
inline std::string* VerilogInstClass::release__inst_name() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogInstClass._inst_name)
  if (!_internal_has__inst_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._inst_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._inst_name_.IsDefault()) {
    _impl_._inst_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerilogInstClass::set_allocated__inst_name(std::string* _inst_name) {
  if (_inst_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._inst_name_.SetAllocated(_inst_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._inst_name_.IsDefault()) {
    _impl_._inst_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogInstClass._inst_name)
}

// required string _cell_name = 2;
inline bool VerilogInstClass::_internal_has__cell_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogInstClass::has__cell_name() const {
  return _internal_has__cell_name();
}
inline void VerilogInstClass::clear__cell_name() {
  _impl_._cell_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VerilogInstClass::_cell_name() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogInstClass._cell_name)
  return _internal__cell_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerilogInstClass::set__cell_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._cell_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogInstClass._cell_name)
}
inline std::string* VerilogInstClass::mutable__cell_name() {
  std::string* _s = _internal_mutable__cell_name();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogInstClass._cell_name)
  return _s;
}
inline const std::string& VerilogInstClass::_internal__cell_name() const {
  return _impl_._cell_name_.Get();
}
inline void VerilogInstClass::_internal_set__cell_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._cell_name_.Set(value, GetArenaForAllocation());
}
inline std::string* VerilogInstClass::_internal_mutable__cell_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._cell_name_.Mutable(GetArenaForAllocation());
}
inline std::string* VerilogInstClass::release__cell_name() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogInstClass._cell_name)
  if (!_internal_has__cell_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._cell_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._cell_name_.IsDefault()) {
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerilogInstClass::set_allocated__cell_name(std::string* _cell_name) {
  if (_cell_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._cell_name_.SetAllocated(_cell_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._cell_name_.IsDefault()) {
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogInstClass._cell_name)
}

// repeated int32 _port_connections = 3;
inline int VerilogInstClass::_internal__port_connections_size() const {
  return _impl_._port_connections_.size();
}
inline int VerilogInstClass::_port_connections_size() const {
  return _internal__port_connections_size();
}
inline void VerilogInstClass::clear__port_connections() {
  _impl_._port_connections_.Clear();
}
inline int32_t VerilogInstClass::_internal__port_connections(int index) const {
  return _impl_._port_connections_.Get(index);
}
inline int32_t VerilogInstClass::_port_connections(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogInstClass._port_connections)
  return _internal__port_connections(index);
}
inline void VerilogInstClass::set__port_connections(int index, int32_t value) {
  _impl_._port_connections_.Set(index, value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogInstClass._port_connections)
}
inline void VerilogInstClass::_internal_add__port_connections(int32_t value) {
  _impl_._port_connections_.Add(value);
}
inline void VerilogInstClass::add__port_connections(int32_t value) {
  _internal_add__port_connections(value);
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogInstClass._port_connections)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogInstClass::_internal__port_connections() const {
  return _impl_._port_connections_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogInstClass::_port_connections() const {
  // @@protoc_insertion_point(field_list:VerilogParser.VerilogInstClass._port_connections)
  return _internal__port_connections();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogInstClass::_internal_mutable__port_connections() {
  return &_impl_._port_connections_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogInstClass::mutable__port_connections() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.VerilogInstClass._port_connections)
  return _internal_mutable__port_connections();
}

// -------------------------------------------------------------------

// VerilogDclTypeEnum

// required .VerilogParser.VerilogDclTypeEnum.DclType dt = 1;
inline bool VerilogDclTypeEnum::_internal_has_dt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogDclTypeEnum::has_dt() const {
  return _internal_has_dt();
}
inline void VerilogDclTypeEnum::clear_dt() {
  _impl_.dt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::VerilogParser::VerilogDclTypeEnum_DclType VerilogDclTypeEnum::_internal_dt() const {
  return static_cast< ::VerilogParser::VerilogDclTypeEnum_DclType >(_impl_.dt_);
}
inline ::VerilogParser::VerilogDclTypeEnum_DclType VerilogDclTypeEnum::dt() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogDclTypeEnum.dt)
  return _internal_dt();
}
inline void VerilogDclTypeEnum::_internal_set_dt(::VerilogParser::VerilogDclTypeEnum_DclType value) {
  assert(::VerilogParser::VerilogDclTypeEnum_DclType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dt_ = value;
}
inline void VerilogDclTypeEnum::set_dt(::VerilogParser::VerilogDclTypeEnum_DclType value) {
  _internal_set_dt(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogDclTypeEnum.dt)
}

// -------------------------------------------------------------------

// VerilogDclClass

// required int32 id = 1;
inline bool VerilogDclClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VerilogDclClass::has_id() const {
  return _internal_has_id();
}
inline void VerilogDclClass::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t VerilogDclClass::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogDclClass::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogDclClass.id)
  return _internal_id();
}
inline void VerilogDclClass::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.id_ = value;
}
inline void VerilogDclClass::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogDclClass.id)
}

// required .VerilogParser.VerilogDclTypeEnum _dcl_type = 2;
inline bool VerilogDclClass::_internal_has__dcl_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._dcl_type_ != nullptr);
  return value;
}
inline bool VerilogDclClass::has__dcl_type() const {
  return _internal_has__dcl_type();
}
inline void VerilogDclClass::clear__dcl_type() {
  if (_impl_._dcl_type_ != nullptr) _impl_._dcl_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::VerilogParser::VerilogDclTypeEnum& VerilogDclClass::_internal__dcl_type() const {
  const ::VerilogParser::VerilogDclTypeEnum* p = _impl_._dcl_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::VerilogParser::VerilogDclTypeEnum&>(
      ::VerilogParser::_VerilogDclTypeEnum_default_instance_);
}
inline const ::VerilogParser::VerilogDclTypeEnum& VerilogDclClass::_dcl_type() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogDclClass._dcl_type)
  return _internal__dcl_type();
}
inline void VerilogDclClass::unsafe_arena_set_allocated__dcl_type(
    ::VerilogParser::VerilogDclTypeEnum* _dcl_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._dcl_type_);
  }
  _impl_._dcl_type_ = _dcl_type;
  if (_dcl_type) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogDclClass._dcl_type)
}
inline ::VerilogParser::VerilogDclTypeEnum* VerilogDclClass::release__dcl_type() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::VerilogParser::VerilogDclTypeEnum* temp = _impl_._dcl_type_;
  _impl_._dcl_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VerilogParser::VerilogDclTypeEnum* VerilogDclClass::unsafe_arena_release__dcl_type() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogDclClass._dcl_type)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::VerilogParser::VerilogDclTypeEnum* temp = _impl_._dcl_type_;
  _impl_._dcl_type_ = nullptr;
  return temp;
}
inline ::VerilogParser::VerilogDclTypeEnum* VerilogDclClass::_internal_mutable__dcl_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_._dcl_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::VerilogParser::VerilogDclTypeEnum>(GetArenaForAllocation());
    _impl_._dcl_type_ = p;
  }
  return _impl_._dcl_type_;
}
inline ::VerilogParser::VerilogDclTypeEnum* VerilogDclClass::mutable__dcl_type() {
  ::VerilogParser::VerilogDclTypeEnum* _msg = _internal_mutable__dcl_type();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogDclClass._dcl_type)
  return _msg;
}
inline void VerilogDclClass::set_allocated__dcl_type(::VerilogParser::VerilogDclTypeEnum* _dcl_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._dcl_type_;
  }
  if (_dcl_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_dcl_type);
    if (message_arena != submessage_arena) {
      _dcl_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _dcl_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._dcl_type_ = _dcl_type;
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogDclClass._dcl_type)
}

// required string _dcl_name = 3;
inline bool VerilogDclClass::_internal_has__dcl_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogDclClass::has__dcl_name() const {
  return _internal_has__dcl_name();
}
inline void VerilogDclClass::clear__dcl_name() {
  _impl_._dcl_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VerilogDclClass::_dcl_name() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogDclClass._dcl_name)
  return _internal__dcl_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerilogDclClass::set__dcl_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._dcl_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogDclClass._dcl_name)
}
inline std::string* VerilogDclClass::mutable__dcl_name() {
  std::string* _s = _internal_mutable__dcl_name();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogDclClass._dcl_name)
  return _s;
}
inline const std::string& VerilogDclClass::_internal__dcl_name() const {
  return _impl_._dcl_name_.Get();
}
inline void VerilogDclClass::_internal_set__dcl_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._dcl_name_.Set(value, GetArenaForAllocation());
}
inline std::string* VerilogDclClass::_internal_mutable__dcl_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._dcl_name_.Mutable(GetArenaForAllocation());
}
inline std::string* VerilogDclClass::release__dcl_name() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogDclClass._dcl_name)
  if (!_internal_has__dcl_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._dcl_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._dcl_name_.IsDefault()) {
    _impl_._dcl_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerilogDclClass::set_allocated__dcl_name(std::string* _dcl_name) {
  if (_dcl_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._dcl_name_.SetAllocated(_dcl_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._dcl_name_.IsDefault()) {
    _impl_._dcl_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogDclClass._dcl_name)
}

// optional .Common.Types.IntPair _range = 4;
inline bool VerilogDclClass::_internal_has__range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._range_ != nullptr);
  return value;
}
inline bool VerilogDclClass::has__range() const {
  return _internal_has__range();
}
inline const ::Common::Types::IntPair& VerilogDclClass::_internal__range() const {
  const ::Common::Types::IntPair* p = _impl_._range_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::IntPair&>(
      ::Common::Types::_IntPair_default_instance_);
}
inline const ::Common::Types::IntPair& VerilogDclClass::_range() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogDclClass._range)
  return _internal__range();
}
inline void VerilogDclClass::unsafe_arena_set_allocated__range(
    ::Common::Types::IntPair* _range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._range_);
  }
  _impl_._range_ = _range;
  if (_range) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogDclClass._range)
}
inline ::Common::Types::IntPair* VerilogDclClass::release__range() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Common::Types::IntPair* temp = _impl_._range_;
  _impl_._range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::IntPair* VerilogDclClass::unsafe_arena_release__range() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogDclClass._range)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Common::Types::IntPair* temp = _impl_._range_;
  _impl_._range_ = nullptr;
  return temp;
}
inline ::Common::Types::IntPair* VerilogDclClass::_internal_mutable__range() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_._range_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::IntPair>(GetArenaForAllocation());
    _impl_._range_ = p;
  }
  return _impl_._range_;
}
inline ::Common::Types::IntPair* VerilogDclClass::mutable__range() {
  ::Common::Types::IntPair* _msg = _internal_mutable__range();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogDclClass._range)
  return _msg;
}
inline void VerilogDclClass::set_allocated__range(::Common::Types::IntPair* _range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._range_);
  }
  if (_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_range));
    if (message_arena != submessage_arena) {
      _range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _range, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_._range_ = _range;
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogDclClass._range)
}

// -------------------------------------------------------------------

// VerilogDclsClass

// repeated int32 _verilog_dcls = 2;
inline int VerilogDclsClass::_internal__verilog_dcls_size() const {
  return _impl_._verilog_dcls_.size();
}
inline int VerilogDclsClass::_verilog_dcls_size() const {
  return _internal__verilog_dcls_size();
}
inline void VerilogDclsClass::clear__verilog_dcls() {
  _impl_._verilog_dcls_.Clear();
}
inline int32_t VerilogDclsClass::_internal__verilog_dcls(int index) const {
  return _impl_._verilog_dcls_.Get(index);
}
inline int32_t VerilogDclsClass::_verilog_dcls(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogDclsClass._verilog_dcls)
  return _internal__verilog_dcls(index);
}
inline void VerilogDclsClass::set__verilog_dcls(int index, int32_t value) {
  _impl_._verilog_dcls_.Set(index, value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogDclsClass._verilog_dcls)
}
inline void VerilogDclsClass::_internal_add__verilog_dcls(int32_t value) {
  _impl_._verilog_dcls_.Add(value);
}
inline void VerilogDclsClass::add__verilog_dcls(int32_t value) {
  _internal_add__verilog_dcls(value);
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogDclsClass._verilog_dcls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogDclsClass::_internal__verilog_dcls() const {
  return _impl_._verilog_dcls_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogDclsClass::_verilog_dcls() const {
  // @@protoc_insertion_point(field_list:VerilogParser.VerilogDclsClass._verilog_dcls)
  return _internal__verilog_dcls();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogDclsClass::_internal_mutable__verilog_dcls() {
  return &_impl_._verilog_dcls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogDclsClass::mutable__verilog_dcls() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.VerilogDclsClass._verilog_dcls)
  return _internal_mutable__verilog_dcls();
}

// -------------------------------------------------------------------

// VerilogModuleClass

// required string _module_name = 1;
inline bool VerilogModuleClass::_internal_has__module_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogModuleClass::has__module_name() const {
  return _internal_has__module_name();
}
inline void VerilogModuleClass::clear__module_name() {
  _impl_._module_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VerilogModuleClass::_module_name() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogModuleClass._module_name)
  return _internal__module_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerilogModuleClass::set__module_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._module_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogModuleClass._module_name)
}
inline std::string* VerilogModuleClass::mutable__module_name() {
  std::string* _s = _internal_mutable__module_name();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogModuleClass._module_name)
  return _s;
}
inline const std::string& VerilogModuleClass::_internal__module_name() const {
  return _impl_._module_name_.Get();
}
inline void VerilogModuleClass::_internal_set__module_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._module_name_.Set(value, GetArenaForAllocation());
}
inline std::string* VerilogModuleClass::_internal_mutable__module_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._module_name_.Mutable(GetArenaForAllocation());
}
inline std::string* VerilogModuleClass::release__module_name() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogModuleClass._module_name)
  if (!_internal_has__module_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._module_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._module_name_.IsDefault()) {
    _impl_._module_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerilogModuleClass::set_allocated__module_name(std::string* _module_name) {
  if (_module_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._module_name_.SetAllocated(_module_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._module_name_.IsDefault()) {
    _impl_._module_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogModuleClass._module_name)
}

// repeated int32 _port_list = 2;
inline int VerilogModuleClass::_internal__port_list_size() const {
  return _impl_._port_list_.size();
}
inline int VerilogModuleClass::_port_list_size() const {
  return _internal__port_list_size();
}
inline void VerilogModuleClass::clear__port_list() {
  _impl_._port_list_.Clear();
}
inline int32_t VerilogModuleClass::_internal__port_list(int index) const {
  return _impl_._port_list_.Get(index);
}
inline int32_t VerilogModuleClass::_port_list(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogModuleClass._port_list)
  return _internal__port_list(index);
}
inline void VerilogModuleClass::set__port_list(int index, int32_t value) {
  _impl_._port_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogModuleClass._port_list)
}
inline void VerilogModuleClass::_internal_add__port_list(int32_t value) {
  _impl_._port_list_.Add(value);
}
inline void VerilogModuleClass::add__port_list(int32_t value) {
  _internal_add__port_list(value);
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogModuleClass._port_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogModuleClass::_internal__port_list() const {
  return _impl_._port_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogModuleClass::_port_list() const {
  // @@protoc_insertion_point(field_list:VerilogParser.VerilogModuleClass._port_list)
  return _internal__port_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogModuleClass::_internal_mutable__port_list() {
  return &_impl_._port_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogModuleClass::mutable__port_list() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.VerilogModuleClass._port_list)
  return _internal_mutable__port_list();
}

// repeated int32 _module_stmts = 3;
inline int VerilogModuleClass::_internal__module_stmts_size() const {
  return _impl_._module_stmts_.size();
}
inline int VerilogModuleClass::_module_stmts_size() const {
  return _internal__module_stmts_size();
}
inline void VerilogModuleClass::clear__module_stmts() {
  _impl_._module_stmts_.Clear();
}
inline int32_t VerilogModuleClass::_internal__module_stmts(int index) const {
  return _impl_._module_stmts_.Get(index);
}
inline int32_t VerilogModuleClass::_module_stmts(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogModuleClass._module_stmts)
  return _internal__module_stmts(index);
}
inline void VerilogModuleClass::set__module_stmts(int index, int32_t value) {
  _impl_._module_stmts_.Set(index, value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogModuleClass._module_stmts)
}
inline void VerilogModuleClass::_internal_add__module_stmts(int32_t value) {
  _impl_._module_stmts_.Add(value);
}
inline void VerilogModuleClass::add__module_stmts(int32_t value) {
  _internal_add__module_stmts(value);
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogModuleClass._module_stmts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogModuleClass::_internal__module_stmts() const {
  return _impl_._module_stmts_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogModuleClass::_module_stmts() const {
  // @@protoc_insertion_point(field_list:VerilogParser.VerilogModuleClass._module_stmts)
  return _internal__module_stmts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogModuleClass::_internal_mutable__module_stmts() {
  return &_impl_._module_stmts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogModuleClass::mutable__module_stmts() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.VerilogModuleClass._module_stmts)
  return _internal_mutable__module_stmts();
}

// -------------------------------------------------------------------

// VerilogStmtSyn

// required int32 id = 1;
inline bool VerilogStmtSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogStmtSyn::has_id() const {
  return _internal_has_id();
}
inline void VerilogStmtSyn::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VerilogStmtSyn::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogStmtSyn::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSyn.id)
  return _internal_id();
}
inline void VerilogStmtSyn::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void VerilogStmtSyn::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSyn.id)
}

// required int32 vss_type = 2;
inline bool VerilogStmtSyn::_internal_has_vss_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VerilogStmtSyn::has_vss_type() const {
  return _internal_has_vss_type();
}
inline void VerilogStmtSyn::clear_vss_type() {
  _impl_.vss_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t VerilogStmtSyn::_internal_vss_type() const {
  return _impl_.vss_type_;
}
inline int32_t VerilogStmtSyn::vss_type() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSyn.vss_type)
  return _internal_vss_type();
}
inline void VerilogStmtSyn::_internal_set_vss_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.vss_type_ = value;
}
inline void VerilogStmtSyn::set_vss_type(int32_t value) {
  _internal_set_vss_type(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSyn.vss_type)
}

// required .VerilogParser.VerilogStmtClass parent = 3;
inline bool VerilogStmtSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool VerilogStmtSyn::has_parent() const {
  return _internal_has_parent();
}
inline void VerilogStmtSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::VerilogParser::VerilogStmtClass& VerilogStmtSyn::_internal_parent() const {
  const ::VerilogParser::VerilogStmtClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::VerilogParser::VerilogStmtClass&>(
      ::VerilogParser::_VerilogStmtClass_default_instance_);
}
inline const ::VerilogParser::VerilogStmtClass& VerilogStmtSyn::parent() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSyn.parent)
  return _internal_parent();
}
inline void VerilogStmtSyn::unsafe_arena_set_allocated_parent(
    ::VerilogParser::VerilogStmtClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogStmtSyn.parent)
}
inline ::VerilogParser::VerilogStmtClass* VerilogStmtSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::VerilogParser::VerilogStmtClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VerilogParser::VerilogStmtClass* VerilogStmtSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogStmtSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::VerilogParser::VerilogStmtClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::VerilogParser::VerilogStmtClass* VerilogStmtSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::VerilogParser::VerilogStmtClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::VerilogParser::VerilogStmtClass* VerilogStmtSyn::mutable_parent() {
  ::VerilogParser::VerilogStmtClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogStmtSyn.parent)
  return _msg;
}
inline void VerilogStmtSyn::set_allocated_parent(::VerilogParser::VerilogStmtClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogStmtSyn.parent)
}

// .VerilogParser.VerilogInstClass i = 4;
inline bool VerilogStmtSyn::_internal_has_i() const {
  return vss_case() == kI;
}
inline bool VerilogStmtSyn::has_i() const {
  return _internal_has_i();
}
inline void VerilogStmtSyn::set_has_i() {
  _impl_._oneof_case_[0] = kI;
}
inline void VerilogStmtSyn::clear_i() {
  if (_internal_has_i()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vss_.i_;
    }
    clear_has_vss();
  }
}
inline ::VerilogParser::VerilogInstClass* VerilogStmtSyn::release_i() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogStmtSyn.i)
  if (_internal_has_i()) {
    clear_has_vss();
    ::VerilogParser::VerilogInstClass* temp = _impl_.vss_.i_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vss_.i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogInstClass& VerilogStmtSyn::_internal_i() const {
  return _internal_has_i()
      ? *_impl_.vss_.i_
      : reinterpret_cast< ::VerilogParser::VerilogInstClass&>(::VerilogParser::_VerilogInstClass_default_instance_);
}
inline const ::VerilogParser::VerilogInstClass& VerilogStmtSyn::i() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSyn.i)
  return _internal_i();
}
inline ::VerilogParser::VerilogInstClass* VerilogStmtSyn::unsafe_arena_release_i() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogStmtSyn.i)
  if (_internal_has_i()) {
    clear_has_vss();
    ::VerilogParser::VerilogInstClass* temp = _impl_.vss_.i_;
    _impl_.vss_.i_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogStmtSyn::unsafe_arena_set_allocated_i(::VerilogParser::VerilogInstClass* i) {
  clear_vss();
  if (i) {
    set_has_i();
    _impl_.vss_.i_ = i;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogStmtSyn.i)
}
inline ::VerilogParser::VerilogInstClass* VerilogStmtSyn::_internal_mutable_i() {
  if (!_internal_has_i()) {
    clear_vss();
    set_has_i();
    _impl_.vss_.i_ = CreateMaybeMessage< ::VerilogParser::VerilogInstClass >(GetArenaForAllocation());
  }
  return _impl_.vss_.i_;
}
inline ::VerilogParser::VerilogInstClass* VerilogStmtSyn::mutable_i() {
  ::VerilogParser::VerilogInstClass* _msg = _internal_mutable_i();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogStmtSyn.i)
  return _msg;
}

// .VerilogParser.VerilogDclClass d = 5;
inline bool VerilogStmtSyn::_internal_has_d() const {
  return vss_case() == kD;
}
inline bool VerilogStmtSyn::has_d() const {
  return _internal_has_d();
}
inline void VerilogStmtSyn::set_has_d() {
  _impl_._oneof_case_[0] = kD;
}
inline void VerilogStmtSyn::clear_d() {
  if (_internal_has_d()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vss_.d_;
    }
    clear_has_vss();
  }
}
inline ::VerilogParser::VerilogDclClass* VerilogStmtSyn::release_d() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogStmtSyn.d)
  if (_internal_has_d()) {
    clear_has_vss();
    ::VerilogParser::VerilogDclClass* temp = _impl_.vss_.d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vss_.d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogDclClass& VerilogStmtSyn::_internal_d() const {
  return _internal_has_d()
      ? *_impl_.vss_.d_
      : reinterpret_cast< ::VerilogParser::VerilogDclClass&>(::VerilogParser::_VerilogDclClass_default_instance_);
}
inline const ::VerilogParser::VerilogDclClass& VerilogStmtSyn::d() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSyn.d)
  return _internal_d();
}
inline ::VerilogParser::VerilogDclClass* VerilogStmtSyn::unsafe_arena_release_d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogStmtSyn.d)
  if (_internal_has_d()) {
    clear_has_vss();
    ::VerilogParser::VerilogDclClass* temp = _impl_.vss_.d_;
    _impl_.vss_.d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogStmtSyn::unsafe_arena_set_allocated_d(::VerilogParser::VerilogDclClass* d) {
  clear_vss();
  if (d) {
    set_has_d();
    _impl_.vss_.d_ = d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogStmtSyn.d)
}
inline ::VerilogParser::VerilogDclClass* VerilogStmtSyn::_internal_mutable_d() {
  if (!_internal_has_d()) {
    clear_vss();
    set_has_d();
    _impl_.vss_.d_ = CreateMaybeMessage< ::VerilogParser::VerilogDclClass >(GetArenaForAllocation());
  }
  return _impl_.vss_.d_;
}
inline ::VerilogParser::VerilogDclClass* VerilogStmtSyn::mutable_d() {
  ::VerilogParser::VerilogDclClass* _msg = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogStmtSyn.d)
  return _msg;
}

// .VerilogParser.VerilogDclsClass ds = 6;
inline bool VerilogStmtSyn::_internal_has_ds() const {
  return vss_case() == kDs;
}
inline bool VerilogStmtSyn::has_ds() const {
  return _internal_has_ds();
}
inline void VerilogStmtSyn::set_has_ds() {
  _impl_._oneof_case_[0] = kDs;
}
inline void VerilogStmtSyn::clear_ds() {
  if (_internal_has_ds()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vss_.ds_;
    }
    clear_has_vss();
  }
}
inline ::VerilogParser::VerilogDclsClass* VerilogStmtSyn::release_ds() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogStmtSyn.ds)
  if (_internal_has_ds()) {
    clear_has_vss();
    ::VerilogParser::VerilogDclsClass* temp = _impl_.vss_.ds_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vss_.ds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogDclsClass& VerilogStmtSyn::_internal_ds() const {
  return _internal_has_ds()
      ? *_impl_.vss_.ds_
      : reinterpret_cast< ::VerilogParser::VerilogDclsClass&>(::VerilogParser::_VerilogDclsClass_default_instance_);
}
inline const ::VerilogParser::VerilogDclsClass& VerilogStmtSyn::ds() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSyn.ds)
  return _internal_ds();
}
inline ::VerilogParser::VerilogDclsClass* VerilogStmtSyn::unsafe_arena_release_ds() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogStmtSyn.ds)
  if (_internal_has_ds()) {
    clear_has_vss();
    ::VerilogParser::VerilogDclsClass* temp = _impl_.vss_.ds_;
    _impl_.vss_.ds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogStmtSyn::unsafe_arena_set_allocated_ds(::VerilogParser::VerilogDclsClass* ds) {
  clear_vss();
  if (ds) {
    set_has_ds();
    _impl_.vss_.ds_ = ds;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogStmtSyn.ds)
}
inline ::VerilogParser::VerilogDclsClass* VerilogStmtSyn::_internal_mutable_ds() {
  if (!_internal_has_ds()) {
    clear_vss();
    set_has_ds();
    _impl_.vss_.ds_ = CreateMaybeMessage< ::VerilogParser::VerilogDclsClass >(GetArenaForAllocation());
  }
  return _impl_.vss_.ds_;
}
inline ::VerilogParser::VerilogDclsClass* VerilogStmtSyn::mutable_ds() {
  ::VerilogParser::VerilogDclsClass* _msg = _internal_mutable_ds();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogStmtSyn.ds)
  return _msg;
}

// .VerilogParser.VerilogModuleClass m = 7;
inline bool VerilogStmtSyn::_internal_has_m() const {
  return vss_case() == kM;
}
inline bool VerilogStmtSyn::has_m() const {
  return _internal_has_m();
}
inline void VerilogStmtSyn::set_has_m() {
  _impl_._oneof_case_[0] = kM;
}
inline void VerilogStmtSyn::clear_m() {
  if (_internal_has_m()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.vss_.m_;
    }
    clear_has_vss();
  }
}
inline ::VerilogParser::VerilogModuleClass* VerilogStmtSyn::release_m() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogStmtSyn.m)
  if (_internal_has_m()) {
    clear_has_vss();
    ::VerilogParser::VerilogModuleClass* temp = _impl_.vss_.m_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.vss_.m_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VerilogParser::VerilogModuleClass& VerilogStmtSyn::_internal_m() const {
  return _internal_has_m()
      ? *_impl_.vss_.m_
      : reinterpret_cast< ::VerilogParser::VerilogModuleClass&>(::VerilogParser::_VerilogModuleClass_default_instance_);
}
inline const ::VerilogParser::VerilogModuleClass& VerilogStmtSyn::m() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSyn.m)
  return _internal_m();
}
inline ::VerilogParser::VerilogModuleClass* VerilogStmtSyn::unsafe_arena_release_m() {
  // @@protoc_insertion_point(field_unsafe_arena_release:VerilogParser.VerilogStmtSyn.m)
  if (_internal_has_m()) {
    clear_has_vss();
    ::VerilogParser::VerilogModuleClass* temp = _impl_.vss_.m_;
    _impl_.vss_.m_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VerilogStmtSyn::unsafe_arena_set_allocated_m(::VerilogParser::VerilogModuleClass* m) {
  clear_vss();
  if (m) {
    set_has_m();
    _impl_.vss_.m_ = m;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VerilogParser.VerilogStmtSyn.m)
}
inline ::VerilogParser::VerilogModuleClass* VerilogStmtSyn::_internal_mutable_m() {
  if (!_internal_has_m()) {
    clear_vss();
    set_has_m();
    _impl_.vss_.m_ = CreateMaybeMessage< ::VerilogParser::VerilogModuleClass >(GetArenaForAllocation());
  }
  return _impl_.vss_.m_;
}
inline ::VerilogParser::VerilogModuleClass* VerilogStmtSyn::mutable_m() {
  ::VerilogParser::VerilogModuleClass* _msg = _internal_mutable_m();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogStmtSyn.m)
  return _msg;
}

inline bool VerilogStmtSyn::has_vss() const {
  return vss_case() != VSS_NOT_SET;
}
inline void VerilogStmtSyn::clear_has_vss() {
  _impl_._oneof_case_[0] = VSS_NOT_SET;
}
inline VerilogStmtSyn::VssCase VerilogStmtSyn::vss_case() const {
  return VerilogStmtSyn::VssCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VerilogReaderClass

// required int32 id = 1;
inline bool VerilogReaderClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogReaderClass::has_id() const {
  return _internal_has_id();
}
inline void VerilogReaderClass::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VerilogReaderClass::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogReaderClass::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogReaderClass.id)
  return _internal_id();
}
inline void VerilogReaderClass::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void VerilogReaderClass::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogReaderClass.id)
}

// required int32 meta_data = 2;
inline bool VerilogReaderClass::_internal_has_meta_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VerilogReaderClass::has_meta_data() const {
  return _internal_has_meta_data();
}
inline void VerilogReaderClass::clear_meta_data() {
  _impl_.meta_data_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t VerilogReaderClass::_internal_meta_data() const {
  return _impl_.meta_data_;
}
inline int32_t VerilogReaderClass::meta_data() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogReaderClass.meta_data)
  return _internal_meta_data();
}
inline void VerilogReaderClass::_internal_set_meta_data(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.meta_data_ = value;
}
inline void VerilogReaderClass::set_meta_data(int32_t value) {
  _internal_set_meta_data(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogReaderClass.meta_data)
}

// required string _file_name = 3;
inline bool VerilogReaderClass::_internal_has__file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogReaderClass::has__file_name() const {
  return _internal_has__file_name();
}
inline void VerilogReaderClass::clear__file_name() {
  _impl_._file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VerilogReaderClass::_file_name() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogReaderClass._file_name)
  return _internal__file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerilogReaderClass::set__file_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogReaderClass._file_name)
}
inline std::string* VerilogReaderClass::mutable__file_name() {
  std::string* _s = _internal_mutable__file_name();
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogReaderClass._file_name)
  return _s;
}
inline const std::string& VerilogReaderClass::_internal__file_name() const {
  return _impl_._file_name_.Get();
}
inline void VerilogReaderClass::_internal_set__file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* VerilogReaderClass::_internal_mutable__file_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* VerilogReaderClass::release__file_name() {
  // @@protoc_insertion_point(field_release:VerilogParser.VerilogReaderClass._file_name)
  if (!_internal_has__file_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerilogReaderClass::set_allocated__file_name(std::string* _file_name) {
  if (_file_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._file_name_.SetAllocated(_file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VerilogParser.VerilogReaderClass._file_name)
}

// repeated int32 _verilog_modules = 4;
inline int VerilogReaderClass::_internal__verilog_modules_size() const {
  return _impl_._verilog_modules_.size();
}
inline int VerilogReaderClass::_verilog_modules_size() const {
  return _internal__verilog_modules_size();
}
inline void VerilogReaderClass::clear__verilog_modules() {
  _impl_._verilog_modules_.Clear();
}
inline int32_t VerilogReaderClass::_internal__verilog_modules(int index) const {
  return _impl_._verilog_modules_.Get(index);
}
inline int32_t VerilogReaderClass::_verilog_modules(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogReaderClass._verilog_modules)
  return _internal__verilog_modules(index);
}
inline void VerilogReaderClass::set__verilog_modules(int index, int32_t value) {
  _impl_._verilog_modules_.Set(index, value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogReaderClass._verilog_modules)
}
inline void VerilogReaderClass::_internal_add__verilog_modules(int32_t value) {
  _impl_._verilog_modules_.Add(value);
}
inline void VerilogReaderClass::add__verilog_modules(int32_t value) {
  _internal_add__verilog_modules(value);
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogReaderClass._verilog_modules)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogReaderClass::_internal__verilog_modules() const {
  return _impl_._verilog_modules_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VerilogReaderClass::_verilog_modules() const {
  // @@protoc_insertion_point(field_list:VerilogParser.VerilogReaderClass._verilog_modules)
  return _internal__verilog_modules();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogReaderClass::_internal_mutable__verilog_modules() {
  return &_impl_._verilog_modules_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VerilogReaderClass::mutable__verilog_modules() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.VerilogReaderClass._verilog_modules)
  return _internal_mutable__verilog_modules();
}

// -------------------------------------------------------------------

// VerilogMetaData

// required int32 id = 1;
inline bool VerilogMetaData::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogMetaData::has_id() const {
  return _internal_has_id();
}
inline void VerilogMetaData::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogMetaData::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogMetaData::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogMetaData.id)
  return _internal_id();
}
inline void VerilogMetaData::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void VerilogMetaData::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogMetaData.id)
}

// required int32 verilog_reader_id = 2;
inline bool VerilogMetaData::_internal_has_verilog_reader_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogMetaData::has_verilog_reader_id() const {
  return _internal_has_verilog_reader_id();
}
inline void VerilogMetaData::clear_verilog_reader_id() {
  _impl_.verilog_reader_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VerilogMetaData::_internal_verilog_reader_id() const {
  return _impl_.verilog_reader_id_;
}
inline int32_t VerilogMetaData::verilog_reader_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogMetaData.verilog_reader_id)
  return _internal_verilog_reader_id();
}
inline void VerilogMetaData::_internal_set_verilog_reader_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.verilog_reader_id_ = value;
}
inline void VerilogMetaData::set_verilog_reader_id(int32_t value) {
  _internal_set_verilog_reader_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogMetaData.verilog_reader_id)
}

// -------------------------------------------------------------------

// BatchRequest

// required int32 batch_size = 1;
inline bool BatchRequest::_internal_has_batch_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BatchRequest::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void BatchRequest::clear_batch_size() {
  _impl_.batch_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t BatchRequest::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t BatchRequest::batch_size() const {
  // @@protoc_insertion_point(field_get:VerilogParser.BatchRequest.batch_size)
  return _internal_batch_size();
}
inline void BatchRequest::_internal_set_batch_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.batch_size_ = value;
}
inline void BatchRequest::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:VerilogParser.BatchRequest.batch_size)
}

// repeated int32 idl = 2;
inline int BatchRequest::_internal_idl_size() const {
  return _impl_.idl_.size();
}
inline int BatchRequest::idl_size() const {
  return _internal_idl_size();
}
inline void BatchRequest::clear_idl() {
  _impl_.idl_.Clear();
}
inline int32_t BatchRequest::_internal_idl(int index) const {
  return _impl_.idl_.Get(index);
}
inline int32_t BatchRequest::idl(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.BatchRequest.idl)
  return _internal_idl(index);
}
inline void BatchRequest::set_idl(int index, int32_t value) {
  _impl_.idl_.Set(index, value);
  // @@protoc_insertion_point(field_set:VerilogParser.BatchRequest.idl)
}
inline void BatchRequest::_internal_add_idl(int32_t value) {
  _impl_.idl_.Add(value);
}
inline void BatchRequest::add_idl(int32_t value) {
  _internal_add_idl(value);
  // @@protoc_insertion_point(field_add:VerilogParser.BatchRequest.idl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BatchRequest::_internal_idl() const {
  return _impl_.idl_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BatchRequest::idl() const {
  // @@protoc_insertion_point(field_list:VerilogParser.BatchRequest.idl)
  return _internal_idl();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BatchRequest::_internal_mutable_idl() {
  return &_impl_.idl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BatchRequest::mutable_idl() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.BatchRequest.idl)
  return _internal_mutable_idl();
}

// -------------------------------------------------------------------

// VerilogStmtSynBatch

// required int32 id = 1;
inline bool VerilogStmtSynBatch::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerilogStmtSynBatch::has_id() const {
  return _internal_has_id();
}
inline void VerilogStmtSynBatch::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VerilogStmtSynBatch::_internal_id() const {
  return _impl_.id_;
}
inline int32_t VerilogStmtSynBatch::id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSynBatch.id)
  return _internal_id();
}
inline void VerilogStmtSynBatch::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void VerilogStmtSynBatch::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSynBatch.id)
}

// required int32 syn_id = 2;
inline bool VerilogStmtSynBatch::_internal_has_syn_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerilogStmtSynBatch::has_syn_id() const {
  return _internal_has_syn_id();
}
inline void VerilogStmtSynBatch::clear_syn_id() {
  _impl_.syn_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VerilogStmtSynBatch::_internal_syn_id() const {
  return _impl_.syn_id_;
}
inline int32_t VerilogStmtSynBatch::syn_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSynBatch.syn_id)
  return _internal_syn_id();
}
inline void VerilogStmtSynBatch::_internal_set_syn_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.syn_id_ = value;
}
inline void VerilogStmtSynBatch::set_syn_id(int32_t value) {
  _internal_set_syn_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSynBatch.syn_id)
}

// required int64 start_stmt_id = 3;
inline bool VerilogStmtSynBatch::_internal_has_start_stmt_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VerilogStmtSynBatch::has_start_stmt_id() const {
  return _internal_has_start_stmt_id();
}
inline void VerilogStmtSynBatch::clear_start_stmt_id() {
  _impl_.start_stmt_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t VerilogStmtSynBatch::_internal_start_stmt_id() const {
  return _impl_.start_stmt_id_;
}
inline int64_t VerilogStmtSynBatch::start_stmt_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSynBatch.start_stmt_id)
  return _internal_start_stmt_id();
}
inline void VerilogStmtSynBatch::_internal_set_start_stmt_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_stmt_id_ = value;
}
inline void VerilogStmtSynBatch::set_start_stmt_id(int64_t value) {
  _internal_set_start_stmt_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSynBatch.start_stmt_id)
}

// required int64 end_stmt_id = 4;
inline bool VerilogStmtSynBatch::_internal_has_end_stmt_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VerilogStmtSynBatch::has_end_stmt_id() const {
  return _internal_has_end_stmt_id();
}
inline void VerilogStmtSynBatch::clear_end_stmt_id() {
  _impl_.end_stmt_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t VerilogStmtSynBatch::_internal_end_stmt_id() const {
  return _impl_.end_stmt_id_;
}
inline int64_t VerilogStmtSynBatch::end_stmt_id() const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSynBatch.end_stmt_id)
  return _internal_end_stmt_id();
}
inline void VerilogStmtSynBatch::_internal_set_end_stmt_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.end_stmt_id_ = value;
}
inline void VerilogStmtSynBatch::set_end_stmt_id(int64_t value) {
  _internal_set_end_stmt_id(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSynBatch.end_stmt_id)
}

// repeated bytes vssl = 5;
inline int VerilogStmtSynBatch::_internal_vssl_size() const {
  return _impl_.vssl_.size();
}
inline int VerilogStmtSynBatch::vssl_size() const {
  return _internal_vssl_size();
}
inline void VerilogStmtSynBatch::clear_vssl() {
  _impl_.vssl_.Clear();
}
inline std::string* VerilogStmtSynBatch::add_vssl() {
  std::string* _s = _internal_add_vssl();
  // @@protoc_insertion_point(field_add_mutable:VerilogParser.VerilogStmtSynBatch.vssl)
  return _s;
}
inline const std::string& VerilogStmtSynBatch::_internal_vssl(int index) const {
  return _impl_.vssl_.Get(index);
}
inline const std::string& VerilogStmtSynBatch::vssl(int index) const {
  // @@protoc_insertion_point(field_get:VerilogParser.VerilogStmtSynBatch.vssl)
  return _internal_vssl(index);
}
inline std::string* VerilogStmtSynBatch::mutable_vssl(int index) {
  // @@protoc_insertion_point(field_mutable:VerilogParser.VerilogStmtSynBatch.vssl)
  return _impl_.vssl_.Mutable(index);
}
inline void VerilogStmtSynBatch::set_vssl(int index, const std::string& value) {
  _impl_.vssl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline void VerilogStmtSynBatch::set_vssl(int index, std::string&& value) {
  _impl_.vssl_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline void VerilogStmtSynBatch::set_vssl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vssl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline void VerilogStmtSynBatch::set_vssl(int index, const void* value, size_t size) {
  _impl_.vssl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline std::string* VerilogStmtSynBatch::_internal_add_vssl() {
  return _impl_.vssl_.Add();
}
inline void VerilogStmtSynBatch::add_vssl(const std::string& value) {
  _impl_.vssl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline void VerilogStmtSynBatch::add_vssl(std::string&& value) {
  _impl_.vssl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline void VerilogStmtSynBatch::add_vssl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vssl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline void VerilogStmtSynBatch::add_vssl(const void* value, size_t size) {
  _impl_.vssl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:VerilogParser.VerilogStmtSynBatch.vssl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VerilogStmtSynBatch::vssl() const {
  // @@protoc_insertion_point(field_list:VerilogParser.VerilogStmtSynBatch.vssl)
  return _impl_.vssl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VerilogStmtSynBatch::mutable_vssl() {
  // @@protoc_insertion_point(field_mutable_list:VerilogParser.VerilogStmtSynBatch.vssl)
  return &_impl_.vssl_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace VerilogParser

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::VerilogParser::VerilogDclTypeEnum_DclType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VerilogParser::VerilogDclTypeEnum_DclType>() {
  return ::VerilogParser::VerilogDclTypeEnum_DclType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_VerilogReader_2eproto
