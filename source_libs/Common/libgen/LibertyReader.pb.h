// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LibertyReader.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_LibertyReader_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_LibertyReader_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommonTypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_LibertyReader_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_LibertyReader_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_LibertyReader_2eproto;
namespace Liberty {
class LibertyArcClass;
struct LibertyArcClassDefaultTypeInternal;
extern LibertyArcClassDefaultTypeInternal _LibertyArcClass_default_instance_;
class LibertyArcSetClass;
struct LibertyArcSetClassDefaultTypeInternal;
extern LibertyArcSetClassDefaultTypeInternal _LibertyArcSetClass_default_instance_;
class LibertyAxisClass;
struct LibertyAxisClassDefaultTypeInternal;
extern LibertyAxisClassDefaultTypeInternal _LibertyAxisClass_default_instance_;
class LibertyBuilderClass;
struct LibertyBuilderClassDefaultTypeInternal;
extern LibertyBuilderClassDefaultTypeInternal _LibertyBuilderClass_default_instance_;
class LibertyCCSTableClass;
struct LibertyCCSTableClassDefaultTypeInternal;
extern LibertyCCSTableClassDefaultTypeInternal _LibertyCCSTableClass_default_instance_;
class LibertyCellClass;
struct LibertyCellClassDefaultTypeInternal;
extern LibertyCellClassDefaultTypeInternal _LibertyCellClass_default_instance_;
class LibertyCheckTableModelClass;
struct LibertyCheckTableModelClassDefaultTypeInternal;
extern LibertyCheckTableModelClassDefaultTypeInternal _LibertyCheckTableModelClass_default_instance_;
class LibertyComplexAttrStmtClass;
struct LibertyComplexAttrStmtClassDefaultTypeInternal;
extern LibertyComplexAttrStmtClassDefaultTypeInternal _LibertyComplexAttrStmtClass_default_instance_;
class LibertyCurrentTemplateClass;
struct LibertyCurrentTemplateClassDefaultTypeInternal;
extern LibertyCurrentTemplateClassDefaultTypeInternal _LibertyCurrentTemplateClass_default_instance_;
class LibertyDelayTableModelClass;
struct LibertyDelayTableModelClassDefaultTypeInternal;
extern LibertyDelayTableModelClassDefaultTypeInternal _LibertyDelayTableModelClass_default_instance_;
class LibertyExprClass;
struct LibertyExprClassDefaultTypeInternal;
extern LibertyExprClassDefaultTypeInternal _LibertyExprClass_default_instance_;
class LibertyExprOperatorEnum;
struct LibertyExprOperatorEnumDefaultTypeInternal;
extern LibertyExprOperatorEnumDefaultTypeInternal _LibertyExprOperatorEnum_default_instance_;
class LibertyGroupStmtClass;
struct LibertyGroupStmtClassDefaultTypeInternal;
extern LibertyGroupStmtClassDefaultTypeInternal _LibertyGroupStmtClass_default_instance_;
class LibertyLeakagePowerClass;
struct LibertyLeakagePowerClassDefaultTypeInternal;
extern LibertyLeakagePowerClassDefaultTypeInternal _LibertyLeakagePowerClass_default_instance_;
class LibertyLibraryClass;
struct LibertyLibraryClassDefaultTypeInternal;
extern LibertyLibraryClassDefaultTypeInternal _LibertyLibraryClass_default_instance_;
class LibertyLutTableTemplateClass;
struct LibertyLutTableTemplateClassDefaultTypeInternal;
extern LibertyLutTableTemplateClassDefaultTypeInternal _LibertyLutTableTemplateClass_default_instance_;
class LibertyLutTableTemplateSyn;
struct LibertyLutTableTemplateSynDefaultTypeInternal;
extern LibertyLutTableTemplateSynDefaultTypeInternal _LibertyLutTableTemplateSyn_default_instance_;
class LibertyObjectClass;
struct LibertyObjectClassDefaultTypeInternal;
extern LibertyObjectClassDefaultTypeInternal _LibertyObjectClass_default_instance_;
class LibertyObjectSyn;
struct LibertyObjectSynDefaultTypeInternal;
extern LibertyObjectSynDefaultTypeInternal _LibertyObjectSyn_default_instance_;
class LibertyOwnPgOrWhenTypeEnum;
struct LibertyOwnPgOrWhenTypeEnumDefaultTypeInternal;
extern LibertyOwnPgOrWhenTypeEnumDefaultTypeInternal _LibertyOwnPgOrWhenTypeEnum_default_instance_;
class LibertyOwnPortTypeEnum;
struct LibertyOwnPortTypeEnumDefaultTypeInternal;
extern LibertyOwnPortTypeEnumDefaultTypeInternal _LibertyOwnPortTypeEnum_default_instance_;
class LibertyPortBusClass;
struct LibertyPortBusClassDefaultTypeInternal;
extern LibertyPortBusClassDefaultTypeInternal _LibertyPortBusClass_default_instance_;
class LibertyPortClass;
struct LibertyPortClassDefaultTypeInternal;
extern LibertyPortClassDefaultTypeInternal _LibertyPortClass_default_instance_;
class LibertyPortSyn;
struct LibertyPortSynDefaultTypeInternal;
extern LibertyPortSynDefaultTypeInternal _LibertyPortSyn_default_instance_;
class LibertyPortTypeEnum;
struct LibertyPortTypeEnumDefaultTypeInternal;
extern LibertyPortTypeEnumDefaultTypeInternal _LibertyPortTypeEnum_default_instance_;
class LibertyPowerArcClass;
struct LibertyPowerArcClassDefaultTypeInternal;
extern LibertyPowerArcClassDefaultTypeInternal _LibertyPowerArcClass_default_instance_;
class LibertyPowerArcSetClass;
struct LibertyPowerArcSetClassDefaultTypeInternal;
extern LibertyPowerArcSetClassDefaultTypeInternal _LibertyPowerArcSetClass_default_instance_;
class LibertyPowerTableModelClass;
struct LibertyPowerTableModelClassDefaultTypeInternal;
extern LibertyPowerTableModelClassDefaultTypeInternal _LibertyPowerTableModelClass_default_instance_;
class LibertyReaderClass;
struct LibertyReaderClassDefaultTypeInternal;
extern LibertyReaderClassDefaultTypeInternal _LibertyReaderClass_default_instance_;
class LibertySimpleAttrStmtClass;
struct LibertySimpleAttrStmtClassDefaultTypeInternal;
extern LibertySimpleAttrStmtClassDefaultTypeInternal _LibertySimpleAttrStmtClass_default_instance_;
class LibertyStmtClass;
struct LibertyStmtClassDefaultTypeInternal;
extern LibertyStmtClassDefaultTypeInternal _LibertyStmtClass_default_instance_;
class LibertyStmtSyn;
struct LibertyStmtSynDefaultTypeInternal;
extern LibertyStmtSynDefaultTypeInternal _LibertyStmtSyn_default_instance_;
class LibertyTableClass;
struct LibertyTableClassDefaultTypeInternal;
extern LibertyTableClassDefaultTypeInternal _LibertyTableClass_default_instance_;
class LibertyTableModelSyn;
struct LibertyTableModelSynDefaultTypeInternal;
extern LibertyTableModelSynDefaultTypeInternal _LibertyTableModelSyn_default_instance_;
class LibertyTableSyn;
struct LibertyTableSynDefaultTypeInternal;
extern LibertyTableSynDefaultTypeInternal _LibertyTableSyn_default_instance_;
class LibertyTableTypeEnum;
struct LibertyTableTypeEnumDefaultTypeInternal;
extern LibertyTableTypeEnumDefaultTypeInternal _LibertyTableTypeEnum_default_instance_;
class LibertyTypeClass;
struct LibertyTypeClassDefaultTypeInternal;
extern LibertyTypeClassDefaultTypeInternal _LibertyTypeClass_default_instance_;
class LibertyVectorTableClass;
struct LibertyVectorTableClassDefaultTypeInternal;
extern LibertyVectorTableClassDefaultTypeInternal _LibertyVectorTableClass_default_instance_;
class LibertyWireLoadClass;
struct LibertyWireLoadClassDefaultTypeInternal;
extern LibertyWireLoadClassDefaultTypeInternal _LibertyWireLoadClass_default_instance_;
class LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse;
struct LibertyWireLoadClass_FanoutToLengthEntry_DoNotUseDefaultTypeInternal;
extern LibertyWireLoadClass_FanoutToLengthEntry_DoNotUseDefaultTypeInternal _LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse_default_instance_;
}  // namespace Liberty
PROTOBUF_NAMESPACE_OPEN
template<> ::Liberty::LibertyArcClass* Arena::CreateMaybeMessage<::Liberty::LibertyArcClass>(Arena*);
template<> ::Liberty::LibertyArcSetClass* Arena::CreateMaybeMessage<::Liberty::LibertyArcSetClass>(Arena*);
template<> ::Liberty::LibertyAxisClass* Arena::CreateMaybeMessage<::Liberty::LibertyAxisClass>(Arena*);
template<> ::Liberty::LibertyBuilderClass* Arena::CreateMaybeMessage<::Liberty::LibertyBuilderClass>(Arena*);
template<> ::Liberty::LibertyCCSTableClass* Arena::CreateMaybeMessage<::Liberty::LibertyCCSTableClass>(Arena*);
template<> ::Liberty::LibertyCellClass* Arena::CreateMaybeMessage<::Liberty::LibertyCellClass>(Arena*);
template<> ::Liberty::LibertyCheckTableModelClass* Arena::CreateMaybeMessage<::Liberty::LibertyCheckTableModelClass>(Arena*);
template<> ::Liberty::LibertyComplexAttrStmtClass* Arena::CreateMaybeMessage<::Liberty::LibertyComplexAttrStmtClass>(Arena*);
template<> ::Liberty::LibertyCurrentTemplateClass* Arena::CreateMaybeMessage<::Liberty::LibertyCurrentTemplateClass>(Arena*);
template<> ::Liberty::LibertyDelayTableModelClass* Arena::CreateMaybeMessage<::Liberty::LibertyDelayTableModelClass>(Arena*);
template<> ::Liberty::LibertyExprClass* Arena::CreateMaybeMessage<::Liberty::LibertyExprClass>(Arena*);
template<> ::Liberty::LibertyExprOperatorEnum* Arena::CreateMaybeMessage<::Liberty::LibertyExprOperatorEnum>(Arena*);
template<> ::Liberty::LibertyGroupStmtClass* Arena::CreateMaybeMessage<::Liberty::LibertyGroupStmtClass>(Arena*);
template<> ::Liberty::LibertyLeakagePowerClass* Arena::CreateMaybeMessage<::Liberty::LibertyLeakagePowerClass>(Arena*);
template<> ::Liberty::LibertyLibraryClass* Arena::CreateMaybeMessage<::Liberty::LibertyLibraryClass>(Arena*);
template<> ::Liberty::LibertyLutTableTemplateClass* Arena::CreateMaybeMessage<::Liberty::LibertyLutTableTemplateClass>(Arena*);
template<> ::Liberty::LibertyLutTableTemplateSyn* Arena::CreateMaybeMessage<::Liberty::LibertyLutTableTemplateSyn>(Arena*);
template<> ::Liberty::LibertyObjectClass* Arena::CreateMaybeMessage<::Liberty::LibertyObjectClass>(Arena*);
template<> ::Liberty::LibertyObjectSyn* Arena::CreateMaybeMessage<::Liberty::LibertyObjectSyn>(Arena*);
template<> ::Liberty::LibertyOwnPgOrWhenTypeEnum* Arena::CreateMaybeMessage<::Liberty::LibertyOwnPgOrWhenTypeEnum>(Arena*);
template<> ::Liberty::LibertyOwnPortTypeEnum* Arena::CreateMaybeMessage<::Liberty::LibertyOwnPortTypeEnum>(Arena*);
template<> ::Liberty::LibertyPortBusClass* Arena::CreateMaybeMessage<::Liberty::LibertyPortBusClass>(Arena*);
template<> ::Liberty::LibertyPortClass* Arena::CreateMaybeMessage<::Liberty::LibertyPortClass>(Arena*);
template<> ::Liberty::LibertyPortSyn* Arena::CreateMaybeMessage<::Liberty::LibertyPortSyn>(Arena*);
template<> ::Liberty::LibertyPortTypeEnum* Arena::CreateMaybeMessage<::Liberty::LibertyPortTypeEnum>(Arena*);
template<> ::Liberty::LibertyPowerArcClass* Arena::CreateMaybeMessage<::Liberty::LibertyPowerArcClass>(Arena*);
template<> ::Liberty::LibertyPowerArcSetClass* Arena::CreateMaybeMessage<::Liberty::LibertyPowerArcSetClass>(Arena*);
template<> ::Liberty::LibertyPowerTableModelClass* Arena::CreateMaybeMessage<::Liberty::LibertyPowerTableModelClass>(Arena*);
template<> ::Liberty::LibertyReaderClass* Arena::CreateMaybeMessage<::Liberty::LibertyReaderClass>(Arena*);
template<> ::Liberty::LibertySimpleAttrStmtClass* Arena::CreateMaybeMessage<::Liberty::LibertySimpleAttrStmtClass>(Arena*);
template<> ::Liberty::LibertyStmtClass* Arena::CreateMaybeMessage<::Liberty::LibertyStmtClass>(Arena*);
template<> ::Liberty::LibertyStmtSyn* Arena::CreateMaybeMessage<::Liberty::LibertyStmtSyn>(Arena*);
template<> ::Liberty::LibertyTableClass* Arena::CreateMaybeMessage<::Liberty::LibertyTableClass>(Arena*);
template<> ::Liberty::LibertyTableModelSyn* Arena::CreateMaybeMessage<::Liberty::LibertyTableModelSyn>(Arena*);
template<> ::Liberty::LibertyTableSyn* Arena::CreateMaybeMessage<::Liberty::LibertyTableSyn>(Arena*);
template<> ::Liberty::LibertyTableTypeEnum* Arena::CreateMaybeMessage<::Liberty::LibertyTableTypeEnum>(Arena*);
template<> ::Liberty::LibertyTypeClass* Arena::CreateMaybeMessage<::Liberty::LibertyTypeClass>(Arena*);
template<> ::Liberty::LibertyVectorTableClass* Arena::CreateMaybeMessage<::Liberty::LibertyVectorTableClass>(Arena*);
template<> ::Liberty::LibertyWireLoadClass* Arena::CreateMaybeMessage<::Liberty::LibertyWireLoadClass>(Arena*);
template<> ::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse* Arena::CreateMaybeMessage<::Liberty::LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Liberty {

enum LibertyExprOperatorEnum_Operator : int {
  LibertyExprOperatorEnum_Operator_kBuffer = 1,
  LibertyExprOperatorEnum_Operator_kNot = 2,
  LibertyExprOperatorEnum_Operator_kOr = 3,
  LibertyExprOperatorEnum_Operator_kAnd = 4,
  LibertyExprOperatorEnum_Operator_kXor = 5,
  LibertyExprOperatorEnum_Operator_kOne = 6,
  LibertyExprOperatorEnum_Operator_kZero = 7,
  LibertyExprOperatorEnum_Operator_kPlus = 8,
  LibertyExprOperatorEnum_Operator_kMult = 9
};
bool LibertyExprOperatorEnum_Operator_IsValid(int value);
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum_Operator_Operator_MIN = LibertyExprOperatorEnum_Operator_kBuffer;
constexpr LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum_Operator_Operator_MAX = LibertyExprOperatorEnum_Operator_kMult;
constexpr int LibertyExprOperatorEnum_Operator_Operator_ARRAYSIZE = LibertyExprOperatorEnum_Operator_Operator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyExprOperatorEnum_Operator_descriptor();
template<typename T>
inline const std::string& LibertyExprOperatorEnum_Operator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LibertyExprOperatorEnum_Operator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LibertyExprOperatorEnum_Operator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LibertyExprOperatorEnum_Operator_descriptor(), enum_t_value);
}
inline bool LibertyExprOperatorEnum_Operator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LibertyExprOperatorEnum_Operator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LibertyExprOperatorEnum_Operator>(
    LibertyExprOperatorEnum_Operator_descriptor(), name, value);
}
enum LibertyTableTypeEnum_TableType : int {
  LibertyTableTypeEnum_TableType_kCellRise = 0,
  LibertyTableTypeEnum_TableType_kCellFall = 1,
  LibertyTableTypeEnum_TableType_kRiseTransition = 2,
  LibertyTableTypeEnum_TableType_kFallTransition = 3,
  LibertyTableTypeEnum_TableType_kRiseConstrain = 4,
  LibertyTableTypeEnum_TableType_kFallConstrain = 5,
  LibertyTableTypeEnum_TableType_kRiseCurrent = 6,
  LibertyTableTypeEnum_TableType_kFallCurrent = 7,
  LibertyTableTypeEnum_TableType_kRisePower = 8,
  LibertyTableTypeEnum_TableType_kFallPower = 9
};
bool LibertyTableTypeEnum_TableType_IsValid(int value);
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum_TableType_TableType_MIN = LibertyTableTypeEnum_TableType_kCellRise;
constexpr LibertyTableTypeEnum_TableType LibertyTableTypeEnum_TableType_TableType_MAX = LibertyTableTypeEnum_TableType_kFallPower;
constexpr int LibertyTableTypeEnum_TableType_TableType_ARRAYSIZE = LibertyTableTypeEnum_TableType_TableType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyTableTypeEnum_TableType_descriptor();
template<typename T>
inline const std::string& LibertyTableTypeEnum_TableType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LibertyTableTypeEnum_TableType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LibertyTableTypeEnum_TableType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LibertyTableTypeEnum_TableType_descriptor(), enum_t_value);
}
inline bool LibertyTableTypeEnum_TableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LibertyTableTypeEnum_TableType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LibertyTableTypeEnum_TableType>(
    LibertyTableTypeEnum_TableType_descriptor(), name, value);
}
enum LibertyPortTypeEnum_PortType : int {
  LibertyPortTypeEnum_PortType_kInput = 1,
  LibertyPortTypeEnum_PortType_kOutput = 2,
  LibertyPortTypeEnum_PortType_kInOut = 3
};
bool LibertyPortTypeEnum_PortType_IsValid(int value);
constexpr LibertyPortTypeEnum_PortType LibertyPortTypeEnum_PortType_PortType_MIN = LibertyPortTypeEnum_PortType_kInput;
constexpr LibertyPortTypeEnum_PortType LibertyPortTypeEnum_PortType_PortType_MAX = LibertyPortTypeEnum_PortType_kInOut;
constexpr int LibertyPortTypeEnum_PortType_PortType_ARRAYSIZE = LibertyPortTypeEnum_PortType_PortType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyPortTypeEnum_PortType_descriptor();
template<typename T>
inline const std::string& LibertyPortTypeEnum_PortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LibertyPortTypeEnum_PortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LibertyPortTypeEnum_PortType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LibertyPortTypeEnum_PortType_descriptor(), enum_t_value);
}
inline bool LibertyPortTypeEnum_PortType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LibertyPortTypeEnum_PortType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LibertyPortTypeEnum_PortType>(
    LibertyPortTypeEnum_PortType_descriptor(), name, value);
}
enum LibertyOwnPortTypeEnum_LibertyOwnPortType : int {
  LibertyOwnPortTypeEnum_LibertyOwnPortType_kTimingArc = 1,
  LibertyOwnPortTypeEnum_LibertyOwnPortType_kPowerArc = 2
};
bool LibertyOwnPortTypeEnum_LibertyOwnPortType_IsValid(int value);
constexpr LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum_LibertyOwnPortType_LibertyOwnPortType_MIN = LibertyOwnPortTypeEnum_LibertyOwnPortType_kTimingArc;
constexpr LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum_LibertyOwnPortType_LibertyOwnPortType_MAX = LibertyOwnPortTypeEnum_LibertyOwnPortType_kPowerArc;
constexpr int LibertyOwnPortTypeEnum_LibertyOwnPortType_LibertyOwnPortType_ARRAYSIZE = LibertyOwnPortTypeEnum_LibertyOwnPortType_LibertyOwnPortType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyOwnPortTypeEnum_LibertyOwnPortType_descriptor();
template<typename T>
inline const std::string& LibertyOwnPortTypeEnum_LibertyOwnPortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LibertyOwnPortTypeEnum_LibertyOwnPortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LibertyOwnPortTypeEnum_LibertyOwnPortType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LibertyOwnPortTypeEnum_LibertyOwnPortType_descriptor(), enum_t_value);
}
inline bool LibertyOwnPortTypeEnum_LibertyOwnPortType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LibertyOwnPortTypeEnum_LibertyOwnPortType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LibertyOwnPortTypeEnum_LibertyOwnPortType>(
    LibertyOwnPortTypeEnum_LibertyOwnPortType_descriptor(), name, value);
}
enum LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType : int {
  LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_kLibertyLeakagePower = 1,
  LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_kPowerArc = 2
};
bool LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_IsValid(int value);
constexpr LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_LibertyOwnPgOrWhenType_MIN = LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_kLibertyLeakagePower;
constexpr LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_LibertyOwnPgOrWhenType_MAX = LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_kPowerArc;
constexpr int LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_LibertyOwnPgOrWhenType_ARRAYSIZE = LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_LibertyOwnPgOrWhenType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_descriptor();
template<typename T>
inline const std::string& LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_descriptor(), enum_t_value);
}
inline bool LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType>(
    LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_descriptor(), name, value);
}
// ===================================================================

class LibertyExprOperatorEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyExprOperatorEnum) */ {
 public:
  inline LibertyExprOperatorEnum() : LibertyExprOperatorEnum(nullptr) {}
  ~LibertyExprOperatorEnum() override;
  explicit PROTOBUF_CONSTEXPR LibertyExprOperatorEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyExprOperatorEnum(const LibertyExprOperatorEnum& from);
  LibertyExprOperatorEnum(LibertyExprOperatorEnum&& from) noexcept
    : LibertyExprOperatorEnum() {
    *this = ::std::move(from);
  }

  inline LibertyExprOperatorEnum& operator=(const LibertyExprOperatorEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyExprOperatorEnum& operator=(LibertyExprOperatorEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyExprOperatorEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyExprOperatorEnum* internal_default_instance() {
    return reinterpret_cast<const LibertyExprOperatorEnum*>(
               &_LibertyExprOperatorEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LibertyExprOperatorEnum& a, LibertyExprOperatorEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyExprOperatorEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyExprOperatorEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyExprOperatorEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyExprOperatorEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyExprOperatorEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyExprOperatorEnum& from) {
    LibertyExprOperatorEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyExprOperatorEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyExprOperatorEnum";
  }
  protected:
  explicit LibertyExprOperatorEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LibertyExprOperatorEnum_Operator Operator;
  static constexpr Operator kBuffer =
    LibertyExprOperatorEnum_Operator_kBuffer;
  static constexpr Operator kNot =
    LibertyExprOperatorEnum_Operator_kNot;
  static constexpr Operator kOr =
    LibertyExprOperatorEnum_Operator_kOr;
  static constexpr Operator kAnd =
    LibertyExprOperatorEnum_Operator_kAnd;
  static constexpr Operator kXor =
    LibertyExprOperatorEnum_Operator_kXor;
  static constexpr Operator kOne =
    LibertyExprOperatorEnum_Operator_kOne;
  static constexpr Operator kZero =
    LibertyExprOperatorEnum_Operator_kZero;
  static constexpr Operator kPlus =
    LibertyExprOperatorEnum_Operator_kPlus;
  static constexpr Operator kMult =
    LibertyExprOperatorEnum_Operator_kMult;
  static inline bool Operator_IsValid(int value) {
    return LibertyExprOperatorEnum_Operator_IsValid(value);
  }
  static constexpr Operator Operator_MIN =
    LibertyExprOperatorEnum_Operator_Operator_MIN;
  static constexpr Operator Operator_MAX =
    LibertyExprOperatorEnum_Operator_Operator_MAX;
  static constexpr int Operator_ARRAYSIZE =
    LibertyExprOperatorEnum_Operator_Operator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operator_descriptor() {
    return LibertyExprOperatorEnum_Operator_descriptor();
  }
  template<typename T>
  static inline const std::string& Operator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operator_Name.");
    return LibertyExprOperatorEnum_Operator_Name(enum_t_value);
  }
  static inline bool Operator_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operator* value) {
    return LibertyExprOperatorEnum_Operator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOFieldNumber = 1,
  };
  // required .Liberty.LibertyExprOperatorEnum.Operator o = 1;
  bool has_o() const;
  private:
  bool _internal_has_o() const;
  public:
  void clear_o();
  ::Liberty::LibertyExprOperatorEnum_Operator o() const;
  void set_o(::Liberty::LibertyExprOperatorEnum_Operator value);
  private:
  ::Liberty::LibertyExprOperatorEnum_Operator _internal_o() const;
  void _internal_set_o(::Liberty::LibertyExprOperatorEnum_Operator value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyExprOperatorEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int o_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyExprClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyExprClass) */ {
 public:
  inline LibertyExprClass() : LibertyExprClass(nullptr) {}
  ~LibertyExprClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyExprClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyExprClass(const LibertyExprClass& from);
  LibertyExprClass(LibertyExprClass&& from) noexcept
    : LibertyExprClass() {
    *this = ::std::move(from);
  }

  inline LibertyExprClass& operator=(const LibertyExprClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyExprClass& operator=(LibertyExprClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyExprClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyExprClass* internal_default_instance() {
    return reinterpret_cast<const LibertyExprClass*>(
               &_LibertyExprClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LibertyExprClass& a, LibertyExprClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyExprClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyExprClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyExprClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyExprClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyExprClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyExprClass& from) {
    LibertyExprClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyExprClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyExprClass";
  }
  protected:
  explicit LibertyExprClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 5,
    kOpFieldNumber = 2,
    kIdFieldNumber = 1,
    kLeftFieldNumber = 3,
    kRightFieldNumber = 4,
  };
  // optional bytes _port = 5;
  bool has__port() const;
  private:
  bool _internal_has__port() const;
  public:
  void clear__port();
  const std::string& _port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__port(ArgT0&& arg0, ArgT... args);
  std::string* mutable__port();
  PROTOBUF_NODISCARD std::string* release__port();
  void set_allocated__port(std::string* _port);
  private:
  const std::string& _internal__port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__port(const std::string& value);
  std::string* _internal_mutable__port();
  public:

  // required .Liberty.LibertyExprOperatorEnum _op = 2;
  bool has__op() const;
  private:
  bool _internal_has__op() const;
  public:
  void clear__op();
  const ::Liberty::LibertyExprOperatorEnum& _op() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyExprOperatorEnum* release__op();
  ::Liberty::LibertyExprOperatorEnum* mutable__op();
  void set_allocated__op(::Liberty::LibertyExprOperatorEnum* _op);
  private:
  const ::Liberty::LibertyExprOperatorEnum& _internal__op() const;
  ::Liberty::LibertyExprOperatorEnum* _internal_mutable__op();
  public:
  void unsafe_arena_set_allocated__op(
      ::Liberty::LibertyExprOperatorEnum* _op);
  ::Liberty::LibertyExprOperatorEnum* unsafe_arena_release__op();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional uint64 _left = 3;
  bool has__left() const;
  private:
  bool _internal_has__left() const;
  public:
  void clear__left();
  uint64_t _left() const;
  void set__left(uint64_t value);
  private:
  uint64_t _internal__left() const;
  void _internal_set__left(uint64_t value);
  public:

  // optional uint64 _right = 4;
  bool has__right() const;
  private:
  bool _internal_has__right() const;
  public:
  void clear__right();
  uint64_t _right() const;
  void set__right(uint64_t value);
  private:
  uint64_t _internal__right() const;
  void _internal_set__right(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyExprClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _port_;
    ::Liberty::LibertyExprOperatorEnum* _op_;
    uint64_t id_;
    uint64_t _left_;
    uint64_t _right_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyStmtClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyStmtClass) */ {
 public:
  inline LibertyStmtClass() : LibertyStmtClass(nullptr) {}
  ~LibertyStmtClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyStmtClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyStmtClass(const LibertyStmtClass& from);
  LibertyStmtClass(LibertyStmtClass&& from) noexcept
    : LibertyStmtClass() {
    *this = ::std::move(from);
  }

  inline LibertyStmtClass& operator=(const LibertyStmtClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyStmtClass& operator=(LibertyStmtClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyStmtClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyStmtClass* internal_default_instance() {
    return reinterpret_cast<const LibertyStmtClass*>(
               &_LibertyStmtClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LibertyStmtClass& a, LibertyStmtClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyStmtClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyStmtClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyStmtClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyStmtClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyStmtClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyStmtClass& from) {
    LibertyStmtClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyStmtClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyStmtClass";
  }
  protected:
  explicit LibertyStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kLineNoFieldNumber = 2,
  };
  // required string _file_name = 1;
  bool has__file_name() const;
  private:
  bool _internal_has__file_name() const;
  public:
  void clear__file_name();
  const std::string& _file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__file_name();
  PROTOBUF_NODISCARD std::string* release__file_name();
  void set_allocated__file_name(std::string* _file_name);
  private:
  const std::string& _internal__file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__file_name(const std::string& value);
  std::string* _internal_mutable__file_name();
  public:

  // required uint32 _line_no = 2;
  bool has__line_no() const;
  private:
  bool _internal_has__line_no() const;
  public:
  void clear__line_no();
  uint32_t _line_no() const;
  void set__line_no(uint32_t value);
  private:
  uint32_t _internal__line_no() const;
  void _internal_set__line_no(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyStmtClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _file_name_;
    uint32_t _line_no_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertySimpleAttrStmtClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertySimpleAttrStmtClass) */ {
 public:
  inline LibertySimpleAttrStmtClass() : LibertySimpleAttrStmtClass(nullptr) {}
  ~LibertySimpleAttrStmtClass() override;
  explicit PROTOBUF_CONSTEXPR LibertySimpleAttrStmtClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertySimpleAttrStmtClass(const LibertySimpleAttrStmtClass& from);
  LibertySimpleAttrStmtClass(LibertySimpleAttrStmtClass&& from) noexcept
    : LibertySimpleAttrStmtClass() {
    *this = ::std::move(from);
  }

  inline LibertySimpleAttrStmtClass& operator=(const LibertySimpleAttrStmtClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertySimpleAttrStmtClass& operator=(LibertySimpleAttrStmtClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertySimpleAttrStmtClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertySimpleAttrStmtClass* internal_default_instance() {
    return reinterpret_cast<const LibertySimpleAttrStmtClass*>(
               &_LibertySimpleAttrStmtClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LibertySimpleAttrStmtClass& a, LibertySimpleAttrStmtClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertySimpleAttrStmtClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertySimpleAttrStmtClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertySimpleAttrStmtClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertySimpleAttrStmtClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertySimpleAttrStmtClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertySimpleAttrStmtClass& from) {
    LibertySimpleAttrStmtClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertySimpleAttrStmtClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertySimpleAttrStmtClass";
  }
  protected:
  explicit LibertySimpleAttrStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttriNameFieldNumber = 1,
    kAttriValueFieldNumber = 3,
    kLavsTypeFieldNumber = 2,
  };
  // required string _attri_name = 1;
  bool has__attri_name() const;
  private:
  bool _internal_has__attri_name() const;
  public:
  void clear__attri_name();
  const std::string& _attri_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__attri_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__attri_name();
  PROTOBUF_NODISCARD std::string* release__attri_name();
  void set_allocated__attri_name(std::string* _attri_name);
  private:
  const std::string& _internal__attri_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__attri_name(const std::string& value);
  std::string* _internal_mutable__attri_name();
  public:

  // required .Common.Types.DoubleOrStr _attri_value = 3;
  bool has__attri_value() const;
  private:
  bool _internal_has__attri_value() const;
  public:
  void clear__attri_value();
  const ::Common::Types::DoubleOrStr& _attri_value() const;
  PROTOBUF_NODISCARD ::Common::Types::DoubleOrStr* release__attri_value();
  ::Common::Types::DoubleOrStr* mutable__attri_value();
  void set_allocated__attri_value(::Common::Types::DoubleOrStr* _attri_value);
  private:
  const ::Common::Types::DoubleOrStr& _internal__attri_value() const;
  ::Common::Types::DoubleOrStr* _internal_mutable__attri_value();
  public:
  void unsafe_arena_set_allocated__attri_value(
      ::Common::Types::DoubleOrStr* _attri_value);
  ::Common::Types::DoubleOrStr* unsafe_arena_release__attri_value();

  // required uint32 lavs_type = 2;
  bool has_lavs_type() const;
  private:
  bool _internal_has_lavs_type() const;
  public:
  void clear_lavs_type();
  uint32_t lavs_type() const;
  void set_lavs_type(uint32_t value);
  private:
  uint32_t _internal_lavs_type() const;
  void _internal_set_lavs_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertySimpleAttrStmtClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _attri_name_;
    ::Common::Types::DoubleOrStr* _attri_value_;
    uint32_t lavs_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyComplexAttrStmtClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyComplexAttrStmtClass) */ {
 public:
  inline LibertyComplexAttrStmtClass() : LibertyComplexAttrStmtClass(nullptr) {}
  ~LibertyComplexAttrStmtClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyComplexAttrStmtClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyComplexAttrStmtClass(const LibertyComplexAttrStmtClass& from);
  LibertyComplexAttrStmtClass(LibertyComplexAttrStmtClass&& from) noexcept
    : LibertyComplexAttrStmtClass() {
    *this = ::std::move(from);
  }

  inline LibertyComplexAttrStmtClass& operator=(const LibertyComplexAttrStmtClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyComplexAttrStmtClass& operator=(LibertyComplexAttrStmtClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyComplexAttrStmtClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyComplexAttrStmtClass* internal_default_instance() {
    return reinterpret_cast<const LibertyComplexAttrStmtClass*>(
               &_LibertyComplexAttrStmtClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LibertyComplexAttrStmtClass& a, LibertyComplexAttrStmtClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyComplexAttrStmtClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyComplexAttrStmtClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyComplexAttrStmtClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyComplexAttrStmtClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyComplexAttrStmtClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyComplexAttrStmtClass& from) {
    LibertyComplexAttrStmtClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyComplexAttrStmtClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyComplexAttrStmtClass";
  }
  protected:
  explicit LibertyComplexAttrStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLavsTypeFieldNumber = 2,
    kAttriValuesFieldNumber = 3,
    kAttriNameFieldNumber = 1,
  };
  // repeated uint32 lavs_type = 2;
  int lavs_type_size() const;
  private:
  int _internal_lavs_type_size() const;
  public:
  void clear_lavs_type();
  private:
  uint32_t _internal_lavs_type(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_lavs_type() const;
  void _internal_add_lavs_type(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_lavs_type();
  public:
  uint32_t lavs_type(int index) const;
  void set_lavs_type(int index, uint32_t value);
  void add_lavs_type(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      lavs_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_lavs_type();

  // repeated .Common.Types.DoubleOrStr _attri_values = 3;
  int _attri_values_size() const;
  private:
  int _internal__attri_values_size() const;
  public:
  void clear__attri_values();
  ::Common::Types::DoubleOrStr* mutable__attri_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
      mutable__attri_values();
  private:
  const ::Common::Types::DoubleOrStr& _internal__attri_values(int index) const;
  ::Common::Types::DoubleOrStr* _internal_add__attri_values();
  public:
  const ::Common::Types::DoubleOrStr& _attri_values(int index) const;
  ::Common::Types::DoubleOrStr* add__attri_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
      _attri_values() const;

  // required string _attri_name = 1;
  bool has__attri_name() const;
  private:
  bool _internal_has__attri_name() const;
  public:
  void clear__attri_name();
  const std::string& _attri_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__attri_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__attri_name();
  PROTOBUF_NODISCARD std::string* release__attri_name();
  void set_allocated__attri_name(std::string* _attri_name);
  private:
  const std::string& _internal__attri_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__attri_name(const std::string& value);
  std::string* _internal_mutable__attri_name();
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyComplexAttrStmtClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > lavs_type_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr > _attri_values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _attri_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyGroupStmtClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyGroupStmtClass) */ {
 public:
  inline LibertyGroupStmtClass() : LibertyGroupStmtClass(nullptr) {}
  ~LibertyGroupStmtClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyGroupStmtClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyGroupStmtClass(const LibertyGroupStmtClass& from);
  LibertyGroupStmtClass(LibertyGroupStmtClass&& from) noexcept
    : LibertyGroupStmtClass() {
    *this = ::std::move(from);
  }

  inline LibertyGroupStmtClass& operator=(const LibertyGroupStmtClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyGroupStmtClass& operator=(LibertyGroupStmtClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyGroupStmtClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyGroupStmtClass* internal_default_instance() {
    return reinterpret_cast<const LibertyGroupStmtClass*>(
               &_LibertyGroupStmtClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LibertyGroupStmtClass& a, LibertyGroupStmtClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyGroupStmtClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyGroupStmtClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyGroupStmtClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyGroupStmtClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyGroupStmtClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyGroupStmtClass& from) {
    LibertyGroupStmtClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyGroupStmtClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyGroupStmtClass";
  }
  protected:
  explicit LibertyGroupStmtClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLavsTypeFieldNumber = 2,
    kAttriValuesFieldNumber = 3,
    kStmtsFieldNumber = 5,
    kGroupNameFieldNumber = 1,
  };
  // repeated uint32 lavs_type = 2;
  int lavs_type_size() const;
  private:
  int _internal_lavs_type_size() const;
  public:
  void clear_lavs_type();
  private:
  uint32_t _internal_lavs_type(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_lavs_type() const;
  void _internal_add_lavs_type(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_lavs_type();
  public:
  uint32_t lavs_type(int index) const;
  void set_lavs_type(int index, uint32_t value);
  void add_lavs_type(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      lavs_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_lavs_type();

  // repeated .Common.Types.DoubleOrStr _attri_values = 3;
  int _attri_values_size() const;
  private:
  int _internal__attri_values_size() const;
  public:
  void clear__attri_values();
  ::Common::Types::DoubleOrStr* mutable__attri_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
      mutable__attri_values();
  private:
  const ::Common::Types::DoubleOrStr& _internal__attri_values(int index) const;
  ::Common::Types::DoubleOrStr* _internal_add__attri_values();
  public:
  const ::Common::Types::DoubleOrStr& _attri_values(int index) const;
  ::Common::Types::DoubleOrStr* add__attri_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
      _attri_values() const;

  // repeated uint64 _stmts = 5;
  int _stmts_size() const;
  private:
  int _internal__stmts_size() const;
  public:
  void clear__stmts();
  private:
  uint64_t _internal__stmts(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__stmts() const;
  void _internal_add__stmts(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__stmts();
  public:
  uint64_t _stmts(int index) const;
  void set__stmts(int index, uint64_t value);
  void add__stmts(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _stmts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__stmts();

  // required string _group_name = 1;
  bool has__group_name() const;
  private:
  bool _internal_has__group_name() const;
  public:
  void clear__group_name();
  const std::string& _group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__group_name();
  PROTOBUF_NODISCARD std::string* release__group_name();
  void set_allocated__group_name(std::string* _group_name);
  private:
  const std::string& _internal__group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__group_name(const std::string& value);
  std::string* _internal_mutable__group_name();
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyGroupStmtClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > lavs_type_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr > _attri_values_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _stmts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _group_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyStmtSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyStmtSyn) */ {
 public:
  inline LibertyStmtSyn() : LibertyStmtSyn(nullptr) {}
  ~LibertyStmtSyn() override;
  explicit PROTOBUF_CONSTEXPR LibertyStmtSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyStmtSyn(const LibertyStmtSyn& from);
  LibertyStmtSyn(LibertyStmtSyn&& from) noexcept
    : LibertyStmtSyn() {
    *this = ::std::move(from);
  }

  inline LibertyStmtSyn& operator=(const LibertyStmtSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyStmtSyn& operator=(LibertyStmtSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyStmtSyn& default_instance() {
    return *internal_default_instance();
  }
  enum LssCase {
    kLsasc = 4,
    kLcasc = 5,
    kLgsc = 6,
    LSS_NOT_SET = 0,
  };

  static inline const LibertyStmtSyn* internal_default_instance() {
    return reinterpret_cast<const LibertyStmtSyn*>(
               &_LibertyStmtSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LibertyStmtSyn& a, LibertyStmtSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyStmtSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyStmtSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyStmtSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyStmtSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyStmtSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyStmtSyn& from) {
    LibertyStmtSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyStmtSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyStmtSyn";
  }
  protected:
  explicit LibertyStmtSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kLssTypeFieldNumber = 2,
    kLsascFieldNumber = 4,
    kLcascFieldNumber = 5,
    kLgscFieldNumber = 6,
  };
  // required .Liberty.LibertyStmtClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Liberty::LibertyStmtClass& parent() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyStmtClass* release_parent();
  ::Liberty::LibertyStmtClass* mutable_parent();
  void set_allocated_parent(::Liberty::LibertyStmtClass* parent);
  private:
  const ::Liberty::LibertyStmtClass& _internal_parent() const;
  ::Liberty::LibertyStmtClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Liberty::LibertyStmtClass* parent);
  ::Liberty::LibertyStmtClass* unsafe_arena_release_parent();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required int32 lss_type = 2;
  bool has_lss_type() const;
  private:
  bool _internal_has_lss_type() const;
  public:
  void clear_lss_type();
  int32_t lss_type() const;
  void set_lss_type(int32_t value);
  private:
  int32_t _internal_lss_type() const;
  void _internal_set_lss_type(int32_t value);
  public:

  // .Liberty.LibertySimpleAttrStmtClass lsasc = 4;
  bool has_lsasc() const;
  private:
  bool _internal_has_lsasc() const;
  public:
  void clear_lsasc();
  const ::Liberty::LibertySimpleAttrStmtClass& lsasc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertySimpleAttrStmtClass* release_lsasc();
  ::Liberty::LibertySimpleAttrStmtClass* mutable_lsasc();
  void set_allocated_lsasc(::Liberty::LibertySimpleAttrStmtClass* lsasc);
  private:
  const ::Liberty::LibertySimpleAttrStmtClass& _internal_lsasc() const;
  ::Liberty::LibertySimpleAttrStmtClass* _internal_mutable_lsasc();
  public:
  void unsafe_arena_set_allocated_lsasc(
      ::Liberty::LibertySimpleAttrStmtClass* lsasc);
  ::Liberty::LibertySimpleAttrStmtClass* unsafe_arena_release_lsasc();

  // .Liberty.LibertyComplexAttrStmtClass lcasc = 5;
  bool has_lcasc() const;
  private:
  bool _internal_has_lcasc() const;
  public:
  void clear_lcasc();
  const ::Liberty::LibertyComplexAttrStmtClass& lcasc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyComplexAttrStmtClass* release_lcasc();
  ::Liberty::LibertyComplexAttrStmtClass* mutable_lcasc();
  void set_allocated_lcasc(::Liberty::LibertyComplexAttrStmtClass* lcasc);
  private:
  const ::Liberty::LibertyComplexAttrStmtClass& _internal_lcasc() const;
  ::Liberty::LibertyComplexAttrStmtClass* _internal_mutable_lcasc();
  public:
  void unsafe_arena_set_allocated_lcasc(
      ::Liberty::LibertyComplexAttrStmtClass* lcasc);
  ::Liberty::LibertyComplexAttrStmtClass* unsafe_arena_release_lcasc();

  // .Liberty.LibertyGroupStmtClass lgsc = 6;
  bool has_lgsc() const;
  private:
  bool _internal_has_lgsc() const;
  public:
  void clear_lgsc();
  const ::Liberty::LibertyGroupStmtClass& lgsc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyGroupStmtClass* release_lgsc();
  ::Liberty::LibertyGroupStmtClass* mutable_lgsc();
  void set_allocated_lgsc(::Liberty::LibertyGroupStmtClass* lgsc);
  private:
  const ::Liberty::LibertyGroupStmtClass& _internal_lgsc() const;
  ::Liberty::LibertyGroupStmtClass* _internal_mutable_lgsc();
  public:
  void unsafe_arena_set_allocated_lgsc(
      ::Liberty::LibertyGroupStmtClass* lgsc);
  ::Liberty::LibertyGroupStmtClass* unsafe_arena_release_lgsc();

  void clear_lss();
  LssCase lss_case() const;
  // @@protoc_insertion_point(class_scope:Liberty.LibertyStmtSyn)
 private:
  class _Internal;
  void set_has_lsasc();
  void set_has_lcasc();
  void set_has_lgsc();

  inline bool has_lss() const;
  inline void clear_has_lss();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Liberty::LibertyStmtClass* parent_;
    uint64_t id_;
    int32_t lss_type_;
    union LssUnion {
      constexpr LssUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Liberty::LibertySimpleAttrStmtClass* lsasc_;
      ::Liberty::LibertyComplexAttrStmtClass* lcasc_;
      ::Liberty::LibertyGroupStmtClass* lgsc_;
    } lss_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyObjectClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyObjectClass) */ {
 public:
  inline LibertyObjectClass() : LibertyObjectClass(nullptr) {}
  ~LibertyObjectClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyObjectClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyObjectClass(const LibertyObjectClass& from);
  LibertyObjectClass(LibertyObjectClass&& from) noexcept
    : LibertyObjectClass() {
    *this = ::std::move(from);
  }

  inline LibertyObjectClass& operator=(const LibertyObjectClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyObjectClass& operator=(LibertyObjectClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyObjectClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyObjectClass* internal_default_instance() {
    return reinterpret_cast<const LibertyObjectClass*>(
               &_LibertyObjectClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LibertyObjectClass& a, LibertyObjectClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyObjectClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyObjectClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyObjectClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyObjectClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyObjectClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyObjectClass& from) {
    LibertyObjectClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyObjectClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyObjectClass";
  }
  protected:
  explicit LibertyObjectClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kLineNoFieldNumber = 2,
  };
  // optional string _file_name = 1;
  bool has__file_name() const;
  private:
  bool _internal_has__file_name() const;
  public:
  void clear__file_name();
  const std::string& _file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__file_name();
  PROTOBUF_NODISCARD std::string* release__file_name();
  void set_allocated__file_name(std::string* _file_name);
  private:
  const std::string& _internal__file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__file_name(const std::string& value);
  std::string* _internal_mutable__file_name();
  public:

  // optional uint32 _line_no = 2;
  bool has__line_no() const;
  private:
  bool _internal_has__line_no() const;
  public:
  void clear__line_no();
  uint32_t _line_no() const;
  void set__line_no(uint32_t value);
  private:
  uint32_t _internal__line_no() const;
  void _internal_set__line_no(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyObjectClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _file_name_;
    uint32_t _line_no_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyAxisClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyAxisClass) */ {
 public:
  inline LibertyAxisClass() : LibertyAxisClass(nullptr) {}
  ~LibertyAxisClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyAxisClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyAxisClass(const LibertyAxisClass& from);
  LibertyAxisClass(LibertyAxisClass&& from) noexcept
    : LibertyAxisClass() {
    *this = ::std::move(from);
  }

  inline LibertyAxisClass& operator=(const LibertyAxisClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyAxisClass& operator=(LibertyAxisClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyAxisClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyAxisClass* internal_default_instance() {
    return reinterpret_cast<const LibertyAxisClass*>(
               &_LibertyAxisClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LibertyAxisClass& a, LibertyAxisClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyAxisClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyAxisClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyAxisClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyAxisClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyAxisClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyAxisClass& from) {
    LibertyAxisClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyAxisClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyAxisClass";
  }
  protected:
  explicit LibertyAxisClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLavsTypeFieldNumber = 2,
    kAxisValuesFieldNumber = 3,
    kAxisNameFieldNumber = 1,
  };
  // repeated uint32 lavs_type = 2;
  int lavs_type_size() const;
  private:
  int _internal_lavs_type_size() const;
  public:
  void clear_lavs_type();
  private:
  uint32_t _internal_lavs_type(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_lavs_type() const;
  void _internal_add_lavs_type(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_lavs_type();
  public:
  uint32_t lavs_type(int index) const;
  void set_lavs_type(int index, uint32_t value);
  void add_lavs_type(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      lavs_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_lavs_type();

  // repeated .Common.Types.DoubleOrStr _axis_values = 3;
  int _axis_values_size() const;
  private:
  int _internal__axis_values_size() const;
  public:
  void clear__axis_values();
  ::Common::Types::DoubleOrStr* mutable__axis_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
      mutable__axis_values();
  private:
  const ::Common::Types::DoubleOrStr& _internal__axis_values(int index) const;
  ::Common::Types::DoubleOrStr* _internal_add__axis_values();
  public:
  const ::Common::Types::DoubleOrStr& _axis_values(int index) const;
  ::Common::Types::DoubleOrStr* add__axis_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
      _axis_values() const;

  // required string _axis_name = 1;
  bool has__axis_name() const;
  private:
  bool _internal_has__axis_name() const;
  public:
  void clear__axis_name();
  const std::string& _axis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__axis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__axis_name();
  PROTOBUF_NODISCARD std::string* release__axis_name();
  void set_allocated__axis_name(std::string* _axis_name);
  private:
  const std::string& _internal__axis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__axis_name(const std::string& value);
  std::string* _internal_mutable__axis_name();
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyAxisClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > lavs_type_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr > _axis_values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _axis_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyTableTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyTableTypeEnum) */ {
 public:
  inline LibertyTableTypeEnum() : LibertyTableTypeEnum(nullptr) {}
  ~LibertyTableTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR LibertyTableTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyTableTypeEnum(const LibertyTableTypeEnum& from);
  LibertyTableTypeEnum(LibertyTableTypeEnum&& from) noexcept
    : LibertyTableTypeEnum() {
    *this = ::std::move(from);
  }

  inline LibertyTableTypeEnum& operator=(const LibertyTableTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyTableTypeEnum& operator=(LibertyTableTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyTableTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyTableTypeEnum* internal_default_instance() {
    return reinterpret_cast<const LibertyTableTypeEnum*>(
               &_LibertyTableTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LibertyTableTypeEnum& a, LibertyTableTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyTableTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyTableTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyTableTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyTableTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyTableTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyTableTypeEnum& from) {
    LibertyTableTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyTableTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyTableTypeEnum";
  }
  protected:
  explicit LibertyTableTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LibertyTableTypeEnum_TableType TableType;
  static constexpr TableType kCellRise =
    LibertyTableTypeEnum_TableType_kCellRise;
  static constexpr TableType kCellFall =
    LibertyTableTypeEnum_TableType_kCellFall;
  static constexpr TableType kRiseTransition =
    LibertyTableTypeEnum_TableType_kRiseTransition;
  static constexpr TableType kFallTransition =
    LibertyTableTypeEnum_TableType_kFallTransition;
  static constexpr TableType kRiseConstrain =
    LibertyTableTypeEnum_TableType_kRiseConstrain;
  static constexpr TableType kFallConstrain =
    LibertyTableTypeEnum_TableType_kFallConstrain;
  static constexpr TableType kRiseCurrent =
    LibertyTableTypeEnum_TableType_kRiseCurrent;
  static constexpr TableType kFallCurrent =
    LibertyTableTypeEnum_TableType_kFallCurrent;
  static constexpr TableType kRisePower =
    LibertyTableTypeEnum_TableType_kRisePower;
  static constexpr TableType kFallPower =
    LibertyTableTypeEnum_TableType_kFallPower;
  static inline bool TableType_IsValid(int value) {
    return LibertyTableTypeEnum_TableType_IsValid(value);
  }
  static constexpr TableType TableType_MIN =
    LibertyTableTypeEnum_TableType_TableType_MIN;
  static constexpr TableType TableType_MAX =
    LibertyTableTypeEnum_TableType_TableType_MAX;
  static constexpr int TableType_ARRAYSIZE =
    LibertyTableTypeEnum_TableType_TableType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TableType_descriptor() {
    return LibertyTableTypeEnum_TableType_descriptor();
  }
  template<typename T>
  static inline const std::string& TableType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TableType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TableType_Name.");
    return LibertyTableTypeEnum_TableType_Name(enum_t_value);
  }
  static inline bool TableType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TableType* value) {
    return LibertyTableTypeEnum_TableType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTtFieldNumber = 1,
  };
  // required .Liberty.LibertyTableTypeEnum.TableType tt = 1;
  bool has_tt() const;
  private:
  bool _internal_has_tt() const;
  public:
  void clear_tt();
  ::Liberty::LibertyTableTypeEnum_TableType tt() const;
  void set_tt(::Liberty::LibertyTableTypeEnum_TableType value);
  private:
  ::Liberty::LibertyTableTypeEnum_TableType _internal_tt() const;
  void _internal_set_tt(::Liberty::LibertyTableTypeEnum_TableType value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyTableTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int tt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyTableClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyTableClass) */ {
 public:
  inline LibertyTableClass() : LibertyTableClass(nullptr) {}
  ~LibertyTableClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyTableClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyTableClass(const LibertyTableClass& from);
  LibertyTableClass(LibertyTableClass&& from) noexcept
    : LibertyTableClass() {
    *this = ::std::move(from);
  }

  inline LibertyTableClass& operator=(const LibertyTableClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyTableClass& operator=(LibertyTableClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyTableClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyTableClass* internal_default_instance() {
    return reinterpret_cast<const LibertyTableClass*>(
               &_LibertyTableClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LibertyTableClass& a, LibertyTableClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyTableClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyTableClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyTableClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyTableClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyTableClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyTableClass& from) {
    LibertyTableClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyTableClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyTableClass";
  }
  protected:
  explicit LibertyTableClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAxesFieldNumber = 1,
    kLavsTypeFieldNumber = 2,
    kTableValuesFieldNumber = 3,
    kTableTypeFieldNumber = 4,
    kTableTemplateFieldNumber = 5,
  };
  // repeated uint64 _axes = 1;
  int _axes_size() const;
  private:
  int _internal__axes_size() const;
  public:
  void clear__axes();
  private:
  uint64_t _internal__axes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__axes() const;
  void _internal_add__axes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__axes();
  public:
  uint64_t _axes(int index) const;
  void set__axes(int index, uint64_t value);
  void add__axes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _axes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__axes();

  // repeated uint32 lavs_type = 2;
  int lavs_type_size() const;
  private:
  int _internal_lavs_type_size() const;
  public:
  void clear_lavs_type();
  private:
  uint32_t _internal_lavs_type(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_lavs_type() const;
  void _internal_add_lavs_type(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_lavs_type();
  public:
  uint32_t lavs_type(int index) const;
  void set_lavs_type(int index, uint32_t value);
  void add_lavs_type(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      lavs_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_lavs_type();

  // repeated .Common.Types.DoubleOrStr _table_values = 3;
  int _table_values_size() const;
  private:
  int _internal__table_values_size() const;
  public:
  void clear__table_values();
  ::Common::Types::DoubleOrStr* mutable__table_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
      mutable__table_values();
  private:
  const ::Common::Types::DoubleOrStr& _internal__table_values(int index) const;
  ::Common::Types::DoubleOrStr* _internal_add__table_values();
  public:
  const ::Common::Types::DoubleOrStr& _table_values(int index) const;
  ::Common::Types::DoubleOrStr* add__table_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
      _table_values() const;

  // required .Liberty.LibertyTableTypeEnum _table_type = 4;
  bool has__table_type() const;
  private:
  bool _internal_has__table_type() const;
  public:
  void clear__table_type();
  const ::Liberty::LibertyTableTypeEnum& _table_type() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyTableTypeEnum* release__table_type();
  ::Liberty::LibertyTableTypeEnum* mutable__table_type();
  void set_allocated__table_type(::Liberty::LibertyTableTypeEnum* _table_type);
  private:
  const ::Liberty::LibertyTableTypeEnum& _internal__table_type() const;
  ::Liberty::LibertyTableTypeEnum* _internal_mutable__table_type();
  public:
  void unsafe_arena_set_allocated__table_type(
      ::Liberty::LibertyTableTypeEnum* _table_type);
  ::Liberty::LibertyTableTypeEnum* unsafe_arena_release__table_type();

  // optional uint64 _table_template = 5;
  bool has__table_template() const;
  private:
  bool _internal_has__table_template() const;
  public:
  void clear__table_template();
  uint64_t _table_template() const;
  void set__table_template(uint64_t value);
  private:
  uint64_t _internal__table_template() const;
  void _internal_set__table_template(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyTableClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _axes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > lavs_type_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr > _table_values_;
    ::Liberty::LibertyTableTypeEnum* _table_type_;
    uint64_t _table_template_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyVectorTableClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyVectorTableClass) */ {
 public:
  inline LibertyVectorTableClass() : LibertyVectorTableClass(nullptr) {}
  ~LibertyVectorTableClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyVectorTableClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyVectorTableClass(const LibertyVectorTableClass& from);
  LibertyVectorTableClass(LibertyVectorTableClass&& from) noexcept
    : LibertyVectorTableClass() {
    *this = ::std::move(from);
  }

  inline LibertyVectorTableClass& operator=(const LibertyVectorTableClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyVectorTableClass& operator=(LibertyVectorTableClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyVectorTableClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyVectorTableClass* internal_default_instance() {
    return reinterpret_cast<const LibertyVectorTableClass*>(
               &_LibertyVectorTableClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LibertyVectorTableClass& a, LibertyVectorTableClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyVectorTableClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyVectorTableClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyVectorTableClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyVectorTableClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyVectorTableClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyVectorTableClass& from) {
    LibertyVectorTableClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyVectorTableClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyVectorTableClass";
  }
  protected:
  explicit LibertyVectorTableClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefTimeFieldNumber = 1,
  };
  // required double _ref_time = 1;
  bool has__ref_time() const;
  private:
  bool _internal_has__ref_time() const;
  public:
  void clear__ref_time();
  double _ref_time() const;
  void set__ref_time(double value);
  private:
  double _internal__ref_time() const;
  void _internal_set__ref_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyVectorTableClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double _ref_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyTableSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyTableSyn) */ {
 public:
  inline LibertyTableSyn() : LibertyTableSyn(nullptr) {}
  ~LibertyTableSyn() override;
  explicit PROTOBUF_CONSTEXPR LibertyTableSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyTableSyn(const LibertyTableSyn& from);
  LibertyTableSyn(LibertyTableSyn&& from) noexcept
    : LibertyTableSyn() {
    *this = ::std::move(from);
  }

  inline LibertyTableSyn& operator=(const LibertyTableSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyTableSyn& operator=(LibertyTableSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyTableSyn& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyTableSyn* internal_default_instance() {
    return reinterpret_cast<const LibertyTableSyn*>(
               &_LibertyTableSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LibertyTableSyn& a, LibertyTableSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyTableSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyTableSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyTableSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyTableSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyTableSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyTableSyn& from) {
    LibertyTableSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyTableSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyTableSyn";
  }
  protected:
  explicit LibertyTableSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kLvtcFieldNumber = 4,
    kIdFieldNumber = 1,
    kLtsTypeFieldNumber = 2,
  };
  // required .Liberty.LibertyTableClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Liberty::LibertyTableClass& parent() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyTableClass* release_parent();
  ::Liberty::LibertyTableClass* mutable_parent();
  void set_allocated_parent(::Liberty::LibertyTableClass* parent);
  private:
  const ::Liberty::LibertyTableClass& _internal_parent() const;
  ::Liberty::LibertyTableClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Liberty::LibertyTableClass* parent);
  ::Liberty::LibertyTableClass* unsafe_arena_release_parent();

  // optional .Liberty.LibertyVectorTableClass lvtc = 4;
  bool has_lvtc() const;
  private:
  bool _internal_has_lvtc() const;
  public:
  void clear_lvtc();
  const ::Liberty::LibertyVectorTableClass& lvtc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyVectorTableClass* release_lvtc();
  ::Liberty::LibertyVectorTableClass* mutable_lvtc();
  void set_allocated_lvtc(::Liberty::LibertyVectorTableClass* lvtc);
  private:
  const ::Liberty::LibertyVectorTableClass& _internal_lvtc() const;
  ::Liberty::LibertyVectorTableClass* _internal_mutable_lvtc();
  public:
  void unsafe_arena_set_allocated_lvtc(
      ::Liberty::LibertyVectorTableClass* lvtc);
  ::Liberty::LibertyVectorTableClass* unsafe_arena_release_lvtc();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 lts_type = 2;
  bool has_lts_type() const;
  private:
  bool _internal_has_lts_type() const;
  public:
  void clear_lts_type();
  uint32_t lts_type() const;
  void set_lts_type(uint32_t value);
  private:
  uint32_t _internal_lts_type() const;
  void _internal_set_lts_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyTableSyn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Liberty::LibertyTableClass* parent_;
    ::Liberty::LibertyVectorTableClass* lvtc_;
    uint64_t id_;
    uint32_t lts_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyCCSTableClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyCCSTableClass) */ {
 public:
  inline LibertyCCSTableClass() : LibertyCCSTableClass(nullptr) {}
  ~LibertyCCSTableClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyCCSTableClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyCCSTableClass(const LibertyCCSTableClass& from);
  LibertyCCSTableClass(LibertyCCSTableClass&& from) noexcept
    : LibertyCCSTableClass() {
    *this = ::std::move(from);
  }

  inline LibertyCCSTableClass& operator=(const LibertyCCSTableClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyCCSTableClass& operator=(LibertyCCSTableClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyCCSTableClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyCCSTableClass* internal_default_instance() {
    return reinterpret_cast<const LibertyCCSTableClass*>(
               &_LibertyCCSTableClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LibertyCCSTableClass& a, LibertyCCSTableClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyCCSTableClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyCCSTableClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyCCSTableClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyCCSTableClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyCCSTableClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyCCSTableClass& from) {
    LibertyCCSTableClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyCCSTableClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyCCSTableClass";
  }
  protected:
  explicit LibertyCCSTableClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorTablesFieldNumber = 2,
    kTableTypeFieldNumber = 1,
  };
  // repeated uint64 _vector_tables = 2;
  int _vector_tables_size() const;
  private:
  int _internal__vector_tables_size() const;
  public:
  void clear__vector_tables();
  private:
  uint64_t _internal__vector_tables(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__vector_tables() const;
  void _internal_add__vector_tables(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__vector_tables();
  public:
  uint64_t _vector_tables(int index) const;
  void set__vector_tables(int index, uint64_t value);
  void add__vector_tables(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _vector_tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__vector_tables();

  // required .Liberty.LibertyTableTypeEnum _table_type = 1;
  bool has__table_type() const;
  private:
  bool _internal_has__table_type() const;
  public:
  void clear__table_type();
  const ::Liberty::LibertyTableTypeEnum& _table_type() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyTableTypeEnum* release__table_type();
  ::Liberty::LibertyTableTypeEnum* mutable__table_type();
  void set_allocated__table_type(::Liberty::LibertyTableTypeEnum* _table_type);
  private:
  const ::Liberty::LibertyTableTypeEnum& _internal__table_type() const;
  ::Liberty::LibertyTableTypeEnum* _internal_mutable__table_type();
  public:
  void unsafe_arena_set_allocated__table_type(
      ::Liberty::LibertyTableTypeEnum* _table_type);
  ::Liberty::LibertyTableTypeEnum* unsafe_arena_release__table_type();

  // @@protoc_insertion_point(class_scope:Liberty.LibertyCCSTableClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _vector_tables_;
    ::Liberty::LibertyTableTypeEnum* _table_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyDelayTableModelClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyDelayTableModelClass) */ {
 public:
  inline LibertyDelayTableModelClass() : LibertyDelayTableModelClass(nullptr) {}
  ~LibertyDelayTableModelClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyDelayTableModelClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyDelayTableModelClass(const LibertyDelayTableModelClass& from);
  LibertyDelayTableModelClass(LibertyDelayTableModelClass&& from) noexcept
    : LibertyDelayTableModelClass() {
    *this = ::std::move(from);
  }

  inline LibertyDelayTableModelClass& operator=(const LibertyDelayTableModelClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyDelayTableModelClass& operator=(LibertyDelayTableModelClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyDelayTableModelClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyDelayTableModelClass* internal_default_instance() {
    return reinterpret_cast<const LibertyDelayTableModelClass*>(
               &_LibertyDelayTableModelClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LibertyDelayTableModelClass& a, LibertyDelayTableModelClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyDelayTableModelClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyDelayTableModelClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyDelayTableModelClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyDelayTableModelClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyDelayTableModelClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyDelayTableModelClass& from) {
    LibertyDelayTableModelClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyDelayTableModelClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyDelayTableModelClass";
  }
  protected:
  explicit LibertyDelayTableModelClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 1,
    kCurrentTablesFieldNumber = 2,
  };
  // repeated uint64 _tables = 1;
  int _tables_size() const;
  private:
  int _internal__tables_size() const;
  public:
  void clear__tables();
  private:
  uint64_t _internal__tables(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__tables() const;
  void _internal_add__tables(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__tables();
  public:
  uint64_t _tables(int index) const;
  void set__tables(int index, uint64_t value);
  void add__tables(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__tables();

  // repeated uint64 _current_tables = 2;
  int _current_tables_size() const;
  private:
  int _internal__current_tables_size() const;
  public:
  void clear__current_tables();
  private:
  uint64_t _internal__current_tables(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__current_tables() const;
  void _internal_add__current_tables(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__current_tables();
  public:
  uint64_t _current_tables(int index) const;
  void set__current_tables(int index, uint64_t value);
  void add__current_tables(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _current_tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__current_tables();

  // @@protoc_insertion_point(class_scope:Liberty.LibertyDelayTableModelClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _tables_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _current_tables_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyCheckTableModelClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyCheckTableModelClass) */ {
 public:
  inline LibertyCheckTableModelClass() : LibertyCheckTableModelClass(nullptr) {}
  ~LibertyCheckTableModelClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyCheckTableModelClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyCheckTableModelClass(const LibertyCheckTableModelClass& from);
  LibertyCheckTableModelClass(LibertyCheckTableModelClass&& from) noexcept
    : LibertyCheckTableModelClass() {
    *this = ::std::move(from);
  }

  inline LibertyCheckTableModelClass& operator=(const LibertyCheckTableModelClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyCheckTableModelClass& operator=(LibertyCheckTableModelClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyCheckTableModelClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyCheckTableModelClass* internal_default_instance() {
    return reinterpret_cast<const LibertyCheckTableModelClass*>(
               &_LibertyCheckTableModelClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LibertyCheckTableModelClass& a, LibertyCheckTableModelClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyCheckTableModelClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyCheckTableModelClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyCheckTableModelClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyCheckTableModelClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyCheckTableModelClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyCheckTableModelClass& from) {
    LibertyCheckTableModelClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyCheckTableModelClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyCheckTableModelClass";
  }
  protected:
  explicit LibertyCheckTableModelClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 1,
  };
  // repeated uint64 _tables = 1;
  int _tables_size() const;
  private:
  int _internal__tables_size() const;
  public:
  void clear__tables();
  private:
  uint64_t _internal__tables(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__tables() const;
  void _internal_add__tables(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__tables();
  public:
  uint64_t _tables(int index) const;
  void set__tables(int index, uint64_t value);
  void add__tables(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__tables();

  // @@protoc_insertion_point(class_scope:Liberty.LibertyCheckTableModelClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _tables_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyPowerTableModelClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyPowerTableModelClass) */ {
 public:
  inline LibertyPowerTableModelClass() : LibertyPowerTableModelClass(nullptr) {}
  ~LibertyPowerTableModelClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyPowerTableModelClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyPowerTableModelClass(const LibertyPowerTableModelClass& from);
  LibertyPowerTableModelClass(LibertyPowerTableModelClass&& from) noexcept
    : LibertyPowerTableModelClass() {
    *this = ::std::move(from);
  }

  inline LibertyPowerTableModelClass& operator=(const LibertyPowerTableModelClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyPowerTableModelClass& operator=(LibertyPowerTableModelClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyPowerTableModelClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyPowerTableModelClass* internal_default_instance() {
    return reinterpret_cast<const LibertyPowerTableModelClass*>(
               &_LibertyPowerTableModelClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LibertyPowerTableModelClass& a, LibertyPowerTableModelClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyPowerTableModelClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyPowerTableModelClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyPowerTableModelClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyPowerTableModelClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyPowerTableModelClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyPowerTableModelClass& from) {
    LibertyPowerTableModelClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyPowerTableModelClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyPowerTableModelClass";
  }
  protected:
  explicit LibertyPowerTableModelClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 1,
  };
  // repeated uint64 _tables = 1;
  int _tables_size() const;
  private:
  int _internal__tables_size() const;
  public:
  void clear__tables();
  private:
  uint64_t _internal__tables(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__tables() const;
  void _internal_add__tables(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__tables();
  public:
  uint64_t _tables(int index) const;
  void set__tables(int index, uint64_t value);
  void add__tables(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__tables();

  // @@protoc_insertion_point(class_scope:Liberty.LibertyPowerTableModelClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _tables_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyTableModelSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyTableModelSyn) */ {
 public:
  inline LibertyTableModelSyn() : LibertyTableModelSyn(nullptr) {}
  ~LibertyTableModelSyn() override;
  explicit PROTOBUF_CONSTEXPR LibertyTableModelSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyTableModelSyn(const LibertyTableModelSyn& from);
  LibertyTableModelSyn(LibertyTableModelSyn&& from) noexcept
    : LibertyTableModelSyn() {
    *this = ::std::move(from);
  }

  inline LibertyTableModelSyn& operator=(const LibertyTableModelSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyTableModelSyn& operator=(LibertyTableModelSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyTableModelSyn& default_instance() {
    return *internal_default_instance();
  }
  enum LtmsCase {
    kLdtmc = 3,
    kLctmc = 4,
    kLptmc = 5,
    LTMS_NOT_SET = 0,
  };

  static inline const LibertyTableModelSyn* internal_default_instance() {
    return reinterpret_cast<const LibertyTableModelSyn*>(
               &_LibertyTableModelSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LibertyTableModelSyn& a, LibertyTableModelSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyTableModelSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyTableModelSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyTableModelSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyTableModelSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyTableModelSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyTableModelSyn& from) {
    LibertyTableModelSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyTableModelSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyTableModelSyn";
  }
  protected:
  explicit LibertyTableModelSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLtmsTypeFieldNumber = 2,
    kLdtmcFieldNumber = 3,
    kLctmcFieldNumber = 4,
    kLptmcFieldNumber = 5,
  };
  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 ltms_type = 2;
  bool has_ltms_type() const;
  private:
  bool _internal_has_ltms_type() const;
  public:
  void clear_ltms_type();
  uint32_t ltms_type() const;
  void set_ltms_type(uint32_t value);
  private:
  uint32_t _internal_ltms_type() const;
  void _internal_set_ltms_type(uint32_t value);
  public:

  // .Liberty.LibertyDelayTableModelClass ldtmc = 3;
  bool has_ldtmc() const;
  private:
  bool _internal_has_ldtmc() const;
  public:
  void clear_ldtmc();
  const ::Liberty::LibertyDelayTableModelClass& ldtmc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyDelayTableModelClass* release_ldtmc();
  ::Liberty::LibertyDelayTableModelClass* mutable_ldtmc();
  void set_allocated_ldtmc(::Liberty::LibertyDelayTableModelClass* ldtmc);
  private:
  const ::Liberty::LibertyDelayTableModelClass& _internal_ldtmc() const;
  ::Liberty::LibertyDelayTableModelClass* _internal_mutable_ldtmc();
  public:
  void unsafe_arena_set_allocated_ldtmc(
      ::Liberty::LibertyDelayTableModelClass* ldtmc);
  ::Liberty::LibertyDelayTableModelClass* unsafe_arena_release_ldtmc();

  // .Liberty.LibertyCheckTableModelClass lctmc = 4;
  bool has_lctmc() const;
  private:
  bool _internal_has_lctmc() const;
  public:
  void clear_lctmc();
  const ::Liberty::LibertyCheckTableModelClass& lctmc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyCheckTableModelClass* release_lctmc();
  ::Liberty::LibertyCheckTableModelClass* mutable_lctmc();
  void set_allocated_lctmc(::Liberty::LibertyCheckTableModelClass* lctmc);
  private:
  const ::Liberty::LibertyCheckTableModelClass& _internal_lctmc() const;
  ::Liberty::LibertyCheckTableModelClass* _internal_mutable_lctmc();
  public:
  void unsafe_arena_set_allocated_lctmc(
      ::Liberty::LibertyCheckTableModelClass* lctmc);
  ::Liberty::LibertyCheckTableModelClass* unsafe_arena_release_lctmc();

  // .Liberty.LibertyPowerTableModelClass lptmc = 5;
  bool has_lptmc() const;
  private:
  bool _internal_has_lptmc() const;
  public:
  void clear_lptmc();
  const ::Liberty::LibertyPowerTableModelClass& lptmc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyPowerTableModelClass* release_lptmc();
  ::Liberty::LibertyPowerTableModelClass* mutable_lptmc();
  void set_allocated_lptmc(::Liberty::LibertyPowerTableModelClass* lptmc);
  private:
  const ::Liberty::LibertyPowerTableModelClass& _internal_lptmc() const;
  ::Liberty::LibertyPowerTableModelClass* _internal_mutable_lptmc();
  public:
  void unsafe_arena_set_allocated_lptmc(
      ::Liberty::LibertyPowerTableModelClass* lptmc);
  ::Liberty::LibertyPowerTableModelClass* unsafe_arena_release_lptmc();

  void clear_ltms();
  LtmsCase ltms_case() const;
  // @@protoc_insertion_point(class_scope:Liberty.LibertyTableModelSyn)
 private:
  class _Internal;
  void set_has_ldtmc();
  void set_has_lctmc();
  void set_has_lptmc();

  inline bool has_ltms() const;
  inline void clear_has_ltms();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t id_;
    uint32_t ltms_type_;
    union LtmsUnion {
      constexpr LtmsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Liberty::LibertyDelayTableModelClass* ldtmc_;
      ::Liberty::LibertyCheckTableModelClass* lctmc_;
      ::Liberty::LibertyPowerTableModelClass* lptmc_;
    } ltms_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyTypeClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyTypeClass) */ {
 public:
  inline LibertyTypeClass() : LibertyTypeClass(nullptr) {}
  ~LibertyTypeClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyTypeClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyTypeClass(const LibertyTypeClass& from);
  LibertyTypeClass(LibertyTypeClass&& from) noexcept
    : LibertyTypeClass() {
    *this = ::std::move(from);
  }

  inline LibertyTypeClass& operator=(const LibertyTypeClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyTypeClass& operator=(LibertyTypeClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyTypeClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyTypeClass* internal_default_instance() {
    return reinterpret_cast<const LibertyTypeClass*>(
               &_LibertyTypeClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LibertyTypeClass& a, LibertyTypeClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyTypeClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyTypeClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyTypeClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyTypeClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyTypeClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyTypeClass& from) {
    LibertyTypeClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyTypeClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyTypeClass";
  }
  protected:
  explicit LibertyTypeClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeNameFieldNumber = 1,
    kBaseTypeFieldNumber = 2,
    kDataTypeFieldNumber = 3,
    kBitWidthFieldNumber = 4,
    kBitFromFieldNumber = 5,
    kBitToFieldNumber = 6,
  };
  // required string _type_name = 1;
  bool has__type_name() const;
  private:
  bool _internal_has__type_name() const;
  public:
  void clear__type_name();
  const std::string& _type_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__type_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__type_name();
  PROTOBUF_NODISCARD std::string* release__type_name();
  void set_allocated__type_name(std::string* _type_name);
  private:
  const std::string& _internal__type_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__type_name(const std::string& value);
  std::string* _internal_mutable__type_name();
  public:

  // required string _base_type = 2;
  bool has__base_type() const;
  private:
  bool _internal_has__base_type() const;
  public:
  void clear__base_type();
  const std::string& _base_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__base_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable__base_type();
  PROTOBUF_NODISCARD std::string* release__base_type();
  void set_allocated__base_type(std::string* _base_type);
  private:
  const std::string& _internal__base_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__base_type(const std::string& value);
  std::string* _internal_mutable__base_type();
  public:

  // required string _data_type = 3;
  bool has__data_type() const;
  private:
  bool _internal_has__data_type() const;
  public:
  void clear__data_type();
  const std::string& _data_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__data_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable__data_type();
  PROTOBUF_NODISCARD std::string* release__data_type();
  void set_allocated__data_type(std::string* _data_type);
  private:
  const std::string& _internal__data_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__data_type(const std::string& value);
  std::string* _internal_mutable__data_type();
  public:

  // required uint32 _bit_width = 4;
  bool has__bit_width() const;
  private:
  bool _internal_has__bit_width() const;
  public:
  void clear__bit_width();
  uint32_t _bit_width() const;
  void set__bit_width(uint32_t value);
  private:
  uint32_t _internal__bit_width() const;
  void _internal_set__bit_width(uint32_t value);
  public:

  // required uint32 _bit_from = 5;
  bool has__bit_from() const;
  private:
  bool _internal_has__bit_from() const;
  public:
  void clear__bit_from();
  uint32_t _bit_from() const;
  void set__bit_from(uint32_t value);
  private:
  uint32_t _internal__bit_from() const;
  void _internal_set__bit_from(uint32_t value);
  public:

  // required uint32 _bit_to = 6;
  bool has__bit_to() const;
  private:
  bool _internal_has__bit_to() const;
  public:
  void clear__bit_to();
  uint32_t _bit_to() const;
  void set__bit_to(uint32_t value);
  private:
  uint32_t _internal__bit_to() const;
  void _internal_set__bit_to(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyTypeClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _type_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _base_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _data_type_;
    uint32_t _bit_width_;
    uint32_t _bit_from_;
    uint32_t _bit_to_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyPortTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyPortTypeEnum) */ {
 public:
  inline LibertyPortTypeEnum() : LibertyPortTypeEnum(nullptr) {}
  ~LibertyPortTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR LibertyPortTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyPortTypeEnum(const LibertyPortTypeEnum& from);
  LibertyPortTypeEnum(LibertyPortTypeEnum&& from) noexcept
    : LibertyPortTypeEnum() {
    *this = ::std::move(from);
  }

  inline LibertyPortTypeEnum& operator=(const LibertyPortTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyPortTypeEnum& operator=(LibertyPortTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyPortTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyPortTypeEnum* internal_default_instance() {
    return reinterpret_cast<const LibertyPortTypeEnum*>(
               &_LibertyPortTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LibertyPortTypeEnum& a, LibertyPortTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyPortTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyPortTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyPortTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyPortTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyPortTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyPortTypeEnum& from) {
    LibertyPortTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyPortTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyPortTypeEnum";
  }
  protected:
  explicit LibertyPortTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LibertyPortTypeEnum_PortType PortType;
  static constexpr PortType kInput =
    LibertyPortTypeEnum_PortType_kInput;
  static constexpr PortType kOutput =
    LibertyPortTypeEnum_PortType_kOutput;
  static constexpr PortType kInOut =
    LibertyPortTypeEnum_PortType_kInOut;
  static inline bool PortType_IsValid(int value) {
    return LibertyPortTypeEnum_PortType_IsValid(value);
  }
  static constexpr PortType PortType_MIN =
    LibertyPortTypeEnum_PortType_PortType_MIN;
  static constexpr PortType PortType_MAX =
    LibertyPortTypeEnum_PortType_PortType_MAX;
  static constexpr int PortType_ARRAYSIZE =
    LibertyPortTypeEnum_PortType_PortType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PortType_descriptor() {
    return LibertyPortTypeEnum_PortType_descriptor();
  }
  template<typename T>
  static inline const std::string& PortType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PortType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PortType_Name.");
    return LibertyPortTypeEnum_PortType_Name(enum_t_value);
  }
  static inline bool PortType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PortType* value) {
    return LibertyPortTypeEnum_PortType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPtFieldNumber = 1,
  };
  // required .Liberty.LibertyPortTypeEnum.PortType pt = 1;
  bool has_pt() const;
  private:
  bool _internal_has_pt() const;
  public:
  void clear_pt();
  ::Liberty::LibertyPortTypeEnum_PortType pt() const;
  void set_pt(::Liberty::LibertyPortTypeEnum_PortType value);
  private:
  ::Liberty::LibertyPortTypeEnum_PortType _internal_pt() const;
  void _internal_set_pt(::Liberty::LibertyPortTypeEnum_PortType value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyPortTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int pt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyPortClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyPortClass) */ {
 public:
  inline LibertyPortClass() : LibertyPortClass(nullptr) {}
  ~LibertyPortClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyPortClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyPortClass(const LibertyPortClass& from);
  LibertyPortClass(LibertyPortClass&& from) noexcept
    : LibertyPortClass() {
    *this = ::std::move(from);
  }

  inline LibertyPortClass& operator=(const LibertyPortClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyPortClass& operator=(LibertyPortClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyPortClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyPortClass* internal_default_instance() {
    return reinterpret_cast<const LibertyPortClass*>(
               &_LibertyPortClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LibertyPortClass& a, LibertyPortClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyPortClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyPortClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyPortClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyPortClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyPortClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyPortClass& from) {
    LibertyPortClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyPortClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyPortClass";
  }
  protected:
  explicit LibertyPortClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortNameFieldNumber = 1,
    kPortTypeFieldNumber = 3,
    kOwnerCellFieldNumber = 2,
    kFuncExprFieldNumber = 4,
    kPortCapFieldNumber = 5,
    kFanoutLoadFieldNumber = 6,
    kPowerTableModelFieldNumber = 7,
  };
  // required string _port_name = 1;
  bool has__port_name() const;
  private:
  bool _internal_has__port_name() const;
  public:
  void clear__port_name();
  const std::string& _port_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__port_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__port_name();
  PROTOBUF_NODISCARD std::string* release__port_name();
  void set_allocated__port_name(std::string* _port_name);
  private:
  const std::string& _internal__port_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__port_name(const std::string& value);
  std::string* _internal_mutable__port_name();
  public:

  // required .Liberty.LibertyPortTypeEnum _port_type = 3;
  bool has__port_type() const;
  private:
  bool _internal_has__port_type() const;
  public:
  void clear__port_type();
  const ::Liberty::LibertyPortTypeEnum& _port_type() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyPortTypeEnum* release__port_type();
  ::Liberty::LibertyPortTypeEnum* mutable__port_type();
  void set_allocated__port_type(::Liberty::LibertyPortTypeEnum* _port_type);
  private:
  const ::Liberty::LibertyPortTypeEnum& _internal__port_type() const;
  ::Liberty::LibertyPortTypeEnum* _internal_mutable__port_type();
  public:
  void unsafe_arena_set_allocated__port_type(
      ::Liberty::LibertyPortTypeEnum* _port_type);
  ::Liberty::LibertyPortTypeEnum* unsafe_arena_release__port_type();

  // required uint64 _owner_cell = 2;
  bool has__owner_cell() const;
  private:
  bool _internal_has__owner_cell() const;
  public:
  void clear__owner_cell();
  uint64_t _owner_cell() const;
  void set__owner_cell(uint64_t value);
  private:
  uint64_t _internal__owner_cell() const;
  void _internal_set__owner_cell(uint64_t value);
  public:

  // optional uint64 _func_expr = 4;
  bool has__func_expr() const;
  private:
  bool _internal_has__func_expr() const;
  public:
  void clear__func_expr();
  uint64_t _func_expr() const;
  void set__func_expr(uint64_t value);
  private:
  uint64_t _internal__func_expr() const;
  void _internal_set__func_expr(uint64_t value);
  public:

  // required double _port_cap = 5;
  bool has__port_cap() const;
  private:
  bool _internal_has__port_cap() const;
  public:
  void clear__port_cap();
  double _port_cap() const;
  void set__port_cap(double value);
  private:
  double _internal__port_cap() const;
  void _internal_set__port_cap(double value);
  public:

  // optional double _fanout_load = 6;
  bool has__fanout_load() const;
  private:
  bool _internal_has__fanout_load() const;
  public:
  void clear__fanout_load();
  double _fanout_load() const;
  void set__fanout_load(double value);
  private:
  double _internal__fanout_load() const;
  void _internal_set__fanout_load(double value);
  public:

  // optional uint64 _power_table_model = 7;
  bool has__power_table_model() const;
  private:
  bool _internal_has__power_table_model() const;
  public:
  void clear__power_table_model();
  uint64_t _power_table_model() const;
  void set__power_table_model(uint64_t value);
  private:
  uint64_t _internal__power_table_model() const;
  void _internal_set__power_table_model(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyPortClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _port_name_;
    ::Liberty::LibertyPortTypeEnum* _port_type_;
    uint64_t _owner_cell_;
    uint64_t _func_expr_;
    double _port_cap_;
    double _fanout_load_;
    uint64_t _power_table_model_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyPortBusClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyPortBusClass) */ {
 public:
  inline LibertyPortBusClass() : LibertyPortBusClass(nullptr) {}
  ~LibertyPortBusClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyPortBusClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyPortBusClass(const LibertyPortBusClass& from);
  LibertyPortBusClass(LibertyPortBusClass&& from) noexcept
    : LibertyPortBusClass() {
    *this = ::std::move(from);
  }

  inline LibertyPortBusClass& operator=(const LibertyPortBusClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyPortBusClass& operator=(LibertyPortBusClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyPortBusClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyPortBusClass* internal_default_instance() {
    return reinterpret_cast<const LibertyPortBusClass*>(
               &_LibertyPortBusClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LibertyPortBusClass& a, LibertyPortBusClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyPortBusClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyPortBusClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyPortBusClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyPortBusClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyPortBusClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyPortBusClass& from) {
    LibertyPortBusClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyPortBusClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyPortBusClass";
  }
  protected:
  explicit LibertyPortBusClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 1,
    kBusTypeFieldNumber = 2,
  };
  // repeated uint64 _ports = 1;
  int _ports_size() const;
  private:
  int _internal__ports_size() const;
  public:
  void clear__ports();
  private:
  uint64_t _internal__ports(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__ports() const;
  void _internal_add__ports(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__ports();
  public:
  uint64_t _ports(int index) const;
  void set__ports(int index, uint64_t value);
  void add__ports(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__ports();

  // required uint64 _bus_type = 2;
  bool has__bus_type() const;
  private:
  bool _internal_has__bus_type() const;
  public:
  void clear__bus_type();
  uint64_t _bus_type() const;
  void set__bus_type(uint64_t value);
  private:
  uint64_t _internal__bus_type() const;
  void _internal_set__bus_type(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyPortBusClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _ports_;
    uint64_t _bus_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyPortSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyPortSyn) */ {
 public:
  inline LibertyPortSyn() : LibertyPortSyn(nullptr) {}
  ~LibertyPortSyn() override;
  explicit PROTOBUF_CONSTEXPR LibertyPortSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyPortSyn(const LibertyPortSyn& from);
  LibertyPortSyn(LibertyPortSyn&& from) noexcept
    : LibertyPortSyn() {
    *this = ::std::move(from);
  }

  inline LibertyPortSyn& operator=(const LibertyPortSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyPortSyn& operator=(LibertyPortSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyPortSyn& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyPortSyn* internal_default_instance() {
    return reinterpret_cast<const LibertyPortSyn*>(
               &_LibertyPortSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LibertyPortSyn& a, LibertyPortSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyPortSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyPortSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyPortSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyPortSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyPortSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyPortSyn& from) {
    LibertyPortSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyPortSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyPortSyn";
  }
  protected:
  explicit LibertyPortSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 2,
    kLpbcFieldNumber = 3,
    kLpsTypeFieldNumber = 1,
  };
  // optional .Liberty.LibertyPortClass parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Liberty::LibertyPortClass& parent() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyPortClass* release_parent();
  ::Liberty::LibertyPortClass* mutable_parent();
  void set_allocated_parent(::Liberty::LibertyPortClass* parent);
  private:
  const ::Liberty::LibertyPortClass& _internal_parent() const;
  ::Liberty::LibertyPortClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Liberty::LibertyPortClass* parent);
  ::Liberty::LibertyPortClass* unsafe_arena_release_parent();

  // optional .Liberty.LibertyPortBusClass lpbc = 3;
  bool has_lpbc() const;
  private:
  bool _internal_has_lpbc() const;
  public:
  void clear_lpbc();
  const ::Liberty::LibertyPortBusClass& lpbc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyPortBusClass* release_lpbc();
  ::Liberty::LibertyPortBusClass* mutable_lpbc();
  void set_allocated_lpbc(::Liberty::LibertyPortBusClass* lpbc);
  private:
  const ::Liberty::LibertyPortBusClass& _internal_lpbc() const;
  ::Liberty::LibertyPortBusClass* _internal_mutable_lpbc();
  public:
  void unsafe_arena_set_allocated_lpbc(
      ::Liberty::LibertyPortBusClass* lpbc);
  ::Liberty::LibertyPortBusClass* unsafe_arena_release_lpbc();

  // required uint32 lps_type = 1;
  bool has_lps_type() const;
  private:
  bool _internal_has_lps_type() const;
  public:
  void clear_lps_type();
  uint32_t lps_type() const;
  void set_lps_type(uint32_t value);
  private:
  uint32_t _internal_lps_type() const;
  void _internal_set_lps_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyPortSyn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Liberty::LibertyPortClass* parent_;
    ::Liberty::LibertyPortBusClass* lpbc_;
    uint32_t lps_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyArcClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyArcClass) */ {
 public:
  inline LibertyArcClass() : LibertyArcClass(nullptr) {}
  ~LibertyArcClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyArcClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyArcClass(const LibertyArcClass& from);
  LibertyArcClass(LibertyArcClass&& from) noexcept
    : LibertyArcClass() {
    *this = ::std::move(from);
  }

  inline LibertyArcClass& operator=(const LibertyArcClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyArcClass& operator=(LibertyArcClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyArcClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyArcClass* internal_default_instance() {
    return reinterpret_cast<const LibertyArcClass*>(
               &_LibertyArcClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LibertyArcClass& a, LibertyArcClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyArcClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyArcClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyArcClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyArcClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyArcClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyArcClass& from) {
    LibertyArcClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyArcClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyArcClass";
  }
  protected:
  explicit LibertyArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcPortFieldNumber = 1,
    kSnkPortFieldNumber = 2,
    kTimingSenseFieldNumber = 4,
    kTimingTypeFieldNumber = 5,
    kOwnerCellFieldNumber = 3,
    kTableModelFieldNumber = 6,
  };
  // required string _src_port = 1;
  bool has__src_port() const;
  private:
  bool _internal_has__src_port() const;
  public:
  void clear__src_port();
  const std::string& _src_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__src_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable__src_port();
  PROTOBUF_NODISCARD std::string* release__src_port();
  void set_allocated__src_port(std::string* _src_port);
  private:
  const std::string& _internal__src_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__src_port(const std::string& value);
  std::string* _internal_mutable__src_port();
  public:

  // required string _snk_port = 2;
  bool has__snk_port() const;
  private:
  bool _internal_has__snk_port() const;
  public:
  void clear__snk_port();
  const std::string& _snk_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__snk_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable__snk_port();
  PROTOBUF_NODISCARD std::string* release__snk_port();
  void set_allocated__snk_port(std::string* _snk_port);
  private:
  const std::string& _internal__snk_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__snk_port(const std::string& value);
  std::string* _internal_mutable__snk_port();
  public:

  // required string _timing_sense = 4;
  bool has__timing_sense() const;
  private:
  bool _internal_has__timing_sense() const;
  public:
  void clear__timing_sense();
  const std::string& _timing_sense() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__timing_sense(ArgT0&& arg0, ArgT... args);
  std::string* mutable__timing_sense();
  PROTOBUF_NODISCARD std::string* release__timing_sense();
  void set_allocated__timing_sense(std::string* _timing_sense);
  private:
  const std::string& _internal__timing_sense() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__timing_sense(const std::string& value);
  std::string* _internal_mutable__timing_sense();
  public:

  // required string _timing_type = 5;
  bool has__timing_type() const;
  private:
  bool _internal_has__timing_type() const;
  public:
  void clear__timing_type();
  const std::string& _timing_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__timing_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable__timing_type();
  PROTOBUF_NODISCARD std::string* release__timing_type();
  void set_allocated__timing_type(std::string* _timing_type);
  private:
  const std::string& _internal__timing_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__timing_type(const std::string& value);
  std::string* _internal_mutable__timing_type();
  public:

  // required uint64 _owner_cell = 3;
  bool has__owner_cell() const;
  private:
  bool _internal_has__owner_cell() const;
  public:
  void clear__owner_cell();
  uint64_t _owner_cell() const;
  void set__owner_cell(uint64_t value);
  private:
  uint64_t _internal__owner_cell() const;
  void _internal_set__owner_cell(uint64_t value);
  public:

  // required uint64 _table_model = 6;
  bool has__table_model() const;
  private:
  bool _internal_has__table_model() const;
  public:
  void clear__table_model();
  uint64_t _table_model() const;
  void set__table_model(uint64_t value);
  private:
  uint64_t _internal__table_model() const;
  void _internal_set__table_model(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyArcClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _src_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _snk_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _timing_sense_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _timing_type_;
    uint64_t _owner_cell_;
    uint64_t _table_model_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyArcSetClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyArcSetClass) */ {
 public:
  inline LibertyArcSetClass() : LibertyArcSetClass(nullptr) {}
  ~LibertyArcSetClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyArcSetClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyArcSetClass(const LibertyArcSetClass& from);
  LibertyArcSetClass(LibertyArcSetClass&& from) noexcept
    : LibertyArcSetClass() {
    *this = ::std::move(from);
  }

  inline LibertyArcSetClass& operator=(const LibertyArcSetClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyArcSetClass& operator=(LibertyArcSetClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyArcSetClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyArcSetClass* internal_default_instance() {
    return reinterpret_cast<const LibertyArcSetClass*>(
               &_LibertyArcSetClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LibertyArcSetClass& a, LibertyArcSetClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyArcSetClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyArcSetClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyArcSetClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyArcSetClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyArcSetClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyArcSetClass& from) {
    LibertyArcSetClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyArcSetClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyArcSetClass";
  }
  protected:
  explicit LibertyArcSetClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArcsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated uint64 _arcs = 2;
  int _arcs_size() const;
  private:
  int _internal__arcs_size() const;
  public:
  void clear__arcs();
  private:
  uint64_t _internal__arcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__arcs() const;
  void _internal_add__arcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__arcs();
  public:
  uint64_t _arcs(int index) const;
  void set__arcs(int index, uint64_t value);
  void add__arcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _arcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__arcs();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyArcSetClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _arcs_;
    uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyPowerArcClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyPowerArcClass) */ {
 public:
  inline LibertyPowerArcClass() : LibertyPowerArcClass(nullptr) {}
  ~LibertyPowerArcClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyPowerArcClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyPowerArcClass(const LibertyPowerArcClass& from);
  LibertyPowerArcClass(LibertyPowerArcClass&& from) noexcept
    : LibertyPowerArcClass() {
    *this = ::std::move(from);
  }

  inline LibertyPowerArcClass& operator=(const LibertyPowerArcClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyPowerArcClass& operator=(LibertyPowerArcClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyPowerArcClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyPowerArcClass* internal_default_instance() {
    return reinterpret_cast<const LibertyPowerArcClass*>(
               &_LibertyPowerArcClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LibertyPowerArcClass& a, LibertyPowerArcClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyPowerArcClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyPowerArcClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyPowerArcClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyPowerArcClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyPowerArcClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyPowerArcClass& from) {
    LibertyPowerArcClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyPowerArcClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyPowerArcClass";
  }
  protected:
  explicit LibertyPowerArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcPortFieldNumber = 1,
    kSnkPortFieldNumber = 2,
    kRelatedPgPortFieldNumber = 3,
    kWhenFieldNumber = 4,
    kOwnerCellFieldNumber = 5,
    kPowerTableModelFieldNumber = 6,
  };
  // required string _src_port = 1;
  bool has__src_port() const;
  private:
  bool _internal_has__src_port() const;
  public:
  void clear__src_port();
  const std::string& _src_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__src_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable__src_port();
  PROTOBUF_NODISCARD std::string* release__src_port();
  void set_allocated__src_port(std::string* _src_port);
  private:
  const std::string& _internal__src_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__src_port(const std::string& value);
  std::string* _internal_mutable__src_port();
  public:

  // required string _snk_port = 2;
  bool has__snk_port() const;
  private:
  bool _internal_has__snk_port() const;
  public:
  void clear__snk_port();
  const std::string& _snk_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__snk_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable__snk_port();
  PROTOBUF_NODISCARD std::string* release__snk_port();
  void set_allocated__snk_port(std::string* _snk_port);
  private:
  const std::string& _internal__snk_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__snk_port(const std::string& value);
  std::string* _internal_mutable__snk_port();
  public:

  // required string _related_pg_port = 3;
  bool has__related_pg_port() const;
  private:
  bool _internal_has__related_pg_port() const;
  public:
  void clear__related_pg_port();
  const std::string& _related_pg_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__related_pg_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable__related_pg_port();
  PROTOBUF_NODISCARD std::string* release__related_pg_port();
  void set_allocated__related_pg_port(std::string* _related_pg_port);
  private:
  const std::string& _internal__related_pg_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__related_pg_port(const std::string& value);
  std::string* _internal_mutable__related_pg_port();
  public:

  // required string _when = 4;
  bool has__when() const;
  private:
  bool _internal_has__when() const;
  public:
  void clear__when();
  const std::string& _when() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__when(ArgT0&& arg0, ArgT... args);
  std::string* mutable__when();
  PROTOBUF_NODISCARD std::string* release__when();
  void set_allocated__when(std::string* _when);
  private:
  const std::string& _internal__when() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__when(const std::string& value);
  std::string* _internal_mutable__when();
  public:

  // required uint64 _owner_cell = 5;
  bool has__owner_cell() const;
  private:
  bool _internal_has__owner_cell() const;
  public:
  void clear__owner_cell();
  uint64_t _owner_cell() const;
  void set__owner_cell(uint64_t value);
  private:
  uint64_t _internal__owner_cell() const;
  void _internal_set__owner_cell(uint64_t value);
  public:

  // optional uint64 _power_table_model = 6;
  bool has__power_table_model() const;
  private:
  bool _internal_has__power_table_model() const;
  public:
  void clear__power_table_model();
  uint64_t _power_table_model() const;
  void set__power_table_model(uint64_t value);
  private:
  uint64_t _internal__power_table_model() const;
  void _internal_set__power_table_model(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyPowerArcClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _src_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _snk_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _related_pg_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _when_;
    uint64_t _owner_cell_;
    uint64_t _power_table_model_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyPowerArcSetClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyPowerArcSetClass) */ {
 public:
  inline LibertyPowerArcSetClass() : LibertyPowerArcSetClass(nullptr) {}
  ~LibertyPowerArcSetClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyPowerArcSetClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyPowerArcSetClass(const LibertyPowerArcSetClass& from);
  LibertyPowerArcSetClass(LibertyPowerArcSetClass&& from) noexcept
    : LibertyPowerArcSetClass() {
    *this = ::std::move(from);
  }

  inline LibertyPowerArcSetClass& operator=(const LibertyPowerArcSetClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyPowerArcSetClass& operator=(LibertyPowerArcSetClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyPowerArcSetClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyPowerArcSetClass* internal_default_instance() {
    return reinterpret_cast<const LibertyPowerArcSetClass*>(
               &_LibertyPowerArcSetClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LibertyPowerArcSetClass& a, LibertyPowerArcSetClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyPowerArcSetClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyPowerArcSetClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyPowerArcSetClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyPowerArcSetClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyPowerArcSetClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyPowerArcSetClass& from) {
    LibertyPowerArcSetClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyPowerArcSetClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyPowerArcSetClass";
  }
  protected:
  explicit LibertyPowerArcSetClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerArcsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated uint64 _power_arcs = 2;
  int _power_arcs_size() const;
  private:
  int _internal__power_arcs_size() const;
  public:
  void clear__power_arcs();
  private:
  uint64_t _internal__power_arcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__power_arcs() const;
  void _internal_add__power_arcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__power_arcs();
  public:
  uint64_t _power_arcs(int index) const;
  void set__power_arcs(int index, uint64_t value);
  void add__power_arcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _power_arcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__power_arcs();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyPowerArcSetClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _power_arcs_;
    uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyLeakagePowerClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyLeakagePowerClass) */ {
 public:
  inline LibertyLeakagePowerClass() : LibertyLeakagePowerClass(nullptr) {}
  ~LibertyLeakagePowerClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyLeakagePowerClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyLeakagePowerClass(const LibertyLeakagePowerClass& from);
  LibertyLeakagePowerClass(LibertyLeakagePowerClass&& from) noexcept
    : LibertyLeakagePowerClass() {
    *this = ::std::move(from);
  }

  inline LibertyLeakagePowerClass& operator=(const LibertyLeakagePowerClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyLeakagePowerClass& operator=(LibertyLeakagePowerClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyLeakagePowerClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyLeakagePowerClass* internal_default_instance() {
    return reinterpret_cast<const LibertyLeakagePowerClass*>(
               &_LibertyLeakagePowerClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(LibertyLeakagePowerClass& a, LibertyLeakagePowerClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyLeakagePowerClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyLeakagePowerClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyLeakagePowerClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyLeakagePowerClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyLeakagePowerClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyLeakagePowerClass& from) {
    LibertyLeakagePowerClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyLeakagePowerClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyLeakagePowerClass";
  }
  protected:
  explicit LibertyLeakagePowerClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelatedPgPortFieldNumber = 1,
    kWhenFieldNumber = 2,
    kValueFieldNumber = 3,
    kOwnerCellFieldNumber = 4,
  };
  // required string _related_pg_port = 1;
  bool has__related_pg_port() const;
  private:
  bool _internal_has__related_pg_port() const;
  public:
  void clear__related_pg_port();
  const std::string& _related_pg_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__related_pg_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable__related_pg_port();
  PROTOBUF_NODISCARD std::string* release__related_pg_port();
  void set_allocated__related_pg_port(std::string* _related_pg_port);
  private:
  const std::string& _internal__related_pg_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__related_pg_port(const std::string& value);
  std::string* _internal_mutable__related_pg_port();
  public:

  // required string _when = 2;
  bool has__when() const;
  private:
  bool _internal_has__when() const;
  public:
  void clear__when();
  const std::string& _when() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__when(ArgT0&& arg0, ArgT... args);
  std::string* mutable__when();
  PROTOBUF_NODISCARD std::string* release__when();
  void set_allocated__when(std::string* _when);
  private:
  const std::string& _internal__when() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__when(const std::string& value);
  std::string* _internal_mutable__when();
  public:

  // required double _value = 3;
  bool has__value() const;
  private:
  bool _internal_has__value() const;
  public:
  void clear__value();
  double _value() const;
  void set__value(double value);
  private:
  double _internal__value() const;
  void _internal_set__value(double value);
  public:

  // required uint64 _owner_cell = 4;
  bool has__owner_cell() const;
  private:
  bool _internal_has__owner_cell() const;
  public:
  void clear__owner_cell();
  uint64_t _owner_cell() const;
  void set__owner_cell(uint64_t value);
  private:
  uint64_t _internal__owner_cell() const;
  void _internal_set__owner_cell(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyLeakagePowerClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _related_pg_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _when_;
    double _value_;
    uint64_t _owner_cell_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyCellClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyCellClass) */ {
 public:
  inline LibertyCellClass() : LibertyCellClass(nullptr) {}
  ~LibertyCellClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyCellClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyCellClass(const LibertyCellClass& from);
  LibertyCellClass(LibertyCellClass&& from) noexcept
    : LibertyCellClass() {
    *this = ::std::move(from);
  }

  inline LibertyCellClass& operator=(const LibertyCellClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyCellClass& operator=(LibertyCellClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyCellClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyCellClass* internal_default_instance() {
    return reinterpret_cast<const LibertyCellClass*>(
               &_LibertyCellClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(LibertyCellClass& a, LibertyCellClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyCellClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyCellClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyCellClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyCellClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyCellClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyCellClass& from) {
    LibertyCellClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyCellClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyCellClass";
  }
  protected:
  explicit LibertyCellClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeakagePowerListFieldNumber = 3,
    kCellPortsFieldNumber = 4,
    kCellPortBusesFieldNumber = 5,
    kCellArcsFieldNumber = 6,
    kCellPowerArcsFieldNumber = 7,
    kCellNameFieldNumber = 1,
    kCellLeakagePowerFieldNumber = 2,
    kOwnerLibFieldNumber = 8,
    kIsDontUseFieldNumber = 9,
  };
  // repeated uint64 _leakage_power_list = 3;
  int _leakage_power_list_size() const;
  private:
  int _internal__leakage_power_list_size() const;
  public:
  void clear__leakage_power_list();
  private:
  uint64_t _internal__leakage_power_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__leakage_power_list() const;
  void _internal_add__leakage_power_list(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__leakage_power_list();
  public:
  uint64_t _leakage_power_list(int index) const;
  void set__leakage_power_list(int index, uint64_t value);
  void add__leakage_power_list(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _leakage_power_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__leakage_power_list();

  // repeated uint64 _cell_ports = 4;
  int _cell_ports_size() const;
  private:
  int _internal__cell_ports_size() const;
  public:
  void clear__cell_ports();
  private:
  uint64_t _internal__cell_ports(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__cell_ports() const;
  void _internal_add__cell_ports(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__cell_ports();
  public:
  uint64_t _cell_ports(int index) const;
  void set__cell_ports(int index, uint64_t value);
  void add__cell_ports(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _cell_ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__cell_ports();

  // repeated uint64 _cell_port_buses = 5;
  int _cell_port_buses_size() const;
  private:
  int _internal__cell_port_buses_size() const;
  public:
  void clear__cell_port_buses();
  private:
  uint64_t _internal__cell_port_buses(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__cell_port_buses() const;
  void _internal_add__cell_port_buses(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__cell_port_buses();
  public:
  uint64_t _cell_port_buses(int index) const;
  void set__cell_port_buses(int index, uint64_t value);
  void add__cell_port_buses(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _cell_port_buses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__cell_port_buses();

  // repeated uint64 _cell_arcs = 6;
  int _cell_arcs_size() const;
  private:
  int _internal__cell_arcs_size() const;
  public:
  void clear__cell_arcs();
  private:
  uint64_t _internal__cell_arcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__cell_arcs() const;
  void _internal_add__cell_arcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__cell_arcs();
  public:
  uint64_t _cell_arcs(int index) const;
  void set__cell_arcs(int index, uint64_t value);
  void add__cell_arcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _cell_arcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__cell_arcs();

  // repeated uint64 _cell_power_arcs = 7;
  int _cell_power_arcs_size() const;
  private:
  int _internal__cell_power_arcs_size() const;
  public:
  void clear__cell_power_arcs();
  private:
  uint64_t _internal__cell_power_arcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__cell_power_arcs() const;
  void _internal_add__cell_power_arcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__cell_power_arcs();
  public:
  uint64_t _cell_power_arcs(int index) const;
  void set__cell_power_arcs(int index, uint64_t value);
  void add__cell_power_arcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _cell_power_arcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__cell_power_arcs();

  // required string _cell_name = 1;
  bool has__cell_name() const;
  private:
  bool _internal_has__cell_name() const;
  public:
  void clear__cell_name();
  const std::string& _cell_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__cell_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__cell_name();
  PROTOBUF_NODISCARD std::string* release__cell_name();
  void set_allocated__cell_name(std::string* _cell_name);
  private:
  const std::string& _internal__cell_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__cell_name(const std::string& value);
  std::string* _internal_mutable__cell_name();
  public:

  // required double _cell_leakage_power = 2;
  bool has__cell_leakage_power() const;
  private:
  bool _internal_has__cell_leakage_power() const;
  public:
  void clear__cell_leakage_power();
  double _cell_leakage_power() const;
  void set__cell_leakage_power(double value);
  private:
  double _internal__cell_leakage_power() const;
  void _internal_set__cell_leakage_power(double value);
  public:

  // required uint64 _owner_lib = 8;
  bool has__owner_lib() const;
  private:
  bool _internal_has__owner_lib() const;
  public:
  void clear__owner_lib();
  uint64_t _owner_lib() const;
  void set__owner_lib(uint64_t value);
  private:
  uint64_t _internal__owner_lib() const;
  void _internal_set__owner_lib(uint64_t value);
  public:

  // required uint32 _is_dont_use = 9;
  bool has__is_dont_use() const;
  private:
  bool _internal_has__is_dont_use() const;
  public:
  void clear__is_dont_use();
  uint32_t _is_dont_use() const;
  void set__is_dont_use(uint32_t value);
  private:
  uint32_t _internal__is_dont_use() const;
  void _internal_set__is_dont_use(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyCellClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _leakage_power_list_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _cell_ports_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _cell_port_buses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _cell_arcs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _cell_power_arcs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _cell_name_;
    double _cell_leakage_power_;
    uint64_t _owner_lib_;
    uint32_t _is_dont_use_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse, 
    int32_t, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse, 
    int32_t, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse& other);
  static const LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse*>(&_LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_LibertyReader_2eproto;
};

// -------------------------------------------------------------------

class LibertyWireLoadClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyWireLoadClass) */ {
 public:
  inline LibertyWireLoadClass() : LibertyWireLoadClass(nullptr) {}
  ~LibertyWireLoadClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyWireLoadClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyWireLoadClass(const LibertyWireLoadClass& from);
  LibertyWireLoadClass(LibertyWireLoadClass&& from) noexcept
    : LibertyWireLoadClass() {
    *this = ::std::move(from);
  }

  inline LibertyWireLoadClass& operator=(const LibertyWireLoadClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyWireLoadClass& operator=(LibertyWireLoadClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyWireLoadClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyWireLoadClass* internal_default_instance() {
    return reinterpret_cast<const LibertyWireLoadClass*>(
               &_LibertyWireLoadClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(LibertyWireLoadClass& a, LibertyWireLoadClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyWireLoadClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyWireLoadClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyWireLoadClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyWireLoadClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyWireLoadClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyWireLoadClass& from) {
    LibertyWireLoadClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyWireLoadClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyWireLoadClass";
  }
  protected:
  explicit LibertyWireLoadClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFanoutToLengthFieldNumber = 2,
    kWireLoadNameFieldNumber = 1,
    kCapPerLengthUnitFieldNumber = 3,
    kResistancePerLengthUnitFieldNumber = 4,
    kSlopeFieldNumber = 5,
  };
  // map<int32, double> _fanout_to_length = 2;
  int _fanout_to_length_size() const;
  private:
  int _internal__fanout_to_length_size() const;
  public:
  void clear__fanout_to_length();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >&
      _internal__fanout_to_length() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >*
      _internal_mutable__fanout_to_length();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >&
      _fanout_to_length() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >*
      mutable__fanout_to_length();

  // required string _wire_load_name = 1;
  bool has__wire_load_name() const;
  private:
  bool _internal_has__wire_load_name() const;
  public:
  void clear__wire_load_name();
  const std::string& _wire_load_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__wire_load_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__wire_load_name();
  PROTOBUF_NODISCARD std::string* release__wire_load_name();
  void set_allocated__wire_load_name(std::string* _wire_load_name);
  private:
  const std::string& _internal__wire_load_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__wire_load_name(const std::string& value);
  std::string* _internal_mutable__wire_load_name();
  public:

  // optional double _cap_per_length_unit = 3;
  bool has__cap_per_length_unit() const;
  private:
  bool _internal_has__cap_per_length_unit() const;
  public:
  void clear__cap_per_length_unit();
  double _cap_per_length_unit() const;
  void set__cap_per_length_unit(double value);
  private:
  double _internal__cap_per_length_unit() const;
  void _internal_set__cap_per_length_unit(double value);
  public:

  // optional double _resistance_per_length_unit = 4;
  bool has__resistance_per_length_unit() const;
  private:
  bool _internal_has__resistance_per_length_unit() const;
  public:
  void clear__resistance_per_length_unit();
  double _resistance_per_length_unit() const;
  void set__resistance_per_length_unit(double value);
  private:
  double _internal__resistance_per_length_unit() const;
  void _internal_set__resistance_per_length_unit(double value);
  public:

  // optional double _slope = 5;
  bool has__slope() const;
  private:
  bool _internal_has__slope() const;
  public:
  void clear__slope();
  double _slope() const;
  void set__slope(double value);
  private:
  double _internal__slope() const;
  void _internal_set__slope(double value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyWireLoadClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LibertyWireLoadClass_FanoutToLengthEntry_DoNotUse,
        int32_t, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> _fanout_to_length_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _wire_load_name_;
    double _cap_per_length_unit_;
    double _resistance_per_length_unit_;
    double _slope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyLutTableTemplateClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyLutTableTemplateClass) */ {
 public:
  inline LibertyLutTableTemplateClass() : LibertyLutTableTemplateClass(nullptr) {}
  ~LibertyLutTableTemplateClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyLutTableTemplateClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyLutTableTemplateClass(const LibertyLutTableTemplateClass& from);
  LibertyLutTableTemplateClass(LibertyLutTableTemplateClass&& from) noexcept
    : LibertyLutTableTemplateClass() {
    *this = ::std::move(from);
  }

  inline LibertyLutTableTemplateClass& operator=(const LibertyLutTableTemplateClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyLutTableTemplateClass& operator=(LibertyLutTableTemplateClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyLutTableTemplateClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyLutTableTemplateClass* internal_default_instance() {
    return reinterpret_cast<const LibertyLutTableTemplateClass*>(
               &_LibertyLutTableTemplateClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LibertyLutTableTemplateClass& a, LibertyLutTableTemplateClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyLutTableTemplateClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyLutTableTemplateClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyLutTableTemplateClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyLutTableTemplateClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyLutTableTemplateClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyLutTableTemplateClass& from) {
    LibertyLutTableTemplateClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyLutTableTemplateClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyLutTableTemplateClass";
  }
  protected:
  explicit LibertyLutTableTemplateClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAxesFieldNumber = 6,
    kTemplateNameFieldNumber = 1,
    kTemplateVariable1FieldNumber = 2,
    kTemplateVariable2FieldNumber = 3,
    kTemplateVariable3FieldNumber = 4,
    kTemplateVariable4FieldNumber = 5,
  };
  // repeated uint64 _axes = 6;
  int _axes_size() const;
  private:
  int _internal__axes_size() const;
  public:
  void clear__axes();
  private:
  uint64_t _internal__axes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__axes() const;
  void _internal_add__axes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__axes();
  public:
  uint64_t _axes(int index) const;
  void set__axes(int index, uint64_t value);
  void add__axes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _axes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__axes();

  // required string _template_name = 1;
  bool has__template_name() const;
  private:
  bool _internal_has__template_name() const;
  public:
  void clear__template_name();
  const std::string& _template_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__template_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__template_name();
  PROTOBUF_NODISCARD std::string* release__template_name();
  void set_allocated__template_name(std::string* _template_name);
  private:
  const std::string& _internal__template_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__template_name(const std::string& value);
  std::string* _internal_mutable__template_name();
  public:

  // optional string _template_variable1 = 2;
  bool has__template_variable1() const;
  private:
  bool _internal_has__template_variable1() const;
  public:
  void clear__template_variable1();
  const std::string& _template_variable1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__template_variable1(ArgT0&& arg0, ArgT... args);
  std::string* mutable__template_variable1();
  PROTOBUF_NODISCARD std::string* release__template_variable1();
  void set_allocated__template_variable1(std::string* _template_variable1);
  private:
  const std::string& _internal__template_variable1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__template_variable1(const std::string& value);
  std::string* _internal_mutable__template_variable1();
  public:

  // optional string _template_variable2 = 3;
  bool has__template_variable2() const;
  private:
  bool _internal_has__template_variable2() const;
  public:
  void clear__template_variable2();
  const std::string& _template_variable2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__template_variable2(ArgT0&& arg0, ArgT... args);
  std::string* mutable__template_variable2();
  PROTOBUF_NODISCARD std::string* release__template_variable2();
  void set_allocated__template_variable2(std::string* _template_variable2);
  private:
  const std::string& _internal__template_variable2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__template_variable2(const std::string& value);
  std::string* _internal_mutable__template_variable2();
  public:

  // optional string _template_variable3 = 4;
  bool has__template_variable3() const;
  private:
  bool _internal_has__template_variable3() const;
  public:
  void clear__template_variable3();
  const std::string& _template_variable3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__template_variable3(ArgT0&& arg0, ArgT... args);
  std::string* mutable__template_variable3();
  PROTOBUF_NODISCARD std::string* release__template_variable3();
  void set_allocated__template_variable3(std::string* _template_variable3);
  private:
  const std::string& _internal__template_variable3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__template_variable3(const std::string& value);
  std::string* _internal_mutable__template_variable3();
  public:

  // optional string _template_variable4 = 5;
  bool has__template_variable4() const;
  private:
  bool _internal_has__template_variable4() const;
  public:
  void clear__template_variable4();
  const std::string& _template_variable4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__template_variable4(ArgT0&& arg0, ArgT... args);
  std::string* mutable__template_variable4();
  PROTOBUF_NODISCARD std::string* release__template_variable4();
  void set_allocated__template_variable4(std::string* _template_variable4);
  private:
  const std::string& _internal__template_variable4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__template_variable4(const std::string& value);
  std::string* _internal_mutable__template_variable4();
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyLutTableTemplateClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _axes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _template_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _template_variable1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _template_variable2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _template_variable3_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _template_variable4_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyCurrentTemplateClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyCurrentTemplateClass) */ {
 public:
  inline LibertyCurrentTemplateClass() : LibertyCurrentTemplateClass(nullptr) {}
  ~LibertyCurrentTemplateClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyCurrentTemplateClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyCurrentTemplateClass(const LibertyCurrentTemplateClass& from);
  LibertyCurrentTemplateClass(LibertyCurrentTemplateClass&& from) noexcept
    : LibertyCurrentTemplateClass() {
    *this = ::std::move(from);
  }

  inline LibertyCurrentTemplateClass& operator=(const LibertyCurrentTemplateClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyCurrentTemplateClass& operator=(LibertyCurrentTemplateClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyCurrentTemplateClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyCurrentTemplateClass* internal_default_instance() {
    return reinterpret_cast<const LibertyCurrentTemplateClass*>(
               &_LibertyCurrentTemplateClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LibertyCurrentTemplateClass& a, LibertyCurrentTemplateClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyCurrentTemplateClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyCurrentTemplateClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyCurrentTemplateClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyCurrentTemplateClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyCurrentTemplateClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyCurrentTemplateClass& from) {
    LibertyCurrentTemplateClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyCurrentTemplateClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyCurrentTemplateClass";
  }
  protected:
  explicit LibertyCurrentTemplateClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemplateAxisFieldNumber = 1,
  };
  // optional uint64 _template_axis = 1;
  bool has__template_axis() const;
  private:
  bool _internal_has__template_axis() const;
  public:
  void clear__template_axis();
  uint64_t _template_axis() const;
  void set__template_axis(uint64_t value);
  private:
  uint64_t _internal__template_axis() const;
  void _internal_set__template_axis(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyCurrentTemplateClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t _template_axis_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyLutTableTemplateSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyLutTableTemplateSyn) */ {
 public:
  inline LibertyLutTableTemplateSyn() : LibertyLutTableTemplateSyn(nullptr) {}
  ~LibertyLutTableTemplateSyn() override;
  explicit PROTOBUF_CONSTEXPR LibertyLutTableTemplateSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyLutTableTemplateSyn(const LibertyLutTableTemplateSyn& from);
  LibertyLutTableTemplateSyn(LibertyLutTableTemplateSyn&& from) noexcept
    : LibertyLutTableTemplateSyn() {
    *this = ::std::move(from);
  }

  inline LibertyLutTableTemplateSyn& operator=(const LibertyLutTableTemplateSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyLutTableTemplateSyn& operator=(LibertyLutTableTemplateSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyLutTableTemplateSyn& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyLutTableTemplateSyn* internal_default_instance() {
    return reinterpret_cast<const LibertyLutTableTemplateSyn*>(
               &_LibertyLutTableTemplateSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(LibertyLutTableTemplateSyn& a, LibertyLutTableTemplateSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyLutTableTemplateSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyLutTableTemplateSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyLutTableTemplateSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyLutTableTemplateSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyLutTableTemplateSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyLutTableTemplateSyn& from) {
    LibertyLutTableTemplateSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyLutTableTemplateSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyLutTableTemplateSyn";
  }
  protected:
  explicit LibertyLutTableTemplateSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 2,
    kLctcFieldNumber = 3,
    kLlttsTypeFieldNumber = 1,
  };
  // required .Liberty.LibertyLutTableTemplateClass parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Liberty::LibertyLutTableTemplateClass& parent() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyLutTableTemplateClass* release_parent();
  ::Liberty::LibertyLutTableTemplateClass* mutable_parent();
  void set_allocated_parent(::Liberty::LibertyLutTableTemplateClass* parent);
  private:
  const ::Liberty::LibertyLutTableTemplateClass& _internal_parent() const;
  ::Liberty::LibertyLutTableTemplateClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Liberty::LibertyLutTableTemplateClass* parent);
  ::Liberty::LibertyLutTableTemplateClass* unsafe_arena_release_parent();

  // optional .Liberty.LibertyCurrentTemplateClass lctc = 3;
  bool has_lctc() const;
  private:
  bool _internal_has_lctc() const;
  public:
  void clear_lctc();
  const ::Liberty::LibertyCurrentTemplateClass& lctc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyCurrentTemplateClass* release_lctc();
  ::Liberty::LibertyCurrentTemplateClass* mutable_lctc();
  void set_allocated_lctc(::Liberty::LibertyCurrentTemplateClass* lctc);
  private:
  const ::Liberty::LibertyCurrentTemplateClass& _internal_lctc() const;
  ::Liberty::LibertyCurrentTemplateClass* _internal_mutable_lctc();
  public:
  void unsafe_arena_set_allocated_lctc(
      ::Liberty::LibertyCurrentTemplateClass* lctc);
  ::Liberty::LibertyCurrentTemplateClass* unsafe_arena_release_lctc();

  // required uint32 lltts_type = 1;
  bool has_lltts_type() const;
  private:
  bool _internal_has_lltts_type() const;
  public:
  void clear_lltts_type();
  uint32_t lltts_type() const;
  void set_lltts_type(uint32_t value);
  private:
  uint32_t _internal_lltts_type() const;
  void _internal_set_lltts_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyLutTableTemplateSyn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Liberty::LibertyLutTableTemplateClass* parent_;
    ::Liberty::LibertyCurrentTemplateClass* lctc_;
    uint32_t lltts_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyObjectSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyObjectSyn) */ {
 public:
  inline LibertyObjectSyn() : LibertyObjectSyn(nullptr) {}
  ~LibertyObjectSyn() override;
  explicit PROTOBUF_CONSTEXPR LibertyObjectSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyObjectSyn(const LibertyObjectSyn& from);
  LibertyObjectSyn(LibertyObjectSyn&& from) noexcept
    : LibertyObjectSyn() {
    *this = ::std::move(from);
  }

  inline LibertyObjectSyn& operator=(const LibertyObjectSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyObjectSyn& operator=(LibertyObjectSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyObjectSyn& default_instance() {
    return *internal_default_instance();
  }
  enum LosCase {
    kLaxc = 4,
    kLts = 5,
    kLccstc = 6,
    kLtms = 7,
    kLps = 8,
    kLtc = 9,
    kLlpc = 10,
    kLarc = 11,
    kLpac = 12,
    kLcc = 13,
    kLwlc = 14,
    kLltts = 15,
    LOS_NOT_SET = 0,
  };

  static inline const LibertyObjectSyn* internal_default_instance() {
    return reinterpret_cast<const LibertyObjectSyn*>(
               &_LibertyObjectSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(LibertyObjectSyn& a, LibertyObjectSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyObjectSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyObjectSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyObjectSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyObjectSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyObjectSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyObjectSyn& from) {
    LibertyObjectSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyObjectSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyObjectSyn";
  }
  protected:
  explicit LibertyObjectSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kLosTypeFieldNumber = 2,
    kLaxcFieldNumber = 4,
    kLtsFieldNumber = 5,
    kLccstcFieldNumber = 6,
    kLtmsFieldNumber = 7,
    kLpsFieldNumber = 8,
    kLtcFieldNumber = 9,
    kLlpcFieldNumber = 10,
    kLarcFieldNumber = 11,
    kLpacFieldNumber = 12,
    kLccFieldNumber = 13,
    kLwlcFieldNumber = 14,
    kLlttsFieldNumber = 15,
  };
  // required .Liberty.LibertyObjectClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Liberty::LibertyObjectClass& parent() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyObjectClass* release_parent();
  ::Liberty::LibertyObjectClass* mutable_parent();
  void set_allocated_parent(::Liberty::LibertyObjectClass* parent);
  private:
  const ::Liberty::LibertyObjectClass& _internal_parent() const;
  ::Liberty::LibertyObjectClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Liberty::LibertyObjectClass* parent);
  ::Liberty::LibertyObjectClass* unsafe_arena_release_parent();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 los_type = 2;
  bool has_los_type() const;
  private:
  bool _internal_has_los_type() const;
  public:
  void clear_los_type();
  uint32_t los_type() const;
  void set_los_type(uint32_t value);
  private:
  uint32_t _internal_los_type() const;
  void _internal_set_los_type(uint32_t value);
  public:

  // .Liberty.LibertyAxisClass laxc = 4;
  bool has_laxc() const;
  private:
  bool _internal_has_laxc() const;
  public:
  void clear_laxc();
  const ::Liberty::LibertyAxisClass& laxc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyAxisClass* release_laxc();
  ::Liberty::LibertyAxisClass* mutable_laxc();
  void set_allocated_laxc(::Liberty::LibertyAxisClass* laxc);
  private:
  const ::Liberty::LibertyAxisClass& _internal_laxc() const;
  ::Liberty::LibertyAxisClass* _internal_mutable_laxc();
  public:
  void unsafe_arena_set_allocated_laxc(
      ::Liberty::LibertyAxisClass* laxc);
  ::Liberty::LibertyAxisClass* unsafe_arena_release_laxc();

  // .Liberty.LibertyTableSyn lts = 5;
  bool has_lts() const;
  private:
  bool _internal_has_lts() const;
  public:
  void clear_lts();
  const ::Liberty::LibertyTableSyn& lts() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyTableSyn* release_lts();
  ::Liberty::LibertyTableSyn* mutable_lts();
  void set_allocated_lts(::Liberty::LibertyTableSyn* lts);
  private:
  const ::Liberty::LibertyTableSyn& _internal_lts() const;
  ::Liberty::LibertyTableSyn* _internal_mutable_lts();
  public:
  void unsafe_arena_set_allocated_lts(
      ::Liberty::LibertyTableSyn* lts);
  ::Liberty::LibertyTableSyn* unsafe_arena_release_lts();

  // .Liberty.LibertyCCSTableClass lccstc = 6;
  bool has_lccstc() const;
  private:
  bool _internal_has_lccstc() const;
  public:
  void clear_lccstc();
  const ::Liberty::LibertyCCSTableClass& lccstc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyCCSTableClass* release_lccstc();
  ::Liberty::LibertyCCSTableClass* mutable_lccstc();
  void set_allocated_lccstc(::Liberty::LibertyCCSTableClass* lccstc);
  private:
  const ::Liberty::LibertyCCSTableClass& _internal_lccstc() const;
  ::Liberty::LibertyCCSTableClass* _internal_mutable_lccstc();
  public:
  void unsafe_arena_set_allocated_lccstc(
      ::Liberty::LibertyCCSTableClass* lccstc);
  ::Liberty::LibertyCCSTableClass* unsafe_arena_release_lccstc();

  // .Liberty.LibertyTableModelSyn ltms = 7;
  bool has_ltms() const;
  private:
  bool _internal_has_ltms() const;
  public:
  void clear_ltms();
  const ::Liberty::LibertyTableModelSyn& ltms() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyTableModelSyn* release_ltms();
  ::Liberty::LibertyTableModelSyn* mutable_ltms();
  void set_allocated_ltms(::Liberty::LibertyTableModelSyn* ltms);
  private:
  const ::Liberty::LibertyTableModelSyn& _internal_ltms() const;
  ::Liberty::LibertyTableModelSyn* _internal_mutable_ltms();
  public:
  void unsafe_arena_set_allocated_ltms(
      ::Liberty::LibertyTableModelSyn* ltms);
  ::Liberty::LibertyTableModelSyn* unsafe_arena_release_ltms();

  // .Liberty.LibertyPortSyn lps = 8;
  bool has_lps() const;
  private:
  bool _internal_has_lps() const;
  public:
  void clear_lps();
  const ::Liberty::LibertyPortSyn& lps() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyPortSyn* release_lps();
  ::Liberty::LibertyPortSyn* mutable_lps();
  void set_allocated_lps(::Liberty::LibertyPortSyn* lps);
  private:
  const ::Liberty::LibertyPortSyn& _internal_lps() const;
  ::Liberty::LibertyPortSyn* _internal_mutable_lps();
  public:
  void unsafe_arena_set_allocated_lps(
      ::Liberty::LibertyPortSyn* lps);
  ::Liberty::LibertyPortSyn* unsafe_arena_release_lps();

  // .Liberty.LibertyTypeClass ltc = 9;
  bool has_ltc() const;
  private:
  bool _internal_has_ltc() const;
  public:
  void clear_ltc();
  const ::Liberty::LibertyTypeClass& ltc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyTypeClass* release_ltc();
  ::Liberty::LibertyTypeClass* mutable_ltc();
  void set_allocated_ltc(::Liberty::LibertyTypeClass* ltc);
  private:
  const ::Liberty::LibertyTypeClass& _internal_ltc() const;
  ::Liberty::LibertyTypeClass* _internal_mutable_ltc();
  public:
  void unsafe_arena_set_allocated_ltc(
      ::Liberty::LibertyTypeClass* ltc);
  ::Liberty::LibertyTypeClass* unsafe_arena_release_ltc();

  // .Liberty.LibertyLeakagePowerClass llpc = 10;
  bool has_llpc() const;
  private:
  bool _internal_has_llpc() const;
  public:
  void clear_llpc();
  const ::Liberty::LibertyLeakagePowerClass& llpc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyLeakagePowerClass* release_llpc();
  ::Liberty::LibertyLeakagePowerClass* mutable_llpc();
  void set_allocated_llpc(::Liberty::LibertyLeakagePowerClass* llpc);
  private:
  const ::Liberty::LibertyLeakagePowerClass& _internal_llpc() const;
  ::Liberty::LibertyLeakagePowerClass* _internal_mutable_llpc();
  public:
  void unsafe_arena_set_allocated_llpc(
      ::Liberty::LibertyLeakagePowerClass* llpc);
  ::Liberty::LibertyLeakagePowerClass* unsafe_arena_release_llpc();

  // .Liberty.LibertyArcClass larc = 11;
  bool has_larc() const;
  private:
  bool _internal_has_larc() const;
  public:
  void clear_larc();
  const ::Liberty::LibertyArcClass& larc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyArcClass* release_larc();
  ::Liberty::LibertyArcClass* mutable_larc();
  void set_allocated_larc(::Liberty::LibertyArcClass* larc);
  private:
  const ::Liberty::LibertyArcClass& _internal_larc() const;
  ::Liberty::LibertyArcClass* _internal_mutable_larc();
  public:
  void unsafe_arena_set_allocated_larc(
      ::Liberty::LibertyArcClass* larc);
  ::Liberty::LibertyArcClass* unsafe_arena_release_larc();

  // .Liberty.LibertyPowerArcClass lpac = 12;
  bool has_lpac() const;
  private:
  bool _internal_has_lpac() const;
  public:
  void clear_lpac();
  const ::Liberty::LibertyPowerArcClass& lpac() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyPowerArcClass* release_lpac();
  ::Liberty::LibertyPowerArcClass* mutable_lpac();
  void set_allocated_lpac(::Liberty::LibertyPowerArcClass* lpac);
  private:
  const ::Liberty::LibertyPowerArcClass& _internal_lpac() const;
  ::Liberty::LibertyPowerArcClass* _internal_mutable_lpac();
  public:
  void unsafe_arena_set_allocated_lpac(
      ::Liberty::LibertyPowerArcClass* lpac);
  ::Liberty::LibertyPowerArcClass* unsafe_arena_release_lpac();

  // .Liberty.LibertyCellClass lcc = 13;
  bool has_lcc() const;
  private:
  bool _internal_has_lcc() const;
  public:
  void clear_lcc();
  const ::Liberty::LibertyCellClass& lcc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyCellClass* release_lcc();
  ::Liberty::LibertyCellClass* mutable_lcc();
  void set_allocated_lcc(::Liberty::LibertyCellClass* lcc);
  private:
  const ::Liberty::LibertyCellClass& _internal_lcc() const;
  ::Liberty::LibertyCellClass* _internal_mutable_lcc();
  public:
  void unsafe_arena_set_allocated_lcc(
      ::Liberty::LibertyCellClass* lcc);
  ::Liberty::LibertyCellClass* unsafe_arena_release_lcc();

  // .Liberty.LibertyWireLoadClass lwlc = 14;
  bool has_lwlc() const;
  private:
  bool _internal_has_lwlc() const;
  public:
  void clear_lwlc();
  const ::Liberty::LibertyWireLoadClass& lwlc() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyWireLoadClass* release_lwlc();
  ::Liberty::LibertyWireLoadClass* mutable_lwlc();
  void set_allocated_lwlc(::Liberty::LibertyWireLoadClass* lwlc);
  private:
  const ::Liberty::LibertyWireLoadClass& _internal_lwlc() const;
  ::Liberty::LibertyWireLoadClass* _internal_mutable_lwlc();
  public:
  void unsafe_arena_set_allocated_lwlc(
      ::Liberty::LibertyWireLoadClass* lwlc);
  ::Liberty::LibertyWireLoadClass* unsafe_arena_release_lwlc();

  // .Liberty.LibertyLutTableTemplateSyn lltts = 15;
  bool has_lltts() const;
  private:
  bool _internal_has_lltts() const;
  public:
  void clear_lltts();
  const ::Liberty::LibertyLutTableTemplateSyn& lltts() const;
  PROTOBUF_NODISCARD ::Liberty::LibertyLutTableTemplateSyn* release_lltts();
  ::Liberty::LibertyLutTableTemplateSyn* mutable_lltts();
  void set_allocated_lltts(::Liberty::LibertyLutTableTemplateSyn* lltts);
  private:
  const ::Liberty::LibertyLutTableTemplateSyn& _internal_lltts() const;
  ::Liberty::LibertyLutTableTemplateSyn* _internal_mutable_lltts();
  public:
  void unsafe_arena_set_allocated_lltts(
      ::Liberty::LibertyLutTableTemplateSyn* lltts);
  ::Liberty::LibertyLutTableTemplateSyn* unsafe_arena_release_lltts();

  void clear_los();
  LosCase los_case() const;
  // @@protoc_insertion_point(class_scope:Liberty.LibertyObjectSyn)
 private:
  class _Internal;
  void set_has_laxc();
  void set_has_lts();
  void set_has_lccstc();
  void set_has_ltms();
  void set_has_lps();
  void set_has_ltc();
  void set_has_llpc();
  void set_has_larc();
  void set_has_lpac();
  void set_has_lcc();
  void set_has_lwlc();
  void set_has_lltts();

  inline bool has_los() const;
  inline void clear_has_los();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Liberty::LibertyObjectClass* parent_;
    uint64_t id_;
    uint32_t los_type_;
    union LosUnion {
      constexpr LosUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Liberty::LibertyAxisClass* laxc_;
      ::Liberty::LibertyTableSyn* lts_;
      ::Liberty::LibertyCCSTableClass* lccstc_;
      ::Liberty::LibertyTableModelSyn* ltms_;
      ::Liberty::LibertyPortSyn* lps_;
      ::Liberty::LibertyTypeClass* ltc_;
      ::Liberty::LibertyLeakagePowerClass* llpc_;
      ::Liberty::LibertyArcClass* larc_;
      ::Liberty::LibertyPowerArcClass* lpac_;
      ::Liberty::LibertyCellClass* lcc_;
      ::Liberty::LibertyWireLoadClass* lwlc_;
      ::Liberty::LibertyLutTableTemplateSyn* lltts_;
    } los_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyLibraryClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyLibraryClass) */ {
 public:
  inline LibertyLibraryClass() : LibertyLibraryClass(nullptr) {}
  ~LibertyLibraryClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyLibraryClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyLibraryClass(const LibertyLibraryClass& from);
  LibertyLibraryClass(LibertyLibraryClass&& from) noexcept
    : LibertyLibraryClass() {
    *this = ::std::move(from);
  }

  inline LibertyLibraryClass& operator=(const LibertyLibraryClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyLibraryClass& operator=(LibertyLibraryClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyLibraryClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyLibraryClass* internal_default_instance() {
    return reinterpret_cast<const LibertyLibraryClass*>(
               &_LibertyLibraryClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(LibertyLibraryClass& a, LibertyLibraryClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyLibraryClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyLibraryClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyLibraryClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyLibraryClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyLibraryClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyLibraryClass& from) {
    LibertyLibraryClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyLibraryClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyLibraryClass";
  }
  protected:
  explicit LibertyLibraryClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellsFieldNumber = 3,
    kLutTemplateFieldNumber = 4,
    kWireLoadsFieldNumber = 5,
    kTypesFieldNumber = 6,
    kLibNameFieldNumber = 2,
    kDefaultWireLoadFieldNumber = 12,
    kCapUnitFieldNumber = 7,
    kResistanceUnitFieldNumber = 8,
    kIdFieldNumber = 1,
    kDefaultMaxTransitionFieldNumber = 9,
    kDefaultMaxFanoutFieldNumber = 10,
    kDefaultFanoutLoadFieldNumber = 11,
  };
  // repeated uint64 _cells = 3;
  int _cells_size() const;
  private:
  int _internal__cells_size() const;
  public:
  void clear__cells();
  private:
  uint64_t _internal__cells(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__cells() const;
  void _internal_add__cells(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__cells();
  public:
  uint64_t _cells(int index) const;
  void set__cells(int index, uint64_t value);
  void add__cells(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _cells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__cells();

  // repeated uint64 _lut_template = 4;
  int _lut_template_size() const;
  private:
  int _internal__lut_template_size() const;
  public:
  void clear__lut_template();
  private:
  uint64_t _internal__lut_template(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__lut_template() const;
  void _internal_add__lut_template(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__lut_template();
  public:
  uint64_t _lut_template(int index) const;
  void set__lut_template(int index, uint64_t value);
  void add__lut_template(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _lut_template() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__lut_template();

  // repeated uint64 _wire_loads = 5;
  int _wire_loads_size() const;
  private:
  int _internal__wire_loads_size() const;
  public:
  void clear__wire_loads();
  private:
  uint64_t _internal__wire_loads(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__wire_loads() const;
  void _internal_add__wire_loads(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__wire_loads();
  public:
  uint64_t _wire_loads(int index) const;
  void set__wire_loads(int index, uint64_t value);
  void add__wire_loads(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _wire_loads() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__wire_loads();

  // repeated uint64 _types = 6;
  int _types_size() const;
  private:
  int _internal__types_size() const;
  public:
  void clear__types();
  private:
  uint64_t _internal__types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__types() const;
  void _internal_add__types(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__types();
  public:
  uint64_t _types(int index) const;
  void set__types(int index, uint64_t value);
  void add__types(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__types();

  // required string _lib_name = 2;
  bool has__lib_name() const;
  private:
  bool _internal_has__lib_name() const;
  public:
  void clear__lib_name();
  const std::string& _lib_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__lib_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__lib_name();
  PROTOBUF_NODISCARD std::string* release__lib_name();
  void set_allocated__lib_name(std::string* _lib_name);
  private:
  const std::string& _internal__lib_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__lib_name(const std::string& value);
  std::string* _internal_mutable__lib_name();
  public:

  // required string _default_wire_load = 12;
  bool has__default_wire_load() const;
  private:
  bool _internal_has__default_wire_load() const;
  public:
  void clear__default_wire_load();
  const std::string& _default_wire_load() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__default_wire_load(ArgT0&& arg0, ArgT... args);
  std::string* mutable__default_wire_load();
  PROTOBUF_NODISCARD std::string* release__default_wire_load();
  void set_allocated__default_wire_load(std::string* _default_wire_load);
  private:
  const std::string& _internal__default_wire_load() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__default_wire_load(const std::string& value);
  std::string* _internal_mutable__default_wire_load();
  public:

  // required .Common.Types.CapacitiveUnitEnum _cap_unit = 7;
  bool has__cap_unit() const;
  private:
  bool _internal_has__cap_unit() const;
  public:
  void clear__cap_unit();
  const ::Common::Types::CapacitiveUnitEnum& _cap_unit() const;
  PROTOBUF_NODISCARD ::Common::Types::CapacitiveUnitEnum* release__cap_unit();
  ::Common::Types::CapacitiveUnitEnum* mutable__cap_unit();
  void set_allocated__cap_unit(::Common::Types::CapacitiveUnitEnum* _cap_unit);
  private:
  const ::Common::Types::CapacitiveUnitEnum& _internal__cap_unit() const;
  ::Common::Types::CapacitiveUnitEnum* _internal_mutable__cap_unit();
  public:
  void unsafe_arena_set_allocated__cap_unit(
      ::Common::Types::CapacitiveUnitEnum* _cap_unit);
  ::Common::Types::CapacitiveUnitEnum* unsafe_arena_release__cap_unit();

  // required .Common.Types.ResistanceUnitEnum _resistance_unit = 8;
  bool has__resistance_unit() const;
  private:
  bool _internal_has__resistance_unit() const;
  public:
  void clear__resistance_unit();
  const ::Common::Types::ResistanceUnitEnum& _resistance_unit() const;
  PROTOBUF_NODISCARD ::Common::Types::ResistanceUnitEnum* release__resistance_unit();
  ::Common::Types::ResistanceUnitEnum* mutable__resistance_unit();
  void set_allocated__resistance_unit(::Common::Types::ResistanceUnitEnum* _resistance_unit);
  private:
  const ::Common::Types::ResistanceUnitEnum& _internal__resistance_unit() const;
  ::Common::Types::ResistanceUnitEnum* _internal_mutable__resistance_unit();
  public:
  void unsafe_arena_set_allocated__resistance_unit(
      ::Common::Types::ResistanceUnitEnum* _resistance_unit);
  ::Common::Types::ResistanceUnitEnum* unsafe_arena_release__resistance_unit();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional double _default_max_transition = 9;
  bool has__default_max_transition() const;
  private:
  bool _internal_has__default_max_transition() const;
  public:
  void clear__default_max_transition();
  double _default_max_transition() const;
  void set__default_max_transition(double value);
  private:
  double _internal__default_max_transition() const;
  void _internal_set__default_max_transition(double value);
  public:

  // optional double _default_max_fanout = 10;
  bool has__default_max_fanout() const;
  private:
  bool _internal_has__default_max_fanout() const;
  public:
  void clear__default_max_fanout();
  double _default_max_fanout() const;
  void set__default_max_fanout(double value);
  private:
  double _internal__default_max_fanout() const;
  void _internal_set__default_max_fanout(double value);
  public:

  // optional double _default_fanout_load = 11;
  bool has__default_fanout_load() const;
  private:
  bool _internal_has__default_fanout_load() const;
  public:
  void clear__default_fanout_load();
  double _default_fanout_load() const;
  void set__default_fanout_load(double value);
  private:
  double _internal__default_fanout_load() const;
  void _internal_set__default_fanout_load(double value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyLibraryClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _cells_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _lut_template_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _wire_loads_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _lib_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _default_wire_load_;
    ::Common::Types::CapacitiveUnitEnum* _cap_unit_;
    ::Common::Types::ResistanceUnitEnum* _resistance_unit_;
    uint64_t id_;
    double _default_max_transition_;
    double _default_max_fanout_;
    double _default_fanout_load_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyOwnPortTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyOwnPortTypeEnum) */ {
 public:
  inline LibertyOwnPortTypeEnum() : LibertyOwnPortTypeEnum(nullptr) {}
  ~LibertyOwnPortTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR LibertyOwnPortTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyOwnPortTypeEnum(const LibertyOwnPortTypeEnum& from);
  LibertyOwnPortTypeEnum(LibertyOwnPortTypeEnum&& from) noexcept
    : LibertyOwnPortTypeEnum() {
    *this = ::std::move(from);
  }

  inline LibertyOwnPortTypeEnum& operator=(const LibertyOwnPortTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyOwnPortTypeEnum& operator=(LibertyOwnPortTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyOwnPortTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyOwnPortTypeEnum* internal_default_instance() {
    return reinterpret_cast<const LibertyOwnPortTypeEnum*>(
               &_LibertyOwnPortTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(LibertyOwnPortTypeEnum& a, LibertyOwnPortTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyOwnPortTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyOwnPortTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyOwnPortTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyOwnPortTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyOwnPortTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyOwnPortTypeEnum& from) {
    LibertyOwnPortTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyOwnPortTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyOwnPortTypeEnum";
  }
  protected:
  explicit LibertyOwnPortTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortType;
  static constexpr LibertyOwnPortType kTimingArc =
    LibertyOwnPortTypeEnum_LibertyOwnPortType_kTimingArc;
  static constexpr LibertyOwnPortType kPowerArc =
    LibertyOwnPortTypeEnum_LibertyOwnPortType_kPowerArc;
  static inline bool LibertyOwnPortType_IsValid(int value) {
    return LibertyOwnPortTypeEnum_LibertyOwnPortType_IsValid(value);
  }
  static constexpr LibertyOwnPortType LibertyOwnPortType_MIN =
    LibertyOwnPortTypeEnum_LibertyOwnPortType_LibertyOwnPortType_MIN;
  static constexpr LibertyOwnPortType LibertyOwnPortType_MAX =
    LibertyOwnPortTypeEnum_LibertyOwnPortType_LibertyOwnPortType_MAX;
  static constexpr int LibertyOwnPortType_ARRAYSIZE =
    LibertyOwnPortTypeEnum_LibertyOwnPortType_LibertyOwnPortType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LibertyOwnPortType_descriptor() {
    return LibertyOwnPortTypeEnum_LibertyOwnPortType_descriptor();
  }
  template<typename T>
  static inline const std::string& LibertyOwnPortType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LibertyOwnPortType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LibertyOwnPortType_Name.");
    return LibertyOwnPortTypeEnum_LibertyOwnPortType_Name(enum_t_value);
  }
  static inline bool LibertyOwnPortType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LibertyOwnPortType* value) {
    return LibertyOwnPortTypeEnum_LibertyOwnPortType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoptFieldNumber = 1,
  };
  // required .Liberty.LibertyOwnPortTypeEnum.LibertyOwnPortType lopt = 1;
  bool has_lopt() const;
  private:
  bool _internal_has_lopt() const;
  public:
  void clear_lopt();
  ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType lopt() const;
  void set_lopt(::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType value);
  private:
  ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType _internal_lopt() const;
  void _internal_set_lopt(::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyOwnPortTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int lopt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyOwnPgOrWhenTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyOwnPgOrWhenTypeEnum) */ {
 public:
  inline LibertyOwnPgOrWhenTypeEnum() : LibertyOwnPgOrWhenTypeEnum(nullptr) {}
  ~LibertyOwnPgOrWhenTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR LibertyOwnPgOrWhenTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyOwnPgOrWhenTypeEnum(const LibertyOwnPgOrWhenTypeEnum& from);
  LibertyOwnPgOrWhenTypeEnum(LibertyOwnPgOrWhenTypeEnum&& from) noexcept
    : LibertyOwnPgOrWhenTypeEnum() {
    *this = ::std::move(from);
  }

  inline LibertyOwnPgOrWhenTypeEnum& operator=(const LibertyOwnPgOrWhenTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyOwnPgOrWhenTypeEnum& operator=(LibertyOwnPgOrWhenTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyOwnPgOrWhenTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyOwnPgOrWhenTypeEnum* internal_default_instance() {
    return reinterpret_cast<const LibertyOwnPgOrWhenTypeEnum*>(
               &_LibertyOwnPgOrWhenTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(LibertyOwnPgOrWhenTypeEnum& a, LibertyOwnPgOrWhenTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyOwnPgOrWhenTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyOwnPgOrWhenTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyOwnPgOrWhenTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyOwnPgOrWhenTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyOwnPgOrWhenTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyOwnPgOrWhenTypeEnum& from) {
    LibertyOwnPgOrWhenTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyOwnPgOrWhenTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyOwnPgOrWhenTypeEnum";
  }
  protected:
  explicit LibertyOwnPgOrWhenTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenType;
  static constexpr LibertyOwnPgOrWhenType kLibertyLeakagePower =
    LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_kLibertyLeakagePower;
  static constexpr LibertyOwnPgOrWhenType kPowerArc =
    LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_kPowerArc;
  static inline bool LibertyOwnPgOrWhenType_IsValid(int value) {
    return LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_IsValid(value);
  }
  static constexpr LibertyOwnPgOrWhenType LibertyOwnPgOrWhenType_MIN =
    LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_LibertyOwnPgOrWhenType_MIN;
  static constexpr LibertyOwnPgOrWhenType LibertyOwnPgOrWhenType_MAX =
    LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_LibertyOwnPgOrWhenType_MAX;
  static constexpr int LibertyOwnPgOrWhenType_ARRAYSIZE =
    LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_LibertyOwnPgOrWhenType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LibertyOwnPgOrWhenType_descriptor() {
    return LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_descriptor();
  }
  template<typename T>
  static inline const std::string& LibertyOwnPgOrWhenType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LibertyOwnPgOrWhenType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LibertyOwnPgOrWhenType_Name.");
    return LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_Name(enum_t_value);
  }
  static inline bool LibertyOwnPgOrWhenType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LibertyOwnPgOrWhenType* value) {
    return LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLopowtFieldNumber = 1,
  };
  // required .Liberty.LibertyOwnPgOrWhenTypeEnum.LibertyOwnPgOrWhenType lopowt = 1;
  bool has_lopowt() const;
  private:
  bool _internal_has_lopowt() const;
  public:
  void clear_lopowt();
  ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType lopowt() const;
  void set_lopowt(::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType value);
  private:
  ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType _internal_lopowt() const;
  void _internal_set_lopowt(::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyOwnPgOrWhenTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int lopowt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyBuilderClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyBuilderClass) */ {
 public:
  inline LibertyBuilderClass() : LibertyBuilderClass(nullptr) {}
  ~LibertyBuilderClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyBuilderClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyBuilderClass(const LibertyBuilderClass& from);
  LibertyBuilderClass(LibertyBuilderClass&& from) noexcept
    : LibertyBuilderClass() {
    *this = ::std::move(from);
  }

  inline LibertyBuilderClass& operator=(const LibertyBuilderClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyBuilderClass& operator=(LibertyBuilderClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyBuilderClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyBuilderClass* internal_default_instance() {
    return reinterpret_cast<const LibertyBuilderClass*>(
               &_LibertyBuilderClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(LibertyBuilderClass& a, LibertyBuilderClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyBuilderClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyBuilderClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyBuilderClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyBuilderClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyBuilderClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyBuilderClass& from) {
    LibertyBuilderClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyBuilderClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyBuilderClass";
  }
  protected:
  explicit LibertyBuilderClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLibFieldNumber = 2,
  };
  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint64 _lib = 2;
  bool has__lib() const;
  private:
  bool _internal_has__lib() const;
  public:
  void clear__lib();
  uint64_t _lib() const;
  void set__lib(uint64_t value);
  private:
  uint64_t _internal__lib() const;
  void _internal_set__lib(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyBuilderClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t id_;
    uint64_t _lib_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// -------------------------------------------------------------------

class LibertyReaderClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Liberty.LibertyReaderClass) */ {
 public:
  inline LibertyReaderClass() : LibertyReaderClass(nullptr) {}
  ~LibertyReaderClass() override;
  explicit PROTOBUF_CONSTEXPR LibertyReaderClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibertyReaderClass(const LibertyReaderClass& from);
  LibertyReaderClass(LibertyReaderClass&& from) noexcept
    : LibertyReaderClass() {
    *this = ::std::move(from);
  }

  inline LibertyReaderClass& operator=(const LibertyReaderClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibertyReaderClass& operator=(LibertyReaderClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibertyReaderClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibertyReaderClass* internal_default_instance() {
    return reinterpret_cast<const LibertyReaderClass*>(
               &_LibertyReaderClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(LibertyReaderClass& a, LibertyReaderClass& b) {
    a.Swap(&b);
  }
  inline void Swap(LibertyReaderClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibertyReaderClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibertyReaderClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibertyReaderClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibertyReaderClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibertyReaderClass& from) {
    LibertyReaderClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibertyReaderClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Liberty.LibertyReaderClass";
  }
  protected:
  explicit LibertyReaderClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kIdFieldNumber = 1,
    kLibraryGroupFieldNumber = 2,
    kLibertyBuilderFieldNumber = 4,
  };
  // required string _file_name = 3;
  bool has__file_name() const;
  private:
  bool _internal_has__file_name() const;
  public:
  void clear__file_name();
  const std::string& _file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__file_name();
  PROTOBUF_NODISCARD std::string* release__file_name();
  void set_allocated__file_name(std::string* _file_name);
  private:
  const std::string& _internal__file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__file_name(const std::string& value);
  std::string* _internal_mutable__file_name();
  public:

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint64 _library_group = 2;
  bool has__library_group() const;
  private:
  bool _internal_has__library_group() const;
  public:
  void clear__library_group();
  uint64_t _library_group() const;
  void set__library_group(uint64_t value);
  private:
  uint64_t _internal__library_group() const;
  void _internal_set__library_group(uint64_t value);
  public:

  // required uint64 _liberty_builder = 4;
  bool has__liberty_builder() const;
  private:
  bool _internal_has__liberty_builder() const;
  public:
  void clear__liberty_builder();
  uint64_t _liberty_builder() const;
  void set__liberty_builder(uint64_t value);
  private:
  uint64_t _internal__liberty_builder() const;
  void _internal_set__liberty_builder(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Liberty.LibertyReaderClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _file_name_;
    uint64_t id_;
    uint64_t _library_group_;
    uint64_t _liberty_builder_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LibertyReader_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LibertyExprOperatorEnum

// required .Liberty.LibertyExprOperatorEnum.Operator o = 1;
inline bool LibertyExprOperatorEnum::_internal_has_o() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyExprOperatorEnum::has_o() const {
  return _internal_has_o();
}
inline void LibertyExprOperatorEnum::clear_o() {
  _impl_.o_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Liberty::LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::_internal_o() const {
  return static_cast< ::Liberty::LibertyExprOperatorEnum_Operator >(_impl_.o_);
}
inline ::Liberty::LibertyExprOperatorEnum_Operator LibertyExprOperatorEnum::o() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyExprOperatorEnum.o)
  return _internal_o();
}
inline void LibertyExprOperatorEnum::_internal_set_o(::Liberty::LibertyExprOperatorEnum_Operator value) {
  assert(::Liberty::LibertyExprOperatorEnum_Operator_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.o_ = value;
}
inline void LibertyExprOperatorEnum::set_o(::Liberty::LibertyExprOperatorEnum_Operator value) {
  _internal_set_o(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyExprOperatorEnum.o)
}

// -------------------------------------------------------------------

// LibertyExprClass

// required uint64 id = 1;
inline bool LibertyExprClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyExprClass::has_id() const {
  return _internal_has_id();
}
inline void LibertyExprClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t LibertyExprClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyExprClass::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyExprClass.id)
  return _internal_id();
}
inline void LibertyExprClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}
inline void LibertyExprClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyExprClass.id)
}

// required .Liberty.LibertyExprOperatorEnum _op = 2;
inline bool LibertyExprClass::_internal_has__op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._op_ != nullptr);
  return value;
}
inline bool LibertyExprClass::has__op() const {
  return _internal_has__op();
}
inline void LibertyExprClass::clear__op() {
  if (_impl_._op_ != nullptr) _impl_._op_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Liberty::LibertyExprOperatorEnum& LibertyExprClass::_internal__op() const {
  const ::Liberty::LibertyExprOperatorEnum* p = _impl_._op_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyExprOperatorEnum&>(
      ::Liberty::_LibertyExprOperatorEnum_default_instance_);
}
inline const ::Liberty::LibertyExprOperatorEnum& LibertyExprClass::_op() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyExprClass._op)
  return _internal__op();
}
inline void LibertyExprClass::unsafe_arena_set_allocated__op(
    ::Liberty::LibertyExprOperatorEnum* _op) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._op_);
  }
  _impl_._op_ = _op;
  if (_op) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyExprClass._op)
}
inline ::Liberty::LibertyExprOperatorEnum* LibertyExprClass::release__op() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyExprOperatorEnum* temp = _impl_._op_;
  _impl_._op_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyExprOperatorEnum* LibertyExprClass::unsafe_arena_release__op() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyExprClass._op)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyExprOperatorEnum* temp = _impl_._op_;
  _impl_._op_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyExprOperatorEnum* LibertyExprClass::_internal_mutable__op() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_._op_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyExprOperatorEnum>(GetArenaForAllocation());
    _impl_._op_ = p;
  }
  return _impl_._op_;
}
inline ::Liberty::LibertyExprOperatorEnum* LibertyExprClass::mutable__op() {
  ::Liberty::LibertyExprOperatorEnum* _msg = _internal_mutable__op();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyExprClass._op)
  return _msg;
}
inline void LibertyExprClass::set_allocated__op(::Liberty::LibertyExprOperatorEnum* _op) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._op_;
  }
  if (_op) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_op);
    if (message_arena != submessage_arena) {
      _op = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _op, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._op_ = _op;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyExprClass._op)
}

// optional uint64 _left = 3;
inline bool LibertyExprClass::_internal_has__left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyExprClass::has__left() const {
  return _internal_has__left();
}
inline void LibertyExprClass::clear__left() {
  _impl_._left_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t LibertyExprClass::_internal__left() const {
  return _impl_._left_;
}
inline uint64_t LibertyExprClass::_left() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyExprClass._left)
  return _internal__left();
}
inline void LibertyExprClass::_internal_set__left(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._left_ = value;
}
inline void LibertyExprClass::set__left(uint64_t value) {
  _internal_set__left(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyExprClass._left)
}

// optional uint64 _right = 4;
inline bool LibertyExprClass::_internal_has__right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LibertyExprClass::has__right() const {
  return _internal_has__right();
}
inline void LibertyExprClass::clear__right() {
  _impl_._right_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t LibertyExprClass::_internal__right() const {
  return _impl_._right_;
}
inline uint64_t LibertyExprClass::_right() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyExprClass._right)
  return _internal__right();
}
inline void LibertyExprClass::_internal_set__right(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._right_ = value;
}
inline void LibertyExprClass::set__right(uint64_t value) {
  _internal_set__right(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyExprClass._right)
}

// optional bytes _port = 5;
inline bool LibertyExprClass::_internal_has__port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyExprClass::has__port() const {
  return _internal_has__port();
}
inline void LibertyExprClass::clear__port() {
  _impl_._port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyExprClass::_port() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyExprClass._port)
  return _internal__port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyExprClass::set__port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._port_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyExprClass._port)
}
inline std::string* LibertyExprClass::mutable__port() {
  std::string* _s = _internal_mutable__port();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyExprClass._port)
  return _s;
}
inline const std::string& LibertyExprClass::_internal__port() const {
  return _impl_._port_.Get();
}
inline void LibertyExprClass::_internal_set__port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._port_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyExprClass::_internal_mutable__port() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._port_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyExprClass::release__port() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyExprClass._port)
  if (!_internal_has__port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._port_.IsDefault()) {
    _impl_._port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyExprClass::set_allocated__port(std::string* _port) {
  if (_port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._port_.SetAllocated(_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._port_.IsDefault()) {
    _impl_._port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyExprClass._port)
}

// -------------------------------------------------------------------

// LibertyStmtClass

// required string _file_name = 1;
inline bool LibertyStmtClass::_internal_has__file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyStmtClass::has__file_name() const {
  return _internal_has__file_name();
}
inline void LibertyStmtClass::clear__file_name() {
  _impl_._file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyStmtClass::_file_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtClass._file_name)
  return _internal__file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyStmtClass::set__file_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyStmtClass._file_name)
}
inline std::string* LibertyStmtClass::mutable__file_name() {
  std::string* _s = _internal_mutable__file_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyStmtClass._file_name)
  return _s;
}
inline const std::string& LibertyStmtClass::_internal__file_name() const {
  return _impl_._file_name_.Get();
}
inline void LibertyStmtClass::_internal_set__file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyStmtClass::_internal_mutable__file_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyStmtClass::release__file_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyStmtClass._file_name)
  if (!_internal_has__file_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyStmtClass::set_allocated__file_name(std::string* _file_name) {
  if (_file_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._file_name_.SetAllocated(_file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyStmtClass._file_name)
}

// required uint32 _line_no = 2;
inline bool LibertyStmtClass::_internal_has__line_no() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyStmtClass::has__line_no() const {
  return _internal_has__line_no();
}
inline void LibertyStmtClass::clear__line_no() {
  _impl_._line_no_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t LibertyStmtClass::_internal__line_no() const {
  return _impl_._line_no_;
}
inline uint32_t LibertyStmtClass::_line_no() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtClass._line_no)
  return _internal__line_no();
}
inline void LibertyStmtClass::_internal_set__line_no(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._line_no_ = value;
}
inline void LibertyStmtClass::set__line_no(uint32_t value) {
  _internal_set__line_no(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyStmtClass._line_no)
}

// -------------------------------------------------------------------

// LibertySimpleAttrStmtClass

// required string _attri_name = 1;
inline bool LibertySimpleAttrStmtClass::_internal_has__attri_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertySimpleAttrStmtClass::has__attri_name() const {
  return _internal_has__attri_name();
}
inline void LibertySimpleAttrStmtClass::clear__attri_name() {
  _impl_._attri_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertySimpleAttrStmtClass::_attri_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertySimpleAttrStmtClass._attri_name)
  return _internal__attri_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertySimpleAttrStmtClass::set__attri_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._attri_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertySimpleAttrStmtClass._attri_name)
}
inline std::string* LibertySimpleAttrStmtClass::mutable__attri_name() {
  std::string* _s = _internal_mutable__attri_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertySimpleAttrStmtClass._attri_name)
  return _s;
}
inline const std::string& LibertySimpleAttrStmtClass::_internal__attri_name() const {
  return _impl_._attri_name_.Get();
}
inline void LibertySimpleAttrStmtClass::_internal_set__attri_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._attri_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertySimpleAttrStmtClass::_internal_mutable__attri_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._attri_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertySimpleAttrStmtClass::release__attri_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertySimpleAttrStmtClass._attri_name)
  if (!_internal_has__attri_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._attri_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._attri_name_.IsDefault()) {
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertySimpleAttrStmtClass::set_allocated__attri_name(std::string* _attri_name) {
  if (_attri_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._attri_name_.SetAllocated(_attri_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._attri_name_.IsDefault()) {
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertySimpleAttrStmtClass._attri_name)
}

// required uint32 lavs_type = 2;
inline bool LibertySimpleAttrStmtClass::_internal_has_lavs_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertySimpleAttrStmtClass::has_lavs_type() const {
  return _internal_has_lavs_type();
}
inline void LibertySimpleAttrStmtClass::clear_lavs_type() {
  _impl_.lavs_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LibertySimpleAttrStmtClass::_internal_lavs_type() const {
  return _impl_.lavs_type_;
}
inline uint32_t LibertySimpleAttrStmtClass::lavs_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertySimpleAttrStmtClass.lavs_type)
  return _internal_lavs_type();
}
inline void LibertySimpleAttrStmtClass::_internal_set_lavs_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lavs_type_ = value;
}
inline void LibertySimpleAttrStmtClass::set_lavs_type(uint32_t value) {
  _internal_set_lavs_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertySimpleAttrStmtClass.lavs_type)
}

// required .Common.Types.DoubleOrStr _attri_value = 3;
inline bool LibertySimpleAttrStmtClass::_internal_has__attri_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._attri_value_ != nullptr);
  return value;
}
inline bool LibertySimpleAttrStmtClass::has__attri_value() const {
  return _internal_has__attri_value();
}
inline const ::Common::Types::DoubleOrStr& LibertySimpleAttrStmtClass::_internal__attri_value() const {
  const ::Common::Types::DoubleOrStr* p = _impl_._attri_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::DoubleOrStr&>(
      ::Common::Types::_DoubleOrStr_default_instance_);
}
inline const ::Common::Types::DoubleOrStr& LibertySimpleAttrStmtClass::_attri_value() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertySimpleAttrStmtClass._attri_value)
  return _internal__attri_value();
}
inline void LibertySimpleAttrStmtClass::unsafe_arena_set_allocated__attri_value(
    ::Common::Types::DoubleOrStr* _attri_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._attri_value_);
  }
  _impl_._attri_value_ = _attri_value;
  if (_attri_value) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertySimpleAttrStmtClass._attri_value)
}
inline ::Common::Types::DoubleOrStr* LibertySimpleAttrStmtClass::release__attri_value() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Common::Types::DoubleOrStr* temp = _impl_._attri_value_;
  _impl_._attri_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::DoubleOrStr* LibertySimpleAttrStmtClass::unsafe_arena_release__attri_value() {
  // @@protoc_insertion_point(field_release:Liberty.LibertySimpleAttrStmtClass._attri_value)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Common::Types::DoubleOrStr* temp = _impl_._attri_value_;
  _impl_._attri_value_ = nullptr;
  return temp;
}
inline ::Common::Types::DoubleOrStr* LibertySimpleAttrStmtClass::_internal_mutable__attri_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_._attri_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::DoubleOrStr>(GetArenaForAllocation());
    _impl_._attri_value_ = p;
  }
  return _impl_._attri_value_;
}
inline ::Common::Types::DoubleOrStr* LibertySimpleAttrStmtClass::mutable__attri_value() {
  ::Common::Types::DoubleOrStr* _msg = _internal_mutable__attri_value();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertySimpleAttrStmtClass._attri_value)
  return _msg;
}
inline void LibertySimpleAttrStmtClass::set_allocated__attri_value(::Common::Types::DoubleOrStr* _attri_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._attri_value_);
  }
  if (_attri_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_attri_value));
    if (message_arena != submessage_arena) {
      _attri_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _attri_value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._attri_value_ = _attri_value;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertySimpleAttrStmtClass._attri_value)
}

// -------------------------------------------------------------------

// LibertyComplexAttrStmtClass

// required string _attri_name = 1;
inline bool LibertyComplexAttrStmtClass::_internal_has__attri_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyComplexAttrStmtClass::has__attri_name() const {
  return _internal_has__attri_name();
}
inline void LibertyComplexAttrStmtClass::clear__attri_name() {
  _impl_._attri_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyComplexAttrStmtClass::_attri_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyComplexAttrStmtClass._attri_name)
  return _internal__attri_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyComplexAttrStmtClass::set__attri_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._attri_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyComplexAttrStmtClass._attri_name)
}
inline std::string* LibertyComplexAttrStmtClass::mutable__attri_name() {
  std::string* _s = _internal_mutable__attri_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyComplexAttrStmtClass._attri_name)
  return _s;
}
inline const std::string& LibertyComplexAttrStmtClass::_internal__attri_name() const {
  return _impl_._attri_name_.Get();
}
inline void LibertyComplexAttrStmtClass::_internal_set__attri_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._attri_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyComplexAttrStmtClass::_internal_mutable__attri_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._attri_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyComplexAttrStmtClass::release__attri_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyComplexAttrStmtClass._attri_name)
  if (!_internal_has__attri_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._attri_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._attri_name_.IsDefault()) {
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyComplexAttrStmtClass::set_allocated__attri_name(std::string* _attri_name) {
  if (_attri_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._attri_name_.SetAllocated(_attri_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._attri_name_.IsDefault()) {
    _impl_._attri_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyComplexAttrStmtClass._attri_name)
}

// repeated uint32 lavs_type = 2;
inline int LibertyComplexAttrStmtClass::_internal_lavs_type_size() const {
  return _impl_.lavs_type_.size();
}
inline int LibertyComplexAttrStmtClass::lavs_type_size() const {
  return _internal_lavs_type_size();
}
inline void LibertyComplexAttrStmtClass::clear_lavs_type() {
  _impl_.lavs_type_.Clear();
}
inline uint32_t LibertyComplexAttrStmtClass::_internal_lavs_type(int index) const {
  return _impl_.lavs_type_.Get(index);
}
inline uint32_t LibertyComplexAttrStmtClass::lavs_type(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyComplexAttrStmtClass.lavs_type)
  return _internal_lavs_type(index);
}
inline void LibertyComplexAttrStmtClass::set_lavs_type(int index, uint32_t value) {
  _impl_.lavs_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyComplexAttrStmtClass.lavs_type)
}
inline void LibertyComplexAttrStmtClass::_internal_add_lavs_type(uint32_t value) {
  _impl_.lavs_type_.Add(value);
}
inline void LibertyComplexAttrStmtClass::add_lavs_type(uint32_t value) {
  _internal_add_lavs_type(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyComplexAttrStmtClass.lavs_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyComplexAttrStmtClass::_internal_lavs_type() const {
  return _impl_.lavs_type_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyComplexAttrStmtClass::lavs_type() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyComplexAttrStmtClass.lavs_type)
  return _internal_lavs_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyComplexAttrStmtClass::_internal_mutable_lavs_type() {
  return &_impl_.lavs_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyComplexAttrStmtClass::mutable_lavs_type() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyComplexAttrStmtClass.lavs_type)
  return _internal_mutable_lavs_type();
}

// repeated .Common.Types.DoubleOrStr _attri_values = 3;
inline int LibertyComplexAttrStmtClass::_internal__attri_values_size() const {
  return _impl_._attri_values_.size();
}
inline int LibertyComplexAttrStmtClass::_attri_values_size() const {
  return _internal__attri_values_size();
}
inline ::Common::Types::DoubleOrStr* LibertyComplexAttrStmtClass::mutable__attri_values(int index) {
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyComplexAttrStmtClass._attri_values)
  return _impl_._attri_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
LibertyComplexAttrStmtClass::mutable__attri_values() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyComplexAttrStmtClass._attri_values)
  return &_impl_._attri_values_;
}
inline const ::Common::Types::DoubleOrStr& LibertyComplexAttrStmtClass::_internal__attri_values(int index) const {
  return _impl_._attri_values_.Get(index);
}
inline const ::Common::Types::DoubleOrStr& LibertyComplexAttrStmtClass::_attri_values(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyComplexAttrStmtClass._attri_values)
  return _internal__attri_values(index);
}
inline ::Common::Types::DoubleOrStr* LibertyComplexAttrStmtClass::_internal_add__attri_values() {
  return _impl_._attri_values_.Add();
}
inline ::Common::Types::DoubleOrStr* LibertyComplexAttrStmtClass::add__attri_values() {
  ::Common::Types::DoubleOrStr* _add = _internal_add__attri_values();
  // @@protoc_insertion_point(field_add:Liberty.LibertyComplexAttrStmtClass._attri_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
LibertyComplexAttrStmtClass::_attri_values() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyComplexAttrStmtClass._attri_values)
  return _impl_._attri_values_;
}

// -------------------------------------------------------------------

// LibertyGroupStmtClass

// required string _group_name = 1;
inline bool LibertyGroupStmtClass::_internal_has__group_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyGroupStmtClass::has__group_name() const {
  return _internal_has__group_name();
}
inline void LibertyGroupStmtClass::clear__group_name() {
  _impl_._group_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyGroupStmtClass::_group_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyGroupStmtClass._group_name)
  return _internal__group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyGroupStmtClass::set__group_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyGroupStmtClass._group_name)
}
inline std::string* LibertyGroupStmtClass::mutable__group_name() {
  std::string* _s = _internal_mutable__group_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyGroupStmtClass._group_name)
  return _s;
}
inline const std::string& LibertyGroupStmtClass::_internal__group_name() const {
  return _impl_._group_name_.Get();
}
inline void LibertyGroupStmtClass::_internal_set__group_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyGroupStmtClass::_internal_mutable__group_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyGroupStmtClass::release__group_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyGroupStmtClass._group_name)
  if (!_internal_has__group_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._group_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._group_name_.IsDefault()) {
    _impl_._group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyGroupStmtClass::set_allocated__group_name(std::string* _group_name) {
  if (_group_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._group_name_.SetAllocated(_group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._group_name_.IsDefault()) {
    _impl_._group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyGroupStmtClass._group_name)
}

// repeated uint32 lavs_type = 2;
inline int LibertyGroupStmtClass::_internal_lavs_type_size() const {
  return _impl_.lavs_type_.size();
}
inline int LibertyGroupStmtClass::lavs_type_size() const {
  return _internal_lavs_type_size();
}
inline void LibertyGroupStmtClass::clear_lavs_type() {
  _impl_.lavs_type_.Clear();
}
inline uint32_t LibertyGroupStmtClass::_internal_lavs_type(int index) const {
  return _impl_.lavs_type_.Get(index);
}
inline uint32_t LibertyGroupStmtClass::lavs_type(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyGroupStmtClass.lavs_type)
  return _internal_lavs_type(index);
}
inline void LibertyGroupStmtClass::set_lavs_type(int index, uint32_t value) {
  _impl_.lavs_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyGroupStmtClass.lavs_type)
}
inline void LibertyGroupStmtClass::_internal_add_lavs_type(uint32_t value) {
  _impl_.lavs_type_.Add(value);
}
inline void LibertyGroupStmtClass::add_lavs_type(uint32_t value) {
  _internal_add_lavs_type(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyGroupStmtClass.lavs_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyGroupStmtClass::_internal_lavs_type() const {
  return _impl_.lavs_type_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyGroupStmtClass::lavs_type() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyGroupStmtClass.lavs_type)
  return _internal_lavs_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyGroupStmtClass::_internal_mutable_lavs_type() {
  return &_impl_.lavs_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyGroupStmtClass::mutable_lavs_type() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyGroupStmtClass.lavs_type)
  return _internal_mutable_lavs_type();
}

// repeated .Common.Types.DoubleOrStr _attri_values = 3;
inline int LibertyGroupStmtClass::_internal__attri_values_size() const {
  return _impl_._attri_values_.size();
}
inline int LibertyGroupStmtClass::_attri_values_size() const {
  return _internal__attri_values_size();
}
inline ::Common::Types::DoubleOrStr* LibertyGroupStmtClass::mutable__attri_values(int index) {
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyGroupStmtClass._attri_values)
  return _impl_._attri_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
LibertyGroupStmtClass::mutable__attri_values() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyGroupStmtClass._attri_values)
  return &_impl_._attri_values_;
}
inline const ::Common::Types::DoubleOrStr& LibertyGroupStmtClass::_internal__attri_values(int index) const {
  return _impl_._attri_values_.Get(index);
}
inline const ::Common::Types::DoubleOrStr& LibertyGroupStmtClass::_attri_values(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyGroupStmtClass._attri_values)
  return _internal__attri_values(index);
}
inline ::Common::Types::DoubleOrStr* LibertyGroupStmtClass::_internal_add__attri_values() {
  return _impl_._attri_values_.Add();
}
inline ::Common::Types::DoubleOrStr* LibertyGroupStmtClass::add__attri_values() {
  ::Common::Types::DoubleOrStr* _add = _internal_add__attri_values();
  // @@protoc_insertion_point(field_add:Liberty.LibertyGroupStmtClass._attri_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
LibertyGroupStmtClass::_attri_values() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyGroupStmtClass._attri_values)
  return _impl_._attri_values_;
}

// repeated uint64 _stmts = 5;
inline int LibertyGroupStmtClass::_internal__stmts_size() const {
  return _impl_._stmts_.size();
}
inline int LibertyGroupStmtClass::_stmts_size() const {
  return _internal__stmts_size();
}
inline void LibertyGroupStmtClass::clear__stmts() {
  _impl_._stmts_.Clear();
}
inline uint64_t LibertyGroupStmtClass::_internal__stmts(int index) const {
  return _impl_._stmts_.Get(index);
}
inline uint64_t LibertyGroupStmtClass::_stmts(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyGroupStmtClass._stmts)
  return _internal__stmts(index);
}
inline void LibertyGroupStmtClass::set__stmts(int index, uint64_t value) {
  _impl_._stmts_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyGroupStmtClass._stmts)
}
inline void LibertyGroupStmtClass::_internal_add__stmts(uint64_t value) {
  _impl_._stmts_.Add(value);
}
inline void LibertyGroupStmtClass::add__stmts(uint64_t value) {
  _internal_add__stmts(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyGroupStmtClass._stmts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyGroupStmtClass::_internal__stmts() const {
  return _impl_._stmts_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyGroupStmtClass::_stmts() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyGroupStmtClass._stmts)
  return _internal__stmts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyGroupStmtClass::_internal_mutable__stmts() {
  return &_impl_._stmts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyGroupStmtClass::mutable__stmts() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyGroupStmtClass._stmts)
  return _internal_mutable__stmts();
}

// -------------------------------------------------------------------

// LibertyStmtSyn

// required uint64 id = 1;
inline bool LibertyStmtSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyStmtSyn::has_id() const {
  return _internal_has_id();
}
inline void LibertyStmtSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t LibertyStmtSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyStmtSyn::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtSyn.id)
  return _internal_id();
}
inline void LibertyStmtSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void LibertyStmtSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyStmtSyn.id)
}

// required int32 lss_type = 2;
inline bool LibertyStmtSyn::_internal_has_lss_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyStmtSyn::has_lss_type() const {
  return _internal_has_lss_type();
}
inline void LibertyStmtSyn::clear_lss_type() {
  _impl_.lss_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t LibertyStmtSyn::_internal_lss_type() const {
  return _impl_.lss_type_;
}
inline int32_t LibertyStmtSyn::lss_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtSyn.lss_type)
  return _internal_lss_type();
}
inline void LibertyStmtSyn::_internal_set_lss_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lss_type_ = value;
}
inline void LibertyStmtSyn::set_lss_type(int32_t value) {
  _internal_set_lss_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyStmtSyn.lss_type)
}

// required .Liberty.LibertyStmtClass parent = 3;
inline bool LibertyStmtSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool LibertyStmtSyn::has_parent() const {
  return _internal_has_parent();
}
inline void LibertyStmtSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Liberty::LibertyStmtClass& LibertyStmtSyn::_internal_parent() const {
  const ::Liberty::LibertyStmtClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyStmtClass&>(
      ::Liberty::_LibertyStmtClass_default_instance_);
}
inline const ::Liberty::LibertyStmtClass& LibertyStmtSyn::parent() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtSyn.parent)
  return _internal_parent();
}
inline void LibertyStmtSyn::unsafe_arena_set_allocated_parent(
    ::Liberty::LibertyStmtClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyStmtSyn.parent)
}
inline ::Liberty::LibertyStmtClass* LibertyStmtSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyStmtClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyStmtClass* LibertyStmtSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyStmtSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyStmtClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyStmtClass* LibertyStmtSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyStmtClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Liberty::LibertyStmtClass* LibertyStmtSyn::mutable_parent() {
  ::Liberty::LibertyStmtClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyStmtSyn.parent)
  return _msg;
}
inline void LibertyStmtSyn::set_allocated_parent(::Liberty::LibertyStmtClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyStmtSyn.parent)
}

// .Liberty.LibertySimpleAttrStmtClass lsasc = 4;
inline bool LibertyStmtSyn::_internal_has_lsasc() const {
  return lss_case() == kLsasc;
}
inline bool LibertyStmtSyn::has_lsasc() const {
  return _internal_has_lsasc();
}
inline void LibertyStmtSyn::set_has_lsasc() {
  _impl_._oneof_case_[0] = kLsasc;
}
inline void LibertyStmtSyn::clear_lsasc() {
  if (_internal_has_lsasc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.lss_.lsasc_;
    }
    clear_has_lss();
  }
}
inline ::Liberty::LibertySimpleAttrStmtClass* LibertyStmtSyn::release_lsasc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyStmtSyn.lsasc)
  if (_internal_has_lsasc()) {
    clear_has_lss();
    ::Liberty::LibertySimpleAttrStmtClass* temp = _impl_.lss_.lsasc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.lss_.lsasc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertySimpleAttrStmtClass& LibertyStmtSyn::_internal_lsasc() const {
  return _internal_has_lsasc()
      ? *_impl_.lss_.lsasc_
      : reinterpret_cast< ::Liberty::LibertySimpleAttrStmtClass&>(::Liberty::_LibertySimpleAttrStmtClass_default_instance_);
}
inline const ::Liberty::LibertySimpleAttrStmtClass& LibertyStmtSyn::lsasc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtSyn.lsasc)
  return _internal_lsasc();
}
inline ::Liberty::LibertySimpleAttrStmtClass* LibertyStmtSyn::unsafe_arena_release_lsasc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyStmtSyn.lsasc)
  if (_internal_has_lsasc()) {
    clear_has_lss();
    ::Liberty::LibertySimpleAttrStmtClass* temp = _impl_.lss_.lsasc_;
    _impl_.lss_.lsasc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyStmtSyn::unsafe_arena_set_allocated_lsasc(::Liberty::LibertySimpleAttrStmtClass* lsasc) {
  clear_lss();
  if (lsasc) {
    set_has_lsasc();
    _impl_.lss_.lsasc_ = lsasc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyStmtSyn.lsasc)
}
inline ::Liberty::LibertySimpleAttrStmtClass* LibertyStmtSyn::_internal_mutable_lsasc() {
  if (!_internal_has_lsasc()) {
    clear_lss();
    set_has_lsasc();
    _impl_.lss_.lsasc_ = CreateMaybeMessage< ::Liberty::LibertySimpleAttrStmtClass >(GetArenaForAllocation());
  }
  return _impl_.lss_.lsasc_;
}
inline ::Liberty::LibertySimpleAttrStmtClass* LibertyStmtSyn::mutable_lsasc() {
  ::Liberty::LibertySimpleAttrStmtClass* _msg = _internal_mutable_lsasc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyStmtSyn.lsasc)
  return _msg;
}

// .Liberty.LibertyComplexAttrStmtClass lcasc = 5;
inline bool LibertyStmtSyn::_internal_has_lcasc() const {
  return lss_case() == kLcasc;
}
inline bool LibertyStmtSyn::has_lcasc() const {
  return _internal_has_lcasc();
}
inline void LibertyStmtSyn::set_has_lcasc() {
  _impl_._oneof_case_[0] = kLcasc;
}
inline void LibertyStmtSyn::clear_lcasc() {
  if (_internal_has_lcasc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.lss_.lcasc_;
    }
    clear_has_lss();
  }
}
inline ::Liberty::LibertyComplexAttrStmtClass* LibertyStmtSyn::release_lcasc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyStmtSyn.lcasc)
  if (_internal_has_lcasc()) {
    clear_has_lss();
    ::Liberty::LibertyComplexAttrStmtClass* temp = _impl_.lss_.lcasc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.lss_.lcasc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyComplexAttrStmtClass& LibertyStmtSyn::_internal_lcasc() const {
  return _internal_has_lcasc()
      ? *_impl_.lss_.lcasc_
      : reinterpret_cast< ::Liberty::LibertyComplexAttrStmtClass&>(::Liberty::_LibertyComplexAttrStmtClass_default_instance_);
}
inline const ::Liberty::LibertyComplexAttrStmtClass& LibertyStmtSyn::lcasc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtSyn.lcasc)
  return _internal_lcasc();
}
inline ::Liberty::LibertyComplexAttrStmtClass* LibertyStmtSyn::unsafe_arena_release_lcasc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyStmtSyn.lcasc)
  if (_internal_has_lcasc()) {
    clear_has_lss();
    ::Liberty::LibertyComplexAttrStmtClass* temp = _impl_.lss_.lcasc_;
    _impl_.lss_.lcasc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyStmtSyn::unsafe_arena_set_allocated_lcasc(::Liberty::LibertyComplexAttrStmtClass* lcasc) {
  clear_lss();
  if (lcasc) {
    set_has_lcasc();
    _impl_.lss_.lcasc_ = lcasc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyStmtSyn.lcasc)
}
inline ::Liberty::LibertyComplexAttrStmtClass* LibertyStmtSyn::_internal_mutable_lcasc() {
  if (!_internal_has_lcasc()) {
    clear_lss();
    set_has_lcasc();
    _impl_.lss_.lcasc_ = CreateMaybeMessage< ::Liberty::LibertyComplexAttrStmtClass >(GetArenaForAllocation());
  }
  return _impl_.lss_.lcasc_;
}
inline ::Liberty::LibertyComplexAttrStmtClass* LibertyStmtSyn::mutable_lcasc() {
  ::Liberty::LibertyComplexAttrStmtClass* _msg = _internal_mutable_lcasc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyStmtSyn.lcasc)
  return _msg;
}

// .Liberty.LibertyGroupStmtClass lgsc = 6;
inline bool LibertyStmtSyn::_internal_has_lgsc() const {
  return lss_case() == kLgsc;
}
inline bool LibertyStmtSyn::has_lgsc() const {
  return _internal_has_lgsc();
}
inline void LibertyStmtSyn::set_has_lgsc() {
  _impl_._oneof_case_[0] = kLgsc;
}
inline void LibertyStmtSyn::clear_lgsc() {
  if (_internal_has_lgsc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.lss_.lgsc_;
    }
    clear_has_lss();
  }
}
inline ::Liberty::LibertyGroupStmtClass* LibertyStmtSyn::release_lgsc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyStmtSyn.lgsc)
  if (_internal_has_lgsc()) {
    clear_has_lss();
    ::Liberty::LibertyGroupStmtClass* temp = _impl_.lss_.lgsc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.lss_.lgsc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyGroupStmtClass& LibertyStmtSyn::_internal_lgsc() const {
  return _internal_has_lgsc()
      ? *_impl_.lss_.lgsc_
      : reinterpret_cast< ::Liberty::LibertyGroupStmtClass&>(::Liberty::_LibertyGroupStmtClass_default_instance_);
}
inline const ::Liberty::LibertyGroupStmtClass& LibertyStmtSyn::lgsc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyStmtSyn.lgsc)
  return _internal_lgsc();
}
inline ::Liberty::LibertyGroupStmtClass* LibertyStmtSyn::unsafe_arena_release_lgsc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyStmtSyn.lgsc)
  if (_internal_has_lgsc()) {
    clear_has_lss();
    ::Liberty::LibertyGroupStmtClass* temp = _impl_.lss_.lgsc_;
    _impl_.lss_.lgsc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyStmtSyn::unsafe_arena_set_allocated_lgsc(::Liberty::LibertyGroupStmtClass* lgsc) {
  clear_lss();
  if (lgsc) {
    set_has_lgsc();
    _impl_.lss_.lgsc_ = lgsc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyStmtSyn.lgsc)
}
inline ::Liberty::LibertyGroupStmtClass* LibertyStmtSyn::_internal_mutable_lgsc() {
  if (!_internal_has_lgsc()) {
    clear_lss();
    set_has_lgsc();
    _impl_.lss_.lgsc_ = CreateMaybeMessage< ::Liberty::LibertyGroupStmtClass >(GetArenaForAllocation());
  }
  return _impl_.lss_.lgsc_;
}
inline ::Liberty::LibertyGroupStmtClass* LibertyStmtSyn::mutable_lgsc() {
  ::Liberty::LibertyGroupStmtClass* _msg = _internal_mutable_lgsc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyStmtSyn.lgsc)
  return _msg;
}

inline bool LibertyStmtSyn::has_lss() const {
  return lss_case() != LSS_NOT_SET;
}
inline void LibertyStmtSyn::clear_has_lss() {
  _impl_._oneof_case_[0] = LSS_NOT_SET;
}
inline LibertyStmtSyn::LssCase LibertyStmtSyn::lss_case() const {
  return LibertyStmtSyn::LssCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LibertyObjectClass

// optional string _file_name = 1;
inline bool LibertyObjectClass::_internal_has__file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyObjectClass::has__file_name() const {
  return _internal_has__file_name();
}
inline void LibertyObjectClass::clear__file_name() {
  _impl_._file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyObjectClass::_file_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectClass._file_name)
  return _internal__file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyObjectClass::set__file_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyObjectClass._file_name)
}
inline std::string* LibertyObjectClass::mutable__file_name() {
  std::string* _s = _internal_mutable__file_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectClass._file_name)
  return _s;
}
inline const std::string& LibertyObjectClass::_internal__file_name() const {
  return _impl_._file_name_.Get();
}
inline void LibertyObjectClass::_internal_set__file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyObjectClass::_internal_mutable__file_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyObjectClass::release__file_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectClass._file_name)
  if (!_internal_has__file_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyObjectClass::set_allocated__file_name(std::string* _file_name) {
  if (_file_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._file_name_.SetAllocated(_file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectClass._file_name)
}

// optional uint32 _line_no = 2;
inline bool LibertyObjectClass::_internal_has__line_no() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyObjectClass::has__line_no() const {
  return _internal_has__line_no();
}
inline void LibertyObjectClass::clear__line_no() {
  _impl_._line_no_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t LibertyObjectClass::_internal__line_no() const {
  return _impl_._line_no_;
}
inline uint32_t LibertyObjectClass::_line_no() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectClass._line_no)
  return _internal__line_no();
}
inline void LibertyObjectClass::_internal_set__line_no(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._line_no_ = value;
}
inline void LibertyObjectClass::set__line_no(uint32_t value) {
  _internal_set__line_no(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyObjectClass._line_no)
}

// -------------------------------------------------------------------

// LibertyAxisClass

// required string _axis_name = 1;
inline bool LibertyAxisClass::_internal_has__axis_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyAxisClass::has__axis_name() const {
  return _internal_has__axis_name();
}
inline void LibertyAxisClass::clear__axis_name() {
  _impl_._axis_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyAxisClass::_axis_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyAxisClass._axis_name)
  return _internal__axis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyAxisClass::set__axis_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._axis_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyAxisClass._axis_name)
}
inline std::string* LibertyAxisClass::mutable__axis_name() {
  std::string* _s = _internal_mutable__axis_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyAxisClass._axis_name)
  return _s;
}
inline const std::string& LibertyAxisClass::_internal__axis_name() const {
  return _impl_._axis_name_.Get();
}
inline void LibertyAxisClass::_internal_set__axis_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._axis_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyAxisClass::_internal_mutable__axis_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._axis_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyAxisClass::release__axis_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyAxisClass._axis_name)
  if (!_internal_has__axis_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._axis_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._axis_name_.IsDefault()) {
    _impl_._axis_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyAxisClass::set_allocated__axis_name(std::string* _axis_name) {
  if (_axis_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._axis_name_.SetAllocated(_axis_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._axis_name_.IsDefault()) {
    _impl_._axis_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyAxisClass._axis_name)
}

// repeated uint32 lavs_type = 2;
inline int LibertyAxisClass::_internal_lavs_type_size() const {
  return _impl_.lavs_type_.size();
}
inline int LibertyAxisClass::lavs_type_size() const {
  return _internal_lavs_type_size();
}
inline void LibertyAxisClass::clear_lavs_type() {
  _impl_.lavs_type_.Clear();
}
inline uint32_t LibertyAxisClass::_internal_lavs_type(int index) const {
  return _impl_.lavs_type_.Get(index);
}
inline uint32_t LibertyAxisClass::lavs_type(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyAxisClass.lavs_type)
  return _internal_lavs_type(index);
}
inline void LibertyAxisClass::set_lavs_type(int index, uint32_t value) {
  _impl_.lavs_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyAxisClass.lavs_type)
}
inline void LibertyAxisClass::_internal_add_lavs_type(uint32_t value) {
  _impl_.lavs_type_.Add(value);
}
inline void LibertyAxisClass::add_lavs_type(uint32_t value) {
  _internal_add_lavs_type(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyAxisClass.lavs_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyAxisClass::_internal_lavs_type() const {
  return _impl_.lavs_type_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyAxisClass::lavs_type() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyAxisClass.lavs_type)
  return _internal_lavs_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyAxisClass::_internal_mutable_lavs_type() {
  return &_impl_.lavs_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyAxisClass::mutable_lavs_type() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyAxisClass.lavs_type)
  return _internal_mutable_lavs_type();
}

// repeated .Common.Types.DoubleOrStr _axis_values = 3;
inline int LibertyAxisClass::_internal__axis_values_size() const {
  return _impl_._axis_values_.size();
}
inline int LibertyAxisClass::_axis_values_size() const {
  return _internal__axis_values_size();
}
inline ::Common::Types::DoubleOrStr* LibertyAxisClass::mutable__axis_values(int index) {
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyAxisClass._axis_values)
  return _impl_._axis_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
LibertyAxisClass::mutable__axis_values() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyAxisClass._axis_values)
  return &_impl_._axis_values_;
}
inline const ::Common::Types::DoubleOrStr& LibertyAxisClass::_internal__axis_values(int index) const {
  return _impl_._axis_values_.Get(index);
}
inline const ::Common::Types::DoubleOrStr& LibertyAxisClass::_axis_values(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyAxisClass._axis_values)
  return _internal__axis_values(index);
}
inline ::Common::Types::DoubleOrStr* LibertyAxisClass::_internal_add__axis_values() {
  return _impl_._axis_values_.Add();
}
inline ::Common::Types::DoubleOrStr* LibertyAxisClass::add__axis_values() {
  ::Common::Types::DoubleOrStr* _add = _internal_add__axis_values();
  // @@protoc_insertion_point(field_add:Liberty.LibertyAxisClass._axis_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
LibertyAxisClass::_axis_values() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyAxisClass._axis_values)
  return _impl_._axis_values_;
}

// -------------------------------------------------------------------

// LibertyTableTypeEnum

// required .Liberty.LibertyTableTypeEnum.TableType tt = 1;
inline bool LibertyTableTypeEnum::_internal_has_tt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyTableTypeEnum::has_tt() const {
  return _internal_has_tt();
}
inline void LibertyTableTypeEnum::clear_tt() {
  _impl_.tt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Liberty::LibertyTableTypeEnum_TableType LibertyTableTypeEnum::_internal_tt() const {
  return static_cast< ::Liberty::LibertyTableTypeEnum_TableType >(_impl_.tt_);
}
inline ::Liberty::LibertyTableTypeEnum_TableType LibertyTableTypeEnum::tt() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableTypeEnum.tt)
  return _internal_tt();
}
inline void LibertyTableTypeEnum::_internal_set_tt(::Liberty::LibertyTableTypeEnum_TableType value) {
  assert(::Liberty::LibertyTableTypeEnum_TableType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tt_ = value;
}
inline void LibertyTableTypeEnum::set_tt(::Liberty::LibertyTableTypeEnum_TableType value) {
  _internal_set_tt(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableTypeEnum.tt)
}

// -------------------------------------------------------------------

// LibertyTableClass

// repeated uint64 _axes = 1;
inline int LibertyTableClass::_internal__axes_size() const {
  return _impl_._axes_.size();
}
inline int LibertyTableClass::_axes_size() const {
  return _internal__axes_size();
}
inline void LibertyTableClass::clear__axes() {
  _impl_._axes_.Clear();
}
inline uint64_t LibertyTableClass::_internal__axes(int index) const {
  return _impl_._axes_.Get(index);
}
inline uint64_t LibertyTableClass::_axes(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableClass._axes)
  return _internal__axes(index);
}
inline void LibertyTableClass::set__axes(int index, uint64_t value) {
  _impl_._axes_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableClass._axes)
}
inline void LibertyTableClass::_internal_add__axes(uint64_t value) {
  _impl_._axes_.Add(value);
}
inline void LibertyTableClass::add__axes(uint64_t value) {
  _internal_add__axes(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyTableClass._axes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyTableClass::_internal__axes() const {
  return _impl_._axes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyTableClass::_axes() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyTableClass._axes)
  return _internal__axes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyTableClass::_internal_mutable__axes() {
  return &_impl_._axes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyTableClass::mutable__axes() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyTableClass._axes)
  return _internal_mutable__axes();
}

// repeated uint32 lavs_type = 2;
inline int LibertyTableClass::_internal_lavs_type_size() const {
  return _impl_.lavs_type_.size();
}
inline int LibertyTableClass::lavs_type_size() const {
  return _internal_lavs_type_size();
}
inline void LibertyTableClass::clear_lavs_type() {
  _impl_.lavs_type_.Clear();
}
inline uint32_t LibertyTableClass::_internal_lavs_type(int index) const {
  return _impl_.lavs_type_.Get(index);
}
inline uint32_t LibertyTableClass::lavs_type(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableClass.lavs_type)
  return _internal_lavs_type(index);
}
inline void LibertyTableClass::set_lavs_type(int index, uint32_t value) {
  _impl_.lavs_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableClass.lavs_type)
}
inline void LibertyTableClass::_internal_add_lavs_type(uint32_t value) {
  _impl_.lavs_type_.Add(value);
}
inline void LibertyTableClass::add_lavs_type(uint32_t value) {
  _internal_add_lavs_type(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyTableClass.lavs_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyTableClass::_internal_lavs_type() const {
  return _impl_.lavs_type_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
LibertyTableClass::lavs_type() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyTableClass.lavs_type)
  return _internal_lavs_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyTableClass::_internal_mutable_lavs_type() {
  return &_impl_.lavs_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
LibertyTableClass::mutable_lavs_type() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyTableClass.lavs_type)
  return _internal_mutable_lavs_type();
}

// repeated .Common.Types.DoubleOrStr _table_values = 3;
inline int LibertyTableClass::_internal__table_values_size() const {
  return _impl_._table_values_.size();
}
inline int LibertyTableClass::_table_values_size() const {
  return _internal__table_values_size();
}
inline ::Common::Types::DoubleOrStr* LibertyTableClass::mutable__table_values(int index) {
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTableClass._table_values)
  return _impl_._table_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >*
LibertyTableClass::mutable__table_values() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyTableClass._table_values)
  return &_impl_._table_values_;
}
inline const ::Common::Types::DoubleOrStr& LibertyTableClass::_internal__table_values(int index) const {
  return _impl_._table_values_.Get(index);
}
inline const ::Common::Types::DoubleOrStr& LibertyTableClass::_table_values(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableClass._table_values)
  return _internal__table_values(index);
}
inline ::Common::Types::DoubleOrStr* LibertyTableClass::_internal_add__table_values() {
  return _impl_._table_values_.Add();
}
inline ::Common::Types::DoubleOrStr* LibertyTableClass::add__table_values() {
  ::Common::Types::DoubleOrStr* _add = _internal_add__table_values();
  // @@protoc_insertion_point(field_add:Liberty.LibertyTableClass._table_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::DoubleOrStr >&
LibertyTableClass::_table_values() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyTableClass._table_values)
  return _impl_._table_values_;
}

// required .Liberty.LibertyTableTypeEnum _table_type = 4;
inline bool LibertyTableClass::_internal_has__table_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._table_type_ != nullptr);
  return value;
}
inline bool LibertyTableClass::has__table_type() const {
  return _internal_has__table_type();
}
inline void LibertyTableClass::clear__table_type() {
  if (_impl_._table_type_ != nullptr) _impl_._table_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Liberty::LibertyTableTypeEnum& LibertyTableClass::_internal__table_type() const {
  const ::Liberty::LibertyTableTypeEnum* p = _impl_._table_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyTableTypeEnum&>(
      ::Liberty::_LibertyTableTypeEnum_default_instance_);
}
inline const ::Liberty::LibertyTableTypeEnum& LibertyTableClass::_table_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableClass._table_type)
  return _internal__table_type();
}
inline void LibertyTableClass::unsafe_arena_set_allocated__table_type(
    ::Liberty::LibertyTableTypeEnum* _table_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._table_type_);
  }
  _impl_._table_type_ = _table_type;
  if (_table_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyTableClass._table_type)
}
inline ::Liberty::LibertyTableTypeEnum* LibertyTableClass::release__table_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyTableTypeEnum* temp = _impl_._table_type_;
  _impl_._table_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyTableTypeEnum* LibertyTableClass::unsafe_arena_release__table_type() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTableClass._table_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyTableTypeEnum* temp = _impl_._table_type_;
  _impl_._table_type_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyTableTypeEnum* LibertyTableClass::_internal_mutable__table_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_._table_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyTableTypeEnum>(GetArenaForAllocation());
    _impl_._table_type_ = p;
  }
  return _impl_._table_type_;
}
inline ::Liberty::LibertyTableTypeEnum* LibertyTableClass::mutable__table_type() {
  ::Liberty::LibertyTableTypeEnum* _msg = _internal_mutable__table_type();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTableClass._table_type)
  return _msg;
}
inline void LibertyTableClass::set_allocated__table_type(::Liberty::LibertyTableTypeEnum* _table_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._table_type_;
  }
  if (_table_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_table_type);
    if (message_arena != submessage_arena) {
      _table_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _table_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._table_type_ = _table_type;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTableClass._table_type)
}

// optional uint64 _table_template = 5;
inline bool LibertyTableClass::_internal_has__table_template() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyTableClass::has__table_template() const {
  return _internal_has__table_template();
}
inline void LibertyTableClass::clear__table_template() {
  _impl_._table_template_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t LibertyTableClass::_internal__table_template() const {
  return _impl_._table_template_;
}
inline uint64_t LibertyTableClass::_table_template() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableClass._table_template)
  return _internal__table_template();
}
inline void LibertyTableClass::_internal_set__table_template(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._table_template_ = value;
}
inline void LibertyTableClass::set__table_template(uint64_t value) {
  _internal_set__table_template(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableClass._table_template)
}

// -------------------------------------------------------------------

// LibertyVectorTableClass

// required double _ref_time = 1;
inline bool LibertyVectorTableClass::_internal_has__ref_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyVectorTableClass::has__ref_time() const {
  return _internal_has__ref_time();
}
inline void LibertyVectorTableClass::clear__ref_time() {
  _impl_._ref_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double LibertyVectorTableClass::_internal__ref_time() const {
  return _impl_._ref_time_;
}
inline double LibertyVectorTableClass::_ref_time() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyVectorTableClass._ref_time)
  return _internal__ref_time();
}
inline void LibertyVectorTableClass::_internal_set__ref_time(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._ref_time_ = value;
}
inline void LibertyVectorTableClass::set__ref_time(double value) {
  _internal_set__ref_time(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyVectorTableClass._ref_time)
}

// -------------------------------------------------------------------

// LibertyTableSyn

// required uint64 id = 1;
inline bool LibertyTableSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyTableSyn::has_id() const {
  return _internal_has_id();
}
inline void LibertyTableSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t LibertyTableSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyTableSyn::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableSyn.id)
  return _internal_id();
}
inline void LibertyTableSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}
inline void LibertyTableSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableSyn.id)
}

// required uint32 lts_type = 2;
inline bool LibertyTableSyn::_internal_has_lts_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyTableSyn::has_lts_type() const {
  return _internal_has_lts_type();
}
inline void LibertyTableSyn::clear_lts_type() {
  _impl_.lts_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LibertyTableSyn::_internal_lts_type() const {
  return _impl_.lts_type_;
}
inline uint32_t LibertyTableSyn::lts_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableSyn.lts_type)
  return _internal_lts_type();
}
inline void LibertyTableSyn::_internal_set_lts_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.lts_type_ = value;
}
inline void LibertyTableSyn::set_lts_type(uint32_t value) {
  _internal_set_lts_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableSyn.lts_type)
}

// required .Liberty.LibertyTableClass parent = 3;
inline bool LibertyTableSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool LibertyTableSyn::has_parent() const {
  return _internal_has_parent();
}
inline void LibertyTableSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Liberty::LibertyTableClass& LibertyTableSyn::_internal_parent() const {
  const ::Liberty::LibertyTableClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyTableClass&>(
      ::Liberty::_LibertyTableClass_default_instance_);
}
inline const ::Liberty::LibertyTableClass& LibertyTableSyn::parent() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableSyn.parent)
  return _internal_parent();
}
inline void LibertyTableSyn::unsafe_arena_set_allocated_parent(
    ::Liberty::LibertyTableClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyTableSyn.parent)
}
inline ::Liberty::LibertyTableClass* LibertyTableSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyTableClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyTableClass* LibertyTableSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTableSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyTableClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyTableClass* LibertyTableSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyTableClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Liberty::LibertyTableClass* LibertyTableSyn::mutable_parent() {
  ::Liberty::LibertyTableClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTableSyn.parent)
  return _msg;
}
inline void LibertyTableSyn::set_allocated_parent(::Liberty::LibertyTableClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTableSyn.parent)
}

// optional .Liberty.LibertyVectorTableClass lvtc = 4;
inline bool LibertyTableSyn::_internal_has_lvtc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lvtc_ != nullptr);
  return value;
}
inline bool LibertyTableSyn::has_lvtc() const {
  return _internal_has_lvtc();
}
inline void LibertyTableSyn::clear_lvtc() {
  if (_impl_.lvtc_ != nullptr) _impl_.lvtc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Liberty::LibertyVectorTableClass& LibertyTableSyn::_internal_lvtc() const {
  const ::Liberty::LibertyVectorTableClass* p = _impl_.lvtc_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyVectorTableClass&>(
      ::Liberty::_LibertyVectorTableClass_default_instance_);
}
inline const ::Liberty::LibertyVectorTableClass& LibertyTableSyn::lvtc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableSyn.lvtc)
  return _internal_lvtc();
}
inline void LibertyTableSyn::unsafe_arena_set_allocated_lvtc(
    ::Liberty::LibertyVectorTableClass* lvtc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lvtc_);
  }
  _impl_.lvtc_ = lvtc;
  if (lvtc) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyTableSyn.lvtc)
}
inline ::Liberty::LibertyVectorTableClass* LibertyTableSyn::release_lvtc() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyVectorTableClass* temp = _impl_.lvtc_;
  _impl_.lvtc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyVectorTableClass* LibertyTableSyn::unsafe_arena_release_lvtc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTableSyn.lvtc)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyVectorTableClass* temp = _impl_.lvtc_;
  _impl_.lvtc_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyVectorTableClass* LibertyTableSyn::_internal_mutable_lvtc() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lvtc_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyVectorTableClass>(GetArenaForAllocation());
    _impl_.lvtc_ = p;
  }
  return _impl_.lvtc_;
}
inline ::Liberty::LibertyVectorTableClass* LibertyTableSyn::mutable_lvtc() {
  ::Liberty::LibertyVectorTableClass* _msg = _internal_mutable_lvtc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTableSyn.lvtc)
  return _msg;
}
inline void LibertyTableSyn::set_allocated_lvtc(::Liberty::LibertyVectorTableClass* lvtc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lvtc_;
  }
  if (lvtc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lvtc);
    if (message_arena != submessage_arena) {
      lvtc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lvtc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lvtc_ = lvtc;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTableSyn.lvtc)
}

// -------------------------------------------------------------------

// LibertyCCSTableClass

// required .Liberty.LibertyTableTypeEnum _table_type = 1;
inline bool LibertyCCSTableClass::_internal_has__table_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._table_type_ != nullptr);
  return value;
}
inline bool LibertyCCSTableClass::has__table_type() const {
  return _internal_has__table_type();
}
inline void LibertyCCSTableClass::clear__table_type() {
  if (_impl_._table_type_ != nullptr) _impl_._table_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Liberty::LibertyTableTypeEnum& LibertyCCSTableClass::_internal__table_type() const {
  const ::Liberty::LibertyTableTypeEnum* p = _impl_._table_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyTableTypeEnum&>(
      ::Liberty::_LibertyTableTypeEnum_default_instance_);
}
inline const ::Liberty::LibertyTableTypeEnum& LibertyCCSTableClass::_table_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCCSTableClass._table_type)
  return _internal__table_type();
}
inline void LibertyCCSTableClass::unsafe_arena_set_allocated__table_type(
    ::Liberty::LibertyTableTypeEnum* _table_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._table_type_);
  }
  _impl_._table_type_ = _table_type;
  if (_table_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyCCSTableClass._table_type)
}
inline ::Liberty::LibertyTableTypeEnum* LibertyCCSTableClass::release__table_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyTableTypeEnum* temp = _impl_._table_type_;
  _impl_._table_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyTableTypeEnum* LibertyCCSTableClass::unsafe_arena_release__table_type() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyCCSTableClass._table_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyTableTypeEnum* temp = _impl_._table_type_;
  _impl_._table_type_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyTableTypeEnum* LibertyCCSTableClass::_internal_mutable__table_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_._table_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyTableTypeEnum>(GetArenaForAllocation());
    _impl_._table_type_ = p;
  }
  return _impl_._table_type_;
}
inline ::Liberty::LibertyTableTypeEnum* LibertyCCSTableClass::mutable__table_type() {
  ::Liberty::LibertyTableTypeEnum* _msg = _internal_mutable__table_type();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyCCSTableClass._table_type)
  return _msg;
}
inline void LibertyCCSTableClass::set_allocated__table_type(::Liberty::LibertyTableTypeEnum* _table_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._table_type_;
  }
  if (_table_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_table_type);
    if (message_arena != submessage_arena) {
      _table_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _table_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._table_type_ = _table_type;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyCCSTableClass._table_type)
}

// repeated uint64 _vector_tables = 2;
inline int LibertyCCSTableClass::_internal__vector_tables_size() const {
  return _impl_._vector_tables_.size();
}
inline int LibertyCCSTableClass::_vector_tables_size() const {
  return _internal__vector_tables_size();
}
inline void LibertyCCSTableClass::clear__vector_tables() {
  _impl_._vector_tables_.Clear();
}
inline uint64_t LibertyCCSTableClass::_internal__vector_tables(int index) const {
  return _impl_._vector_tables_.Get(index);
}
inline uint64_t LibertyCCSTableClass::_vector_tables(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCCSTableClass._vector_tables)
  return _internal__vector_tables(index);
}
inline void LibertyCCSTableClass::set__vector_tables(int index, uint64_t value) {
  _impl_._vector_tables_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCCSTableClass._vector_tables)
}
inline void LibertyCCSTableClass::_internal_add__vector_tables(uint64_t value) {
  _impl_._vector_tables_.Add(value);
}
inline void LibertyCCSTableClass::add__vector_tables(uint64_t value) {
  _internal_add__vector_tables(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyCCSTableClass._vector_tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCCSTableClass::_internal__vector_tables() const {
  return _impl_._vector_tables_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCCSTableClass::_vector_tables() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyCCSTableClass._vector_tables)
  return _internal__vector_tables();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCCSTableClass::_internal_mutable__vector_tables() {
  return &_impl_._vector_tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCCSTableClass::mutable__vector_tables() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyCCSTableClass._vector_tables)
  return _internal_mutable__vector_tables();
}

// -------------------------------------------------------------------

// LibertyDelayTableModelClass

// repeated uint64 _tables = 1;
inline int LibertyDelayTableModelClass::_internal__tables_size() const {
  return _impl_._tables_.size();
}
inline int LibertyDelayTableModelClass::_tables_size() const {
  return _internal__tables_size();
}
inline void LibertyDelayTableModelClass::clear__tables() {
  _impl_._tables_.Clear();
}
inline uint64_t LibertyDelayTableModelClass::_internal__tables(int index) const {
  return _impl_._tables_.Get(index);
}
inline uint64_t LibertyDelayTableModelClass::_tables(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyDelayTableModelClass._tables)
  return _internal__tables(index);
}
inline void LibertyDelayTableModelClass::set__tables(int index, uint64_t value) {
  _impl_._tables_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyDelayTableModelClass._tables)
}
inline void LibertyDelayTableModelClass::_internal_add__tables(uint64_t value) {
  _impl_._tables_.Add(value);
}
inline void LibertyDelayTableModelClass::add__tables(uint64_t value) {
  _internal_add__tables(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyDelayTableModelClass._tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyDelayTableModelClass::_internal__tables() const {
  return _impl_._tables_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyDelayTableModelClass::_tables() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyDelayTableModelClass._tables)
  return _internal__tables();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyDelayTableModelClass::_internal_mutable__tables() {
  return &_impl_._tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyDelayTableModelClass::mutable__tables() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyDelayTableModelClass._tables)
  return _internal_mutable__tables();
}

// repeated uint64 _current_tables = 2;
inline int LibertyDelayTableModelClass::_internal__current_tables_size() const {
  return _impl_._current_tables_.size();
}
inline int LibertyDelayTableModelClass::_current_tables_size() const {
  return _internal__current_tables_size();
}
inline void LibertyDelayTableModelClass::clear__current_tables() {
  _impl_._current_tables_.Clear();
}
inline uint64_t LibertyDelayTableModelClass::_internal__current_tables(int index) const {
  return _impl_._current_tables_.Get(index);
}
inline uint64_t LibertyDelayTableModelClass::_current_tables(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyDelayTableModelClass._current_tables)
  return _internal__current_tables(index);
}
inline void LibertyDelayTableModelClass::set__current_tables(int index, uint64_t value) {
  _impl_._current_tables_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyDelayTableModelClass._current_tables)
}
inline void LibertyDelayTableModelClass::_internal_add__current_tables(uint64_t value) {
  _impl_._current_tables_.Add(value);
}
inline void LibertyDelayTableModelClass::add__current_tables(uint64_t value) {
  _internal_add__current_tables(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyDelayTableModelClass._current_tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyDelayTableModelClass::_internal__current_tables() const {
  return _impl_._current_tables_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyDelayTableModelClass::_current_tables() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyDelayTableModelClass._current_tables)
  return _internal__current_tables();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyDelayTableModelClass::_internal_mutable__current_tables() {
  return &_impl_._current_tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyDelayTableModelClass::mutable__current_tables() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyDelayTableModelClass._current_tables)
  return _internal_mutable__current_tables();
}

// -------------------------------------------------------------------

// LibertyCheckTableModelClass

// repeated uint64 _tables = 1;
inline int LibertyCheckTableModelClass::_internal__tables_size() const {
  return _impl_._tables_.size();
}
inline int LibertyCheckTableModelClass::_tables_size() const {
  return _internal__tables_size();
}
inline void LibertyCheckTableModelClass::clear__tables() {
  _impl_._tables_.Clear();
}
inline uint64_t LibertyCheckTableModelClass::_internal__tables(int index) const {
  return _impl_._tables_.Get(index);
}
inline uint64_t LibertyCheckTableModelClass::_tables(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCheckTableModelClass._tables)
  return _internal__tables(index);
}
inline void LibertyCheckTableModelClass::set__tables(int index, uint64_t value) {
  _impl_._tables_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCheckTableModelClass._tables)
}
inline void LibertyCheckTableModelClass::_internal_add__tables(uint64_t value) {
  _impl_._tables_.Add(value);
}
inline void LibertyCheckTableModelClass::add__tables(uint64_t value) {
  _internal_add__tables(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyCheckTableModelClass._tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCheckTableModelClass::_internal__tables() const {
  return _impl_._tables_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCheckTableModelClass::_tables() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyCheckTableModelClass._tables)
  return _internal__tables();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCheckTableModelClass::_internal_mutable__tables() {
  return &_impl_._tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCheckTableModelClass::mutable__tables() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyCheckTableModelClass._tables)
  return _internal_mutable__tables();
}

// -------------------------------------------------------------------

// LibertyPowerTableModelClass

// repeated uint64 _tables = 1;
inline int LibertyPowerTableModelClass::_internal__tables_size() const {
  return _impl_._tables_.size();
}
inline int LibertyPowerTableModelClass::_tables_size() const {
  return _internal__tables_size();
}
inline void LibertyPowerTableModelClass::clear__tables() {
  _impl_._tables_.Clear();
}
inline uint64_t LibertyPowerTableModelClass::_internal__tables(int index) const {
  return _impl_._tables_.Get(index);
}
inline uint64_t LibertyPowerTableModelClass::_tables(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerTableModelClass._tables)
  return _internal__tables(index);
}
inline void LibertyPowerTableModelClass::set__tables(int index, uint64_t value) {
  _impl_._tables_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerTableModelClass._tables)
}
inline void LibertyPowerTableModelClass::_internal_add__tables(uint64_t value) {
  _impl_._tables_.Add(value);
}
inline void LibertyPowerTableModelClass::add__tables(uint64_t value) {
  _internal_add__tables(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyPowerTableModelClass._tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyPowerTableModelClass::_internal__tables() const {
  return _impl_._tables_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyPowerTableModelClass::_tables() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyPowerTableModelClass._tables)
  return _internal__tables();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyPowerTableModelClass::_internal_mutable__tables() {
  return &_impl_._tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyPowerTableModelClass::mutable__tables() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyPowerTableModelClass._tables)
  return _internal_mutable__tables();
}

// -------------------------------------------------------------------

// LibertyTableModelSyn

// required uint64 id = 1;
inline bool LibertyTableModelSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyTableModelSyn::has_id() const {
  return _internal_has_id();
}
inline void LibertyTableModelSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LibertyTableModelSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyTableModelSyn::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableModelSyn.id)
  return _internal_id();
}
inline void LibertyTableModelSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void LibertyTableModelSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableModelSyn.id)
}

// required uint32 ltms_type = 2;
inline bool LibertyTableModelSyn::_internal_has_ltms_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyTableModelSyn::has_ltms_type() const {
  return _internal_has_ltms_type();
}
inline void LibertyTableModelSyn::clear_ltms_type() {
  _impl_.ltms_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t LibertyTableModelSyn::_internal_ltms_type() const {
  return _impl_.ltms_type_;
}
inline uint32_t LibertyTableModelSyn::ltms_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableModelSyn.ltms_type)
  return _internal_ltms_type();
}
inline void LibertyTableModelSyn::_internal_set_ltms_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ltms_type_ = value;
}
inline void LibertyTableModelSyn::set_ltms_type(uint32_t value) {
  _internal_set_ltms_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTableModelSyn.ltms_type)
}

// .Liberty.LibertyDelayTableModelClass ldtmc = 3;
inline bool LibertyTableModelSyn::_internal_has_ldtmc() const {
  return ltms_case() == kLdtmc;
}
inline bool LibertyTableModelSyn::has_ldtmc() const {
  return _internal_has_ldtmc();
}
inline void LibertyTableModelSyn::set_has_ldtmc() {
  _impl_._oneof_case_[0] = kLdtmc;
}
inline void LibertyTableModelSyn::clear_ldtmc() {
  if (_internal_has_ldtmc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ltms_.ldtmc_;
    }
    clear_has_ltms();
  }
}
inline ::Liberty::LibertyDelayTableModelClass* LibertyTableModelSyn::release_ldtmc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTableModelSyn.ldtmc)
  if (_internal_has_ldtmc()) {
    clear_has_ltms();
    ::Liberty::LibertyDelayTableModelClass* temp = _impl_.ltms_.ldtmc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ltms_.ldtmc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyDelayTableModelClass& LibertyTableModelSyn::_internal_ldtmc() const {
  return _internal_has_ldtmc()
      ? *_impl_.ltms_.ldtmc_
      : reinterpret_cast< ::Liberty::LibertyDelayTableModelClass&>(::Liberty::_LibertyDelayTableModelClass_default_instance_);
}
inline const ::Liberty::LibertyDelayTableModelClass& LibertyTableModelSyn::ldtmc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableModelSyn.ldtmc)
  return _internal_ldtmc();
}
inline ::Liberty::LibertyDelayTableModelClass* LibertyTableModelSyn::unsafe_arena_release_ldtmc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyTableModelSyn.ldtmc)
  if (_internal_has_ldtmc()) {
    clear_has_ltms();
    ::Liberty::LibertyDelayTableModelClass* temp = _impl_.ltms_.ldtmc_;
    _impl_.ltms_.ldtmc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyTableModelSyn::unsafe_arena_set_allocated_ldtmc(::Liberty::LibertyDelayTableModelClass* ldtmc) {
  clear_ltms();
  if (ldtmc) {
    set_has_ldtmc();
    _impl_.ltms_.ldtmc_ = ldtmc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyTableModelSyn.ldtmc)
}
inline ::Liberty::LibertyDelayTableModelClass* LibertyTableModelSyn::_internal_mutable_ldtmc() {
  if (!_internal_has_ldtmc()) {
    clear_ltms();
    set_has_ldtmc();
    _impl_.ltms_.ldtmc_ = CreateMaybeMessage< ::Liberty::LibertyDelayTableModelClass >(GetArenaForAllocation());
  }
  return _impl_.ltms_.ldtmc_;
}
inline ::Liberty::LibertyDelayTableModelClass* LibertyTableModelSyn::mutable_ldtmc() {
  ::Liberty::LibertyDelayTableModelClass* _msg = _internal_mutable_ldtmc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTableModelSyn.ldtmc)
  return _msg;
}

// .Liberty.LibertyCheckTableModelClass lctmc = 4;
inline bool LibertyTableModelSyn::_internal_has_lctmc() const {
  return ltms_case() == kLctmc;
}
inline bool LibertyTableModelSyn::has_lctmc() const {
  return _internal_has_lctmc();
}
inline void LibertyTableModelSyn::set_has_lctmc() {
  _impl_._oneof_case_[0] = kLctmc;
}
inline void LibertyTableModelSyn::clear_lctmc() {
  if (_internal_has_lctmc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ltms_.lctmc_;
    }
    clear_has_ltms();
  }
}
inline ::Liberty::LibertyCheckTableModelClass* LibertyTableModelSyn::release_lctmc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTableModelSyn.lctmc)
  if (_internal_has_lctmc()) {
    clear_has_ltms();
    ::Liberty::LibertyCheckTableModelClass* temp = _impl_.ltms_.lctmc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ltms_.lctmc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyCheckTableModelClass& LibertyTableModelSyn::_internal_lctmc() const {
  return _internal_has_lctmc()
      ? *_impl_.ltms_.lctmc_
      : reinterpret_cast< ::Liberty::LibertyCheckTableModelClass&>(::Liberty::_LibertyCheckTableModelClass_default_instance_);
}
inline const ::Liberty::LibertyCheckTableModelClass& LibertyTableModelSyn::lctmc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableModelSyn.lctmc)
  return _internal_lctmc();
}
inline ::Liberty::LibertyCheckTableModelClass* LibertyTableModelSyn::unsafe_arena_release_lctmc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyTableModelSyn.lctmc)
  if (_internal_has_lctmc()) {
    clear_has_ltms();
    ::Liberty::LibertyCheckTableModelClass* temp = _impl_.ltms_.lctmc_;
    _impl_.ltms_.lctmc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyTableModelSyn::unsafe_arena_set_allocated_lctmc(::Liberty::LibertyCheckTableModelClass* lctmc) {
  clear_ltms();
  if (lctmc) {
    set_has_lctmc();
    _impl_.ltms_.lctmc_ = lctmc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyTableModelSyn.lctmc)
}
inline ::Liberty::LibertyCheckTableModelClass* LibertyTableModelSyn::_internal_mutable_lctmc() {
  if (!_internal_has_lctmc()) {
    clear_ltms();
    set_has_lctmc();
    _impl_.ltms_.lctmc_ = CreateMaybeMessage< ::Liberty::LibertyCheckTableModelClass >(GetArenaForAllocation());
  }
  return _impl_.ltms_.lctmc_;
}
inline ::Liberty::LibertyCheckTableModelClass* LibertyTableModelSyn::mutable_lctmc() {
  ::Liberty::LibertyCheckTableModelClass* _msg = _internal_mutable_lctmc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTableModelSyn.lctmc)
  return _msg;
}

// .Liberty.LibertyPowerTableModelClass lptmc = 5;
inline bool LibertyTableModelSyn::_internal_has_lptmc() const {
  return ltms_case() == kLptmc;
}
inline bool LibertyTableModelSyn::has_lptmc() const {
  return _internal_has_lptmc();
}
inline void LibertyTableModelSyn::set_has_lptmc() {
  _impl_._oneof_case_[0] = kLptmc;
}
inline void LibertyTableModelSyn::clear_lptmc() {
  if (_internal_has_lptmc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ltms_.lptmc_;
    }
    clear_has_ltms();
  }
}
inline ::Liberty::LibertyPowerTableModelClass* LibertyTableModelSyn::release_lptmc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTableModelSyn.lptmc)
  if (_internal_has_lptmc()) {
    clear_has_ltms();
    ::Liberty::LibertyPowerTableModelClass* temp = _impl_.ltms_.lptmc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ltms_.lptmc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyPowerTableModelClass& LibertyTableModelSyn::_internal_lptmc() const {
  return _internal_has_lptmc()
      ? *_impl_.ltms_.lptmc_
      : reinterpret_cast< ::Liberty::LibertyPowerTableModelClass&>(::Liberty::_LibertyPowerTableModelClass_default_instance_);
}
inline const ::Liberty::LibertyPowerTableModelClass& LibertyTableModelSyn::lptmc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTableModelSyn.lptmc)
  return _internal_lptmc();
}
inline ::Liberty::LibertyPowerTableModelClass* LibertyTableModelSyn::unsafe_arena_release_lptmc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyTableModelSyn.lptmc)
  if (_internal_has_lptmc()) {
    clear_has_ltms();
    ::Liberty::LibertyPowerTableModelClass* temp = _impl_.ltms_.lptmc_;
    _impl_.ltms_.lptmc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyTableModelSyn::unsafe_arena_set_allocated_lptmc(::Liberty::LibertyPowerTableModelClass* lptmc) {
  clear_ltms();
  if (lptmc) {
    set_has_lptmc();
    _impl_.ltms_.lptmc_ = lptmc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyTableModelSyn.lptmc)
}
inline ::Liberty::LibertyPowerTableModelClass* LibertyTableModelSyn::_internal_mutable_lptmc() {
  if (!_internal_has_lptmc()) {
    clear_ltms();
    set_has_lptmc();
    _impl_.ltms_.lptmc_ = CreateMaybeMessage< ::Liberty::LibertyPowerTableModelClass >(GetArenaForAllocation());
  }
  return _impl_.ltms_.lptmc_;
}
inline ::Liberty::LibertyPowerTableModelClass* LibertyTableModelSyn::mutable_lptmc() {
  ::Liberty::LibertyPowerTableModelClass* _msg = _internal_mutable_lptmc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTableModelSyn.lptmc)
  return _msg;
}

inline bool LibertyTableModelSyn::has_ltms() const {
  return ltms_case() != LTMS_NOT_SET;
}
inline void LibertyTableModelSyn::clear_has_ltms() {
  _impl_._oneof_case_[0] = LTMS_NOT_SET;
}
inline LibertyTableModelSyn::LtmsCase LibertyTableModelSyn::ltms_case() const {
  return LibertyTableModelSyn::LtmsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LibertyTypeClass

// required string _type_name = 1;
inline bool LibertyTypeClass::_internal_has__type_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyTypeClass::has__type_name() const {
  return _internal_has__type_name();
}
inline void LibertyTypeClass::clear__type_name() {
  _impl_._type_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyTypeClass::_type_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTypeClass._type_name)
  return _internal__type_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyTypeClass::set__type_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._type_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyTypeClass._type_name)
}
inline std::string* LibertyTypeClass::mutable__type_name() {
  std::string* _s = _internal_mutable__type_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTypeClass._type_name)
  return _s;
}
inline const std::string& LibertyTypeClass::_internal__type_name() const {
  return _impl_._type_name_.Get();
}
inline void LibertyTypeClass::_internal_set__type_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._type_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyTypeClass::_internal_mutable__type_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._type_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyTypeClass::release__type_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTypeClass._type_name)
  if (!_internal_has__type_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._type_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._type_name_.IsDefault()) {
    _impl_._type_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyTypeClass::set_allocated__type_name(std::string* _type_name) {
  if (_type_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._type_name_.SetAllocated(_type_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._type_name_.IsDefault()) {
    _impl_._type_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTypeClass._type_name)
}

// required string _base_type = 2;
inline bool LibertyTypeClass::_internal_has__base_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyTypeClass::has__base_type() const {
  return _internal_has__base_type();
}
inline void LibertyTypeClass::clear__base_type() {
  _impl_._base_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LibertyTypeClass::_base_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTypeClass._base_type)
  return _internal__base_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyTypeClass::set__base_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._base_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyTypeClass._base_type)
}
inline std::string* LibertyTypeClass::mutable__base_type() {
  std::string* _s = _internal_mutable__base_type();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTypeClass._base_type)
  return _s;
}
inline const std::string& LibertyTypeClass::_internal__base_type() const {
  return _impl_._base_type_.Get();
}
inline void LibertyTypeClass::_internal_set__base_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._base_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyTypeClass::_internal_mutable__base_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._base_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyTypeClass::release__base_type() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTypeClass._base_type)
  if (!_internal_has__base_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._base_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._base_type_.IsDefault()) {
    _impl_._base_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyTypeClass::set_allocated__base_type(std::string* _base_type) {
  if (_base_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._base_type_.SetAllocated(_base_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._base_type_.IsDefault()) {
    _impl_._base_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTypeClass._base_type)
}

// required string _data_type = 3;
inline bool LibertyTypeClass::_internal_has__data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyTypeClass::has__data_type() const {
  return _internal_has__data_type();
}
inline void LibertyTypeClass::clear__data_type() {
  _impl_._data_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LibertyTypeClass::_data_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTypeClass._data_type)
  return _internal__data_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyTypeClass::set__data_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_._data_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyTypeClass._data_type)
}
inline std::string* LibertyTypeClass::mutable__data_type() {
  std::string* _s = _internal_mutable__data_type();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyTypeClass._data_type)
  return _s;
}
inline const std::string& LibertyTypeClass::_internal__data_type() const {
  return _impl_._data_type_.Get();
}
inline void LibertyTypeClass::_internal_set__data_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._data_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyTypeClass::_internal_mutable__data_type() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_._data_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyTypeClass::release__data_type() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyTypeClass._data_type)
  if (!_internal_has__data_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_._data_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._data_type_.IsDefault()) {
    _impl_._data_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyTypeClass::set_allocated__data_type(std::string* _data_type) {
  if (_data_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_._data_type_.SetAllocated(_data_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._data_type_.IsDefault()) {
    _impl_._data_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyTypeClass._data_type)
}

// required uint32 _bit_width = 4;
inline bool LibertyTypeClass::_internal_has__bit_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyTypeClass::has__bit_width() const {
  return _internal_has__bit_width();
}
inline void LibertyTypeClass::clear__bit_width() {
  _impl_._bit_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LibertyTypeClass::_internal__bit_width() const {
  return _impl_._bit_width_;
}
inline uint32_t LibertyTypeClass::_bit_width() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTypeClass._bit_width)
  return _internal__bit_width();
}
inline void LibertyTypeClass::_internal_set__bit_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._bit_width_ = value;
}
inline void LibertyTypeClass::set__bit_width(uint32_t value) {
  _internal_set__bit_width(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTypeClass._bit_width)
}

// required uint32 _bit_from = 5;
inline bool LibertyTypeClass::_internal_has__bit_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LibertyTypeClass::has__bit_from() const {
  return _internal_has__bit_from();
}
inline void LibertyTypeClass::clear__bit_from() {
  _impl_._bit_from_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LibertyTypeClass::_internal__bit_from() const {
  return _impl_._bit_from_;
}
inline uint32_t LibertyTypeClass::_bit_from() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTypeClass._bit_from)
  return _internal__bit_from();
}
inline void LibertyTypeClass::_internal_set__bit_from(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._bit_from_ = value;
}
inline void LibertyTypeClass::set__bit_from(uint32_t value) {
  _internal_set__bit_from(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTypeClass._bit_from)
}

// required uint32 _bit_to = 6;
inline bool LibertyTypeClass::_internal_has__bit_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LibertyTypeClass::has__bit_to() const {
  return _internal_has__bit_to();
}
inline void LibertyTypeClass::clear__bit_to() {
  _impl_._bit_to_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LibertyTypeClass::_internal__bit_to() const {
  return _impl_._bit_to_;
}
inline uint32_t LibertyTypeClass::_bit_to() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyTypeClass._bit_to)
  return _internal__bit_to();
}
inline void LibertyTypeClass::_internal_set__bit_to(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_._bit_to_ = value;
}
inline void LibertyTypeClass::set__bit_to(uint32_t value) {
  _internal_set__bit_to(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyTypeClass._bit_to)
}

// -------------------------------------------------------------------

// LibertyPortTypeEnum

// required .Liberty.LibertyPortTypeEnum.PortType pt = 1;
inline bool LibertyPortTypeEnum::_internal_has_pt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyPortTypeEnum::has_pt() const {
  return _internal_has_pt();
}
inline void LibertyPortTypeEnum::clear_pt() {
  _impl_.pt_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Liberty::LibertyPortTypeEnum_PortType LibertyPortTypeEnum::_internal_pt() const {
  return static_cast< ::Liberty::LibertyPortTypeEnum_PortType >(_impl_.pt_);
}
inline ::Liberty::LibertyPortTypeEnum_PortType LibertyPortTypeEnum::pt() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortTypeEnum.pt)
  return _internal_pt();
}
inline void LibertyPortTypeEnum::_internal_set_pt(::Liberty::LibertyPortTypeEnum_PortType value) {
  assert(::Liberty::LibertyPortTypeEnum_PortType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pt_ = value;
}
inline void LibertyPortTypeEnum::set_pt(::Liberty::LibertyPortTypeEnum_PortType value) {
  _internal_set_pt(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortTypeEnum.pt)
}

// -------------------------------------------------------------------

// LibertyPortClass

// required string _port_name = 1;
inline bool LibertyPortClass::_internal_has__port_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyPortClass::has__port_name() const {
  return _internal_has__port_name();
}
inline void LibertyPortClass::clear__port_name() {
  _impl_._port_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyPortClass::_port_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortClass._port_name)
  return _internal__port_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyPortClass::set__port_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._port_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortClass._port_name)
}
inline std::string* LibertyPortClass::mutable__port_name() {
  std::string* _s = _internal_mutable__port_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPortClass._port_name)
  return _s;
}
inline const std::string& LibertyPortClass::_internal__port_name() const {
  return _impl_._port_name_.Get();
}
inline void LibertyPortClass::_internal_set__port_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._port_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyPortClass::_internal_mutable__port_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._port_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyPortClass::release__port_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPortClass._port_name)
  if (!_internal_has__port_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._port_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._port_name_.IsDefault()) {
    _impl_._port_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyPortClass::set_allocated__port_name(std::string* _port_name) {
  if (_port_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._port_name_.SetAllocated(_port_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._port_name_.IsDefault()) {
    _impl_._port_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPortClass._port_name)
}

// required uint64 _owner_cell = 2;
inline bool LibertyPortClass::_internal_has__owner_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyPortClass::has__owner_cell() const {
  return _internal_has__owner_cell();
}
inline void LibertyPortClass::clear__owner_cell() {
  _impl_._owner_cell_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t LibertyPortClass::_internal__owner_cell() const {
  return _impl_._owner_cell_;
}
inline uint64_t LibertyPortClass::_owner_cell() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortClass._owner_cell)
  return _internal__owner_cell();
}
inline void LibertyPortClass::_internal_set__owner_cell(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._owner_cell_ = value;
}
inline void LibertyPortClass::set__owner_cell(uint64_t value) {
  _internal_set__owner_cell(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortClass._owner_cell)
}

// required .Liberty.LibertyPortTypeEnum _port_type = 3;
inline bool LibertyPortClass::_internal_has__port_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._port_type_ != nullptr);
  return value;
}
inline bool LibertyPortClass::has__port_type() const {
  return _internal_has__port_type();
}
inline void LibertyPortClass::clear__port_type() {
  if (_impl_._port_type_ != nullptr) _impl_._port_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Liberty::LibertyPortTypeEnum& LibertyPortClass::_internal__port_type() const {
  const ::Liberty::LibertyPortTypeEnum* p = _impl_._port_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyPortTypeEnum&>(
      ::Liberty::_LibertyPortTypeEnum_default_instance_);
}
inline const ::Liberty::LibertyPortTypeEnum& LibertyPortClass::_port_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortClass._port_type)
  return _internal__port_type();
}
inline void LibertyPortClass::unsafe_arena_set_allocated__port_type(
    ::Liberty::LibertyPortTypeEnum* _port_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._port_type_);
  }
  _impl_._port_type_ = _port_type;
  if (_port_type) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyPortClass._port_type)
}
inline ::Liberty::LibertyPortTypeEnum* LibertyPortClass::release__port_type() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyPortTypeEnum* temp = _impl_._port_type_;
  _impl_._port_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyPortTypeEnum* LibertyPortClass::unsafe_arena_release__port_type() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPortClass._port_type)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyPortTypeEnum* temp = _impl_._port_type_;
  _impl_._port_type_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyPortTypeEnum* LibertyPortClass::_internal_mutable__port_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_._port_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyPortTypeEnum>(GetArenaForAllocation());
    _impl_._port_type_ = p;
  }
  return _impl_._port_type_;
}
inline ::Liberty::LibertyPortTypeEnum* LibertyPortClass::mutable__port_type() {
  ::Liberty::LibertyPortTypeEnum* _msg = _internal_mutable__port_type();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPortClass._port_type)
  return _msg;
}
inline void LibertyPortClass::set_allocated__port_type(::Liberty::LibertyPortTypeEnum* _port_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_._port_type_;
  }
  if (_port_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(_port_type);
    if (message_arena != submessage_arena) {
      _port_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _port_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._port_type_ = _port_type;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPortClass._port_type)
}

// optional uint64 _func_expr = 4;
inline bool LibertyPortClass::_internal_has__func_expr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyPortClass::has__func_expr() const {
  return _internal_has__func_expr();
}
inline void LibertyPortClass::clear__func_expr() {
  _impl_._func_expr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t LibertyPortClass::_internal__func_expr() const {
  return _impl_._func_expr_;
}
inline uint64_t LibertyPortClass::_func_expr() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortClass._func_expr)
  return _internal__func_expr();
}
inline void LibertyPortClass::_internal_set__func_expr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._func_expr_ = value;
}
inline void LibertyPortClass::set__func_expr(uint64_t value) {
  _internal_set__func_expr(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortClass._func_expr)
}

// required double _port_cap = 5;
inline bool LibertyPortClass::_internal_has__port_cap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LibertyPortClass::has__port_cap() const {
  return _internal_has__port_cap();
}
inline void LibertyPortClass::clear__port_cap() {
  _impl_._port_cap_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double LibertyPortClass::_internal__port_cap() const {
  return _impl_._port_cap_;
}
inline double LibertyPortClass::_port_cap() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortClass._port_cap)
  return _internal__port_cap();
}
inline void LibertyPortClass::_internal_set__port_cap(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._port_cap_ = value;
}
inline void LibertyPortClass::set__port_cap(double value) {
  _internal_set__port_cap(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortClass._port_cap)
}

// optional double _fanout_load = 6;
inline bool LibertyPortClass::_internal_has__fanout_load() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LibertyPortClass::has__fanout_load() const {
  return _internal_has__fanout_load();
}
inline void LibertyPortClass::clear__fanout_load() {
  _impl_._fanout_load_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double LibertyPortClass::_internal__fanout_load() const {
  return _impl_._fanout_load_;
}
inline double LibertyPortClass::_fanout_load() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortClass._fanout_load)
  return _internal__fanout_load();
}
inline void LibertyPortClass::_internal_set__fanout_load(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_._fanout_load_ = value;
}
inline void LibertyPortClass::set__fanout_load(double value) {
  _internal_set__fanout_load(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortClass._fanout_load)
}

// optional uint64 _power_table_model = 7;
inline bool LibertyPortClass::_internal_has__power_table_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LibertyPortClass::has__power_table_model() const {
  return _internal_has__power_table_model();
}
inline void LibertyPortClass::clear__power_table_model() {
  _impl_._power_table_model_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t LibertyPortClass::_internal__power_table_model() const {
  return _impl_._power_table_model_;
}
inline uint64_t LibertyPortClass::_power_table_model() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortClass._power_table_model)
  return _internal__power_table_model();
}
inline void LibertyPortClass::_internal_set__power_table_model(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_._power_table_model_ = value;
}
inline void LibertyPortClass::set__power_table_model(uint64_t value) {
  _internal_set__power_table_model(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortClass._power_table_model)
}

// -------------------------------------------------------------------

// LibertyPortBusClass

// repeated uint64 _ports = 1;
inline int LibertyPortBusClass::_internal__ports_size() const {
  return _impl_._ports_.size();
}
inline int LibertyPortBusClass::_ports_size() const {
  return _internal__ports_size();
}
inline void LibertyPortBusClass::clear__ports() {
  _impl_._ports_.Clear();
}
inline uint64_t LibertyPortBusClass::_internal__ports(int index) const {
  return _impl_._ports_.Get(index);
}
inline uint64_t LibertyPortBusClass::_ports(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortBusClass._ports)
  return _internal__ports(index);
}
inline void LibertyPortBusClass::set__ports(int index, uint64_t value) {
  _impl_._ports_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortBusClass._ports)
}
inline void LibertyPortBusClass::_internal_add__ports(uint64_t value) {
  _impl_._ports_.Add(value);
}
inline void LibertyPortBusClass::add__ports(uint64_t value) {
  _internal_add__ports(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyPortBusClass._ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyPortBusClass::_internal__ports() const {
  return _impl_._ports_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyPortBusClass::_ports() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyPortBusClass._ports)
  return _internal__ports();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyPortBusClass::_internal_mutable__ports() {
  return &_impl_._ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyPortBusClass::mutable__ports() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyPortBusClass._ports)
  return _internal_mutable__ports();
}

// required uint64 _bus_type = 2;
inline bool LibertyPortBusClass::_internal_has__bus_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyPortBusClass::has__bus_type() const {
  return _internal_has__bus_type();
}
inline void LibertyPortBusClass::clear__bus_type() {
  _impl_._bus_type_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LibertyPortBusClass::_internal__bus_type() const {
  return _impl_._bus_type_;
}
inline uint64_t LibertyPortBusClass::_bus_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortBusClass._bus_type)
  return _internal__bus_type();
}
inline void LibertyPortBusClass::_internal_set__bus_type(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._bus_type_ = value;
}
inline void LibertyPortBusClass::set__bus_type(uint64_t value) {
  _internal_set__bus_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortBusClass._bus_type)
}

// -------------------------------------------------------------------

// LibertyPortSyn

// required uint32 lps_type = 1;
inline bool LibertyPortSyn::_internal_has_lps_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyPortSyn::has_lps_type() const {
  return _internal_has_lps_type();
}
inline void LibertyPortSyn::clear_lps_type() {
  _impl_.lps_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LibertyPortSyn::_internal_lps_type() const {
  return _impl_.lps_type_;
}
inline uint32_t LibertyPortSyn::lps_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortSyn.lps_type)
  return _internal_lps_type();
}
inline void LibertyPortSyn::_internal_set_lps_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lps_type_ = value;
}
inline void LibertyPortSyn::set_lps_type(uint32_t value) {
  _internal_set_lps_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPortSyn.lps_type)
}

// optional .Liberty.LibertyPortClass parent = 2;
inline bool LibertyPortSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool LibertyPortSyn::has_parent() const {
  return _internal_has_parent();
}
inline void LibertyPortSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Liberty::LibertyPortClass& LibertyPortSyn::_internal_parent() const {
  const ::Liberty::LibertyPortClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyPortClass&>(
      ::Liberty::_LibertyPortClass_default_instance_);
}
inline const ::Liberty::LibertyPortClass& LibertyPortSyn::parent() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortSyn.parent)
  return _internal_parent();
}
inline void LibertyPortSyn::unsafe_arena_set_allocated_parent(
    ::Liberty::LibertyPortClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyPortSyn.parent)
}
inline ::Liberty::LibertyPortClass* LibertyPortSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyPortClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyPortClass* LibertyPortSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPortSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyPortClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyPortClass* LibertyPortSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyPortClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Liberty::LibertyPortClass* LibertyPortSyn::mutable_parent() {
  ::Liberty::LibertyPortClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPortSyn.parent)
  return _msg;
}
inline void LibertyPortSyn::set_allocated_parent(::Liberty::LibertyPortClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPortSyn.parent)
}

// optional .Liberty.LibertyPortBusClass lpbc = 3;
inline bool LibertyPortSyn::_internal_has_lpbc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lpbc_ != nullptr);
  return value;
}
inline bool LibertyPortSyn::has_lpbc() const {
  return _internal_has_lpbc();
}
inline void LibertyPortSyn::clear_lpbc() {
  if (_impl_.lpbc_ != nullptr) _impl_.lpbc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Liberty::LibertyPortBusClass& LibertyPortSyn::_internal_lpbc() const {
  const ::Liberty::LibertyPortBusClass* p = _impl_.lpbc_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyPortBusClass&>(
      ::Liberty::_LibertyPortBusClass_default_instance_);
}
inline const ::Liberty::LibertyPortBusClass& LibertyPortSyn::lpbc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPortSyn.lpbc)
  return _internal_lpbc();
}
inline void LibertyPortSyn::unsafe_arena_set_allocated_lpbc(
    ::Liberty::LibertyPortBusClass* lpbc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lpbc_);
  }
  _impl_.lpbc_ = lpbc;
  if (lpbc) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyPortSyn.lpbc)
}
inline ::Liberty::LibertyPortBusClass* LibertyPortSyn::release_lpbc() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyPortBusClass* temp = _impl_.lpbc_;
  _impl_.lpbc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyPortBusClass* LibertyPortSyn::unsafe_arena_release_lpbc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPortSyn.lpbc)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyPortBusClass* temp = _impl_.lpbc_;
  _impl_.lpbc_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyPortBusClass* LibertyPortSyn::_internal_mutable_lpbc() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lpbc_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyPortBusClass>(GetArenaForAllocation());
    _impl_.lpbc_ = p;
  }
  return _impl_.lpbc_;
}
inline ::Liberty::LibertyPortBusClass* LibertyPortSyn::mutable_lpbc() {
  ::Liberty::LibertyPortBusClass* _msg = _internal_mutable_lpbc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPortSyn.lpbc)
  return _msg;
}
inline void LibertyPortSyn::set_allocated_lpbc(::Liberty::LibertyPortBusClass* lpbc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lpbc_;
  }
  if (lpbc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lpbc);
    if (message_arena != submessage_arena) {
      lpbc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lpbc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lpbc_ = lpbc;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPortSyn.lpbc)
}

// -------------------------------------------------------------------

// LibertyArcClass

// required string _src_port = 1;
inline bool LibertyArcClass::_internal_has__src_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyArcClass::has__src_port() const {
  return _internal_has__src_port();
}
inline void LibertyArcClass::clear__src_port() {
  _impl_._src_port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyArcClass::_src_port() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcClass._src_port)
  return _internal__src_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyArcClass::set__src_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._src_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcClass._src_port)
}
inline std::string* LibertyArcClass::mutable__src_port() {
  std::string* _s = _internal_mutable__src_port();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyArcClass._src_port)
  return _s;
}
inline const std::string& LibertyArcClass::_internal__src_port() const {
  return _impl_._src_port_.Get();
}
inline void LibertyArcClass::_internal_set__src_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._src_port_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyArcClass::_internal_mutable__src_port() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._src_port_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyArcClass::release__src_port() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyArcClass._src_port)
  if (!_internal_has__src_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._src_port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._src_port_.IsDefault()) {
    _impl_._src_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyArcClass::set_allocated__src_port(std::string* _src_port) {
  if (_src_port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._src_port_.SetAllocated(_src_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._src_port_.IsDefault()) {
    _impl_._src_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyArcClass._src_port)
}

// required string _snk_port = 2;
inline bool LibertyArcClass::_internal_has__snk_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyArcClass::has__snk_port() const {
  return _internal_has__snk_port();
}
inline void LibertyArcClass::clear__snk_port() {
  _impl_._snk_port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LibertyArcClass::_snk_port() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcClass._snk_port)
  return _internal__snk_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyArcClass::set__snk_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._snk_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcClass._snk_port)
}
inline std::string* LibertyArcClass::mutable__snk_port() {
  std::string* _s = _internal_mutable__snk_port();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyArcClass._snk_port)
  return _s;
}
inline const std::string& LibertyArcClass::_internal__snk_port() const {
  return _impl_._snk_port_.Get();
}
inline void LibertyArcClass::_internal_set__snk_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._snk_port_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyArcClass::_internal_mutable__snk_port() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._snk_port_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyArcClass::release__snk_port() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyArcClass._snk_port)
  if (!_internal_has__snk_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._snk_port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._snk_port_.IsDefault()) {
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyArcClass::set_allocated__snk_port(std::string* _snk_port) {
  if (_snk_port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._snk_port_.SetAllocated(_snk_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._snk_port_.IsDefault()) {
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyArcClass._snk_port)
}

// required uint64 _owner_cell = 3;
inline bool LibertyArcClass::_internal_has__owner_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LibertyArcClass::has__owner_cell() const {
  return _internal_has__owner_cell();
}
inline void LibertyArcClass::clear__owner_cell() {
  _impl_._owner_cell_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t LibertyArcClass::_internal__owner_cell() const {
  return _impl_._owner_cell_;
}
inline uint64_t LibertyArcClass::_owner_cell() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcClass._owner_cell)
  return _internal__owner_cell();
}
inline void LibertyArcClass::_internal_set__owner_cell(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._owner_cell_ = value;
}
inline void LibertyArcClass::set__owner_cell(uint64_t value) {
  _internal_set__owner_cell(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcClass._owner_cell)
}

// required string _timing_sense = 4;
inline bool LibertyArcClass::_internal_has__timing_sense() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyArcClass::has__timing_sense() const {
  return _internal_has__timing_sense();
}
inline void LibertyArcClass::clear__timing_sense() {
  _impl_._timing_sense_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LibertyArcClass::_timing_sense() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcClass._timing_sense)
  return _internal__timing_sense();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyArcClass::set__timing_sense(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_._timing_sense_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcClass._timing_sense)
}
inline std::string* LibertyArcClass::mutable__timing_sense() {
  std::string* _s = _internal_mutable__timing_sense();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyArcClass._timing_sense)
  return _s;
}
inline const std::string& LibertyArcClass::_internal__timing_sense() const {
  return _impl_._timing_sense_.Get();
}
inline void LibertyArcClass::_internal_set__timing_sense(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._timing_sense_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyArcClass::_internal_mutable__timing_sense() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_._timing_sense_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyArcClass::release__timing_sense() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyArcClass._timing_sense)
  if (!_internal_has__timing_sense()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_._timing_sense_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._timing_sense_.IsDefault()) {
    _impl_._timing_sense_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyArcClass::set_allocated__timing_sense(std::string* _timing_sense) {
  if (_timing_sense != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_._timing_sense_.SetAllocated(_timing_sense, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._timing_sense_.IsDefault()) {
    _impl_._timing_sense_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyArcClass._timing_sense)
}

// required string _timing_type = 5;
inline bool LibertyArcClass::_internal_has__timing_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyArcClass::has__timing_type() const {
  return _internal_has__timing_type();
}
inline void LibertyArcClass::clear__timing_type() {
  _impl_._timing_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LibertyArcClass::_timing_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcClass._timing_type)
  return _internal__timing_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyArcClass::set__timing_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_._timing_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcClass._timing_type)
}
inline std::string* LibertyArcClass::mutable__timing_type() {
  std::string* _s = _internal_mutable__timing_type();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyArcClass._timing_type)
  return _s;
}
inline const std::string& LibertyArcClass::_internal__timing_type() const {
  return _impl_._timing_type_.Get();
}
inline void LibertyArcClass::_internal_set__timing_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._timing_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyArcClass::_internal_mutable__timing_type() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_._timing_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyArcClass::release__timing_type() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyArcClass._timing_type)
  if (!_internal_has__timing_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_._timing_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._timing_type_.IsDefault()) {
    _impl_._timing_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyArcClass::set_allocated__timing_type(std::string* _timing_type) {
  if (_timing_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_._timing_type_.SetAllocated(_timing_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._timing_type_.IsDefault()) {
    _impl_._timing_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyArcClass._timing_type)
}

// required uint64 _table_model = 6;
inline bool LibertyArcClass::_internal_has__table_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LibertyArcClass::has__table_model() const {
  return _internal_has__table_model();
}
inline void LibertyArcClass::clear__table_model() {
  _impl_._table_model_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t LibertyArcClass::_internal__table_model() const {
  return _impl_._table_model_;
}
inline uint64_t LibertyArcClass::_table_model() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcClass._table_model)
  return _internal__table_model();
}
inline void LibertyArcClass::_internal_set__table_model(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_._table_model_ = value;
}
inline void LibertyArcClass::set__table_model(uint64_t value) {
  _internal_set__table_model(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcClass._table_model)
}

// -------------------------------------------------------------------

// LibertyArcSetClass

// required uint64 id = 1;
inline bool LibertyArcSetClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyArcSetClass::has_id() const {
  return _internal_has_id();
}
inline void LibertyArcSetClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LibertyArcSetClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyArcSetClass::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcSetClass.id)
  return _internal_id();
}
inline void LibertyArcSetClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void LibertyArcSetClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcSetClass.id)
}

// repeated uint64 _arcs = 2;
inline int LibertyArcSetClass::_internal__arcs_size() const {
  return _impl_._arcs_.size();
}
inline int LibertyArcSetClass::_arcs_size() const {
  return _internal__arcs_size();
}
inline void LibertyArcSetClass::clear__arcs() {
  _impl_._arcs_.Clear();
}
inline uint64_t LibertyArcSetClass::_internal__arcs(int index) const {
  return _impl_._arcs_.Get(index);
}
inline uint64_t LibertyArcSetClass::_arcs(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyArcSetClass._arcs)
  return _internal__arcs(index);
}
inline void LibertyArcSetClass::set__arcs(int index, uint64_t value) {
  _impl_._arcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyArcSetClass._arcs)
}
inline void LibertyArcSetClass::_internal_add__arcs(uint64_t value) {
  _impl_._arcs_.Add(value);
}
inline void LibertyArcSetClass::add__arcs(uint64_t value) {
  _internal_add__arcs(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyArcSetClass._arcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyArcSetClass::_internal__arcs() const {
  return _impl_._arcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyArcSetClass::_arcs() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyArcSetClass._arcs)
  return _internal__arcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyArcSetClass::_internal_mutable__arcs() {
  return &_impl_._arcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyArcSetClass::mutable__arcs() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyArcSetClass._arcs)
  return _internal_mutable__arcs();
}

// -------------------------------------------------------------------

// LibertyPowerArcClass

// required string _src_port = 1;
inline bool LibertyPowerArcClass::_internal_has__src_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyPowerArcClass::has__src_port() const {
  return _internal_has__src_port();
}
inline void LibertyPowerArcClass::clear__src_port() {
  _impl_._src_port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyPowerArcClass::_src_port() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcClass._src_port)
  return _internal__src_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyPowerArcClass::set__src_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._src_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcClass._src_port)
}
inline std::string* LibertyPowerArcClass::mutable__src_port() {
  std::string* _s = _internal_mutable__src_port();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPowerArcClass._src_port)
  return _s;
}
inline const std::string& LibertyPowerArcClass::_internal__src_port() const {
  return _impl_._src_port_.Get();
}
inline void LibertyPowerArcClass::_internal_set__src_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._src_port_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::_internal_mutable__src_port() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._src_port_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::release__src_port() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPowerArcClass._src_port)
  if (!_internal_has__src_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._src_port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._src_port_.IsDefault()) {
    _impl_._src_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyPowerArcClass::set_allocated__src_port(std::string* _src_port) {
  if (_src_port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._src_port_.SetAllocated(_src_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._src_port_.IsDefault()) {
    _impl_._src_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPowerArcClass._src_port)
}

// required string _snk_port = 2;
inline bool LibertyPowerArcClass::_internal_has__snk_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyPowerArcClass::has__snk_port() const {
  return _internal_has__snk_port();
}
inline void LibertyPowerArcClass::clear__snk_port() {
  _impl_._snk_port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LibertyPowerArcClass::_snk_port() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcClass._snk_port)
  return _internal__snk_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyPowerArcClass::set__snk_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._snk_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcClass._snk_port)
}
inline std::string* LibertyPowerArcClass::mutable__snk_port() {
  std::string* _s = _internal_mutable__snk_port();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPowerArcClass._snk_port)
  return _s;
}
inline const std::string& LibertyPowerArcClass::_internal__snk_port() const {
  return _impl_._snk_port_.Get();
}
inline void LibertyPowerArcClass::_internal_set__snk_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._snk_port_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::_internal_mutable__snk_port() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._snk_port_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::release__snk_port() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPowerArcClass._snk_port)
  if (!_internal_has__snk_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._snk_port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._snk_port_.IsDefault()) {
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyPowerArcClass::set_allocated__snk_port(std::string* _snk_port) {
  if (_snk_port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._snk_port_.SetAllocated(_snk_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._snk_port_.IsDefault()) {
    _impl_._snk_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPowerArcClass._snk_port)
}

// required string _related_pg_port = 3;
inline bool LibertyPowerArcClass::_internal_has__related_pg_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyPowerArcClass::has__related_pg_port() const {
  return _internal_has__related_pg_port();
}
inline void LibertyPowerArcClass::clear__related_pg_port() {
  _impl_._related_pg_port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LibertyPowerArcClass::_related_pg_port() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcClass._related_pg_port)
  return _internal__related_pg_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyPowerArcClass::set__related_pg_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_._related_pg_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcClass._related_pg_port)
}
inline std::string* LibertyPowerArcClass::mutable__related_pg_port() {
  std::string* _s = _internal_mutable__related_pg_port();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPowerArcClass._related_pg_port)
  return _s;
}
inline const std::string& LibertyPowerArcClass::_internal__related_pg_port() const {
  return _impl_._related_pg_port_.Get();
}
inline void LibertyPowerArcClass::_internal_set__related_pg_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._related_pg_port_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::_internal_mutable__related_pg_port() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_._related_pg_port_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::release__related_pg_port() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPowerArcClass._related_pg_port)
  if (!_internal_has__related_pg_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_._related_pg_port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._related_pg_port_.IsDefault()) {
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyPowerArcClass::set_allocated__related_pg_port(std::string* _related_pg_port) {
  if (_related_pg_port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_._related_pg_port_.SetAllocated(_related_pg_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._related_pg_port_.IsDefault()) {
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPowerArcClass._related_pg_port)
}

// required string _when = 4;
inline bool LibertyPowerArcClass::_internal_has__when() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyPowerArcClass::has__when() const {
  return _internal_has__when();
}
inline void LibertyPowerArcClass::clear__when() {
  _impl_._when_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LibertyPowerArcClass::_when() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcClass._when)
  return _internal__when();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyPowerArcClass::set__when(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_._when_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcClass._when)
}
inline std::string* LibertyPowerArcClass::mutable__when() {
  std::string* _s = _internal_mutable__when();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyPowerArcClass._when)
  return _s;
}
inline const std::string& LibertyPowerArcClass::_internal__when() const {
  return _impl_._when_.Get();
}
inline void LibertyPowerArcClass::_internal_set__when(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._when_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::_internal_mutable__when() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_._when_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyPowerArcClass::release__when() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyPowerArcClass._when)
  if (!_internal_has__when()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_._when_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._when_.IsDefault()) {
    _impl_._when_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyPowerArcClass::set_allocated__when(std::string* _when) {
  if (_when != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_._when_.SetAllocated(_when, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._when_.IsDefault()) {
    _impl_._when_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyPowerArcClass._when)
}

// required uint64 _owner_cell = 5;
inline bool LibertyPowerArcClass::_internal_has__owner_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LibertyPowerArcClass::has__owner_cell() const {
  return _internal_has__owner_cell();
}
inline void LibertyPowerArcClass::clear__owner_cell() {
  _impl_._owner_cell_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t LibertyPowerArcClass::_internal__owner_cell() const {
  return _impl_._owner_cell_;
}
inline uint64_t LibertyPowerArcClass::_owner_cell() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcClass._owner_cell)
  return _internal__owner_cell();
}
inline void LibertyPowerArcClass::_internal_set__owner_cell(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._owner_cell_ = value;
}
inline void LibertyPowerArcClass::set__owner_cell(uint64_t value) {
  _internal_set__owner_cell(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcClass._owner_cell)
}

// optional uint64 _power_table_model = 6;
inline bool LibertyPowerArcClass::_internal_has__power_table_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LibertyPowerArcClass::has__power_table_model() const {
  return _internal_has__power_table_model();
}
inline void LibertyPowerArcClass::clear__power_table_model() {
  _impl_._power_table_model_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t LibertyPowerArcClass::_internal__power_table_model() const {
  return _impl_._power_table_model_;
}
inline uint64_t LibertyPowerArcClass::_power_table_model() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcClass._power_table_model)
  return _internal__power_table_model();
}
inline void LibertyPowerArcClass::_internal_set__power_table_model(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_._power_table_model_ = value;
}
inline void LibertyPowerArcClass::set__power_table_model(uint64_t value) {
  _internal_set__power_table_model(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcClass._power_table_model)
}

// -------------------------------------------------------------------

// LibertyPowerArcSetClass

// required uint64 id = 1;
inline bool LibertyPowerArcSetClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyPowerArcSetClass::has_id() const {
  return _internal_has_id();
}
inline void LibertyPowerArcSetClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LibertyPowerArcSetClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyPowerArcSetClass::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcSetClass.id)
  return _internal_id();
}
inline void LibertyPowerArcSetClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void LibertyPowerArcSetClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcSetClass.id)
}

// repeated uint64 _power_arcs = 2;
inline int LibertyPowerArcSetClass::_internal__power_arcs_size() const {
  return _impl_._power_arcs_.size();
}
inline int LibertyPowerArcSetClass::_power_arcs_size() const {
  return _internal__power_arcs_size();
}
inline void LibertyPowerArcSetClass::clear__power_arcs() {
  _impl_._power_arcs_.Clear();
}
inline uint64_t LibertyPowerArcSetClass::_internal__power_arcs(int index) const {
  return _impl_._power_arcs_.Get(index);
}
inline uint64_t LibertyPowerArcSetClass::_power_arcs(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyPowerArcSetClass._power_arcs)
  return _internal__power_arcs(index);
}
inline void LibertyPowerArcSetClass::set__power_arcs(int index, uint64_t value) {
  _impl_._power_arcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyPowerArcSetClass._power_arcs)
}
inline void LibertyPowerArcSetClass::_internal_add__power_arcs(uint64_t value) {
  _impl_._power_arcs_.Add(value);
}
inline void LibertyPowerArcSetClass::add__power_arcs(uint64_t value) {
  _internal_add__power_arcs(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyPowerArcSetClass._power_arcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyPowerArcSetClass::_internal__power_arcs() const {
  return _impl_._power_arcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyPowerArcSetClass::_power_arcs() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyPowerArcSetClass._power_arcs)
  return _internal__power_arcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyPowerArcSetClass::_internal_mutable__power_arcs() {
  return &_impl_._power_arcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyPowerArcSetClass::mutable__power_arcs() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyPowerArcSetClass._power_arcs)
  return _internal_mutable__power_arcs();
}

// -------------------------------------------------------------------

// LibertyLeakagePowerClass

// required string _related_pg_port = 1;
inline bool LibertyLeakagePowerClass::_internal_has__related_pg_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyLeakagePowerClass::has__related_pg_port() const {
  return _internal_has__related_pg_port();
}
inline void LibertyLeakagePowerClass::clear__related_pg_port() {
  _impl_._related_pg_port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyLeakagePowerClass::_related_pg_port() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLeakagePowerClass._related_pg_port)
  return _internal__related_pg_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLeakagePowerClass::set__related_pg_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._related_pg_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLeakagePowerClass._related_pg_port)
}
inline std::string* LibertyLeakagePowerClass::mutable__related_pg_port() {
  std::string* _s = _internal_mutable__related_pg_port();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLeakagePowerClass._related_pg_port)
  return _s;
}
inline const std::string& LibertyLeakagePowerClass::_internal__related_pg_port() const {
  return _impl_._related_pg_port_.Get();
}
inline void LibertyLeakagePowerClass::_internal_set__related_pg_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._related_pg_port_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLeakagePowerClass::_internal_mutable__related_pg_port() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._related_pg_port_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLeakagePowerClass::release__related_pg_port() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLeakagePowerClass._related_pg_port)
  if (!_internal_has__related_pg_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._related_pg_port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._related_pg_port_.IsDefault()) {
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLeakagePowerClass::set_allocated__related_pg_port(std::string* _related_pg_port) {
  if (_related_pg_port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._related_pg_port_.SetAllocated(_related_pg_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._related_pg_port_.IsDefault()) {
    _impl_._related_pg_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLeakagePowerClass._related_pg_port)
}

// required string _when = 2;
inline bool LibertyLeakagePowerClass::_internal_has__when() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyLeakagePowerClass::has__when() const {
  return _internal_has__when();
}
inline void LibertyLeakagePowerClass::clear__when() {
  _impl_._when_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LibertyLeakagePowerClass::_when() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLeakagePowerClass._when)
  return _internal__when();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLeakagePowerClass::set__when(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._when_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLeakagePowerClass._when)
}
inline std::string* LibertyLeakagePowerClass::mutable__when() {
  std::string* _s = _internal_mutable__when();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLeakagePowerClass._when)
  return _s;
}
inline const std::string& LibertyLeakagePowerClass::_internal__when() const {
  return _impl_._when_.Get();
}
inline void LibertyLeakagePowerClass::_internal_set__when(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._when_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLeakagePowerClass::_internal_mutable__when() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._when_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLeakagePowerClass::release__when() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLeakagePowerClass._when)
  if (!_internal_has__when()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._when_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._when_.IsDefault()) {
    _impl_._when_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLeakagePowerClass::set_allocated__when(std::string* _when) {
  if (_when != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._when_.SetAllocated(_when, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._when_.IsDefault()) {
    _impl_._when_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLeakagePowerClass._when)
}

// required double _value = 3;
inline bool LibertyLeakagePowerClass::_internal_has__value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyLeakagePowerClass::has__value() const {
  return _internal_has__value();
}
inline void LibertyLeakagePowerClass::clear__value() {
  _impl_._value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double LibertyLeakagePowerClass::_internal__value() const {
  return _impl_._value_;
}
inline double LibertyLeakagePowerClass::_value() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLeakagePowerClass._value)
  return _internal__value();
}
inline void LibertyLeakagePowerClass::_internal_set__value(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._value_ = value;
}
inline void LibertyLeakagePowerClass::set__value(double value) {
  _internal_set__value(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLeakagePowerClass._value)
}

// required uint64 _owner_cell = 4;
inline bool LibertyLeakagePowerClass::_internal_has__owner_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyLeakagePowerClass::has__owner_cell() const {
  return _internal_has__owner_cell();
}
inline void LibertyLeakagePowerClass::clear__owner_cell() {
  _impl_._owner_cell_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t LibertyLeakagePowerClass::_internal__owner_cell() const {
  return _impl_._owner_cell_;
}
inline uint64_t LibertyLeakagePowerClass::_owner_cell() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLeakagePowerClass._owner_cell)
  return _internal__owner_cell();
}
inline void LibertyLeakagePowerClass::_internal_set__owner_cell(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._owner_cell_ = value;
}
inline void LibertyLeakagePowerClass::set__owner_cell(uint64_t value) {
  _internal_set__owner_cell(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLeakagePowerClass._owner_cell)
}

// -------------------------------------------------------------------

// LibertyCellClass

// required string _cell_name = 1;
inline bool LibertyCellClass::_internal_has__cell_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyCellClass::has__cell_name() const {
  return _internal_has__cell_name();
}
inline void LibertyCellClass::clear__cell_name() {
  _impl_._cell_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyCellClass::_cell_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._cell_name)
  return _internal__cell_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyCellClass::set__cell_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._cell_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._cell_name)
}
inline std::string* LibertyCellClass::mutable__cell_name() {
  std::string* _s = _internal_mutable__cell_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyCellClass._cell_name)
  return _s;
}
inline const std::string& LibertyCellClass::_internal__cell_name() const {
  return _impl_._cell_name_.Get();
}
inline void LibertyCellClass::_internal_set__cell_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._cell_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyCellClass::_internal_mutable__cell_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._cell_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyCellClass::release__cell_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyCellClass._cell_name)
  if (!_internal_has__cell_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._cell_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._cell_name_.IsDefault()) {
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyCellClass::set_allocated__cell_name(std::string* _cell_name) {
  if (_cell_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._cell_name_.SetAllocated(_cell_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._cell_name_.IsDefault()) {
    _impl_._cell_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyCellClass._cell_name)
}

// required double _cell_leakage_power = 2;
inline bool LibertyCellClass::_internal_has__cell_leakage_power() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyCellClass::has__cell_leakage_power() const {
  return _internal_has__cell_leakage_power();
}
inline void LibertyCellClass::clear__cell_leakage_power() {
  _impl_._cell_leakage_power_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double LibertyCellClass::_internal__cell_leakage_power() const {
  return _impl_._cell_leakage_power_;
}
inline double LibertyCellClass::_cell_leakage_power() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._cell_leakage_power)
  return _internal__cell_leakage_power();
}
inline void LibertyCellClass::_internal_set__cell_leakage_power(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._cell_leakage_power_ = value;
}
inline void LibertyCellClass::set__cell_leakage_power(double value) {
  _internal_set__cell_leakage_power(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._cell_leakage_power)
}

// repeated uint64 _leakage_power_list = 3;
inline int LibertyCellClass::_internal__leakage_power_list_size() const {
  return _impl_._leakage_power_list_.size();
}
inline int LibertyCellClass::_leakage_power_list_size() const {
  return _internal__leakage_power_list_size();
}
inline void LibertyCellClass::clear__leakage_power_list() {
  _impl_._leakage_power_list_.Clear();
}
inline uint64_t LibertyCellClass::_internal__leakage_power_list(int index) const {
  return _impl_._leakage_power_list_.Get(index);
}
inline uint64_t LibertyCellClass::_leakage_power_list(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._leakage_power_list)
  return _internal__leakage_power_list(index);
}
inline void LibertyCellClass::set__leakage_power_list(int index, uint64_t value) {
  _impl_._leakage_power_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._leakage_power_list)
}
inline void LibertyCellClass::_internal_add__leakage_power_list(uint64_t value) {
  _impl_._leakage_power_list_.Add(value);
}
inline void LibertyCellClass::add__leakage_power_list(uint64_t value) {
  _internal_add__leakage_power_list(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyCellClass._leakage_power_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_internal__leakage_power_list() const {
  return _impl_._leakage_power_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_leakage_power_list() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyCellClass._leakage_power_list)
  return _internal__leakage_power_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::_internal_mutable__leakage_power_list() {
  return &_impl_._leakage_power_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::mutable__leakage_power_list() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyCellClass._leakage_power_list)
  return _internal_mutable__leakage_power_list();
}

// repeated uint64 _cell_ports = 4;
inline int LibertyCellClass::_internal__cell_ports_size() const {
  return _impl_._cell_ports_.size();
}
inline int LibertyCellClass::_cell_ports_size() const {
  return _internal__cell_ports_size();
}
inline void LibertyCellClass::clear__cell_ports() {
  _impl_._cell_ports_.Clear();
}
inline uint64_t LibertyCellClass::_internal__cell_ports(int index) const {
  return _impl_._cell_ports_.Get(index);
}
inline uint64_t LibertyCellClass::_cell_ports(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._cell_ports)
  return _internal__cell_ports(index);
}
inline void LibertyCellClass::set__cell_ports(int index, uint64_t value) {
  _impl_._cell_ports_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._cell_ports)
}
inline void LibertyCellClass::_internal_add__cell_ports(uint64_t value) {
  _impl_._cell_ports_.Add(value);
}
inline void LibertyCellClass::add__cell_ports(uint64_t value) {
  _internal_add__cell_ports(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyCellClass._cell_ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_internal__cell_ports() const {
  return _impl_._cell_ports_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_cell_ports() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyCellClass._cell_ports)
  return _internal__cell_ports();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::_internal_mutable__cell_ports() {
  return &_impl_._cell_ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::mutable__cell_ports() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyCellClass._cell_ports)
  return _internal_mutable__cell_ports();
}

// repeated uint64 _cell_port_buses = 5;
inline int LibertyCellClass::_internal__cell_port_buses_size() const {
  return _impl_._cell_port_buses_.size();
}
inline int LibertyCellClass::_cell_port_buses_size() const {
  return _internal__cell_port_buses_size();
}
inline void LibertyCellClass::clear__cell_port_buses() {
  _impl_._cell_port_buses_.Clear();
}
inline uint64_t LibertyCellClass::_internal__cell_port_buses(int index) const {
  return _impl_._cell_port_buses_.Get(index);
}
inline uint64_t LibertyCellClass::_cell_port_buses(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._cell_port_buses)
  return _internal__cell_port_buses(index);
}
inline void LibertyCellClass::set__cell_port_buses(int index, uint64_t value) {
  _impl_._cell_port_buses_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._cell_port_buses)
}
inline void LibertyCellClass::_internal_add__cell_port_buses(uint64_t value) {
  _impl_._cell_port_buses_.Add(value);
}
inline void LibertyCellClass::add__cell_port_buses(uint64_t value) {
  _internal_add__cell_port_buses(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyCellClass._cell_port_buses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_internal__cell_port_buses() const {
  return _impl_._cell_port_buses_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_cell_port_buses() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyCellClass._cell_port_buses)
  return _internal__cell_port_buses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::_internal_mutable__cell_port_buses() {
  return &_impl_._cell_port_buses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::mutable__cell_port_buses() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyCellClass._cell_port_buses)
  return _internal_mutable__cell_port_buses();
}

// repeated uint64 _cell_arcs = 6;
inline int LibertyCellClass::_internal__cell_arcs_size() const {
  return _impl_._cell_arcs_.size();
}
inline int LibertyCellClass::_cell_arcs_size() const {
  return _internal__cell_arcs_size();
}
inline void LibertyCellClass::clear__cell_arcs() {
  _impl_._cell_arcs_.Clear();
}
inline uint64_t LibertyCellClass::_internal__cell_arcs(int index) const {
  return _impl_._cell_arcs_.Get(index);
}
inline uint64_t LibertyCellClass::_cell_arcs(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._cell_arcs)
  return _internal__cell_arcs(index);
}
inline void LibertyCellClass::set__cell_arcs(int index, uint64_t value) {
  _impl_._cell_arcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._cell_arcs)
}
inline void LibertyCellClass::_internal_add__cell_arcs(uint64_t value) {
  _impl_._cell_arcs_.Add(value);
}
inline void LibertyCellClass::add__cell_arcs(uint64_t value) {
  _internal_add__cell_arcs(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyCellClass._cell_arcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_internal__cell_arcs() const {
  return _impl_._cell_arcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_cell_arcs() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyCellClass._cell_arcs)
  return _internal__cell_arcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::_internal_mutable__cell_arcs() {
  return &_impl_._cell_arcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::mutable__cell_arcs() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyCellClass._cell_arcs)
  return _internal_mutable__cell_arcs();
}

// repeated uint64 _cell_power_arcs = 7;
inline int LibertyCellClass::_internal__cell_power_arcs_size() const {
  return _impl_._cell_power_arcs_.size();
}
inline int LibertyCellClass::_cell_power_arcs_size() const {
  return _internal__cell_power_arcs_size();
}
inline void LibertyCellClass::clear__cell_power_arcs() {
  _impl_._cell_power_arcs_.Clear();
}
inline uint64_t LibertyCellClass::_internal__cell_power_arcs(int index) const {
  return _impl_._cell_power_arcs_.Get(index);
}
inline uint64_t LibertyCellClass::_cell_power_arcs(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._cell_power_arcs)
  return _internal__cell_power_arcs(index);
}
inline void LibertyCellClass::set__cell_power_arcs(int index, uint64_t value) {
  _impl_._cell_power_arcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._cell_power_arcs)
}
inline void LibertyCellClass::_internal_add__cell_power_arcs(uint64_t value) {
  _impl_._cell_power_arcs_.Add(value);
}
inline void LibertyCellClass::add__cell_power_arcs(uint64_t value) {
  _internal_add__cell_power_arcs(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyCellClass._cell_power_arcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_internal__cell_power_arcs() const {
  return _impl_._cell_power_arcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyCellClass::_cell_power_arcs() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyCellClass._cell_power_arcs)
  return _internal__cell_power_arcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::_internal_mutable__cell_power_arcs() {
  return &_impl_._cell_power_arcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyCellClass::mutable__cell_power_arcs() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyCellClass._cell_power_arcs)
  return _internal_mutable__cell_power_arcs();
}

// required uint64 _owner_lib = 8;
inline bool LibertyCellClass::_internal_has__owner_lib() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyCellClass::has__owner_lib() const {
  return _internal_has__owner_lib();
}
inline void LibertyCellClass::clear__owner_lib() {
  _impl_._owner_lib_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t LibertyCellClass::_internal__owner_lib() const {
  return _impl_._owner_lib_;
}
inline uint64_t LibertyCellClass::_owner_lib() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._owner_lib)
  return _internal__owner_lib();
}
inline void LibertyCellClass::_internal_set__owner_lib(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._owner_lib_ = value;
}
inline void LibertyCellClass::set__owner_lib(uint64_t value) {
  _internal_set__owner_lib(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._owner_lib)
}

// required uint32 _is_dont_use = 9;
inline bool LibertyCellClass::_internal_has__is_dont_use() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyCellClass::has__is_dont_use() const {
  return _internal_has__is_dont_use();
}
inline void LibertyCellClass::clear__is_dont_use() {
  _impl_._is_dont_use_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LibertyCellClass::_internal__is_dont_use() const {
  return _impl_._is_dont_use_;
}
inline uint32_t LibertyCellClass::_is_dont_use() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCellClass._is_dont_use)
  return _internal__is_dont_use();
}
inline void LibertyCellClass::_internal_set__is_dont_use(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._is_dont_use_ = value;
}
inline void LibertyCellClass::set__is_dont_use(uint32_t value) {
  _internal_set__is_dont_use(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCellClass._is_dont_use)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LibertyWireLoadClass

// required string _wire_load_name = 1;
inline bool LibertyWireLoadClass::_internal_has__wire_load_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyWireLoadClass::has__wire_load_name() const {
  return _internal_has__wire_load_name();
}
inline void LibertyWireLoadClass::clear__wire_load_name() {
  _impl_._wire_load_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyWireLoadClass::_wire_load_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyWireLoadClass._wire_load_name)
  return _internal__wire_load_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyWireLoadClass::set__wire_load_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._wire_load_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyWireLoadClass._wire_load_name)
}
inline std::string* LibertyWireLoadClass::mutable__wire_load_name() {
  std::string* _s = _internal_mutable__wire_load_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyWireLoadClass._wire_load_name)
  return _s;
}
inline const std::string& LibertyWireLoadClass::_internal__wire_load_name() const {
  return _impl_._wire_load_name_.Get();
}
inline void LibertyWireLoadClass::_internal_set__wire_load_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._wire_load_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyWireLoadClass::_internal_mutable__wire_load_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._wire_load_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyWireLoadClass::release__wire_load_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyWireLoadClass._wire_load_name)
  if (!_internal_has__wire_load_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._wire_load_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._wire_load_name_.IsDefault()) {
    _impl_._wire_load_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyWireLoadClass::set_allocated__wire_load_name(std::string* _wire_load_name) {
  if (_wire_load_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._wire_load_name_.SetAllocated(_wire_load_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._wire_load_name_.IsDefault()) {
    _impl_._wire_load_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyWireLoadClass._wire_load_name)
}

// map<int32, double> _fanout_to_length = 2;
inline int LibertyWireLoadClass::_internal__fanout_to_length_size() const {
  return _impl_._fanout_to_length_.size();
}
inline int LibertyWireLoadClass::_fanout_to_length_size() const {
  return _internal__fanout_to_length_size();
}
inline void LibertyWireLoadClass::clear__fanout_to_length() {
  _impl_._fanout_to_length_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >&
LibertyWireLoadClass::_internal__fanout_to_length() const {
  return _impl_._fanout_to_length_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >&
LibertyWireLoadClass::_fanout_to_length() const {
  // @@protoc_insertion_point(field_map:Liberty.LibertyWireLoadClass._fanout_to_length)
  return _internal__fanout_to_length();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >*
LibertyWireLoadClass::_internal_mutable__fanout_to_length() {
  return _impl_._fanout_to_length_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, double >*
LibertyWireLoadClass::mutable__fanout_to_length() {
  // @@protoc_insertion_point(field_mutable_map:Liberty.LibertyWireLoadClass._fanout_to_length)
  return _internal_mutable__fanout_to_length();
}

// optional double _cap_per_length_unit = 3;
inline bool LibertyWireLoadClass::_internal_has__cap_per_length_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyWireLoadClass::has__cap_per_length_unit() const {
  return _internal_has__cap_per_length_unit();
}
inline void LibertyWireLoadClass::clear__cap_per_length_unit() {
  _impl_._cap_per_length_unit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double LibertyWireLoadClass::_internal__cap_per_length_unit() const {
  return _impl_._cap_per_length_unit_;
}
inline double LibertyWireLoadClass::_cap_per_length_unit() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyWireLoadClass._cap_per_length_unit)
  return _internal__cap_per_length_unit();
}
inline void LibertyWireLoadClass::_internal_set__cap_per_length_unit(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._cap_per_length_unit_ = value;
}
inline void LibertyWireLoadClass::set__cap_per_length_unit(double value) {
  _internal_set__cap_per_length_unit(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyWireLoadClass._cap_per_length_unit)
}

// optional double _resistance_per_length_unit = 4;
inline bool LibertyWireLoadClass::_internal_has__resistance_per_length_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyWireLoadClass::has__resistance_per_length_unit() const {
  return _internal_has__resistance_per_length_unit();
}
inline void LibertyWireLoadClass::clear__resistance_per_length_unit() {
  _impl_._resistance_per_length_unit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double LibertyWireLoadClass::_internal__resistance_per_length_unit() const {
  return _impl_._resistance_per_length_unit_;
}
inline double LibertyWireLoadClass::_resistance_per_length_unit() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyWireLoadClass._resistance_per_length_unit)
  return _internal__resistance_per_length_unit();
}
inline void LibertyWireLoadClass::_internal_set__resistance_per_length_unit(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._resistance_per_length_unit_ = value;
}
inline void LibertyWireLoadClass::set__resistance_per_length_unit(double value) {
  _internal_set__resistance_per_length_unit(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyWireLoadClass._resistance_per_length_unit)
}

// optional double _slope = 5;
inline bool LibertyWireLoadClass::_internal_has__slope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyWireLoadClass::has__slope() const {
  return _internal_has__slope();
}
inline void LibertyWireLoadClass::clear__slope() {
  _impl_._slope_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double LibertyWireLoadClass::_internal__slope() const {
  return _impl_._slope_;
}
inline double LibertyWireLoadClass::_slope() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyWireLoadClass._slope)
  return _internal__slope();
}
inline void LibertyWireLoadClass::_internal_set__slope(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._slope_ = value;
}
inline void LibertyWireLoadClass::set__slope(double value) {
  _internal_set__slope(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyWireLoadClass._slope)
}

// -------------------------------------------------------------------

// LibertyLutTableTemplateClass

// required string _template_name = 1;
inline bool LibertyLutTableTemplateClass::_internal_has__template_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyLutTableTemplateClass::has__template_name() const {
  return _internal_has__template_name();
}
inline void LibertyLutTableTemplateClass::clear__template_name() {
  _impl_._template_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyLutTableTemplateClass::_template_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateClass._template_name)
  return _internal__template_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLutTableTemplateClass::set__template_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._template_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLutTableTemplateClass._template_name)
}
inline std::string* LibertyLutTableTemplateClass::mutable__template_name() {
  std::string* _s = _internal_mutable__template_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLutTableTemplateClass._template_name)
  return _s;
}
inline const std::string& LibertyLutTableTemplateClass::_internal__template_name() const {
  return _impl_._template_name_.Get();
}
inline void LibertyLutTableTemplateClass::_internal_set__template_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._template_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::_internal_mutable__template_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._template_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::release__template_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLutTableTemplateClass._template_name)
  if (!_internal_has__template_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._template_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_name_.IsDefault()) {
    _impl_._template_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLutTableTemplateClass::set_allocated__template_name(std::string* _template_name) {
  if (_template_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._template_name_.SetAllocated(_template_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_name_.IsDefault()) {
    _impl_._template_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLutTableTemplateClass._template_name)
}

// optional string _template_variable1 = 2;
inline bool LibertyLutTableTemplateClass::_internal_has__template_variable1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyLutTableTemplateClass::has__template_variable1() const {
  return _internal_has__template_variable1();
}
inline void LibertyLutTableTemplateClass::clear__template_variable1() {
  _impl_._template_variable1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LibertyLutTableTemplateClass::_template_variable1() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateClass._template_variable1)
  return _internal__template_variable1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLutTableTemplateClass::set__template_variable1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._template_variable1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLutTableTemplateClass._template_variable1)
}
inline std::string* LibertyLutTableTemplateClass::mutable__template_variable1() {
  std::string* _s = _internal_mutable__template_variable1();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLutTableTemplateClass._template_variable1)
  return _s;
}
inline const std::string& LibertyLutTableTemplateClass::_internal__template_variable1() const {
  return _impl_._template_variable1_.Get();
}
inline void LibertyLutTableTemplateClass::_internal_set__template_variable1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._template_variable1_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::_internal_mutable__template_variable1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._template_variable1_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::release__template_variable1() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLutTableTemplateClass._template_variable1)
  if (!_internal_has__template_variable1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._template_variable1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable1_.IsDefault()) {
    _impl_._template_variable1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLutTableTemplateClass::set_allocated__template_variable1(std::string* _template_variable1) {
  if (_template_variable1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._template_variable1_.SetAllocated(_template_variable1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable1_.IsDefault()) {
    _impl_._template_variable1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLutTableTemplateClass._template_variable1)
}

// optional string _template_variable2 = 3;
inline bool LibertyLutTableTemplateClass::_internal_has__template_variable2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyLutTableTemplateClass::has__template_variable2() const {
  return _internal_has__template_variable2();
}
inline void LibertyLutTableTemplateClass::clear__template_variable2() {
  _impl_._template_variable2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LibertyLutTableTemplateClass::_template_variable2() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateClass._template_variable2)
  return _internal__template_variable2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLutTableTemplateClass::set__template_variable2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_._template_variable2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLutTableTemplateClass._template_variable2)
}
inline std::string* LibertyLutTableTemplateClass::mutable__template_variable2() {
  std::string* _s = _internal_mutable__template_variable2();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLutTableTemplateClass._template_variable2)
  return _s;
}
inline const std::string& LibertyLutTableTemplateClass::_internal__template_variable2() const {
  return _impl_._template_variable2_.Get();
}
inline void LibertyLutTableTemplateClass::_internal_set__template_variable2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._template_variable2_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::_internal_mutable__template_variable2() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_._template_variable2_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::release__template_variable2() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLutTableTemplateClass._template_variable2)
  if (!_internal_has__template_variable2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_._template_variable2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable2_.IsDefault()) {
    _impl_._template_variable2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLutTableTemplateClass::set_allocated__template_variable2(std::string* _template_variable2) {
  if (_template_variable2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_._template_variable2_.SetAllocated(_template_variable2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable2_.IsDefault()) {
    _impl_._template_variable2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLutTableTemplateClass._template_variable2)
}

// optional string _template_variable3 = 4;
inline bool LibertyLutTableTemplateClass::_internal_has__template_variable3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyLutTableTemplateClass::has__template_variable3() const {
  return _internal_has__template_variable3();
}
inline void LibertyLutTableTemplateClass::clear__template_variable3() {
  _impl_._template_variable3_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LibertyLutTableTemplateClass::_template_variable3() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateClass._template_variable3)
  return _internal__template_variable3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLutTableTemplateClass::set__template_variable3(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_._template_variable3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLutTableTemplateClass._template_variable3)
}
inline std::string* LibertyLutTableTemplateClass::mutable__template_variable3() {
  std::string* _s = _internal_mutable__template_variable3();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLutTableTemplateClass._template_variable3)
  return _s;
}
inline const std::string& LibertyLutTableTemplateClass::_internal__template_variable3() const {
  return _impl_._template_variable3_.Get();
}
inline void LibertyLutTableTemplateClass::_internal_set__template_variable3(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._template_variable3_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::_internal_mutable__template_variable3() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_._template_variable3_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::release__template_variable3() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLutTableTemplateClass._template_variable3)
  if (!_internal_has__template_variable3()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_._template_variable3_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable3_.IsDefault()) {
    _impl_._template_variable3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLutTableTemplateClass::set_allocated__template_variable3(std::string* _template_variable3) {
  if (_template_variable3 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_._template_variable3_.SetAllocated(_template_variable3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable3_.IsDefault()) {
    _impl_._template_variable3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLutTableTemplateClass._template_variable3)
}

// optional string _template_variable4 = 5;
inline bool LibertyLutTableTemplateClass::_internal_has__template_variable4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LibertyLutTableTemplateClass::has__template_variable4() const {
  return _internal_has__template_variable4();
}
inline void LibertyLutTableTemplateClass::clear__template_variable4() {
  _impl_._template_variable4_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LibertyLutTableTemplateClass::_template_variable4() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateClass._template_variable4)
  return _internal__template_variable4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLutTableTemplateClass::set__template_variable4(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_._template_variable4_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLutTableTemplateClass._template_variable4)
}
inline std::string* LibertyLutTableTemplateClass::mutable__template_variable4() {
  std::string* _s = _internal_mutable__template_variable4();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLutTableTemplateClass._template_variable4)
  return _s;
}
inline const std::string& LibertyLutTableTemplateClass::_internal__template_variable4() const {
  return _impl_._template_variable4_.Get();
}
inline void LibertyLutTableTemplateClass::_internal_set__template_variable4(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_._template_variable4_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::_internal_mutable__template_variable4() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_._template_variable4_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLutTableTemplateClass::release__template_variable4() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLutTableTemplateClass._template_variable4)
  if (!_internal_has__template_variable4()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_._template_variable4_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable4_.IsDefault()) {
    _impl_._template_variable4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLutTableTemplateClass::set_allocated__template_variable4(std::string* _template_variable4) {
  if (_template_variable4 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_._template_variable4_.SetAllocated(_template_variable4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._template_variable4_.IsDefault()) {
    _impl_._template_variable4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLutTableTemplateClass._template_variable4)
}

// repeated uint64 _axes = 6;
inline int LibertyLutTableTemplateClass::_internal__axes_size() const {
  return _impl_._axes_.size();
}
inline int LibertyLutTableTemplateClass::_axes_size() const {
  return _internal__axes_size();
}
inline void LibertyLutTableTemplateClass::clear__axes() {
  _impl_._axes_.Clear();
}
inline uint64_t LibertyLutTableTemplateClass::_internal__axes(int index) const {
  return _impl_._axes_.Get(index);
}
inline uint64_t LibertyLutTableTemplateClass::_axes(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateClass._axes)
  return _internal__axes(index);
}
inline void LibertyLutTableTemplateClass::set__axes(int index, uint64_t value) {
  _impl_._axes_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLutTableTemplateClass._axes)
}
inline void LibertyLutTableTemplateClass::_internal_add__axes(uint64_t value) {
  _impl_._axes_.Add(value);
}
inline void LibertyLutTableTemplateClass::add__axes(uint64_t value) {
  _internal_add__axes(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyLutTableTemplateClass._axes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLutTableTemplateClass::_internal__axes() const {
  return _impl_._axes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLutTableTemplateClass::_axes() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyLutTableTemplateClass._axes)
  return _internal__axes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLutTableTemplateClass::_internal_mutable__axes() {
  return &_impl_._axes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLutTableTemplateClass::mutable__axes() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyLutTableTemplateClass._axes)
  return _internal_mutable__axes();
}

// -------------------------------------------------------------------

// LibertyCurrentTemplateClass

// optional uint64 _template_axis = 1;
inline bool LibertyCurrentTemplateClass::_internal_has__template_axis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyCurrentTemplateClass::has__template_axis() const {
  return _internal_has__template_axis();
}
inline void LibertyCurrentTemplateClass::clear__template_axis() {
  _impl_._template_axis_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LibertyCurrentTemplateClass::_internal__template_axis() const {
  return _impl_._template_axis_;
}
inline uint64_t LibertyCurrentTemplateClass::_template_axis() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyCurrentTemplateClass._template_axis)
  return _internal__template_axis();
}
inline void LibertyCurrentTemplateClass::_internal_set__template_axis(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._template_axis_ = value;
}
inline void LibertyCurrentTemplateClass::set__template_axis(uint64_t value) {
  _internal_set__template_axis(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyCurrentTemplateClass._template_axis)
}

// -------------------------------------------------------------------

// LibertyLutTableTemplateSyn

// required uint32 lltts_type = 1;
inline bool LibertyLutTableTemplateSyn::_internal_has_lltts_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyLutTableTemplateSyn::has_lltts_type() const {
  return _internal_has_lltts_type();
}
inline void LibertyLutTableTemplateSyn::clear_lltts_type() {
  _impl_.lltts_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LibertyLutTableTemplateSyn::_internal_lltts_type() const {
  return _impl_.lltts_type_;
}
inline uint32_t LibertyLutTableTemplateSyn::lltts_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateSyn.lltts_type)
  return _internal_lltts_type();
}
inline void LibertyLutTableTemplateSyn::_internal_set_lltts_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lltts_type_ = value;
}
inline void LibertyLutTableTemplateSyn::set_lltts_type(uint32_t value) {
  _internal_set_lltts_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLutTableTemplateSyn.lltts_type)
}

// required .Liberty.LibertyLutTableTemplateClass parent = 2;
inline bool LibertyLutTableTemplateSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool LibertyLutTableTemplateSyn::has_parent() const {
  return _internal_has_parent();
}
inline void LibertyLutTableTemplateSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Liberty::LibertyLutTableTemplateClass& LibertyLutTableTemplateSyn::_internal_parent() const {
  const ::Liberty::LibertyLutTableTemplateClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyLutTableTemplateClass&>(
      ::Liberty::_LibertyLutTableTemplateClass_default_instance_);
}
inline const ::Liberty::LibertyLutTableTemplateClass& LibertyLutTableTemplateSyn::parent() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateSyn.parent)
  return _internal_parent();
}
inline void LibertyLutTableTemplateSyn::unsafe_arena_set_allocated_parent(
    ::Liberty::LibertyLutTableTemplateClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyLutTableTemplateSyn.parent)
}
inline ::Liberty::LibertyLutTableTemplateClass* LibertyLutTableTemplateSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyLutTableTemplateClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyLutTableTemplateClass* LibertyLutTableTemplateSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLutTableTemplateSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyLutTableTemplateClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyLutTableTemplateClass* LibertyLutTableTemplateSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyLutTableTemplateClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Liberty::LibertyLutTableTemplateClass* LibertyLutTableTemplateSyn::mutable_parent() {
  ::Liberty::LibertyLutTableTemplateClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLutTableTemplateSyn.parent)
  return _msg;
}
inline void LibertyLutTableTemplateSyn::set_allocated_parent(::Liberty::LibertyLutTableTemplateClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLutTableTemplateSyn.parent)
}

// optional .Liberty.LibertyCurrentTemplateClass lctc = 3;
inline bool LibertyLutTableTemplateSyn::_internal_has_lctc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lctc_ != nullptr);
  return value;
}
inline bool LibertyLutTableTemplateSyn::has_lctc() const {
  return _internal_has_lctc();
}
inline void LibertyLutTableTemplateSyn::clear_lctc() {
  if (_impl_.lctc_ != nullptr) _impl_.lctc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Liberty::LibertyCurrentTemplateClass& LibertyLutTableTemplateSyn::_internal_lctc() const {
  const ::Liberty::LibertyCurrentTemplateClass* p = _impl_.lctc_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyCurrentTemplateClass&>(
      ::Liberty::_LibertyCurrentTemplateClass_default_instance_);
}
inline const ::Liberty::LibertyCurrentTemplateClass& LibertyLutTableTemplateSyn::lctc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLutTableTemplateSyn.lctc)
  return _internal_lctc();
}
inline void LibertyLutTableTemplateSyn::unsafe_arena_set_allocated_lctc(
    ::Liberty::LibertyCurrentTemplateClass* lctc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lctc_);
  }
  _impl_.lctc_ = lctc;
  if (lctc) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyLutTableTemplateSyn.lctc)
}
inline ::Liberty::LibertyCurrentTemplateClass* LibertyLutTableTemplateSyn::release_lctc() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyCurrentTemplateClass* temp = _impl_.lctc_;
  _impl_.lctc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyCurrentTemplateClass* LibertyLutTableTemplateSyn::unsafe_arena_release_lctc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLutTableTemplateSyn.lctc)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Liberty::LibertyCurrentTemplateClass* temp = _impl_.lctc_;
  _impl_.lctc_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyCurrentTemplateClass* LibertyLutTableTemplateSyn::_internal_mutable_lctc() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lctc_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyCurrentTemplateClass>(GetArenaForAllocation());
    _impl_.lctc_ = p;
  }
  return _impl_.lctc_;
}
inline ::Liberty::LibertyCurrentTemplateClass* LibertyLutTableTemplateSyn::mutable_lctc() {
  ::Liberty::LibertyCurrentTemplateClass* _msg = _internal_mutable_lctc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLutTableTemplateSyn.lctc)
  return _msg;
}
inline void LibertyLutTableTemplateSyn::set_allocated_lctc(::Liberty::LibertyCurrentTemplateClass* lctc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lctc_;
  }
  if (lctc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lctc);
    if (message_arena != submessage_arena) {
      lctc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lctc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lctc_ = lctc;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLutTableTemplateSyn.lctc)
}

// -------------------------------------------------------------------

// LibertyObjectSyn

// required uint64 id = 1;
inline bool LibertyObjectSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyObjectSyn::has_id() const {
  return _internal_has_id();
}
inline void LibertyObjectSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t LibertyObjectSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyObjectSyn::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.id)
  return _internal_id();
}
inline void LibertyObjectSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void LibertyObjectSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyObjectSyn.id)
}

// required uint32 los_type = 2;
inline bool LibertyObjectSyn::_internal_has_los_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyObjectSyn::has_los_type() const {
  return _internal_has_los_type();
}
inline void LibertyObjectSyn::clear_los_type() {
  _impl_.los_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LibertyObjectSyn::_internal_los_type() const {
  return _impl_.los_type_;
}
inline uint32_t LibertyObjectSyn::los_type() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.los_type)
  return _internal_los_type();
}
inline void LibertyObjectSyn::_internal_set_los_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.los_type_ = value;
}
inline void LibertyObjectSyn::set_los_type(uint32_t value) {
  _internal_set_los_type(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyObjectSyn.los_type)
}

// required .Liberty.LibertyObjectClass parent = 3;
inline bool LibertyObjectSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool LibertyObjectSyn::has_parent() const {
  return _internal_has_parent();
}
inline void LibertyObjectSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Liberty::LibertyObjectClass& LibertyObjectSyn::_internal_parent() const {
  const ::Liberty::LibertyObjectClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Liberty::LibertyObjectClass&>(
      ::Liberty::_LibertyObjectClass_default_instance_);
}
inline const ::Liberty::LibertyObjectClass& LibertyObjectSyn::parent() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.parent)
  return _internal_parent();
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_parent(
    ::Liberty::LibertyObjectClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.parent)
}
inline ::Liberty::LibertyObjectClass* LibertyObjectSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyObjectClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Liberty::LibertyObjectClass* LibertyObjectSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Liberty::LibertyObjectClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Liberty::LibertyObjectClass* LibertyObjectSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Liberty::LibertyObjectClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Liberty::LibertyObjectClass* LibertyObjectSyn::mutable_parent() {
  ::Liberty::LibertyObjectClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.parent)
  return _msg;
}
inline void LibertyObjectSyn::set_allocated_parent(::Liberty::LibertyObjectClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyObjectSyn.parent)
}

// .Liberty.LibertyAxisClass laxc = 4;
inline bool LibertyObjectSyn::_internal_has_laxc() const {
  return los_case() == kLaxc;
}
inline bool LibertyObjectSyn::has_laxc() const {
  return _internal_has_laxc();
}
inline void LibertyObjectSyn::set_has_laxc() {
  _impl_._oneof_case_[0] = kLaxc;
}
inline void LibertyObjectSyn::clear_laxc() {
  if (_internal_has_laxc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.laxc_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyAxisClass* LibertyObjectSyn::release_laxc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.laxc)
  if (_internal_has_laxc()) {
    clear_has_los();
    ::Liberty::LibertyAxisClass* temp = _impl_.los_.laxc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.laxc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyAxisClass& LibertyObjectSyn::_internal_laxc() const {
  return _internal_has_laxc()
      ? *_impl_.los_.laxc_
      : reinterpret_cast< ::Liberty::LibertyAxisClass&>(::Liberty::_LibertyAxisClass_default_instance_);
}
inline const ::Liberty::LibertyAxisClass& LibertyObjectSyn::laxc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.laxc)
  return _internal_laxc();
}
inline ::Liberty::LibertyAxisClass* LibertyObjectSyn::unsafe_arena_release_laxc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.laxc)
  if (_internal_has_laxc()) {
    clear_has_los();
    ::Liberty::LibertyAxisClass* temp = _impl_.los_.laxc_;
    _impl_.los_.laxc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_laxc(::Liberty::LibertyAxisClass* laxc) {
  clear_los();
  if (laxc) {
    set_has_laxc();
    _impl_.los_.laxc_ = laxc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.laxc)
}
inline ::Liberty::LibertyAxisClass* LibertyObjectSyn::_internal_mutable_laxc() {
  if (!_internal_has_laxc()) {
    clear_los();
    set_has_laxc();
    _impl_.los_.laxc_ = CreateMaybeMessage< ::Liberty::LibertyAxisClass >(GetArenaForAllocation());
  }
  return _impl_.los_.laxc_;
}
inline ::Liberty::LibertyAxisClass* LibertyObjectSyn::mutable_laxc() {
  ::Liberty::LibertyAxisClass* _msg = _internal_mutable_laxc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.laxc)
  return _msg;
}

// .Liberty.LibertyTableSyn lts = 5;
inline bool LibertyObjectSyn::_internal_has_lts() const {
  return los_case() == kLts;
}
inline bool LibertyObjectSyn::has_lts() const {
  return _internal_has_lts();
}
inline void LibertyObjectSyn::set_has_lts() {
  _impl_._oneof_case_[0] = kLts;
}
inline void LibertyObjectSyn::clear_lts() {
  if (_internal_has_lts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.lts_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyTableSyn* LibertyObjectSyn::release_lts() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.lts)
  if (_internal_has_lts()) {
    clear_has_los();
    ::Liberty::LibertyTableSyn* temp = _impl_.los_.lts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.lts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyTableSyn& LibertyObjectSyn::_internal_lts() const {
  return _internal_has_lts()
      ? *_impl_.los_.lts_
      : reinterpret_cast< ::Liberty::LibertyTableSyn&>(::Liberty::_LibertyTableSyn_default_instance_);
}
inline const ::Liberty::LibertyTableSyn& LibertyObjectSyn::lts() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.lts)
  return _internal_lts();
}
inline ::Liberty::LibertyTableSyn* LibertyObjectSyn::unsafe_arena_release_lts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.lts)
  if (_internal_has_lts()) {
    clear_has_los();
    ::Liberty::LibertyTableSyn* temp = _impl_.los_.lts_;
    _impl_.los_.lts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_lts(::Liberty::LibertyTableSyn* lts) {
  clear_los();
  if (lts) {
    set_has_lts();
    _impl_.los_.lts_ = lts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.lts)
}
inline ::Liberty::LibertyTableSyn* LibertyObjectSyn::_internal_mutable_lts() {
  if (!_internal_has_lts()) {
    clear_los();
    set_has_lts();
    _impl_.los_.lts_ = CreateMaybeMessage< ::Liberty::LibertyTableSyn >(GetArenaForAllocation());
  }
  return _impl_.los_.lts_;
}
inline ::Liberty::LibertyTableSyn* LibertyObjectSyn::mutable_lts() {
  ::Liberty::LibertyTableSyn* _msg = _internal_mutable_lts();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.lts)
  return _msg;
}

// .Liberty.LibertyCCSTableClass lccstc = 6;
inline bool LibertyObjectSyn::_internal_has_lccstc() const {
  return los_case() == kLccstc;
}
inline bool LibertyObjectSyn::has_lccstc() const {
  return _internal_has_lccstc();
}
inline void LibertyObjectSyn::set_has_lccstc() {
  _impl_._oneof_case_[0] = kLccstc;
}
inline void LibertyObjectSyn::clear_lccstc() {
  if (_internal_has_lccstc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.lccstc_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyCCSTableClass* LibertyObjectSyn::release_lccstc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.lccstc)
  if (_internal_has_lccstc()) {
    clear_has_los();
    ::Liberty::LibertyCCSTableClass* temp = _impl_.los_.lccstc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.lccstc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyCCSTableClass& LibertyObjectSyn::_internal_lccstc() const {
  return _internal_has_lccstc()
      ? *_impl_.los_.lccstc_
      : reinterpret_cast< ::Liberty::LibertyCCSTableClass&>(::Liberty::_LibertyCCSTableClass_default_instance_);
}
inline const ::Liberty::LibertyCCSTableClass& LibertyObjectSyn::lccstc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.lccstc)
  return _internal_lccstc();
}
inline ::Liberty::LibertyCCSTableClass* LibertyObjectSyn::unsafe_arena_release_lccstc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.lccstc)
  if (_internal_has_lccstc()) {
    clear_has_los();
    ::Liberty::LibertyCCSTableClass* temp = _impl_.los_.lccstc_;
    _impl_.los_.lccstc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_lccstc(::Liberty::LibertyCCSTableClass* lccstc) {
  clear_los();
  if (lccstc) {
    set_has_lccstc();
    _impl_.los_.lccstc_ = lccstc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.lccstc)
}
inline ::Liberty::LibertyCCSTableClass* LibertyObjectSyn::_internal_mutable_lccstc() {
  if (!_internal_has_lccstc()) {
    clear_los();
    set_has_lccstc();
    _impl_.los_.lccstc_ = CreateMaybeMessage< ::Liberty::LibertyCCSTableClass >(GetArenaForAllocation());
  }
  return _impl_.los_.lccstc_;
}
inline ::Liberty::LibertyCCSTableClass* LibertyObjectSyn::mutable_lccstc() {
  ::Liberty::LibertyCCSTableClass* _msg = _internal_mutable_lccstc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.lccstc)
  return _msg;
}

// .Liberty.LibertyTableModelSyn ltms = 7;
inline bool LibertyObjectSyn::_internal_has_ltms() const {
  return los_case() == kLtms;
}
inline bool LibertyObjectSyn::has_ltms() const {
  return _internal_has_ltms();
}
inline void LibertyObjectSyn::set_has_ltms() {
  _impl_._oneof_case_[0] = kLtms;
}
inline void LibertyObjectSyn::clear_ltms() {
  if (_internal_has_ltms()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.ltms_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyTableModelSyn* LibertyObjectSyn::release_ltms() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.ltms)
  if (_internal_has_ltms()) {
    clear_has_los();
    ::Liberty::LibertyTableModelSyn* temp = _impl_.los_.ltms_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.ltms_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyTableModelSyn& LibertyObjectSyn::_internal_ltms() const {
  return _internal_has_ltms()
      ? *_impl_.los_.ltms_
      : reinterpret_cast< ::Liberty::LibertyTableModelSyn&>(::Liberty::_LibertyTableModelSyn_default_instance_);
}
inline const ::Liberty::LibertyTableModelSyn& LibertyObjectSyn::ltms() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.ltms)
  return _internal_ltms();
}
inline ::Liberty::LibertyTableModelSyn* LibertyObjectSyn::unsafe_arena_release_ltms() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.ltms)
  if (_internal_has_ltms()) {
    clear_has_los();
    ::Liberty::LibertyTableModelSyn* temp = _impl_.los_.ltms_;
    _impl_.los_.ltms_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_ltms(::Liberty::LibertyTableModelSyn* ltms) {
  clear_los();
  if (ltms) {
    set_has_ltms();
    _impl_.los_.ltms_ = ltms;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.ltms)
}
inline ::Liberty::LibertyTableModelSyn* LibertyObjectSyn::_internal_mutable_ltms() {
  if (!_internal_has_ltms()) {
    clear_los();
    set_has_ltms();
    _impl_.los_.ltms_ = CreateMaybeMessage< ::Liberty::LibertyTableModelSyn >(GetArenaForAllocation());
  }
  return _impl_.los_.ltms_;
}
inline ::Liberty::LibertyTableModelSyn* LibertyObjectSyn::mutable_ltms() {
  ::Liberty::LibertyTableModelSyn* _msg = _internal_mutable_ltms();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.ltms)
  return _msg;
}

// .Liberty.LibertyPortSyn lps = 8;
inline bool LibertyObjectSyn::_internal_has_lps() const {
  return los_case() == kLps;
}
inline bool LibertyObjectSyn::has_lps() const {
  return _internal_has_lps();
}
inline void LibertyObjectSyn::set_has_lps() {
  _impl_._oneof_case_[0] = kLps;
}
inline void LibertyObjectSyn::clear_lps() {
  if (_internal_has_lps()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.lps_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyPortSyn* LibertyObjectSyn::release_lps() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.lps)
  if (_internal_has_lps()) {
    clear_has_los();
    ::Liberty::LibertyPortSyn* temp = _impl_.los_.lps_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.lps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyPortSyn& LibertyObjectSyn::_internal_lps() const {
  return _internal_has_lps()
      ? *_impl_.los_.lps_
      : reinterpret_cast< ::Liberty::LibertyPortSyn&>(::Liberty::_LibertyPortSyn_default_instance_);
}
inline const ::Liberty::LibertyPortSyn& LibertyObjectSyn::lps() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.lps)
  return _internal_lps();
}
inline ::Liberty::LibertyPortSyn* LibertyObjectSyn::unsafe_arena_release_lps() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.lps)
  if (_internal_has_lps()) {
    clear_has_los();
    ::Liberty::LibertyPortSyn* temp = _impl_.los_.lps_;
    _impl_.los_.lps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_lps(::Liberty::LibertyPortSyn* lps) {
  clear_los();
  if (lps) {
    set_has_lps();
    _impl_.los_.lps_ = lps;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.lps)
}
inline ::Liberty::LibertyPortSyn* LibertyObjectSyn::_internal_mutable_lps() {
  if (!_internal_has_lps()) {
    clear_los();
    set_has_lps();
    _impl_.los_.lps_ = CreateMaybeMessage< ::Liberty::LibertyPortSyn >(GetArenaForAllocation());
  }
  return _impl_.los_.lps_;
}
inline ::Liberty::LibertyPortSyn* LibertyObjectSyn::mutable_lps() {
  ::Liberty::LibertyPortSyn* _msg = _internal_mutable_lps();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.lps)
  return _msg;
}

// .Liberty.LibertyTypeClass ltc = 9;
inline bool LibertyObjectSyn::_internal_has_ltc() const {
  return los_case() == kLtc;
}
inline bool LibertyObjectSyn::has_ltc() const {
  return _internal_has_ltc();
}
inline void LibertyObjectSyn::set_has_ltc() {
  _impl_._oneof_case_[0] = kLtc;
}
inline void LibertyObjectSyn::clear_ltc() {
  if (_internal_has_ltc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.ltc_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyTypeClass* LibertyObjectSyn::release_ltc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.ltc)
  if (_internal_has_ltc()) {
    clear_has_los();
    ::Liberty::LibertyTypeClass* temp = _impl_.los_.ltc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.ltc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyTypeClass& LibertyObjectSyn::_internal_ltc() const {
  return _internal_has_ltc()
      ? *_impl_.los_.ltc_
      : reinterpret_cast< ::Liberty::LibertyTypeClass&>(::Liberty::_LibertyTypeClass_default_instance_);
}
inline const ::Liberty::LibertyTypeClass& LibertyObjectSyn::ltc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.ltc)
  return _internal_ltc();
}
inline ::Liberty::LibertyTypeClass* LibertyObjectSyn::unsafe_arena_release_ltc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.ltc)
  if (_internal_has_ltc()) {
    clear_has_los();
    ::Liberty::LibertyTypeClass* temp = _impl_.los_.ltc_;
    _impl_.los_.ltc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_ltc(::Liberty::LibertyTypeClass* ltc) {
  clear_los();
  if (ltc) {
    set_has_ltc();
    _impl_.los_.ltc_ = ltc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.ltc)
}
inline ::Liberty::LibertyTypeClass* LibertyObjectSyn::_internal_mutable_ltc() {
  if (!_internal_has_ltc()) {
    clear_los();
    set_has_ltc();
    _impl_.los_.ltc_ = CreateMaybeMessage< ::Liberty::LibertyTypeClass >(GetArenaForAllocation());
  }
  return _impl_.los_.ltc_;
}
inline ::Liberty::LibertyTypeClass* LibertyObjectSyn::mutable_ltc() {
  ::Liberty::LibertyTypeClass* _msg = _internal_mutable_ltc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.ltc)
  return _msg;
}

// .Liberty.LibertyLeakagePowerClass llpc = 10;
inline bool LibertyObjectSyn::_internal_has_llpc() const {
  return los_case() == kLlpc;
}
inline bool LibertyObjectSyn::has_llpc() const {
  return _internal_has_llpc();
}
inline void LibertyObjectSyn::set_has_llpc() {
  _impl_._oneof_case_[0] = kLlpc;
}
inline void LibertyObjectSyn::clear_llpc() {
  if (_internal_has_llpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.llpc_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyLeakagePowerClass* LibertyObjectSyn::release_llpc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.llpc)
  if (_internal_has_llpc()) {
    clear_has_los();
    ::Liberty::LibertyLeakagePowerClass* temp = _impl_.los_.llpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.llpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyLeakagePowerClass& LibertyObjectSyn::_internal_llpc() const {
  return _internal_has_llpc()
      ? *_impl_.los_.llpc_
      : reinterpret_cast< ::Liberty::LibertyLeakagePowerClass&>(::Liberty::_LibertyLeakagePowerClass_default_instance_);
}
inline const ::Liberty::LibertyLeakagePowerClass& LibertyObjectSyn::llpc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.llpc)
  return _internal_llpc();
}
inline ::Liberty::LibertyLeakagePowerClass* LibertyObjectSyn::unsafe_arena_release_llpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.llpc)
  if (_internal_has_llpc()) {
    clear_has_los();
    ::Liberty::LibertyLeakagePowerClass* temp = _impl_.los_.llpc_;
    _impl_.los_.llpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_llpc(::Liberty::LibertyLeakagePowerClass* llpc) {
  clear_los();
  if (llpc) {
    set_has_llpc();
    _impl_.los_.llpc_ = llpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.llpc)
}
inline ::Liberty::LibertyLeakagePowerClass* LibertyObjectSyn::_internal_mutable_llpc() {
  if (!_internal_has_llpc()) {
    clear_los();
    set_has_llpc();
    _impl_.los_.llpc_ = CreateMaybeMessage< ::Liberty::LibertyLeakagePowerClass >(GetArenaForAllocation());
  }
  return _impl_.los_.llpc_;
}
inline ::Liberty::LibertyLeakagePowerClass* LibertyObjectSyn::mutable_llpc() {
  ::Liberty::LibertyLeakagePowerClass* _msg = _internal_mutable_llpc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.llpc)
  return _msg;
}

// .Liberty.LibertyArcClass larc = 11;
inline bool LibertyObjectSyn::_internal_has_larc() const {
  return los_case() == kLarc;
}
inline bool LibertyObjectSyn::has_larc() const {
  return _internal_has_larc();
}
inline void LibertyObjectSyn::set_has_larc() {
  _impl_._oneof_case_[0] = kLarc;
}
inline void LibertyObjectSyn::clear_larc() {
  if (_internal_has_larc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.larc_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyArcClass* LibertyObjectSyn::release_larc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.larc)
  if (_internal_has_larc()) {
    clear_has_los();
    ::Liberty::LibertyArcClass* temp = _impl_.los_.larc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.larc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyArcClass& LibertyObjectSyn::_internal_larc() const {
  return _internal_has_larc()
      ? *_impl_.los_.larc_
      : reinterpret_cast< ::Liberty::LibertyArcClass&>(::Liberty::_LibertyArcClass_default_instance_);
}
inline const ::Liberty::LibertyArcClass& LibertyObjectSyn::larc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.larc)
  return _internal_larc();
}
inline ::Liberty::LibertyArcClass* LibertyObjectSyn::unsafe_arena_release_larc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.larc)
  if (_internal_has_larc()) {
    clear_has_los();
    ::Liberty::LibertyArcClass* temp = _impl_.los_.larc_;
    _impl_.los_.larc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_larc(::Liberty::LibertyArcClass* larc) {
  clear_los();
  if (larc) {
    set_has_larc();
    _impl_.los_.larc_ = larc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.larc)
}
inline ::Liberty::LibertyArcClass* LibertyObjectSyn::_internal_mutable_larc() {
  if (!_internal_has_larc()) {
    clear_los();
    set_has_larc();
    _impl_.los_.larc_ = CreateMaybeMessage< ::Liberty::LibertyArcClass >(GetArenaForAllocation());
  }
  return _impl_.los_.larc_;
}
inline ::Liberty::LibertyArcClass* LibertyObjectSyn::mutable_larc() {
  ::Liberty::LibertyArcClass* _msg = _internal_mutable_larc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.larc)
  return _msg;
}

// .Liberty.LibertyPowerArcClass lpac = 12;
inline bool LibertyObjectSyn::_internal_has_lpac() const {
  return los_case() == kLpac;
}
inline bool LibertyObjectSyn::has_lpac() const {
  return _internal_has_lpac();
}
inline void LibertyObjectSyn::set_has_lpac() {
  _impl_._oneof_case_[0] = kLpac;
}
inline void LibertyObjectSyn::clear_lpac() {
  if (_internal_has_lpac()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.lpac_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyPowerArcClass* LibertyObjectSyn::release_lpac() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.lpac)
  if (_internal_has_lpac()) {
    clear_has_los();
    ::Liberty::LibertyPowerArcClass* temp = _impl_.los_.lpac_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.lpac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyPowerArcClass& LibertyObjectSyn::_internal_lpac() const {
  return _internal_has_lpac()
      ? *_impl_.los_.lpac_
      : reinterpret_cast< ::Liberty::LibertyPowerArcClass&>(::Liberty::_LibertyPowerArcClass_default_instance_);
}
inline const ::Liberty::LibertyPowerArcClass& LibertyObjectSyn::lpac() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.lpac)
  return _internal_lpac();
}
inline ::Liberty::LibertyPowerArcClass* LibertyObjectSyn::unsafe_arena_release_lpac() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.lpac)
  if (_internal_has_lpac()) {
    clear_has_los();
    ::Liberty::LibertyPowerArcClass* temp = _impl_.los_.lpac_;
    _impl_.los_.lpac_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_lpac(::Liberty::LibertyPowerArcClass* lpac) {
  clear_los();
  if (lpac) {
    set_has_lpac();
    _impl_.los_.lpac_ = lpac;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.lpac)
}
inline ::Liberty::LibertyPowerArcClass* LibertyObjectSyn::_internal_mutable_lpac() {
  if (!_internal_has_lpac()) {
    clear_los();
    set_has_lpac();
    _impl_.los_.lpac_ = CreateMaybeMessage< ::Liberty::LibertyPowerArcClass >(GetArenaForAllocation());
  }
  return _impl_.los_.lpac_;
}
inline ::Liberty::LibertyPowerArcClass* LibertyObjectSyn::mutable_lpac() {
  ::Liberty::LibertyPowerArcClass* _msg = _internal_mutable_lpac();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.lpac)
  return _msg;
}

// .Liberty.LibertyCellClass lcc = 13;
inline bool LibertyObjectSyn::_internal_has_lcc() const {
  return los_case() == kLcc;
}
inline bool LibertyObjectSyn::has_lcc() const {
  return _internal_has_lcc();
}
inline void LibertyObjectSyn::set_has_lcc() {
  _impl_._oneof_case_[0] = kLcc;
}
inline void LibertyObjectSyn::clear_lcc() {
  if (_internal_has_lcc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.lcc_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyCellClass* LibertyObjectSyn::release_lcc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.lcc)
  if (_internal_has_lcc()) {
    clear_has_los();
    ::Liberty::LibertyCellClass* temp = _impl_.los_.lcc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.lcc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyCellClass& LibertyObjectSyn::_internal_lcc() const {
  return _internal_has_lcc()
      ? *_impl_.los_.lcc_
      : reinterpret_cast< ::Liberty::LibertyCellClass&>(::Liberty::_LibertyCellClass_default_instance_);
}
inline const ::Liberty::LibertyCellClass& LibertyObjectSyn::lcc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.lcc)
  return _internal_lcc();
}
inline ::Liberty::LibertyCellClass* LibertyObjectSyn::unsafe_arena_release_lcc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.lcc)
  if (_internal_has_lcc()) {
    clear_has_los();
    ::Liberty::LibertyCellClass* temp = _impl_.los_.lcc_;
    _impl_.los_.lcc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_lcc(::Liberty::LibertyCellClass* lcc) {
  clear_los();
  if (lcc) {
    set_has_lcc();
    _impl_.los_.lcc_ = lcc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.lcc)
}
inline ::Liberty::LibertyCellClass* LibertyObjectSyn::_internal_mutable_lcc() {
  if (!_internal_has_lcc()) {
    clear_los();
    set_has_lcc();
    _impl_.los_.lcc_ = CreateMaybeMessage< ::Liberty::LibertyCellClass >(GetArenaForAllocation());
  }
  return _impl_.los_.lcc_;
}
inline ::Liberty::LibertyCellClass* LibertyObjectSyn::mutable_lcc() {
  ::Liberty::LibertyCellClass* _msg = _internal_mutable_lcc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.lcc)
  return _msg;
}

// .Liberty.LibertyWireLoadClass lwlc = 14;
inline bool LibertyObjectSyn::_internal_has_lwlc() const {
  return los_case() == kLwlc;
}
inline bool LibertyObjectSyn::has_lwlc() const {
  return _internal_has_lwlc();
}
inline void LibertyObjectSyn::set_has_lwlc() {
  _impl_._oneof_case_[0] = kLwlc;
}
inline void LibertyObjectSyn::clear_lwlc() {
  if (_internal_has_lwlc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.lwlc_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyWireLoadClass* LibertyObjectSyn::release_lwlc() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.lwlc)
  if (_internal_has_lwlc()) {
    clear_has_los();
    ::Liberty::LibertyWireLoadClass* temp = _impl_.los_.lwlc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.lwlc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyWireLoadClass& LibertyObjectSyn::_internal_lwlc() const {
  return _internal_has_lwlc()
      ? *_impl_.los_.lwlc_
      : reinterpret_cast< ::Liberty::LibertyWireLoadClass&>(::Liberty::_LibertyWireLoadClass_default_instance_);
}
inline const ::Liberty::LibertyWireLoadClass& LibertyObjectSyn::lwlc() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.lwlc)
  return _internal_lwlc();
}
inline ::Liberty::LibertyWireLoadClass* LibertyObjectSyn::unsafe_arena_release_lwlc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.lwlc)
  if (_internal_has_lwlc()) {
    clear_has_los();
    ::Liberty::LibertyWireLoadClass* temp = _impl_.los_.lwlc_;
    _impl_.los_.lwlc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_lwlc(::Liberty::LibertyWireLoadClass* lwlc) {
  clear_los();
  if (lwlc) {
    set_has_lwlc();
    _impl_.los_.lwlc_ = lwlc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.lwlc)
}
inline ::Liberty::LibertyWireLoadClass* LibertyObjectSyn::_internal_mutable_lwlc() {
  if (!_internal_has_lwlc()) {
    clear_los();
    set_has_lwlc();
    _impl_.los_.lwlc_ = CreateMaybeMessage< ::Liberty::LibertyWireLoadClass >(GetArenaForAllocation());
  }
  return _impl_.los_.lwlc_;
}
inline ::Liberty::LibertyWireLoadClass* LibertyObjectSyn::mutable_lwlc() {
  ::Liberty::LibertyWireLoadClass* _msg = _internal_mutable_lwlc();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.lwlc)
  return _msg;
}

// .Liberty.LibertyLutTableTemplateSyn lltts = 15;
inline bool LibertyObjectSyn::_internal_has_lltts() const {
  return los_case() == kLltts;
}
inline bool LibertyObjectSyn::has_lltts() const {
  return _internal_has_lltts();
}
inline void LibertyObjectSyn::set_has_lltts() {
  _impl_._oneof_case_[0] = kLltts;
}
inline void LibertyObjectSyn::clear_lltts() {
  if (_internal_has_lltts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.los_.lltts_;
    }
    clear_has_los();
  }
}
inline ::Liberty::LibertyLutTableTemplateSyn* LibertyObjectSyn::release_lltts() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyObjectSyn.lltts)
  if (_internal_has_lltts()) {
    clear_has_los();
    ::Liberty::LibertyLutTableTemplateSyn* temp = _impl_.los_.lltts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.los_.lltts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Liberty::LibertyLutTableTemplateSyn& LibertyObjectSyn::_internal_lltts() const {
  return _internal_has_lltts()
      ? *_impl_.los_.lltts_
      : reinterpret_cast< ::Liberty::LibertyLutTableTemplateSyn&>(::Liberty::_LibertyLutTableTemplateSyn_default_instance_);
}
inline const ::Liberty::LibertyLutTableTemplateSyn& LibertyObjectSyn::lltts() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyObjectSyn.lltts)
  return _internal_lltts();
}
inline ::Liberty::LibertyLutTableTemplateSyn* LibertyObjectSyn::unsafe_arena_release_lltts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Liberty.LibertyObjectSyn.lltts)
  if (_internal_has_lltts()) {
    clear_has_los();
    ::Liberty::LibertyLutTableTemplateSyn* temp = _impl_.los_.lltts_;
    _impl_.los_.lltts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LibertyObjectSyn::unsafe_arena_set_allocated_lltts(::Liberty::LibertyLutTableTemplateSyn* lltts) {
  clear_los();
  if (lltts) {
    set_has_lltts();
    _impl_.los_.lltts_ = lltts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyObjectSyn.lltts)
}
inline ::Liberty::LibertyLutTableTemplateSyn* LibertyObjectSyn::_internal_mutable_lltts() {
  if (!_internal_has_lltts()) {
    clear_los();
    set_has_lltts();
    _impl_.los_.lltts_ = CreateMaybeMessage< ::Liberty::LibertyLutTableTemplateSyn >(GetArenaForAllocation());
  }
  return _impl_.los_.lltts_;
}
inline ::Liberty::LibertyLutTableTemplateSyn* LibertyObjectSyn::mutable_lltts() {
  ::Liberty::LibertyLutTableTemplateSyn* _msg = _internal_mutable_lltts();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyObjectSyn.lltts)
  return _msg;
}

inline bool LibertyObjectSyn::has_los() const {
  return los_case() != LOS_NOT_SET;
}
inline void LibertyObjectSyn::clear_has_los() {
  _impl_._oneof_case_[0] = LOS_NOT_SET;
}
inline LibertyObjectSyn::LosCase LibertyObjectSyn::los_case() const {
  return LibertyObjectSyn::LosCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LibertyLibraryClass

// required uint64 id = 1;
inline bool LibertyLibraryClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LibertyLibraryClass::has_id() const {
  return _internal_has_id();
}
inline void LibertyLibraryClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t LibertyLibraryClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyLibraryClass::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass.id)
  return _internal_id();
}
inline void LibertyLibraryClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}
inline void LibertyLibraryClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass.id)
}

// required string _lib_name = 2;
inline bool LibertyLibraryClass::_internal_has__lib_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyLibraryClass::has__lib_name() const {
  return _internal_has__lib_name();
}
inline void LibertyLibraryClass::clear__lib_name() {
  _impl_._lib_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyLibraryClass::_lib_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._lib_name)
  return _internal__lib_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLibraryClass::set__lib_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._lib_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._lib_name)
}
inline std::string* LibertyLibraryClass::mutable__lib_name() {
  std::string* _s = _internal_mutable__lib_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLibraryClass._lib_name)
  return _s;
}
inline const std::string& LibertyLibraryClass::_internal__lib_name() const {
  return _impl_._lib_name_.Get();
}
inline void LibertyLibraryClass::_internal_set__lib_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._lib_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLibraryClass::_internal_mutable__lib_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._lib_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLibraryClass::release__lib_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLibraryClass._lib_name)
  if (!_internal_has__lib_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._lib_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._lib_name_.IsDefault()) {
    _impl_._lib_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLibraryClass::set_allocated__lib_name(std::string* _lib_name) {
  if (_lib_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._lib_name_.SetAllocated(_lib_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._lib_name_.IsDefault()) {
    _impl_._lib_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLibraryClass._lib_name)
}

// repeated uint64 _cells = 3;
inline int LibertyLibraryClass::_internal__cells_size() const {
  return _impl_._cells_.size();
}
inline int LibertyLibraryClass::_cells_size() const {
  return _internal__cells_size();
}
inline void LibertyLibraryClass::clear__cells() {
  _impl_._cells_.Clear();
}
inline uint64_t LibertyLibraryClass::_internal__cells(int index) const {
  return _impl_._cells_.Get(index);
}
inline uint64_t LibertyLibraryClass::_cells(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._cells)
  return _internal__cells(index);
}
inline void LibertyLibraryClass::set__cells(int index, uint64_t value) {
  _impl_._cells_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._cells)
}
inline void LibertyLibraryClass::_internal_add__cells(uint64_t value) {
  _impl_._cells_.Add(value);
}
inline void LibertyLibraryClass::add__cells(uint64_t value) {
  _internal_add__cells(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyLibraryClass._cells)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_internal__cells() const {
  return _impl_._cells_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_cells() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyLibraryClass._cells)
  return _internal__cells();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::_internal_mutable__cells() {
  return &_impl_._cells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::mutable__cells() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyLibraryClass._cells)
  return _internal_mutable__cells();
}

// repeated uint64 _lut_template = 4;
inline int LibertyLibraryClass::_internal__lut_template_size() const {
  return _impl_._lut_template_.size();
}
inline int LibertyLibraryClass::_lut_template_size() const {
  return _internal__lut_template_size();
}
inline void LibertyLibraryClass::clear__lut_template() {
  _impl_._lut_template_.Clear();
}
inline uint64_t LibertyLibraryClass::_internal__lut_template(int index) const {
  return _impl_._lut_template_.Get(index);
}
inline uint64_t LibertyLibraryClass::_lut_template(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._lut_template)
  return _internal__lut_template(index);
}
inline void LibertyLibraryClass::set__lut_template(int index, uint64_t value) {
  _impl_._lut_template_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._lut_template)
}
inline void LibertyLibraryClass::_internal_add__lut_template(uint64_t value) {
  _impl_._lut_template_.Add(value);
}
inline void LibertyLibraryClass::add__lut_template(uint64_t value) {
  _internal_add__lut_template(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyLibraryClass._lut_template)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_internal__lut_template() const {
  return _impl_._lut_template_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_lut_template() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyLibraryClass._lut_template)
  return _internal__lut_template();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::_internal_mutable__lut_template() {
  return &_impl_._lut_template_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::mutable__lut_template() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyLibraryClass._lut_template)
  return _internal_mutable__lut_template();
}

// repeated uint64 _wire_loads = 5;
inline int LibertyLibraryClass::_internal__wire_loads_size() const {
  return _impl_._wire_loads_.size();
}
inline int LibertyLibraryClass::_wire_loads_size() const {
  return _internal__wire_loads_size();
}
inline void LibertyLibraryClass::clear__wire_loads() {
  _impl_._wire_loads_.Clear();
}
inline uint64_t LibertyLibraryClass::_internal__wire_loads(int index) const {
  return _impl_._wire_loads_.Get(index);
}
inline uint64_t LibertyLibraryClass::_wire_loads(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._wire_loads)
  return _internal__wire_loads(index);
}
inline void LibertyLibraryClass::set__wire_loads(int index, uint64_t value) {
  _impl_._wire_loads_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._wire_loads)
}
inline void LibertyLibraryClass::_internal_add__wire_loads(uint64_t value) {
  _impl_._wire_loads_.Add(value);
}
inline void LibertyLibraryClass::add__wire_loads(uint64_t value) {
  _internal_add__wire_loads(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyLibraryClass._wire_loads)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_internal__wire_loads() const {
  return _impl_._wire_loads_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_wire_loads() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyLibraryClass._wire_loads)
  return _internal__wire_loads();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::_internal_mutable__wire_loads() {
  return &_impl_._wire_loads_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::mutable__wire_loads() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyLibraryClass._wire_loads)
  return _internal_mutable__wire_loads();
}

// repeated uint64 _types = 6;
inline int LibertyLibraryClass::_internal__types_size() const {
  return _impl_._types_.size();
}
inline int LibertyLibraryClass::_types_size() const {
  return _internal__types_size();
}
inline void LibertyLibraryClass::clear__types() {
  _impl_._types_.Clear();
}
inline uint64_t LibertyLibraryClass::_internal__types(int index) const {
  return _impl_._types_.Get(index);
}
inline uint64_t LibertyLibraryClass::_types(int index) const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._types)
  return _internal__types(index);
}
inline void LibertyLibraryClass::set__types(int index, uint64_t value) {
  _impl_._types_.Set(index, value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._types)
}
inline void LibertyLibraryClass::_internal_add__types(uint64_t value) {
  _impl_._types_.Add(value);
}
inline void LibertyLibraryClass::add__types(uint64_t value) {
  _internal_add__types(value);
  // @@protoc_insertion_point(field_add:Liberty.LibertyLibraryClass._types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_internal__types() const {
  return _impl_._types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LibertyLibraryClass::_types() const {
  // @@protoc_insertion_point(field_list:Liberty.LibertyLibraryClass._types)
  return _internal__types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::_internal_mutable__types() {
  return &_impl_._types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LibertyLibraryClass::mutable__types() {
  // @@protoc_insertion_point(field_mutable_list:Liberty.LibertyLibraryClass._types)
  return _internal_mutable__types();
}

// required .Common.Types.CapacitiveUnitEnum _cap_unit = 7;
inline bool LibertyLibraryClass::_internal_has__cap_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._cap_unit_ != nullptr);
  return value;
}
inline bool LibertyLibraryClass::has__cap_unit() const {
  return _internal_has__cap_unit();
}
inline const ::Common::Types::CapacitiveUnitEnum& LibertyLibraryClass::_internal__cap_unit() const {
  const ::Common::Types::CapacitiveUnitEnum* p = _impl_._cap_unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::CapacitiveUnitEnum&>(
      ::Common::Types::_CapacitiveUnitEnum_default_instance_);
}
inline const ::Common::Types::CapacitiveUnitEnum& LibertyLibraryClass::_cap_unit() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._cap_unit)
  return _internal__cap_unit();
}
inline void LibertyLibraryClass::unsafe_arena_set_allocated__cap_unit(
    ::Common::Types::CapacitiveUnitEnum* _cap_unit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._cap_unit_);
  }
  _impl_._cap_unit_ = _cap_unit;
  if (_cap_unit) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyLibraryClass._cap_unit)
}
inline ::Common::Types::CapacitiveUnitEnum* LibertyLibraryClass::release__cap_unit() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Common::Types::CapacitiveUnitEnum* temp = _impl_._cap_unit_;
  _impl_._cap_unit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::CapacitiveUnitEnum* LibertyLibraryClass::unsafe_arena_release__cap_unit() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLibraryClass._cap_unit)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Common::Types::CapacitiveUnitEnum* temp = _impl_._cap_unit_;
  _impl_._cap_unit_ = nullptr;
  return temp;
}
inline ::Common::Types::CapacitiveUnitEnum* LibertyLibraryClass::_internal_mutable__cap_unit() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_._cap_unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::CapacitiveUnitEnum>(GetArenaForAllocation());
    _impl_._cap_unit_ = p;
  }
  return _impl_._cap_unit_;
}
inline ::Common::Types::CapacitiveUnitEnum* LibertyLibraryClass::mutable__cap_unit() {
  ::Common::Types::CapacitiveUnitEnum* _msg = _internal_mutable__cap_unit();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLibraryClass._cap_unit)
  return _msg;
}
inline void LibertyLibraryClass::set_allocated__cap_unit(::Common::Types::CapacitiveUnitEnum* _cap_unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._cap_unit_);
  }
  if (_cap_unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_cap_unit));
    if (message_arena != submessage_arena) {
      _cap_unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _cap_unit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_._cap_unit_ = _cap_unit;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLibraryClass._cap_unit)
}

// required .Common.Types.ResistanceUnitEnum _resistance_unit = 8;
inline bool LibertyLibraryClass::_internal_has__resistance_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_._resistance_unit_ != nullptr);
  return value;
}
inline bool LibertyLibraryClass::has__resistance_unit() const {
  return _internal_has__resistance_unit();
}
inline const ::Common::Types::ResistanceUnitEnum& LibertyLibraryClass::_internal__resistance_unit() const {
  const ::Common::Types::ResistanceUnitEnum* p = _impl_._resistance_unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::Common::Types::ResistanceUnitEnum&>(
      ::Common::Types::_ResistanceUnitEnum_default_instance_);
}
inline const ::Common::Types::ResistanceUnitEnum& LibertyLibraryClass::_resistance_unit() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._resistance_unit)
  return _internal__resistance_unit();
}
inline void LibertyLibraryClass::unsafe_arena_set_allocated__resistance_unit(
    ::Common::Types::ResistanceUnitEnum* _resistance_unit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._resistance_unit_);
  }
  _impl_._resistance_unit_ = _resistance_unit;
  if (_resistance_unit) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Liberty.LibertyLibraryClass._resistance_unit)
}
inline ::Common::Types::ResistanceUnitEnum* LibertyLibraryClass::release__resistance_unit() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Common::Types::ResistanceUnitEnum* temp = _impl_._resistance_unit_;
  _impl_._resistance_unit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Common::Types::ResistanceUnitEnum* LibertyLibraryClass::unsafe_arena_release__resistance_unit() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLibraryClass._resistance_unit)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Common::Types::ResistanceUnitEnum* temp = _impl_._resistance_unit_;
  _impl_._resistance_unit_ = nullptr;
  return temp;
}
inline ::Common::Types::ResistanceUnitEnum* LibertyLibraryClass::_internal_mutable__resistance_unit() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_._resistance_unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::Common::Types::ResistanceUnitEnum>(GetArenaForAllocation());
    _impl_._resistance_unit_ = p;
  }
  return _impl_._resistance_unit_;
}
inline ::Common::Types::ResistanceUnitEnum* LibertyLibraryClass::mutable__resistance_unit() {
  ::Common::Types::ResistanceUnitEnum* _msg = _internal_mutable__resistance_unit();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLibraryClass._resistance_unit)
  return _msg;
}
inline void LibertyLibraryClass::set_allocated__resistance_unit(::Common::Types::ResistanceUnitEnum* _resistance_unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_._resistance_unit_);
  }
  if (_resistance_unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_resistance_unit));
    if (message_arena != submessage_arena) {
      _resistance_unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, _resistance_unit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_._resistance_unit_ = _resistance_unit;
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLibraryClass._resistance_unit)
}

// optional double _default_max_transition = 9;
inline bool LibertyLibraryClass::_internal_has__default_max_transition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LibertyLibraryClass::has__default_max_transition() const {
  return _internal_has__default_max_transition();
}
inline void LibertyLibraryClass::clear__default_max_transition() {
  _impl_._default_max_transition_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double LibertyLibraryClass::_internal__default_max_transition() const {
  return _impl_._default_max_transition_;
}
inline double LibertyLibraryClass::_default_max_transition() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._default_max_transition)
  return _internal__default_max_transition();
}
inline void LibertyLibraryClass::_internal_set__default_max_transition(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_._default_max_transition_ = value;
}
inline void LibertyLibraryClass::set__default_max_transition(double value) {
  _internal_set__default_max_transition(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._default_max_transition)
}

// optional double _default_max_fanout = 10;
inline bool LibertyLibraryClass::_internal_has__default_max_fanout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LibertyLibraryClass::has__default_max_fanout() const {
  return _internal_has__default_max_fanout();
}
inline void LibertyLibraryClass::clear__default_max_fanout() {
  _impl_._default_max_fanout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double LibertyLibraryClass::_internal__default_max_fanout() const {
  return _impl_._default_max_fanout_;
}
inline double LibertyLibraryClass::_default_max_fanout() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._default_max_fanout)
  return _internal__default_max_fanout();
}
inline void LibertyLibraryClass::_internal_set__default_max_fanout(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_._default_max_fanout_ = value;
}
inline void LibertyLibraryClass::set__default_max_fanout(double value) {
  _internal_set__default_max_fanout(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._default_max_fanout)
}

// optional double _default_fanout_load = 11;
inline bool LibertyLibraryClass::_internal_has__default_fanout_load() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LibertyLibraryClass::has__default_fanout_load() const {
  return _internal_has__default_fanout_load();
}
inline void LibertyLibraryClass::clear__default_fanout_load() {
  _impl_._default_fanout_load_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double LibertyLibraryClass::_internal__default_fanout_load() const {
  return _impl_._default_fanout_load_;
}
inline double LibertyLibraryClass::_default_fanout_load() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._default_fanout_load)
  return _internal__default_fanout_load();
}
inline void LibertyLibraryClass::_internal_set__default_fanout_load(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_._default_fanout_load_ = value;
}
inline void LibertyLibraryClass::set__default_fanout_load(double value) {
  _internal_set__default_fanout_load(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._default_fanout_load)
}

// required string _default_wire_load = 12;
inline bool LibertyLibraryClass::_internal_has__default_wire_load() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyLibraryClass::has__default_wire_load() const {
  return _internal_has__default_wire_load();
}
inline void LibertyLibraryClass::clear__default_wire_load() {
  _impl_._default_wire_load_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LibertyLibraryClass::_default_wire_load() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyLibraryClass._default_wire_load)
  return _internal__default_wire_load();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyLibraryClass::set__default_wire_load(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._default_wire_load_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyLibraryClass._default_wire_load)
}
inline std::string* LibertyLibraryClass::mutable__default_wire_load() {
  std::string* _s = _internal_mutable__default_wire_load();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyLibraryClass._default_wire_load)
  return _s;
}
inline const std::string& LibertyLibraryClass::_internal__default_wire_load() const {
  return _impl_._default_wire_load_.Get();
}
inline void LibertyLibraryClass::_internal_set__default_wire_load(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._default_wire_load_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyLibraryClass::_internal_mutable__default_wire_load() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._default_wire_load_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyLibraryClass::release__default_wire_load() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyLibraryClass._default_wire_load)
  if (!_internal_has__default_wire_load()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._default_wire_load_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._default_wire_load_.IsDefault()) {
    _impl_._default_wire_load_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyLibraryClass::set_allocated__default_wire_load(std::string* _default_wire_load) {
  if (_default_wire_load != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._default_wire_load_.SetAllocated(_default_wire_load, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._default_wire_load_.IsDefault()) {
    _impl_._default_wire_load_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyLibraryClass._default_wire_load)
}

// -------------------------------------------------------------------

// LibertyOwnPortTypeEnum

// required .Liberty.LibertyOwnPortTypeEnum.LibertyOwnPortType lopt = 1;
inline bool LibertyOwnPortTypeEnum::_internal_has_lopt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyOwnPortTypeEnum::has_lopt() const {
  return _internal_has_lopt();
}
inline void LibertyOwnPortTypeEnum::clear_lopt() {
  _impl_.lopt_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum::_internal_lopt() const {
  return static_cast< ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType >(_impl_.lopt_);
}
inline ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType LibertyOwnPortTypeEnum::lopt() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyOwnPortTypeEnum.lopt)
  return _internal_lopt();
}
inline void LibertyOwnPortTypeEnum::_internal_set_lopt(::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType value) {
  assert(::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lopt_ = value;
}
inline void LibertyOwnPortTypeEnum::set_lopt(::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType value) {
  _internal_set_lopt(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyOwnPortTypeEnum.lopt)
}

// -------------------------------------------------------------------

// LibertyOwnPgOrWhenTypeEnum

// required .Liberty.LibertyOwnPgOrWhenTypeEnum.LibertyOwnPgOrWhenType lopowt = 1;
inline bool LibertyOwnPgOrWhenTypeEnum::_internal_has_lopowt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyOwnPgOrWhenTypeEnum::has_lopowt() const {
  return _internal_has_lopowt();
}
inline void LibertyOwnPgOrWhenTypeEnum::clear_lopowt() {
  _impl_.lopowt_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum::_internal_lopowt() const {
  return static_cast< ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType >(_impl_.lopowt_);
}
inline ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType LibertyOwnPgOrWhenTypeEnum::lopowt() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyOwnPgOrWhenTypeEnum.lopowt)
  return _internal_lopowt();
}
inline void LibertyOwnPgOrWhenTypeEnum::_internal_set_lopowt(::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType value) {
  assert(::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lopowt_ = value;
}
inline void LibertyOwnPgOrWhenTypeEnum::set_lopowt(::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType value) {
  _internal_set_lopowt(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyOwnPgOrWhenTypeEnum.lopowt)
}

// -------------------------------------------------------------------

// LibertyBuilderClass

// required uint64 id = 1;
inline bool LibertyBuilderClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyBuilderClass::has_id() const {
  return _internal_has_id();
}
inline void LibertyBuilderClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LibertyBuilderClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyBuilderClass::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyBuilderClass.id)
  return _internal_id();
}
inline void LibertyBuilderClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void LibertyBuilderClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyBuilderClass.id)
}

// required uint64 _lib = 2;
inline bool LibertyBuilderClass::_internal_has__lib() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyBuilderClass::has__lib() const {
  return _internal_has__lib();
}
inline void LibertyBuilderClass::clear__lib() {
  _impl_._lib_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t LibertyBuilderClass::_internal__lib() const {
  return _impl_._lib_;
}
inline uint64_t LibertyBuilderClass::_lib() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyBuilderClass._lib)
  return _internal__lib();
}
inline void LibertyBuilderClass::_internal_set__lib(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._lib_ = value;
}
inline void LibertyBuilderClass::set__lib(uint64_t value) {
  _internal_set__lib(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyBuilderClass._lib)
}

// -------------------------------------------------------------------

// LibertyReaderClass

// required uint64 id = 1;
inline bool LibertyReaderClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibertyReaderClass::has_id() const {
  return _internal_has_id();
}
inline void LibertyReaderClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t LibertyReaderClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t LibertyReaderClass::id() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyReaderClass.id)
  return _internal_id();
}
inline void LibertyReaderClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void LibertyReaderClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyReaderClass.id)
}

// required uint64 _library_group = 2;
inline bool LibertyReaderClass::_internal_has__library_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LibertyReaderClass::has__library_group() const {
  return _internal_has__library_group();
}
inline void LibertyReaderClass::clear__library_group() {
  _impl_._library_group_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t LibertyReaderClass::_internal__library_group() const {
  return _impl_._library_group_;
}
inline uint64_t LibertyReaderClass::_library_group() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyReaderClass._library_group)
  return _internal__library_group();
}
inline void LibertyReaderClass::_internal_set__library_group(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._library_group_ = value;
}
inline void LibertyReaderClass::set__library_group(uint64_t value) {
  _internal_set__library_group(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyReaderClass._library_group)
}

// required string _file_name = 3;
inline bool LibertyReaderClass::_internal_has__file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibertyReaderClass::has__file_name() const {
  return _internal_has__file_name();
}
inline void LibertyReaderClass::clear__file_name() {
  _impl_._file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibertyReaderClass::_file_name() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyReaderClass._file_name)
  return _internal__file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibertyReaderClass::set__file_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Liberty.LibertyReaderClass._file_name)
}
inline std::string* LibertyReaderClass::mutable__file_name() {
  std::string* _s = _internal_mutable__file_name();
  // @@protoc_insertion_point(field_mutable:Liberty.LibertyReaderClass._file_name)
  return _s;
}
inline const std::string& LibertyReaderClass::_internal__file_name() const {
  return _impl_._file_name_.Get();
}
inline void LibertyReaderClass::_internal_set__file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LibertyReaderClass::_internal_mutable__file_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LibertyReaderClass::release__file_name() {
  // @@protoc_insertion_point(field_release:Liberty.LibertyReaderClass._file_name)
  if (!_internal_has__file_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibertyReaderClass::set_allocated__file_name(std::string* _file_name) {
  if (_file_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._file_name_.SetAllocated(_file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Liberty.LibertyReaderClass._file_name)
}

// required uint64 _liberty_builder = 4;
inline bool LibertyReaderClass::_internal_has__liberty_builder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LibertyReaderClass::has__liberty_builder() const {
  return _internal_has__liberty_builder();
}
inline void LibertyReaderClass::clear__liberty_builder() {
  _impl_._liberty_builder_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t LibertyReaderClass::_internal__liberty_builder() const {
  return _impl_._liberty_builder_;
}
inline uint64_t LibertyReaderClass::_liberty_builder() const {
  // @@protoc_insertion_point(field_get:Liberty.LibertyReaderClass._liberty_builder)
  return _internal__liberty_builder();
}
inline void LibertyReaderClass::_internal_set__liberty_builder(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._liberty_builder_ = value;
}
inline void LibertyReaderClass::set__liberty_builder(uint64_t value) {
  _internal_set__liberty_builder(value);
  // @@protoc_insertion_point(field_set:Liberty.LibertyReaderClass._liberty_builder)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Liberty

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Liberty::LibertyExprOperatorEnum_Operator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Liberty::LibertyExprOperatorEnum_Operator>() {
  return ::Liberty::LibertyExprOperatorEnum_Operator_descriptor();
}
template <> struct is_proto_enum< ::Liberty::LibertyTableTypeEnum_TableType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Liberty::LibertyTableTypeEnum_TableType>() {
  return ::Liberty::LibertyTableTypeEnum_TableType_descriptor();
}
template <> struct is_proto_enum< ::Liberty::LibertyPortTypeEnum_PortType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Liberty::LibertyPortTypeEnum_PortType>() {
  return ::Liberty::LibertyPortTypeEnum_PortType_descriptor();
}
template <> struct is_proto_enum< ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType>() {
  return ::Liberty::LibertyOwnPortTypeEnum_LibertyOwnPortType_descriptor();
}
template <> struct is_proto_enum< ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType>() {
  return ::Liberty::LibertyOwnPgOrWhenTypeEnum_LibertyOwnPgOrWhenType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_LibertyReader_2eproto
