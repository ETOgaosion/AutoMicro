// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SdcConstrains.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SdcConstrains_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SdcConstrains_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommonTypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SdcConstrains_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SdcConstrains_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SdcConstrains_2eproto;
namespace Sdc {
class SdcAllClocksClass;
struct SdcAllClocksClassDefaultTypeInternal;
extern SdcAllClocksClassDefaultTypeInternal _SdcAllClocksClass_default_instance_;
class SdcClockClass;
struct SdcClockClassDefaultTypeInternal;
extern SdcClockClassDefaultTypeInternal _SdcClockClass_default_instance_;
class SdcClockGroupClass;
struct SdcClockGroupClassDefaultTypeInternal;
extern SdcClockGroupClassDefaultTypeInternal _SdcClockGroupClass_default_instance_;
class SdcClockGroupsClass;
struct SdcClockGroupsClassDefaultTypeInternal;
extern SdcClockGroupsClassDefaultTypeInternal _SdcClockGroupsClass_default_instance_;
class SdcClockSyn;
struct SdcClockSynDefaultTypeInternal;
extern SdcClockSynDefaultTypeInternal _SdcClockSyn_default_instance_;
class SdcCollectionClass;
struct SdcCollectionClassDefaultTypeInternal;
extern SdcCollectionClassDefaultTypeInternal _SdcCollectionClass_default_instance_;
class SdcCollectionTypeEnum;
struct SdcCollectionTypeEnumDefaultTypeInternal;
extern SdcCollectionTypeEnumDefaultTypeInternal _SdcCollectionTypeEnum_default_instance_;
class SdcCommandObjClass;
struct SdcCommandObjClassDefaultTypeInternal;
extern SdcCommandObjClassDefaultTypeInternal _SdcCommandObjClass_default_instance_;
class SdcCommandObjSyn;
struct SdcCommandObjSynDefaultTypeInternal;
extern SdcCommandObjSynDefaultTypeInternal _SdcCommandObjSyn_default_instance_;
class SdcConstrainClass;
struct SdcConstrainClassDefaultTypeInternal;
extern SdcConstrainClassDefaultTypeInternal _SdcConstrainClass_default_instance_;
class SdcExceptionClass;
struct SdcExceptionClassDefaultTypeInternal;
extern SdcExceptionClassDefaultTypeInternal _SdcExceptionClass_default_instance_;
class SdcExceptionSyn;
struct SdcExceptionSynDefaultTypeInternal;
extern SdcExceptionSynDefaultTypeInternal _SdcExceptionSyn_default_instance_;
class SdcGenrateClockClass;
struct SdcGenrateClockClassDefaultTypeInternal;
extern SdcGenrateClockClassDefaultTypeInternal _SdcGenrateClockClass_default_instance_;
class SdcIOConstrainClass;
struct SdcIOConstrainClassDefaultTypeInternal;
extern SdcIOConstrainClassDefaultTypeInternal _SdcIOConstrainClass_default_instance_;
class SdcIOConstrainSyn;
struct SdcIOConstrainSynDefaultTypeInternal;
extern SdcIOConstrainSynDefaultTypeInternal _SdcIOConstrainSyn_default_instance_;
class SdcMulticyclePathClass;
struct SdcMulticyclePathClassDefaultTypeInternal;
extern SdcMulticyclePathClassDefaultTypeInternal _SdcMulticyclePathClass_default_instance_;
class SdcSetClockLatencyClass;
struct SdcSetClockLatencyClassDefaultTypeInternal;
extern SdcSetClockLatencyClassDefaultTypeInternal _SdcSetClockLatencyClass_default_instance_;
class SdcSetClockUncertaintyClass;
struct SdcSetClockUncertaintyClassDefaultTypeInternal;
extern SdcSetClockUncertaintyClassDefaultTypeInternal _SdcSetClockUncertaintyClass_default_instance_;
class SdcSetIODelayClass;
struct SdcSetIODelayClassDefaultTypeInternal;
extern SdcSetIODelayClassDefaultTypeInternal _SdcSetIODelayClass_default_instance_;
class SdcSetInputTransitionClass;
struct SdcSetInputTransitionClassDefaultTypeInternal;
extern SdcSetInputTransitionClassDefaultTypeInternal _SdcSetInputTransitionClass_default_instance_;
class SdcSetLoadClass;
struct SdcSetLoadClassDefaultTypeInternal;
extern SdcSetLoadClassDefaultTypeInternal _SdcSetLoadClass_default_instance_;
class SdcSetMaxCapacitanceClass;
struct SdcSetMaxCapacitanceClassDefaultTypeInternal;
extern SdcSetMaxCapacitanceClassDefaultTypeInternal _SdcSetMaxCapacitanceClass_default_instance_;
class SdcSetMaxTransitionClass;
struct SdcSetMaxTransitionClassDefaultTypeInternal;
extern SdcSetMaxTransitionClassDefaultTypeInternal _SdcSetMaxTransitionClass_default_instance_;
class SdcTimingDRCClass;
struct SdcTimingDRCClassDefaultTypeInternal;
extern SdcTimingDRCClassDefaultTypeInternal _SdcTimingDRCClass_default_instance_;
class SdcTimingDRCSyn;
struct SdcTimingDRCSynDefaultTypeInternal;
extern SdcTimingDRCSynDefaultTypeInternal _SdcTimingDRCSyn_default_instance_;
class SdcTimingDerateClass;
struct SdcTimingDerateClassDefaultTypeInternal;
extern SdcTimingDerateClassDefaultTypeInternal _SdcTimingDerateClass_default_instance_;
}  // namespace Sdc
PROTOBUF_NAMESPACE_OPEN
template<> ::Sdc::SdcAllClocksClass* Arena::CreateMaybeMessage<::Sdc::SdcAllClocksClass>(Arena*);
template<> ::Sdc::SdcClockClass* Arena::CreateMaybeMessage<::Sdc::SdcClockClass>(Arena*);
template<> ::Sdc::SdcClockGroupClass* Arena::CreateMaybeMessage<::Sdc::SdcClockGroupClass>(Arena*);
template<> ::Sdc::SdcClockGroupsClass* Arena::CreateMaybeMessage<::Sdc::SdcClockGroupsClass>(Arena*);
template<> ::Sdc::SdcClockSyn* Arena::CreateMaybeMessage<::Sdc::SdcClockSyn>(Arena*);
template<> ::Sdc::SdcCollectionClass* Arena::CreateMaybeMessage<::Sdc::SdcCollectionClass>(Arena*);
template<> ::Sdc::SdcCollectionTypeEnum* Arena::CreateMaybeMessage<::Sdc::SdcCollectionTypeEnum>(Arena*);
template<> ::Sdc::SdcCommandObjClass* Arena::CreateMaybeMessage<::Sdc::SdcCommandObjClass>(Arena*);
template<> ::Sdc::SdcCommandObjSyn* Arena::CreateMaybeMessage<::Sdc::SdcCommandObjSyn>(Arena*);
template<> ::Sdc::SdcConstrainClass* Arena::CreateMaybeMessage<::Sdc::SdcConstrainClass>(Arena*);
template<> ::Sdc::SdcExceptionClass* Arena::CreateMaybeMessage<::Sdc::SdcExceptionClass>(Arena*);
template<> ::Sdc::SdcExceptionSyn* Arena::CreateMaybeMessage<::Sdc::SdcExceptionSyn>(Arena*);
template<> ::Sdc::SdcGenrateClockClass* Arena::CreateMaybeMessage<::Sdc::SdcGenrateClockClass>(Arena*);
template<> ::Sdc::SdcIOConstrainClass* Arena::CreateMaybeMessage<::Sdc::SdcIOConstrainClass>(Arena*);
template<> ::Sdc::SdcIOConstrainSyn* Arena::CreateMaybeMessage<::Sdc::SdcIOConstrainSyn>(Arena*);
template<> ::Sdc::SdcMulticyclePathClass* Arena::CreateMaybeMessage<::Sdc::SdcMulticyclePathClass>(Arena*);
template<> ::Sdc::SdcSetClockLatencyClass* Arena::CreateMaybeMessage<::Sdc::SdcSetClockLatencyClass>(Arena*);
template<> ::Sdc::SdcSetClockUncertaintyClass* Arena::CreateMaybeMessage<::Sdc::SdcSetClockUncertaintyClass>(Arena*);
template<> ::Sdc::SdcSetIODelayClass* Arena::CreateMaybeMessage<::Sdc::SdcSetIODelayClass>(Arena*);
template<> ::Sdc::SdcSetInputTransitionClass* Arena::CreateMaybeMessage<::Sdc::SdcSetInputTransitionClass>(Arena*);
template<> ::Sdc::SdcSetLoadClass* Arena::CreateMaybeMessage<::Sdc::SdcSetLoadClass>(Arena*);
template<> ::Sdc::SdcSetMaxCapacitanceClass* Arena::CreateMaybeMessage<::Sdc::SdcSetMaxCapacitanceClass>(Arena*);
template<> ::Sdc::SdcSetMaxTransitionClass* Arena::CreateMaybeMessage<::Sdc::SdcSetMaxTransitionClass>(Arena*);
template<> ::Sdc::SdcTimingDRCClass* Arena::CreateMaybeMessage<::Sdc::SdcTimingDRCClass>(Arena*);
template<> ::Sdc::SdcTimingDRCSyn* Arena::CreateMaybeMessage<::Sdc::SdcTimingDRCSyn>(Arena*);
template<> ::Sdc::SdcTimingDerateClass* Arena::CreateMaybeMessage<::Sdc::SdcTimingDerateClass>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Sdc {

enum SdcCollectionTypeEnum_CollectionType : int {
  SdcCollectionTypeEnum_CollectionType_kClock = 0,
  SdcCollectionTypeEnum_CollectionType_kPin = 1,
  SdcCollectionTypeEnum_CollectionType_kPort = 2,
  SdcCollectionTypeEnum_CollectionType_kInst = 3,
  SdcCollectionTypeEnum_CollectionType_kNet = 4,
  SdcCollectionTypeEnum_CollectionType_kNetlist = 5,
  SdcCollectionTypeEnum_CollectionType_kAllClocks = 6
};
bool SdcCollectionTypeEnum_CollectionType_IsValid(int value);
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum_CollectionType_CollectionType_MIN = SdcCollectionTypeEnum_CollectionType_kClock;
constexpr SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum_CollectionType_CollectionType_MAX = SdcCollectionTypeEnum_CollectionType_kAllClocks;
constexpr int SdcCollectionTypeEnum_CollectionType_CollectionType_ARRAYSIZE = SdcCollectionTypeEnum_CollectionType_CollectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SdcCollectionTypeEnum_CollectionType_descriptor();
template<typename T>
inline const std::string& SdcCollectionTypeEnum_CollectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SdcCollectionTypeEnum_CollectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SdcCollectionTypeEnum_CollectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SdcCollectionTypeEnum_CollectionType_descriptor(), enum_t_value);
}
inline bool SdcCollectionTypeEnum_CollectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SdcCollectionTypeEnum_CollectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SdcCollectionTypeEnum_CollectionType>(
    SdcCollectionTypeEnum_CollectionType_descriptor(), name, value);
}
// ===================================================================

class SdcCommandObjClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcCommandObjClass) */ {
 public:
  inline SdcCommandObjClass() : SdcCommandObjClass(nullptr) {}
  ~SdcCommandObjClass() override;
  explicit PROTOBUF_CONSTEXPR SdcCommandObjClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcCommandObjClass(const SdcCommandObjClass& from);
  SdcCommandObjClass(SdcCommandObjClass&& from) noexcept
    : SdcCommandObjClass() {
    *this = ::std::move(from);
  }

  inline SdcCommandObjClass& operator=(const SdcCommandObjClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcCommandObjClass& operator=(SdcCommandObjClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcCommandObjClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcCommandObjClass* internal_default_instance() {
    return reinterpret_cast<const SdcCommandObjClass*>(
               &_SdcCommandObjClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SdcCommandObjClass& a, SdcCommandObjClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcCommandObjClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcCommandObjClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcCommandObjClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcCommandObjClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcCommandObjClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcCommandObjClass& from) {
    SdcCommandObjClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcCommandObjClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcCommandObjClass";
  }
  protected:
  explicit SdcCommandObjClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kLineNoFieldNumber = 2,
  };
  // required string _file_name = 1;
  bool has__file_name() const;
  private:
  bool _internal_has__file_name() const;
  public:
  void clear__file_name();
  const std::string& _file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__file_name();
  PROTOBUF_NODISCARD std::string* release__file_name();
  void set_allocated__file_name(std::string* _file_name);
  private:
  const std::string& _internal__file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__file_name(const std::string& value);
  std::string* _internal_mutable__file_name();
  public:

  // required uint32 _line_no = 2;
  bool has__line_no() const;
  private:
  bool _internal_has__line_no() const;
  public:
  void clear__line_no();
  uint32_t _line_no() const;
  void set__line_no(uint32_t value);
  private:
  uint32_t _internal__line_no() const;
  void _internal_set__line_no(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcCommandObjClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _file_name_;
    uint32_t _line_no_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcIOConstrainClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcIOConstrainClass) */ {
 public:
  inline SdcIOConstrainClass() : SdcIOConstrainClass(nullptr) {}
  ~SdcIOConstrainClass() override;
  explicit PROTOBUF_CONSTEXPR SdcIOConstrainClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcIOConstrainClass(const SdcIOConstrainClass& from);
  SdcIOConstrainClass(SdcIOConstrainClass&& from) noexcept
    : SdcIOConstrainClass() {
    *this = ::std::move(from);
  }

  inline SdcIOConstrainClass& operator=(const SdcIOConstrainClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcIOConstrainClass& operator=(SdcIOConstrainClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcIOConstrainClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcIOConstrainClass* internal_default_instance() {
    return reinterpret_cast<const SdcIOConstrainClass*>(
               &_SdcIOConstrainClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SdcIOConstrainClass& a, SdcIOConstrainClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcIOConstrainClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcIOConstrainClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcIOConstrainClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcIOConstrainClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcIOConstrainClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcIOConstrainClass& from) {
    SdcIOConstrainClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcIOConstrainClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcIOConstrainClass";
  }
  protected:
  explicit SdcIOConstrainClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstrainNameFieldNumber = 1,
  };
  // required string _constrain_name = 1;
  bool has__constrain_name() const;
  private:
  bool _internal_has__constrain_name() const;
  public:
  void clear__constrain_name();
  const std::string& _constrain_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__constrain_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__constrain_name();
  PROTOBUF_NODISCARD std::string* release__constrain_name();
  void set_allocated__constrain_name(std::string* _constrain_name);
  private:
  const std::string& _internal__constrain_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__constrain_name(const std::string& value);
  std::string* _internal_mutable__constrain_name();
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcIOConstrainClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _constrain_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcSetInputTransitionClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcSetInputTransitionClass) */ {
 public:
  inline SdcSetInputTransitionClass() : SdcSetInputTransitionClass(nullptr) {}
  ~SdcSetInputTransitionClass() override;
  explicit PROTOBUF_CONSTEXPR SdcSetInputTransitionClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcSetInputTransitionClass(const SdcSetInputTransitionClass& from);
  SdcSetInputTransitionClass(SdcSetInputTransitionClass&& from) noexcept
    : SdcSetInputTransitionClass() {
    *this = ::std::move(from);
  }

  inline SdcSetInputTransitionClass& operator=(const SdcSetInputTransitionClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcSetInputTransitionClass& operator=(SdcSetInputTransitionClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcSetInputTransitionClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcSetInputTransitionClass* internal_default_instance() {
    return reinterpret_cast<const SdcSetInputTransitionClass*>(
               &_SdcSetInputTransitionClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SdcSetInputTransitionClass& a, SdcSetInputTransitionClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcSetInputTransitionClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcSetInputTransitionClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcSetInputTransitionClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcSetInputTransitionClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcSetInputTransitionClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcSetInputTransitionClass& from) {
    SdcSetInputTransitionClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcSetInputTransitionClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcSetInputTransitionClass";
  }
  protected:
  explicit SdcSetInputTransitionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 2,
    kTransitionValueFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated uint64 _objs = 2;
  int _objs_size() const;
  private:
  int _internal__objs_size() const;
  public:
  void clear__objs();
  private:
  uint64_t _internal__objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__objs() const;
  void _internal_add__objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__objs();
  public:
  uint64_t _objs(int index) const;
  void set__objs(int index, uint64_t value);
  void add__objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__objs();

  // required double _transition_value = 3;
  bool has__transition_value() const;
  private:
  bool _internal_has__transition_value() const;
  public:
  void clear__transition_value();
  double _transition_value() const;
  void set__transition_value(double value);
  private:
  double _internal__transition_value() const;
  void _internal_set__transition_value(double value);
  public:

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcSetInputTransitionClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _objs_;
    double _transition_value_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcSetIODelayClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcSetIODelayClass) */ {
 public:
  inline SdcSetIODelayClass() : SdcSetIODelayClass(nullptr) {}
  ~SdcSetIODelayClass() override;
  explicit PROTOBUF_CONSTEXPR SdcSetIODelayClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcSetIODelayClass(const SdcSetIODelayClass& from);
  SdcSetIODelayClass(SdcSetIODelayClass&& from) noexcept
    : SdcSetIODelayClass() {
    *this = ::std::move(from);
  }

  inline SdcSetIODelayClass& operator=(const SdcSetIODelayClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcSetIODelayClass& operator=(SdcSetIODelayClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcSetIODelayClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcSetIODelayClass* internal_default_instance() {
    return reinterpret_cast<const SdcSetIODelayClass*>(
               &_SdcSetIODelayClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SdcSetIODelayClass& a, SdcSetIODelayClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcSetIODelayClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcSetIODelayClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcSetIODelayClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcSetIODelayClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcSetIODelayClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcSetIODelayClass& from) {
    SdcSetIODelayClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcSetIODelayClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcSetIODelayClass";
  }
  protected:
  explicit SdcSetIODelayClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 4,
    kClockNameFieldNumber = 2,
    kDelayValueFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated uint64 _objs = 4;
  int _objs_size() const;
  private:
  int _internal__objs_size() const;
  public:
  void clear__objs();
  private:
  uint64_t _internal__objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__objs() const;
  void _internal_add__objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__objs();
  public:
  uint64_t _objs(int index) const;
  void set__objs(int index, uint64_t value);
  void add__objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__objs();

  // required string _clock_name = 2;
  bool has__clock_name() const;
  private:
  bool _internal_has__clock_name() const;
  public:
  void clear__clock_name();
  const std::string& _clock_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__clock_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__clock_name();
  PROTOBUF_NODISCARD std::string* release__clock_name();
  void set_allocated__clock_name(std::string* _clock_name);
  private:
  const std::string& _internal__clock_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__clock_name(const std::string& value);
  std::string* _internal_mutable__clock_name();
  public:

  // required double _delay_value = 3;
  bool has__delay_value() const;
  private:
  bool _internal_has__delay_value() const;
  public:
  void clear__delay_value();
  double _delay_value() const;
  void set__delay_value(double value);
  private:
  double _internal__delay_value() const;
  void _internal_set__delay_value(double value);
  public:

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcSetIODelayClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _objs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _clock_name_;
    double _delay_value_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcSetLoadClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcSetLoadClass) */ {
 public:
  inline SdcSetLoadClass() : SdcSetLoadClass(nullptr) {}
  ~SdcSetLoadClass() override;
  explicit PROTOBUF_CONSTEXPR SdcSetLoadClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcSetLoadClass(const SdcSetLoadClass& from);
  SdcSetLoadClass(SdcSetLoadClass&& from) noexcept
    : SdcSetLoadClass() {
    *this = ::std::move(from);
  }

  inline SdcSetLoadClass& operator=(const SdcSetLoadClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcSetLoadClass& operator=(SdcSetLoadClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcSetLoadClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcSetLoadClass* internal_default_instance() {
    return reinterpret_cast<const SdcSetLoadClass*>(
               &_SdcSetLoadClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SdcSetLoadClass& a, SdcSetLoadClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcSetLoadClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcSetLoadClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcSetLoadClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcSetLoadClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcSetLoadClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcSetLoadClass& from) {
    SdcSetLoadClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcSetLoadClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcSetLoadClass";
  }
  protected:
  explicit SdcSetLoadClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 2,
    kLoadValueFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated uint64 _objs = 2;
  int _objs_size() const;
  private:
  int _internal__objs_size() const;
  public:
  void clear__objs();
  private:
  uint64_t _internal__objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__objs() const;
  void _internal_add__objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__objs();
  public:
  uint64_t _objs(int index) const;
  void set__objs(int index, uint64_t value);
  void add__objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__objs();

  // required double _load_value = 3;
  bool has__load_value() const;
  private:
  bool _internal_has__load_value() const;
  public:
  void clear__load_value();
  double _load_value() const;
  void set__load_value(double value);
  private:
  double _internal__load_value() const;
  void _internal_set__load_value(double value);
  public:

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcSetLoadClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _objs_;
    double _load_value_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcIOConstrainSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcIOConstrainSyn) */ {
 public:
  inline SdcIOConstrainSyn() : SdcIOConstrainSyn(nullptr) {}
  ~SdcIOConstrainSyn() override;
  explicit PROTOBUF_CONSTEXPR SdcIOConstrainSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcIOConstrainSyn(const SdcIOConstrainSyn& from);
  SdcIOConstrainSyn(SdcIOConstrainSyn&& from) noexcept
    : SdcIOConstrainSyn() {
    *this = ::std::move(from);
  }

  inline SdcIOConstrainSyn& operator=(const SdcIOConstrainSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcIOConstrainSyn& operator=(SdcIOConstrainSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcIOConstrainSyn& default_instance() {
    return *internal_default_instance();
  }
  enum SiocsCase {
    kSsitc = 3,
    kSsiodc = 4,
    kSslc = 5,
    SIOCS_NOT_SET = 0,
  };

  static inline const SdcIOConstrainSyn* internal_default_instance() {
    return reinterpret_cast<const SdcIOConstrainSyn*>(
               &_SdcIOConstrainSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SdcIOConstrainSyn& a, SdcIOConstrainSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcIOConstrainSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcIOConstrainSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcIOConstrainSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcIOConstrainSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcIOConstrainSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcIOConstrainSyn& from) {
    SdcIOConstrainSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcIOConstrainSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcIOConstrainSyn";
  }
  protected:
  explicit SdcIOConstrainSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 2,
    kTypeFieldNumber = 1,
    kSsitcFieldNumber = 3,
    kSsiodcFieldNumber = 4,
    kSslcFieldNumber = 5,
  };
  // required .Sdc.SdcIOConstrainClass parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Sdc::SdcIOConstrainClass& parent() const;
  PROTOBUF_NODISCARD ::Sdc::SdcIOConstrainClass* release_parent();
  ::Sdc::SdcIOConstrainClass* mutable_parent();
  void set_allocated_parent(::Sdc::SdcIOConstrainClass* parent);
  private:
  const ::Sdc::SdcIOConstrainClass& _internal_parent() const;
  ::Sdc::SdcIOConstrainClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Sdc::SdcIOConstrainClass* parent);
  ::Sdc::SdcIOConstrainClass* unsafe_arena_release_parent();

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .Sdc.SdcSetInputTransitionClass ssitc = 3;
  bool has_ssitc() const;
  private:
  bool _internal_has_ssitc() const;
  public:
  void clear_ssitc();
  const ::Sdc::SdcSetInputTransitionClass& ssitc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcSetInputTransitionClass* release_ssitc();
  ::Sdc::SdcSetInputTransitionClass* mutable_ssitc();
  void set_allocated_ssitc(::Sdc::SdcSetInputTransitionClass* ssitc);
  private:
  const ::Sdc::SdcSetInputTransitionClass& _internal_ssitc() const;
  ::Sdc::SdcSetInputTransitionClass* _internal_mutable_ssitc();
  public:
  void unsafe_arena_set_allocated_ssitc(
      ::Sdc::SdcSetInputTransitionClass* ssitc);
  ::Sdc::SdcSetInputTransitionClass* unsafe_arena_release_ssitc();

  // .Sdc.SdcSetIODelayClass ssiodc = 4;
  bool has_ssiodc() const;
  private:
  bool _internal_has_ssiodc() const;
  public:
  void clear_ssiodc();
  const ::Sdc::SdcSetIODelayClass& ssiodc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcSetIODelayClass* release_ssiodc();
  ::Sdc::SdcSetIODelayClass* mutable_ssiodc();
  void set_allocated_ssiodc(::Sdc::SdcSetIODelayClass* ssiodc);
  private:
  const ::Sdc::SdcSetIODelayClass& _internal_ssiodc() const;
  ::Sdc::SdcSetIODelayClass* _internal_mutable_ssiodc();
  public:
  void unsafe_arena_set_allocated_ssiodc(
      ::Sdc::SdcSetIODelayClass* ssiodc);
  ::Sdc::SdcSetIODelayClass* unsafe_arena_release_ssiodc();

  // .Sdc.SdcSetLoadClass sslc = 5;
  bool has_sslc() const;
  private:
  bool _internal_has_sslc() const;
  public:
  void clear_sslc();
  const ::Sdc::SdcSetLoadClass& sslc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcSetLoadClass* release_sslc();
  ::Sdc::SdcSetLoadClass* mutable_sslc();
  void set_allocated_sslc(::Sdc::SdcSetLoadClass* sslc);
  private:
  const ::Sdc::SdcSetLoadClass& _internal_sslc() const;
  ::Sdc::SdcSetLoadClass* _internal_mutable_sslc();
  public:
  void unsafe_arena_set_allocated_sslc(
      ::Sdc::SdcSetLoadClass* sslc);
  ::Sdc::SdcSetLoadClass* unsafe_arena_release_sslc();

  void clear_siocs();
  SiocsCase siocs_case() const;
  // @@protoc_insertion_point(class_scope:Sdc.SdcIOConstrainSyn)
 private:
  class _Internal;
  void set_has_ssitc();
  void set_has_ssiodc();
  void set_has_sslc();

  inline bool has_siocs() const;
  inline void clear_has_siocs();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Sdc::SdcIOConstrainClass* parent_;
    uint32_t type_;
    union SiocsUnion {
      constexpr SiocsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Sdc::SdcSetInputTransitionClass* ssitc_;
      ::Sdc::SdcSetIODelayClass* ssiodc_;
      ::Sdc::SdcSetLoadClass* sslc_;
    } siocs_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcClockClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcClockClass) */ {
 public:
  inline SdcClockClass() : SdcClockClass(nullptr) {}
  ~SdcClockClass() override;
  explicit PROTOBUF_CONSTEXPR SdcClockClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcClockClass(const SdcClockClass& from);
  SdcClockClass(SdcClockClass&& from) noexcept
    : SdcClockClass() {
    *this = ::std::move(from);
  }

  inline SdcClockClass& operator=(const SdcClockClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcClockClass& operator=(SdcClockClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcClockClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcClockClass* internal_default_instance() {
    return reinterpret_cast<const SdcClockClass*>(
               &_SdcClockClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SdcClockClass& a, SdcClockClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcClockClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcClockClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcClockClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcClockClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcClockClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcClockClass& from) {
    SdcClockClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcClockClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcClockClass";
  }
  protected:
  explicit SdcClockClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 3,
    kEdgesFieldNumber = 4,
    kClockNameFieldNumber = 1,
    kTrackingCommentFieldNumber = 6,
    kPeriodFieldNumber = 2,
    kIsPropagatedFieldNumber = 5,
  };
  // repeated uint64 _objs = 3;
  int _objs_size() const;
  private:
  int _internal__objs_size() const;
  public:
  void clear__objs();
  private:
  uint64_t _internal__objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__objs() const;
  void _internal_add__objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__objs();
  public:
  uint64_t _objs(int index) const;
  void set__objs(int index, uint64_t value);
  void add__objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__objs();

  // repeated double _edges = 4;
  int _edges_size() const;
  private:
  int _internal__edges_size() const;
  public:
  void clear__edges();
  private:
  double _internal__edges(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal__edges() const;
  void _internal_add__edges(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable__edges();
  public:
  double _edges(int index) const;
  void set__edges(int index, double value);
  void add__edges(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _edges() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable__edges();

  // required string _clock_name = 1;
  bool has__clock_name() const;
  private:
  bool _internal_has__clock_name() const;
  public:
  void clear__clock_name();
  const std::string& _clock_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__clock_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__clock_name();
  PROTOBUF_NODISCARD std::string* release__clock_name();
  void set_allocated__clock_name(std::string* _clock_name);
  private:
  const std::string& _internal__clock_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__clock_name(const std::string& value);
  std::string* _internal_mutable__clock_name();
  public:

  // required string _tracking_comment = 6;
  bool has__tracking_comment() const;
  private:
  bool _internal_has__tracking_comment() const;
  public:
  void clear__tracking_comment();
  const std::string& _tracking_comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__tracking_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable__tracking_comment();
  PROTOBUF_NODISCARD std::string* release__tracking_comment();
  void set_allocated__tracking_comment(std::string* _tracking_comment);
  private:
  const std::string& _internal__tracking_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__tracking_comment(const std::string& value);
  std::string* _internal_mutable__tracking_comment();
  public:

  // required double _period = 2;
  bool has__period() const;
  private:
  bool _internal_has__period() const;
  public:
  void clear__period();
  double _period() const;
  void set__period(double value);
  private:
  double _internal__period() const;
  void _internal_set__period(double value);
  public:

  // required uint32 _is_propagated = 5;
  bool has__is_propagated() const;
  private:
  bool _internal_has__is_propagated() const;
  public:
  void clear__is_propagated();
  uint32_t _is_propagated() const;
  void set__is_propagated(uint32_t value);
  private:
  uint32_t _internal__is_propagated() const;
  void _internal_set__is_propagated(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcClockClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _objs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > _edges_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _clock_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _tracking_comment_;
    double _period_;
    uint32_t _is_propagated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcGenrateClockClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcGenrateClockClass) */ {
 public:
  inline SdcGenrateClockClass() : SdcGenrateClockClass(nullptr) {}
  ~SdcGenrateClockClass() override;
  explicit PROTOBUF_CONSTEXPR SdcGenrateClockClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcGenrateClockClass(const SdcGenrateClockClass& from);
  SdcGenrateClockClass(SdcGenrateClockClass&& from) noexcept
    : SdcGenrateClockClass() {
    *this = ::std::move(from);
  }

  inline SdcGenrateClockClass& operator=(const SdcGenrateClockClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcGenrateClockClass& operator=(SdcGenrateClockClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcGenrateClockClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcGenrateClockClass* internal_default_instance() {
    return reinterpret_cast<const SdcGenrateClockClass*>(
               &_SdcGenrateClockClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SdcGenrateClockClass& a, SdcGenrateClockClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcGenrateClockClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcGenrateClockClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcGenrateClockClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcGenrateClockClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcGenrateClockClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcGenrateClockClass& from) {
    SdcGenrateClockClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcGenrateClockClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcGenrateClockClass";
  }
  protected:
  explicit SdcGenrateClockClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceNameFieldNumber = 1,
  };
  // required string _source_name = 1;
  bool has__source_name() const;
  private:
  bool _internal_has__source_name() const;
  public:
  void clear__source_name();
  const std::string& _source_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__source_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__source_name();
  PROTOBUF_NODISCARD std::string* release__source_name();
  void set_allocated__source_name(std::string* _source_name);
  private:
  const std::string& _internal__source_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__source_name(const std::string& value);
  std::string* _internal_mutable__source_name();
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcGenrateClockClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _source_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcClockSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcClockSyn) */ {
 public:
  inline SdcClockSyn() : SdcClockSyn(nullptr) {}
  ~SdcClockSyn() override;
  explicit PROTOBUF_CONSTEXPR SdcClockSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcClockSyn(const SdcClockSyn& from);
  SdcClockSyn(SdcClockSyn&& from) noexcept
    : SdcClockSyn() {
    *this = ::std::move(from);
  }

  inline SdcClockSyn& operator=(const SdcClockSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcClockSyn& operator=(SdcClockSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcClockSyn& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcClockSyn* internal_default_instance() {
    return reinterpret_cast<const SdcClockSyn*>(
               &_SdcClockSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SdcClockSyn& a, SdcClockSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcClockSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcClockSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcClockSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcClockSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcClockSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcClockSyn& from) {
    SdcClockSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcClockSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcClockSyn";
  }
  protected:
  explicit SdcClockSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kChildFieldNumber = 4,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // required .Sdc.SdcClockClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Sdc::SdcClockClass& parent() const;
  PROTOBUF_NODISCARD ::Sdc::SdcClockClass* release_parent();
  ::Sdc::SdcClockClass* mutable_parent();
  void set_allocated_parent(::Sdc::SdcClockClass* parent);
  private:
  const ::Sdc::SdcClockClass& _internal_parent() const;
  ::Sdc::SdcClockClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Sdc::SdcClockClass* parent);
  ::Sdc::SdcClockClass* unsafe_arena_release_parent();

  // optional .Sdc.SdcGenrateClockClass child = 4;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::Sdc::SdcGenrateClockClass& child() const;
  PROTOBUF_NODISCARD ::Sdc::SdcGenrateClockClass* release_child();
  ::Sdc::SdcGenrateClockClass* mutable_child();
  void set_allocated_child(::Sdc::SdcGenrateClockClass* child);
  private:
  const ::Sdc::SdcGenrateClockClass& _internal_child() const;
  ::Sdc::SdcGenrateClockClass* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::Sdc::SdcGenrateClockClass* child);
  ::Sdc::SdcGenrateClockClass* unsafe_arena_release_child();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcClockSyn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Sdc::SdcClockClass* parent_;
    ::Sdc::SdcGenrateClockClass* child_;
    uint64_t id_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcAllClocksClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcAllClocksClass) */ {
 public:
  inline SdcAllClocksClass() : SdcAllClocksClass(nullptr) {}
  ~SdcAllClocksClass() override;
  explicit PROTOBUF_CONSTEXPR SdcAllClocksClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcAllClocksClass(const SdcAllClocksClass& from);
  SdcAllClocksClass(SdcAllClocksClass&& from) noexcept
    : SdcAllClocksClass() {
    *this = ::std::move(from);
  }

  inline SdcAllClocksClass& operator=(const SdcAllClocksClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcAllClocksClass& operator=(SdcAllClocksClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcAllClocksClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcAllClocksClass* internal_default_instance() {
    return reinterpret_cast<const SdcAllClocksClass*>(
               &_SdcAllClocksClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SdcAllClocksClass& a, SdcAllClocksClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcAllClocksClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcAllClocksClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcAllClocksClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcAllClocksClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcAllClocksClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcAllClocksClass& from) {
    SdcAllClocksClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcAllClocksClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcAllClocksClass";
  }
  protected:
  explicit SdcAllClocksClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClocksFieldNumber = 1,
  };
  // repeated uint64 _clocks = 1;
  int _clocks_size() const;
  private:
  int _internal__clocks_size() const;
  public:
  void clear__clocks();
  private:
  uint64_t _internal__clocks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__clocks() const;
  void _internal_add__clocks(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__clocks();
  public:
  uint64_t _clocks(int index) const;
  void set__clocks(int index, uint64_t value);
  void add__clocks(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _clocks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__clocks();

  // @@protoc_insertion_point(class_scope:Sdc.SdcAllClocksClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _clocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcClockGroupClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcClockGroupClass) */ {
 public:
  inline SdcClockGroupClass() : SdcClockGroupClass(nullptr) {}
  ~SdcClockGroupClass() override;
  explicit PROTOBUF_CONSTEXPR SdcClockGroupClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcClockGroupClass(const SdcClockGroupClass& from);
  SdcClockGroupClass(SdcClockGroupClass&& from) noexcept
    : SdcClockGroupClass() {
    *this = ::std::move(from);
  }

  inline SdcClockGroupClass& operator=(const SdcClockGroupClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcClockGroupClass& operator=(SdcClockGroupClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcClockGroupClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcClockGroupClass* internal_default_instance() {
    return reinterpret_cast<const SdcClockGroupClass*>(
               &_SdcClockGroupClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SdcClockGroupClass& a, SdcClockGroupClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcClockGroupClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcClockGroupClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcClockGroupClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcClockGroupClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcClockGroupClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcClockGroupClass& from) {
    SdcClockGroupClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcClockGroupClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcClockGroupClass";
  }
  protected:
  explicit SdcClockGroupClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClockGroupFieldNumber = 1,
  };
  // repeated string _clock_group = 1;
  int _clock_group_size() const;
  private:
  int _internal__clock_group_size() const;
  public:
  void clear__clock_group();
  const std::string& _clock_group(int index) const;
  std::string* mutable__clock_group(int index);
  void set__clock_group(int index, const std::string& value);
  void set__clock_group(int index, std::string&& value);
  void set__clock_group(int index, const char* value);
  void set__clock_group(int index, const char* value, size_t size);
  std::string* add__clock_group();
  void add__clock_group(const std::string& value);
  void add__clock_group(std::string&& value);
  void add__clock_group(const char* value);
  void add__clock_group(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _clock_group() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable__clock_group();
  private:
  const std::string& _internal__clock_group(int index) const;
  std::string* _internal_add__clock_group();
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcClockGroupClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> _clock_group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcClockGroupsClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcClockGroupsClass) */ {
 public:
  inline SdcClockGroupsClass() : SdcClockGroupsClass(nullptr) {}
  ~SdcClockGroupsClass() override;
  explicit PROTOBUF_CONSTEXPR SdcClockGroupsClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcClockGroupsClass(const SdcClockGroupsClass& from);
  SdcClockGroupsClass(SdcClockGroupsClass&& from) noexcept
    : SdcClockGroupsClass() {
    *this = ::std::move(from);
  }

  inline SdcClockGroupsClass& operator=(const SdcClockGroupsClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcClockGroupsClass& operator=(SdcClockGroupsClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcClockGroupsClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcClockGroupsClass* internal_default_instance() {
    return reinterpret_cast<const SdcClockGroupsClass*>(
               &_SdcClockGroupsClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SdcClockGroupsClass& a, SdcClockGroupsClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcClockGroupsClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcClockGroupsClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcClockGroupsClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcClockGroupsClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcClockGroupsClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcClockGroupsClass& from) {
    SdcClockGroupsClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcClockGroupsClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcClockGroupsClass";
  }
  protected:
  explicit SdcClockGroupsClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClockGroupsFieldNumber = 1,
    kGroupNameFieldNumber = 2,
  };
  // repeated .Sdc.SdcClockGroupClass _clock_groups = 1;
  int _clock_groups_size() const;
  private:
  int _internal__clock_groups_size() const;
  public:
  void clear__clock_groups();
  ::Sdc::SdcClockGroupClass* mutable__clock_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sdc::SdcClockGroupClass >*
      mutable__clock_groups();
  private:
  const ::Sdc::SdcClockGroupClass& _internal__clock_groups(int index) const;
  ::Sdc::SdcClockGroupClass* _internal_add__clock_groups();
  public:
  const ::Sdc::SdcClockGroupClass& _clock_groups(int index) const;
  ::Sdc::SdcClockGroupClass* add__clock_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sdc::SdcClockGroupClass >&
      _clock_groups() const;

  // required string _group_name = 2;
  bool has__group_name() const;
  private:
  bool _internal_has__group_name() const;
  public:
  void clear__group_name();
  const std::string& _group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable__group_name();
  PROTOBUF_NODISCARD std::string* release__group_name();
  void set_allocated__group_name(std::string* _group_name);
  private:
  const std::string& _internal__group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__group_name(const std::string& value);
  std::string* _internal_mutable__group_name();
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcClockGroupsClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sdc::SdcClockGroupClass > _clock_groups_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _group_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcCollectionTypeEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcCollectionTypeEnum) */ {
 public:
  inline SdcCollectionTypeEnum() : SdcCollectionTypeEnum(nullptr) {}
  ~SdcCollectionTypeEnum() override;
  explicit PROTOBUF_CONSTEXPR SdcCollectionTypeEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcCollectionTypeEnum(const SdcCollectionTypeEnum& from);
  SdcCollectionTypeEnum(SdcCollectionTypeEnum&& from) noexcept
    : SdcCollectionTypeEnum() {
    *this = ::std::move(from);
  }

  inline SdcCollectionTypeEnum& operator=(const SdcCollectionTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcCollectionTypeEnum& operator=(SdcCollectionTypeEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcCollectionTypeEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcCollectionTypeEnum* internal_default_instance() {
    return reinterpret_cast<const SdcCollectionTypeEnum*>(
               &_SdcCollectionTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SdcCollectionTypeEnum& a, SdcCollectionTypeEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcCollectionTypeEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcCollectionTypeEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcCollectionTypeEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcCollectionTypeEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcCollectionTypeEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcCollectionTypeEnum& from) {
    SdcCollectionTypeEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcCollectionTypeEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcCollectionTypeEnum";
  }
  protected:
  explicit SdcCollectionTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SdcCollectionTypeEnum_CollectionType CollectionType;
  static constexpr CollectionType kClock =
    SdcCollectionTypeEnum_CollectionType_kClock;
  static constexpr CollectionType kPin =
    SdcCollectionTypeEnum_CollectionType_kPin;
  static constexpr CollectionType kPort =
    SdcCollectionTypeEnum_CollectionType_kPort;
  static constexpr CollectionType kInst =
    SdcCollectionTypeEnum_CollectionType_kInst;
  static constexpr CollectionType kNet =
    SdcCollectionTypeEnum_CollectionType_kNet;
  static constexpr CollectionType kNetlist =
    SdcCollectionTypeEnum_CollectionType_kNetlist;
  static constexpr CollectionType kAllClocks =
    SdcCollectionTypeEnum_CollectionType_kAllClocks;
  static inline bool CollectionType_IsValid(int value) {
    return SdcCollectionTypeEnum_CollectionType_IsValid(value);
  }
  static constexpr CollectionType CollectionType_MIN =
    SdcCollectionTypeEnum_CollectionType_CollectionType_MIN;
  static constexpr CollectionType CollectionType_MAX =
    SdcCollectionTypeEnum_CollectionType_CollectionType_MAX;
  static constexpr int CollectionType_ARRAYSIZE =
    SdcCollectionTypeEnum_CollectionType_CollectionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CollectionType_descriptor() {
    return SdcCollectionTypeEnum_CollectionType_descriptor();
  }
  template<typename T>
  static inline const std::string& CollectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CollectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CollectionType_Name.");
    return SdcCollectionTypeEnum_CollectionType_Name(enum_t_value);
  }
  static inline bool CollectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CollectionType* value) {
    return SdcCollectionTypeEnum_CollectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCtFieldNumber = 1,
  };
  // required .Sdc.SdcCollectionTypeEnum.CollectionType ct = 1;
  bool has_ct() const;
  private:
  bool _internal_has_ct() const;
  public:
  void clear_ct();
  ::Sdc::SdcCollectionTypeEnum_CollectionType ct() const;
  void set_ct(::Sdc::SdcCollectionTypeEnum_CollectionType value);
  private:
  ::Sdc::SdcCollectionTypeEnum_CollectionType _internal_ct() const;
  void _internal_set_ct(::Sdc::SdcCollectionTypeEnum_CollectionType value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcCollectionTypeEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int ct_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcCollectionClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcCollectionClass) */ {
 public:
  inline SdcCollectionClass() : SdcCollectionClass(nullptr) {}
  ~SdcCollectionClass() override;
  explicit PROTOBUF_CONSTEXPR SdcCollectionClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcCollectionClass(const SdcCollectionClass& from);
  SdcCollectionClass(SdcCollectionClass&& from) noexcept
    : SdcCollectionClass() {
    *this = ::std::move(from);
  }

  inline SdcCollectionClass& operator=(const SdcCollectionClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcCollectionClass& operator=(SdcCollectionClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcCollectionClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcCollectionClass* internal_default_instance() {
    return reinterpret_cast<const SdcCollectionClass*>(
               &_SdcCollectionClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SdcCollectionClass& a, SdcCollectionClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcCollectionClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcCollectionClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcCollectionClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcCollectionClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcCollectionClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcCollectionClass& from) {
    SdcCollectionClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcCollectionClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcCollectionClass";
  }
  protected:
  explicit SdcCollectionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionObjsFieldNumber = 2,
    kCollectionObjTypesFieldNumber = 3,
    kScteFieldNumber = 1,
  };
  // repeated uint64 _collection_objs = 2;
  int _collection_objs_size() const;
  private:
  int _internal__collection_objs_size() const;
  public:
  void clear__collection_objs();
  private:
  uint64_t _internal__collection_objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__collection_objs() const;
  void _internal_add__collection_objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__collection_objs();
  public:
  uint64_t _collection_objs(int index) const;
  void set__collection_objs(int index, uint64_t value);
  void add__collection_objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _collection_objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__collection_objs();

  // repeated uint32 _collection_obj_types = 3;
  int _collection_obj_types_size() const;
  private:
  int _internal__collection_obj_types_size() const;
  public:
  void clear__collection_obj_types();
  private:
  uint32_t _internal__collection_obj_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal__collection_obj_types() const;
  void _internal_add__collection_obj_types(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable__collection_obj_types();
  public:
  uint32_t _collection_obj_types(int index) const;
  void set__collection_obj_types(int index, uint32_t value);
  void add__collection_obj_types(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _collection_obj_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable__collection_obj_types();

  // required .Sdc.SdcCollectionTypeEnum scte = 1;
  bool has_scte() const;
  private:
  bool _internal_has_scte() const;
  public:
  void clear_scte();
  const ::Sdc::SdcCollectionTypeEnum& scte() const;
  PROTOBUF_NODISCARD ::Sdc::SdcCollectionTypeEnum* release_scte();
  ::Sdc::SdcCollectionTypeEnum* mutable_scte();
  void set_allocated_scte(::Sdc::SdcCollectionTypeEnum* scte);
  private:
  const ::Sdc::SdcCollectionTypeEnum& _internal_scte() const;
  ::Sdc::SdcCollectionTypeEnum* _internal_mutable_scte();
  public:
  void unsafe_arena_set_allocated_scte(
      ::Sdc::SdcCollectionTypeEnum* scte);
  ::Sdc::SdcCollectionTypeEnum* unsafe_arena_release_scte();

  // @@protoc_insertion_point(class_scope:Sdc.SdcCollectionClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _collection_objs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > _collection_obj_types_;
    ::Sdc::SdcCollectionTypeEnum* scte_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcTimingDerateClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcTimingDerateClass) */ {
 public:
  inline SdcTimingDerateClass() : SdcTimingDerateClass(nullptr) {}
  ~SdcTimingDerateClass() override;
  explicit PROTOBUF_CONSTEXPR SdcTimingDerateClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcTimingDerateClass(const SdcTimingDerateClass& from);
  SdcTimingDerateClass(SdcTimingDerateClass&& from) noexcept
    : SdcTimingDerateClass() {
    *this = ::std::move(from);
  }

  inline SdcTimingDerateClass& operator=(const SdcTimingDerateClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcTimingDerateClass& operator=(SdcTimingDerateClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcTimingDerateClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcTimingDerateClass* internal_default_instance() {
    return reinterpret_cast<const SdcTimingDerateClass*>(
               &_SdcTimingDerateClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SdcTimingDerateClass& a, SdcTimingDerateClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcTimingDerateClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcTimingDerateClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcTimingDerateClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcTimingDerateClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcTimingDerateClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcTimingDerateClass& from) {
    SdcTimingDerateClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcTimingDerateClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcTimingDerateClass";
  }
  protected:
  explicit SdcTimingDerateClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDerateValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // required double _derate_value = 2;
  bool has__derate_value() const;
  private:
  bool _internal_has__derate_value() const;
  public:
  void clear__derate_value();
  double _derate_value() const;
  void set__derate_value(double value);
  private:
  double _internal__derate_value() const;
  void _internal_set__derate_value(double value);
  public:

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcTimingDerateClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double _derate_value_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcTimingDRCClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcTimingDRCClass) */ {
 public:
  inline SdcTimingDRCClass() : SdcTimingDRCClass(nullptr) {}
  ~SdcTimingDRCClass() override;
  explicit PROTOBUF_CONSTEXPR SdcTimingDRCClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcTimingDRCClass(const SdcTimingDRCClass& from);
  SdcTimingDRCClass(SdcTimingDRCClass&& from) noexcept
    : SdcTimingDRCClass() {
    *this = ::std::move(from);
  }

  inline SdcTimingDRCClass& operator=(const SdcTimingDRCClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcTimingDRCClass& operator=(SdcTimingDRCClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcTimingDRCClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcTimingDRCClass* internal_default_instance() {
    return reinterpret_cast<const SdcTimingDRCClass*>(
               &_SdcTimingDRCClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SdcTimingDRCClass& a, SdcTimingDRCClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcTimingDRCClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcTimingDRCClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcTimingDRCClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcTimingDRCClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcTimingDRCClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcTimingDRCClass& from) {
    SdcTimingDRCClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcTimingDRCClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcTimingDRCClass";
  }
  protected:
  explicit SdcTimingDRCClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 2,
    kObjTypesFieldNumber = 3,
    kDrcValFieldNumber = 1,
  };
  // repeated uint64 _objs = 2;
  int _objs_size() const;
  private:
  int _internal__objs_size() const;
  public:
  void clear__objs();
  private:
  uint64_t _internal__objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__objs() const;
  void _internal_add__objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__objs();
  public:
  uint64_t _objs(int index) const;
  void set__objs(int index, uint64_t value);
  void add__objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__objs();

  // repeated uint32 _obj_types = 3;
  int _obj_types_size() const;
  private:
  int _internal__obj_types_size() const;
  public:
  void clear__obj_types();
  private:
  uint32_t _internal__obj_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal__obj_types() const;
  void _internal_add__obj_types(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable__obj_types();
  public:
  uint32_t _obj_types(int index) const;
  void set__obj_types(int index, uint32_t value);
  void add__obj_types(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _obj_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable__obj_types();

  // required double _drc_val = 1;
  bool has__drc_val() const;
  private:
  bool _internal_has__drc_val() const;
  public:
  void clear__drc_val();
  double _drc_val() const;
  void set__drc_val(double value);
  private:
  double _internal__drc_val() const;
  void _internal_set__drc_val(double value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcTimingDRCClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _objs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > _obj_types_;
    double _drc_val_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcSetMaxTransitionClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcSetMaxTransitionClass) */ {
 public:
  inline SdcSetMaxTransitionClass() : SdcSetMaxTransitionClass(nullptr) {}
  ~SdcSetMaxTransitionClass() override;
  explicit PROTOBUF_CONSTEXPR SdcSetMaxTransitionClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcSetMaxTransitionClass(const SdcSetMaxTransitionClass& from);
  SdcSetMaxTransitionClass(SdcSetMaxTransitionClass&& from) noexcept
    : SdcSetMaxTransitionClass() {
    *this = ::std::move(from);
  }

  inline SdcSetMaxTransitionClass& operator=(const SdcSetMaxTransitionClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcSetMaxTransitionClass& operator=(SdcSetMaxTransitionClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcSetMaxTransitionClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcSetMaxTransitionClass* internal_default_instance() {
    return reinterpret_cast<const SdcSetMaxTransitionClass*>(
               &_SdcSetMaxTransitionClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SdcSetMaxTransitionClass& a, SdcSetMaxTransitionClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcSetMaxTransitionClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcSetMaxTransitionClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcSetMaxTransitionClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcSetMaxTransitionClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcSetMaxTransitionClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcSetMaxTransitionClass& from) {
    SdcSetMaxTransitionClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcSetMaxTransitionClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcSetMaxTransitionClass";
  }
  protected:
  explicit SdcSetMaxTransitionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcSetMaxTransitionClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcSetMaxCapacitanceClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcSetMaxCapacitanceClass) */ {
 public:
  inline SdcSetMaxCapacitanceClass() : SdcSetMaxCapacitanceClass(nullptr) {}
  ~SdcSetMaxCapacitanceClass() override;
  explicit PROTOBUF_CONSTEXPR SdcSetMaxCapacitanceClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcSetMaxCapacitanceClass(const SdcSetMaxCapacitanceClass& from);
  SdcSetMaxCapacitanceClass(SdcSetMaxCapacitanceClass&& from) noexcept
    : SdcSetMaxCapacitanceClass() {
    *this = ::std::move(from);
  }

  inline SdcSetMaxCapacitanceClass& operator=(const SdcSetMaxCapacitanceClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcSetMaxCapacitanceClass& operator=(SdcSetMaxCapacitanceClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcSetMaxCapacitanceClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcSetMaxCapacitanceClass* internal_default_instance() {
    return reinterpret_cast<const SdcSetMaxCapacitanceClass*>(
               &_SdcSetMaxCapacitanceClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SdcSetMaxCapacitanceClass& a, SdcSetMaxCapacitanceClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcSetMaxCapacitanceClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcSetMaxCapacitanceClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcSetMaxCapacitanceClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcSetMaxCapacitanceClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcSetMaxCapacitanceClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcSetMaxCapacitanceClass& from) {
    SdcSetMaxCapacitanceClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcSetMaxCapacitanceClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcSetMaxCapacitanceClass";
  }
  protected:
  explicit SdcSetMaxCapacitanceClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
  };
  // required uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcSetMaxCapacitanceClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcTimingDRCSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcTimingDRCSyn) */ {
 public:
  inline SdcTimingDRCSyn() : SdcTimingDRCSyn(nullptr) {}
  ~SdcTimingDRCSyn() override;
  explicit PROTOBUF_CONSTEXPR SdcTimingDRCSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcTimingDRCSyn(const SdcTimingDRCSyn& from);
  SdcTimingDRCSyn(SdcTimingDRCSyn&& from) noexcept
    : SdcTimingDRCSyn() {
    *this = ::std::move(from);
  }

  inline SdcTimingDRCSyn& operator=(const SdcTimingDRCSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcTimingDRCSyn& operator=(SdcTimingDRCSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcTimingDRCSyn& default_instance() {
    return *internal_default_instance();
  }
  enum StdrcsCase {
    kSsntc = 3,
    kSsncc = 4,
    STDRCS_NOT_SET = 0,
  };

  static inline const SdcTimingDRCSyn* internal_default_instance() {
    return reinterpret_cast<const SdcTimingDRCSyn*>(
               &_SdcTimingDRCSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SdcTimingDRCSyn& a, SdcTimingDRCSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcTimingDRCSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcTimingDRCSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcTimingDRCSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcTimingDRCSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcTimingDRCSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcTimingDRCSyn& from) {
    SdcTimingDRCSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcTimingDRCSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcTimingDRCSyn";
  }
  protected:
  explicit SdcTimingDRCSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 2,
    kTypeFieldNumber = 1,
    kSsntcFieldNumber = 3,
    kSsnccFieldNumber = 4,
  };
  // required .Sdc.SdcTimingDRCClass parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Sdc::SdcTimingDRCClass& parent() const;
  PROTOBUF_NODISCARD ::Sdc::SdcTimingDRCClass* release_parent();
  ::Sdc::SdcTimingDRCClass* mutable_parent();
  void set_allocated_parent(::Sdc::SdcTimingDRCClass* parent);
  private:
  const ::Sdc::SdcTimingDRCClass& _internal_parent() const;
  ::Sdc::SdcTimingDRCClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Sdc::SdcTimingDRCClass* parent);
  ::Sdc::SdcTimingDRCClass* unsafe_arena_release_parent();

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .Sdc.SdcSetMaxTransitionClass ssntc = 3;
  bool has_ssntc() const;
  private:
  bool _internal_has_ssntc() const;
  public:
  void clear_ssntc();
  const ::Sdc::SdcSetMaxTransitionClass& ssntc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcSetMaxTransitionClass* release_ssntc();
  ::Sdc::SdcSetMaxTransitionClass* mutable_ssntc();
  void set_allocated_ssntc(::Sdc::SdcSetMaxTransitionClass* ssntc);
  private:
  const ::Sdc::SdcSetMaxTransitionClass& _internal_ssntc() const;
  ::Sdc::SdcSetMaxTransitionClass* _internal_mutable_ssntc();
  public:
  void unsafe_arena_set_allocated_ssntc(
      ::Sdc::SdcSetMaxTransitionClass* ssntc);
  ::Sdc::SdcSetMaxTransitionClass* unsafe_arena_release_ssntc();

  // .Sdc.SdcSetMaxCapacitanceClass ssncc = 4;
  bool has_ssncc() const;
  private:
  bool _internal_has_ssncc() const;
  public:
  void clear_ssncc();
  const ::Sdc::SdcSetMaxCapacitanceClass& ssncc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcSetMaxCapacitanceClass* release_ssncc();
  ::Sdc::SdcSetMaxCapacitanceClass* mutable_ssncc();
  void set_allocated_ssncc(::Sdc::SdcSetMaxCapacitanceClass* ssncc);
  private:
  const ::Sdc::SdcSetMaxCapacitanceClass& _internal_ssncc() const;
  ::Sdc::SdcSetMaxCapacitanceClass* _internal_mutable_ssncc();
  public:
  void unsafe_arena_set_allocated_ssncc(
      ::Sdc::SdcSetMaxCapacitanceClass* ssncc);
  ::Sdc::SdcSetMaxCapacitanceClass* unsafe_arena_release_ssncc();

  void clear_stdrcs();
  StdrcsCase stdrcs_case() const;
  // @@protoc_insertion_point(class_scope:Sdc.SdcTimingDRCSyn)
 private:
  class _Internal;
  void set_has_ssntc();
  void set_has_ssncc();

  inline bool has_stdrcs() const;
  inline void clear_has_stdrcs();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Sdc::SdcTimingDRCClass* parent_;
    uint32_t type_;
    union StdrcsUnion {
      constexpr StdrcsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Sdc::SdcSetMaxTransitionClass* ssntc_;
      ::Sdc::SdcSetMaxCapacitanceClass* ssncc_;
    } stdrcs_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcSetClockLatencyClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcSetClockLatencyClass) */ {
 public:
  inline SdcSetClockLatencyClass() : SdcSetClockLatencyClass(nullptr) {}
  ~SdcSetClockLatencyClass() override;
  explicit PROTOBUF_CONSTEXPR SdcSetClockLatencyClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcSetClockLatencyClass(const SdcSetClockLatencyClass& from);
  SdcSetClockLatencyClass(SdcSetClockLatencyClass&& from) noexcept
    : SdcSetClockLatencyClass() {
    *this = ::std::move(from);
  }

  inline SdcSetClockLatencyClass& operator=(const SdcSetClockLatencyClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcSetClockLatencyClass& operator=(SdcSetClockLatencyClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcSetClockLatencyClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcSetClockLatencyClass* internal_default_instance() {
    return reinterpret_cast<const SdcSetClockLatencyClass*>(
               &_SdcSetClockLatencyClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SdcSetClockLatencyClass& a, SdcSetClockLatencyClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcSetClockLatencyClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcSetClockLatencyClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcSetClockLatencyClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcSetClockLatencyClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcSetClockLatencyClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcSetClockLatencyClass& from) {
    SdcSetClockLatencyClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcSetClockLatencyClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcSetClockLatencyClass";
  }
  protected:
  explicit SdcSetClockLatencyClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 3,
    kDelayValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated uint64 _objs = 3;
  int _objs_size() const;
  private:
  int _internal__objs_size() const;
  public:
  void clear__objs();
  private:
  uint64_t _internal__objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__objs() const;
  void _internal_add__objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__objs();
  public:
  uint64_t _objs(int index) const;
  void set__objs(int index, uint64_t value);
  void add__objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__objs();

  // required double _delay_value = 2;
  bool has__delay_value() const;
  private:
  bool _internal_has__delay_value() const;
  public:
  void clear__delay_value();
  double _delay_value() const;
  void set__delay_value(double value);
  private:
  double _internal__delay_value() const;
  void _internal_set__delay_value(double value);
  public:

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcSetClockLatencyClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _objs_;
    double _delay_value_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcSetClockUncertaintyClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcSetClockUncertaintyClass) */ {
 public:
  inline SdcSetClockUncertaintyClass() : SdcSetClockUncertaintyClass(nullptr) {}
  ~SdcSetClockUncertaintyClass() override;
  explicit PROTOBUF_CONSTEXPR SdcSetClockUncertaintyClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcSetClockUncertaintyClass(const SdcSetClockUncertaintyClass& from);
  SdcSetClockUncertaintyClass(SdcSetClockUncertaintyClass&& from) noexcept
    : SdcSetClockUncertaintyClass() {
    *this = ::std::move(from);
  }

  inline SdcSetClockUncertaintyClass& operator=(const SdcSetClockUncertaintyClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcSetClockUncertaintyClass& operator=(SdcSetClockUncertaintyClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcSetClockUncertaintyClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcSetClockUncertaintyClass* internal_default_instance() {
    return reinterpret_cast<const SdcSetClockUncertaintyClass*>(
               &_SdcSetClockUncertaintyClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SdcSetClockUncertaintyClass& a, SdcSetClockUncertaintyClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcSetClockUncertaintyClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcSetClockUncertaintyClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcSetClockUncertaintyClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcSetClockUncertaintyClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcSetClockUncertaintyClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcSetClockUncertaintyClass& from) {
    SdcSetClockUncertaintyClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcSetClockUncertaintyClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcSetClockUncertaintyClass";
  }
  protected:
  explicit SdcSetClockUncertaintyClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjsFieldNumber = 3,
    kUncertaintyValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated uint64 _objs = 3;
  int _objs_size() const;
  private:
  int _internal__objs_size() const;
  public:
  void clear__objs();
  private:
  uint64_t _internal__objs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__objs() const;
  void _internal_add__objs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__objs();
  public:
  uint64_t _objs(int index) const;
  void set__objs(int index, uint64_t value);
  void add__objs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__objs();

  // required double _uncertainty_value = 2;
  bool has__uncertainty_value() const;
  private:
  bool _internal_has__uncertainty_value() const;
  public:
  void clear__uncertainty_value();
  double _uncertainty_value() const;
  void set__uncertainty_value(double value);
  private:
  double _internal__uncertainty_value() const;
  void _internal_set__uncertainty_value(double value);
  public:

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcSetClockUncertaintyClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _objs_;
    double _uncertainty_value_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcExceptionClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcExceptionClass) */ {
 public:
  inline SdcExceptionClass() : SdcExceptionClass(nullptr) {}
  ~SdcExceptionClass() override;
  explicit PROTOBUF_CONSTEXPR SdcExceptionClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcExceptionClass(const SdcExceptionClass& from);
  SdcExceptionClass(SdcExceptionClass&& from) noexcept
    : SdcExceptionClass() {
    *this = ::std::move(from);
  }

  inline SdcExceptionClass& operator=(const SdcExceptionClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcExceptionClass& operator=(SdcExceptionClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcExceptionClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcExceptionClass* internal_default_instance() {
    return reinterpret_cast<const SdcExceptionClass*>(
               &_SdcExceptionClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SdcExceptionClass& a, SdcExceptionClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcExceptionClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcExceptionClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcExceptionClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcExceptionClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcExceptionClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcExceptionClass& from) {
    SdcExceptionClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcExceptionClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcExceptionClass";
  }
  protected:
  explicit SdcExceptionClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropFromsFieldNumber = 1,
    kPropTosFieldNumber = 2,
    kPropThroughsFieldNumber = 3,
  };
  // repeated string _prop_froms = 1;
  int _prop_froms_size() const;
  private:
  int _internal__prop_froms_size() const;
  public:
  void clear__prop_froms();
  const std::string& _prop_froms(int index) const;
  std::string* mutable__prop_froms(int index);
  void set__prop_froms(int index, const std::string& value);
  void set__prop_froms(int index, std::string&& value);
  void set__prop_froms(int index, const char* value);
  void set__prop_froms(int index, const char* value, size_t size);
  std::string* add__prop_froms();
  void add__prop_froms(const std::string& value);
  void add__prop_froms(std::string&& value);
  void add__prop_froms(const char* value);
  void add__prop_froms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _prop_froms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable__prop_froms();
  private:
  const std::string& _internal__prop_froms(int index) const;
  std::string* _internal_add__prop_froms();
  public:

  // repeated string _prop_tos = 2;
  int _prop_tos_size() const;
  private:
  int _internal__prop_tos_size() const;
  public:
  void clear__prop_tos();
  const std::string& _prop_tos(int index) const;
  std::string* mutable__prop_tos(int index);
  void set__prop_tos(int index, const std::string& value);
  void set__prop_tos(int index, std::string&& value);
  void set__prop_tos(int index, const char* value);
  void set__prop_tos(int index, const char* value, size_t size);
  std::string* add__prop_tos();
  void add__prop_tos(const std::string& value);
  void add__prop_tos(std::string&& value);
  void add__prop_tos(const char* value);
  void add__prop_tos(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _prop_tos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable__prop_tos();
  private:
  const std::string& _internal__prop_tos(int index) const;
  std::string* _internal_add__prop_tos();
  public:

  // repeated .Common.Types.StringList _prop_throughs = 3;
  int _prop_throughs_size() const;
  private:
  int _internal__prop_throughs_size() const;
  public:
  void clear__prop_throughs();
  ::Common::Types::StringList* mutable__prop_throughs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StringList >*
      mutable__prop_throughs();
  private:
  const ::Common::Types::StringList& _internal__prop_throughs(int index) const;
  ::Common::Types::StringList* _internal_add__prop_throughs();
  public:
  const ::Common::Types::StringList& _prop_throughs(int index) const;
  ::Common::Types::StringList* add__prop_throughs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StringList >&
      _prop_throughs() const;

  // @@protoc_insertion_point(class_scope:Sdc.SdcExceptionClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> _prop_froms_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> _prop_tos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StringList > _prop_throughs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcMulticyclePathClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcMulticyclePathClass) */ {
 public:
  inline SdcMulticyclePathClass() : SdcMulticyclePathClass(nullptr) {}
  ~SdcMulticyclePathClass() override;
  explicit PROTOBUF_CONSTEXPR SdcMulticyclePathClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcMulticyclePathClass(const SdcMulticyclePathClass& from);
  SdcMulticyclePathClass(SdcMulticyclePathClass&& from) noexcept
    : SdcMulticyclePathClass() {
    *this = ::std::move(from);
  }

  inline SdcMulticyclePathClass& operator=(const SdcMulticyclePathClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcMulticyclePathClass& operator=(SdcMulticyclePathClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcMulticyclePathClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcMulticyclePathClass* internal_default_instance() {
    return reinterpret_cast<const SdcMulticyclePathClass*>(
               &_SdcMulticyclePathClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SdcMulticyclePathClass& a, SdcMulticyclePathClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcMulticyclePathClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcMulticyclePathClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcMulticyclePathClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcMulticyclePathClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcMulticyclePathClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcMulticyclePathClass& from) {
    SdcMulticyclePathClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcMulticyclePathClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcMulticyclePathClass";
  }
  protected:
  explicit SdcMulticyclePathClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathMultiplierFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // required int32 _path_multiplier = 1;
  bool has__path_multiplier() const;
  private:
  bool _internal_has__path_multiplier() const;
  public:
  void clear__path_multiplier();
  int32_t _path_multiplier() const;
  void set__path_multiplier(int32_t value);
  private:
  int32_t _internal__path_multiplier() const;
  void _internal_set__path_multiplier(int32_t value);
  public:

  // required uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcMulticyclePathClass)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t _path_multiplier_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcExceptionSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcExceptionSyn) */ {
 public:
  inline SdcExceptionSyn() : SdcExceptionSyn(nullptr) {}
  ~SdcExceptionSyn() override;
  explicit PROTOBUF_CONSTEXPR SdcExceptionSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcExceptionSyn(const SdcExceptionSyn& from);
  SdcExceptionSyn(SdcExceptionSyn&& from) noexcept
    : SdcExceptionSyn() {
    *this = ::std::move(from);
  }

  inline SdcExceptionSyn& operator=(const SdcExceptionSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcExceptionSyn& operator=(SdcExceptionSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcExceptionSyn& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcExceptionSyn* internal_default_instance() {
    return reinterpret_cast<const SdcExceptionSyn*>(
               &_SdcExceptionSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SdcExceptionSyn& a, SdcExceptionSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcExceptionSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcExceptionSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcExceptionSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcExceptionSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcExceptionSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcExceptionSyn& from) {
    SdcExceptionSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcExceptionSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcExceptionSyn";
  }
  protected:
  explicit SdcExceptionSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 2,
    kChildFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // required .Sdc.SdcExceptionClass parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Sdc::SdcExceptionClass& parent() const;
  PROTOBUF_NODISCARD ::Sdc::SdcExceptionClass* release_parent();
  ::Sdc::SdcExceptionClass* mutable_parent();
  void set_allocated_parent(::Sdc::SdcExceptionClass* parent);
  private:
  const ::Sdc::SdcExceptionClass& _internal_parent() const;
  ::Sdc::SdcExceptionClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Sdc::SdcExceptionClass* parent);
  ::Sdc::SdcExceptionClass* unsafe_arena_release_parent();

  // optional .Sdc.SdcMulticyclePathClass child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::Sdc::SdcMulticyclePathClass& child() const;
  PROTOBUF_NODISCARD ::Sdc::SdcMulticyclePathClass* release_child();
  ::Sdc::SdcMulticyclePathClass* mutable_child();
  void set_allocated_child(::Sdc::SdcMulticyclePathClass* child);
  private:
  const ::Sdc::SdcMulticyclePathClass& _internal_child() const;
  ::Sdc::SdcMulticyclePathClass* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::Sdc::SdcMulticyclePathClass* child);
  ::Sdc::SdcMulticyclePathClass* unsafe_arena_release_child();

  // required uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcExceptionSyn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Sdc::SdcExceptionClass* parent_;
    ::Sdc::SdcMulticyclePathClass* child_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcCommandObjSyn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcCommandObjSyn) */ {
 public:
  inline SdcCommandObjSyn() : SdcCommandObjSyn(nullptr) {}
  ~SdcCommandObjSyn() override;
  explicit PROTOBUF_CONSTEXPR SdcCommandObjSyn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcCommandObjSyn(const SdcCommandObjSyn& from);
  SdcCommandObjSyn(SdcCommandObjSyn&& from) noexcept
    : SdcCommandObjSyn() {
    *this = ::std::move(from);
  }

  inline SdcCommandObjSyn& operator=(const SdcCommandObjSyn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcCommandObjSyn& operator=(SdcCommandObjSyn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcCommandObjSyn& default_instance() {
    return *internal_default_instance();
  }
  enum ScosCase {
    kSiocs = 4,
    kScs = 5,
    kCacc = 6,
    kScgc = 7,
    kScc = 8,
    kStdc = 9,
    kStdrcs = 10,
    kSsclc = 11,
    kSscuc = 12,
    kSes = 13,
    SCOS_NOT_SET = 0,
  };

  static inline const SdcCommandObjSyn* internal_default_instance() {
    return reinterpret_cast<const SdcCommandObjSyn*>(
               &_SdcCommandObjSyn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SdcCommandObjSyn& a, SdcCommandObjSyn& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcCommandObjSyn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcCommandObjSyn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcCommandObjSyn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcCommandObjSyn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcCommandObjSyn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcCommandObjSyn& from) {
    SdcCommandObjSyn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcCommandObjSyn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcCommandObjSyn";
  }
  protected:
  explicit SdcCommandObjSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kSiocsFieldNumber = 4,
    kScsFieldNumber = 5,
    kCaccFieldNumber = 6,
    kScgcFieldNumber = 7,
    kSccFieldNumber = 8,
    kStdcFieldNumber = 9,
    kStdrcsFieldNumber = 10,
    kSsclcFieldNumber = 11,
    kSscucFieldNumber = 12,
    kSesFieldNumber = 13,
  };
  // required .Sdc.SdcCommandObjClass parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Sdc::SdcCommandObjClass& parent() const;
  PROTOBUF_NODISCARD ::Sdc::SdcCommandObjClass* release_parent();
  ::Sdc::SdcCommandObjClass* mutable_parent();
  void set_allocated_parent(::Sdc::SdcCommandObjClass* parent);
  private:
  const ::Sdc::SdcCommandObjClass& _internal_parent() const;
  ::Sdc::SdcCommandObjClass* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Sdc::SdcCommandObjClass* parent);
  ::Sdc::SdcCommandObjClass* unsafe_arena_release_parent();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // required uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .Sdc.SdcIOConstrainSyn siocs = 4;
  bool has_siocs() const;
  private:
  bool _internal_has_siocs() const;
  public:
  void clear_siocs();
  const ::Sdc::SdcIOConstrainSyn& siocs() const;
  PROTOBUF_NODISCARD ::Sdc::SdcIOConstrainSyn* release_siocs();
  ::Sdc::SdcIOConstrainSyn* mutable_siocs();
  void set_allocated_siocs(::Sdc::SdcIOConstrainSyn* siocs);
  private:
  const ::Sdc::SdcIOConstrainSyn& _internal_siocs() const;
  ::Sdc::SdcIOConstrainSyn* _internal_mutable_siocs();
  public:
  void unsafe_arena_set_allocated_siocs(
      ::Sdc::SdcIOConstrainSyn* siocs);
  ::Sdc::SdcIOConstrainSyn* unsafe_arena_release_siocs();

  // .Sdc.SdcClockSyn scs = 5;
  bool has_scs() const;
  private:
  bool _internal_has_scs() const;
  public:
  void clear_scs();
  const ::Sdc::SdcClockSyn& scs() const;
  PROTOBUF_NODISCARD ::Sdc::SdcClockSyn* release_scs();
  ::Sdc::SdcClockSyn* mutable_scs();
  void set_allocated_scs(::Sdc::SdcClockSyn* scs);
  private:
  const ::Sdc::SdcClockSyn& _internal_scs() const;
  ::Sdc::SdcClockSyn* _internal_mutable_scs();
  public:
  void unsafe_arena_set_allocated_scs(
      ::Sdc::SdcClockSyn* scs);
  ::Sdc::SdcClockSyn* unsafe_arena_release_scs();

  // .Sdc.SdcAllClocksClass cacc = 6;
  bool has_cacc() const;
  private:
  bool _internal_has_cacc() const;
  public:
  void clear_cacc();
  const ::Sdc::SdcAllClocksClass& cacc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcAllClocksClass* release_cacc();
  ::Sdc::SdcAllClocksClass* mutable_cacc();
  void set_allocated_cacc(::Sdc::SdcAllClocksClass* cacc);
  private:
  const ::Sdc::SdcAllClocksClass& _internal_cacc() const;
  ::Sdc::SdcAllClocksClass* _internal_mutable_cacc();
  public:
  void unsafe_arena_set_allocated_cacc(
      ::Sdc::SdcAllClocksClass* cacc);
  ::Sdc::SdcAllClocksClass* unsafe_arena_release_cacc();

  // .Sdc.SdcClockGroupsClass scgc = 7;
  bool has_scgc() const;
  private:
  bool _internal_has_scgc() const;
  public:
  void clear_scgc();
  const ::Sdc::SdcClockGroupsClass& scgc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcClockGroupsClass* release_scgc();
  ::Sdc::SdcClockGroupsClass* mutable_scgc();
  void set_allocated_scgc(::Sdc::SdcClockGroupsClass* scgc);
  private:
  const ::Sdc::SdcClockGroupsClass& _internal_scgc() const;
  ::Sdc::SdcClockGroupsClass* _internal_mutable_scgc();
  public:
  void unsafe_arena_set_allocated_scgc(
      ::Sdc::SdcClockGroupsClass* scgc);
  ::Sdc::SdcClockGroupsClass* unsafe_arena_release_scgc();

  // .Sdc.SdcCollectionClass scc = 8;
  bool has_scc() const;
  private:
  bool _internal_has_scc() const;
  public:
  void clear_scc();
  const ::Sdc::SdcCollectionClass& scc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcCollectionClass* release_scc();
  ::Sdc::SdcCollectionClass* mutable_scc();
  void set_allocated_scc(::Sdc::SdcCollectionClass* scc);
  private:
  const ::Sdc::SdcCollectionClass& _internal_scc() const;
  ::Sdc::SdcCollectionClass* _internal_mutable_scc();
  public:
  void unsafe_arena_set_allocated_scc(
      ::Sdc::SdcCollectionClass* scc);
  ::Sdc::SdcCollectionClass* unsafe_arena_release_scc();

  // .Sdc.SdcTimingDerateClass stdc = 9;
  bool has_stdc() const;
  private:
  bool _internal_has_stdc() const;
  public:
  void clear_stdc();
  const ::Sdc::SdcTimingDerateClass& stdc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcTimingDerateClass* release_stdc();
  ::Sdc::SdcTimingDerateClass* mutable_stdc();
  void set_allocated_stdc(::Sdc::SdcTimingDerateClass* stdc);
  private:
  const ::Sdc::SdcTimingDerateClass& _internal_stdc() const;
  ::Sdc::SdcTimingDerateClass* _internal_mutable_stdc();
  public:
  void unsafe_arena_set_allocated_stdc(
      ::Sdc::SdcTimingDerateClass* stdc);
  ::Sdc::SdcTimingDerateClass* unsafe_arena_release_stdc();

  // .Sdc.SdcTimingDRCSyn stdrcs = 10;
  bool has_stdrcs() const;
  private:
  bool _internal_has_stdrcs() const;
  public:
  void clear_stdrcs();
  const ::Sdc::SdcTimingDRCSyn& stdrcs() const;
  PROTOBUF_NODISCARD ::Sdc::SdcTimingDRCSyn* release_stdrcs();
  ::Sdc::SdcTimingDRCSyn* mutable_stdrcs();
  void set_allocated_stdrcs(::Sdc::SdcTimingDRCSyn* stdrcs);
  private:
  const ::Sdc::SdcTimingDRCSyn& _internal_stdrcs() const;
  ::Sdc::SdcTimingDRCSyn* _internal_mutable_stdrcs();
  public:
  void unsafe_arena_set_allocated_stdrcs(
      ::Sdc::SdcTimingDRCSyn* stdrcs);
  ::Sdc::SdcTimingDRCSyn* unsafe_arena_release_stdrcs();

  // .Sdc.SdcSetClockLatencyClass ssclc = 11;
  bool has_ssclc() const;
  private:
  bool _internal_has_ssclc() const;
  public:
  void clear_ssclc();
  const ::Sdc::SdcSetClockLatencyClass& ssclc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcSetClockLatencyClass* release_ssclc();
  ::Sdc::SdcSetClockLatencyClass* mutable_ssclc();
  void set_allocated_ssclc(::Sdc::SdcSetClockLatencyClass* ssclc);
  private:
  const ::Sdc::SdcSetClockLatencyClass& _internal_ssclc() const;
  ::Sdc::SdcSetClockLatencyClass* _internal_mutable_ssclc();
  public:
  void unsafe_arena_set_allocated_ssclc(
      ::Sdc::SdcSetClockLatencyClass* ssclc);
  ::Sdc::SdcSetClockLatencyClass* unsafe_arena_release_ssclc();

  // .Sdc.SdcSetClockUncertaintyClass sscuc = 12;
  bool has_sscuc() const;
  private:
  bool _internal_has_sscuc() const;
  public:
  void clear_sscuc();
  const ::Sdc::SdcSetClockUncertaintyClass& sscuc() const;
  PROTOBUF_NODISCARD ::Sdc::SdcSetClockUncertaintyClass* release_sscuc();
  ::Sdc::SdcSetClockUncertaintyClass* mutable_sscuc();
  void set_allocated_sscuc(::Sdc::SdcSetClockUncertaintyClass* sscuc);
  private:
  const ::Sdc::SdcSetClockUncertaintyClass& _internal_sscuc() const;
  ::Sdc::SdcSetClockUncertaintyClass* _internal_mutable_sscuc();
  public:
  void unsafe_arena_set_allocated_sscuc(
      ::Sdc::SdcSetClockUncertaintyClass* sscuc);
  ::Sdc::SdcSetClockUncertaintyClass* unsafe_arena_release_sscuc();

  // .Sdc.SdcExceptionSyn ses = 13;
  bool has_ses() const;
  private:
  bool _internal_has_ses() const;
  public:
  void clear_ses();
  const ::Sdc::SdcExceptionSyn& ses() const;
  PROTOBUF_NODISCARD ::Sdc::SdcExceptionSyn* release_ses();
  ::Sdc::SdcExceptionSyn* mutable_ses();
  void set_allocated_ses(::Sdc::SdcExceptionSyn* ses);
  private:
  const ::Sdc::SdcExceptionSyn& _internal_ses() const;
  ::Sdc::SdcExceptionSyn* _internal_mutable_ses();
  public:
  void unsafe_arena_set_allocated_ses(
      ::Sdc::SdcExceptionSyn* ses);
  ::Sdc::SdcExceptionSyn* unsafe_arena_release_ses();

  void clear_scos();
  ScosCase scos_case() const;
  // @@protoc_insertion_point(class_scope:Sdc.SdcCommandObjSyn)
 private:
  class _Internal;
  void set_has_siocs();
  void set_has_scs();
  void set_has_cacc();
  void set_has_scgc();
  void set_has_scc();
  void set_has_stdc();
  void set_has_stdrcs();
  void set_has_ssclc();
  void set_has_sscuc();
  void set_has_ses();

  inline bool has_scos() const;
  inline void clear_has_scos();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Sdc::SdcCommandObjClass* parent_;
    uint64_t id_;
    uint32_t type_;
    union ScosUnion {
      constexpr ScosUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Sdc::SdcIOConstrainSyn* siocs_;
      ::Sdc::SdcClockSyn* scs_;
      ::Sdc::SdcAllClocksClass* cacc_;
      ::Sdc::SdcClockGroupsClass* scgc_;
      ::Sdc::SdcCollectionClass* scc_;
      ::Sdc::SdcTimingDerateClass* stdc_;
      ::Sdc::SdcTimingDRCSyn* stdrcs_;
      ::Sdc::SdcSetClockLatencyClass* ssclc_;
      ::Sdc::SdcSetClockUncertaintyClass* sscuc_;
      ::Sdc::SdcExceptionSyn* ses_;
    } scos_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// -------------------------------------------------------------------

class SdcConstrainClass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Sdc.SdcConstrainClass) */ {
 public:
  inline SdcConstrainClass() : SdcConstrainClass(nullptr) {}
  ~SdcConstrainClass() override;
  explicit PROTOBUF_CONSTEXPR SdcConstrainClass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdcConstrainClass(const SdcConstrainClass& from);
  SdcConstrainClass(SdcConstrainClass&& from) noexcept
    : SdcConstrainClass() {
    *this = ::std::move(from);
  }

  inline SdcConstrainClass& operator=(const SdcConstrainClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdcConstrainClass& operator=(SdcConstrainClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdcConstrainClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdcConstrainClass* internal_default_instance() {
    return reinterpret_cast<const SdcConstrainClass*>(
               &_SdcConstrainClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SdcConstrainClass& a, SdcConstrainClass& b) {
    a.Swap(&b);
  }
  inline void Swap(SdcConstrainClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdcConstrainClass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdcConstrainClass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdcConstrainClass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdcConstrainClass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdcConstrainClass& from) {
    SdcConstrainClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdcConstrainClass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Sdc.SdcConstrainClass";
  }
  protected:
  explicit SdcConstrainClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdcClocksFieldNumber = 2,
    kSdcIoConstraintsFieldNumber = 3,
    kSdcTimingDeratesFieldNumber = 4,
    kSdcTimingDrcsFieldNumber = 5,
    kSdcClockLatencysFieldNumber = 6,
    kSdcClockUncertaintysFieldNumber = 7,
    kSdcClockGroupsFieldNumber = 8,
    kSdcExceptionsFieldNumber = 9,
    kSdcCollectionsFieldNumber = 10,
    kIdFieldNumber = 1,
  };
  // repeated .Common.Types.StrULongMap _sdc_clocks = 2;
  int _sdc_clocks_size() const;
  private:
  int _internal__sdc_clocks_size() const;
  public:
  void clear__sdc_clocks();
  ::Common::Types::StrULongMap* mutable__sdc_clocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StrULongMap >*
      mutable__sdc_clocks();
  private:
  const ::Common::Types::StrULongMap& _internal__sdc_clocks(int index) const;
  ::Common::Types::StrULongMap* _internal_add__sdc_clocks();
  public:
  const ::Common::Types::StrULongMap& _sdc_clocks(int index) const;
  ::Common::Types::StrULongMap* add__sdc_clocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StrULongMap >&
      _sdc_clocks() const;

  // repeated uint64 _sdc_io_constraints = 3;
  int _sdc_io_constraints_size() const;
  private:
  int _internal__sdc_io_constraints_size() const;
  public:
  void clear__sdc_io_constraints();
  private:
  uint64_t _internal__sdc_io_constraints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_io_constraints() const;
  void _internal_add__sdc_io_constraints(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_io_constraints();
  public:
  uint64_t _sdc_io_constraints(int index) const;
  void set__sdc_io_constraints(int index, uint64_t value);
  void add__sdc_io_constraints(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_io_constraints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_io_constraints();

  // repeated uint64 _sdc_timing_derates = 4;
  int _sdc_timing_derates_size() const;
  private:
  int _internal__sdc_timing_derates_size() const;
  public:
  void clear__sdc_timing_derates();
  private:
  uint64_t _internal__sdc_timing_derates(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_timing_derates() const;
  void _internal_add__sdc_timing_derates(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_timing_derates();
  public:
  uint64_t _sdc_timing_derates(int index) const;
  void set__sdc_timing_derates(int index, uint64_t value);
  void add__sdc_timing_derates(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_timing_derates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_timing_derates();

  // repeated uint64 _sdc_timing_drcs = 5;
  int _sdc_timing_drcs_size() const;
  private:
  int _internal__sdc_timing_drcs_size() const;
  public:
  void clear__sdc_timing_drcs();
  private:
  uint64_t _internal__sdc_timing_drcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_timing_drcs() const;
  void _internal_add__sdc_timing_drcs(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_timing_drcs();
  public:
  uint64_t _sdc_timing_drcs(int index) const;
  void set__sdc_timing_drcs(int index, uint64_t value);
  void add__sdc_timing_drcs(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_timing_drcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_timing_drcs();

  // repeated uint64 _sdc_clock_latencys = 6;
  int _sdc_clock_latencys_size() const;
  private:
  int _internal__sdc_clock_latencys_size() const;
  public:
  void clear__sdc_clock_latencys();
  private:
  uint64_t _internal__sdc_clock_latencys(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_clock_latencys() const;
  void _internal_add__sdc_clock_latencys(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_clock_latencys();
  public:
  uint64_t _sdc_clock_latencys(int index) const;
  void set__sdc_clock_latencys(int index, uint64_t value);
  void add__sdc_clock_latencys(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_clock_latencys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_clock_latencys();

  // repeated uint64 _sdc_clock_uncertaintys = 7;
  int _sdc_clock_uncertaintys_size() const;
  private:
  int _internal__sdc_clock_uncertaintys_size() const;
  public:
  void clear__sdc_clock_uncertaintys();
  private:
  uint64_t _internal__sdc_clock_uncertaintys(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_clock_uncertaintys() const;
  void _internal_add__sdc_clock_uncertaintys(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_clock_uncertaintys();
  public:
  uint64_t _sdc_clock_uncertaintys(int index) const;
  void set__sdc_clock_uncertaintys(int index, uint64_t value);
  void add__sdc_clock_uncertaintys(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_clock_uncertaintys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_clock_uncertaintys();

  // repeated uint64 _sdc_clock_groups = 8;
  int _sdc_clock_groups_size() const;
  private:
  int _internal__sdc_clock_groups_size() const;
  public:
  void clear__sdc_clock_groups();
  private:
  uint64_t _internal__sdc_clock_groups(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_clock_groups() const;
  void _internal_add__sdc_clock_groups(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_clock_groups();
  public:
  uint64_t _sdc_clock_groups(int index) const;
  void set__sdc_clock_groups(int index, uint64_t value);
  void add__sdc_clock_groups(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_clock_groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_clock_groups();

  // repeated uint64 _sdc_exceptions = 9;
  int _sdc_exceptions_size() const;
  private:
  int _internal__sdc_exceptions_size() const;
  public:
  void clear__sdc_exceptions();
  private:
  uint64_t _internal__sdc_exceptions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_exceptions() const;
  void _internal_add__sdc_exceptions(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_exceptions();
  public:
  uint64_t _sdc_exceptions(int index) const;
  void set__sdc_exceptions(int index, uint64_t value);
  void add__sdc_exceptions(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_exceptions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_exceptions();

  // repeated uint64 _sdc_collections = 10;
  int _sdc_collections_size() const;
  private:
  int _internal__sdc_collections_size() const;
  public:
  void clear__sdc_collections();
  private:
  uint64_t _internal__sdc_collections(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal__sdc_collections() const;
  void _internal_add__sdc_collections(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable__sdc_collections();
  public:
  uint64_t _sdc_collections(int index) const;
  void set__sdc_collections(int index, uint64_t value);
  void add__sdc_collections(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _sdc_collections() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable__sdc_collections();

  // required uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Sdc.SdcConstrainClass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StrULongMap > _sdc_clocks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_io_constraints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_timing_derates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_timing_drcs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_clock_latencys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_clock_uncertaintys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_clock_groups_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_exceptions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > _sdc_collections_;
    uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SdcConstrains_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SdcCommandObjClass

// required string _file_name = 1;
inline bool SdcCommandObjClass::_internal_has__file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcCommandObjClass::has__file_name() const {
  return _internal_has__file_name();
}
inline void SdcCommandObjClass::clear__file_name() {
  _impl_._file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SdcCommandObjClass::_file_name() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjClass._file_name)
  return _internal__file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SdcCommandObjClass::set__file_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sdc.SdcCommandObjClass._file_name)
}
inline std::string* SdcCommandObjClass::mutable__file_name() {
  std::string* _s = _internal_mutable__file_name();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjClass._file_name)
  return _s;
}
inline const std::string& SdcCommandObjClass::_internal__file_name() const {
  return _impl_._file_name_.Get();
}
inline void SdcCommandObjClass::_internal_set__file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SdcCommandObjClass::_internal_mutable__file_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SdcCommandObjClass::release__file_name() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjClass._file_name)
  if (!_internal_has__file_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SdcCommandObjClass::set_allocated__file_name(std::string* _file_name) {
  if (_file_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._file_name_.SetAllocated(_file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._file_name_.IsDefault()) {
    _impl_._file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjClass._file_name)
}

// required uint32 _line_no = 2;
inline bool SdcCommandObjClass::_internal_has__line_no() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcCommandObjClass::has__line_no() const {
  return _internal_has__line_no();
}
inline void SdcCommandObjClass::clear__line_no() {
  _impl_._line_no_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcCommandObjClass::_internal__line_no() const {
  return _impl_._line_no_;
}
inline uint32_t SdcCommandObjClass::_line_no() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjClass._line_no)
  return _internal__line_no();
}
inline void SdcCommandObjClass::_internal_set__line_no(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._line_no_ = value;
}
inline void SdcCommandObjClass::set__line_no(uint32_t value) {
  _internal_set__line_no(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcCommandObjClass._line_no)
}

// -------------------------------------------------------------------

// SdcIOConstrainClass

// required string _constrain_name = 1;
inline bool SdcIOConstrainClass::_internal_has__constrain_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcIOConstrainClass::has__constrain_name() const {
  return _internal_has__constrain_name();
}
inline void SdcIOConstrainClass::clear__constrain_name() {
  _impl_._constrain_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SdcIOConstrainClass::_constrain_name() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcIOConstrainClass._constrain_name)
  return _internal__constrain_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SdcIOConstrainClass::set__constrain_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._constrain_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sdc.SdcIOConstrainClass._constrain_name)
}
inline std::string* SdcIOConstrainClass::mutable__constrain_name() {
  std::string* _s = _internal_mutable__constrain_name();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcIOConstrainClass._constrain_name)
  return _s;
}
inline const std::string& SdcIOConstrainClass::_internal__constrain_name() const {
  return _impl_._constrain_name_.Get();
}
inline void SdcIOConstrainClass::_internal_set__constrain_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._constrain_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SdcIOConstrainClass::_internal_mutable__constrain_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._constrain_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SdcIOConstrainClass::release__constrain_name() {
  // @@protoc_insertion_point(field_release:Sdc.SdcIOConstrainClass._constrain_name)
  if (!_internal_has__constrain_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._constrain_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._constrain_name_.IsDefault()) {
    _impl_._constrain_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SdcIOConstrainClass::set_allocated__constrain_name(std::string* _constrain_name) {
  if (_constrain_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._constrain_name_.SetAllocated(_constrain_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._constrain_name_.IsDefault()) {
    _impl_._constrain_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcIOConstrainClass._constrain_name)
}

// -------------------------------------------------------------------

// SdcSetInputTransitionClass

// required uint32 type = 1;
inline bool SdcSetInputTransitionClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcSetInputTransitionClass::has_type() const {
  return _internal_has_type();
}
inline void SdcSetInputTransitionClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcSetInputTransitionClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcSetInputTransitionClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetInputTransitionClass.type)
  return _internal_type();
}
inline void SdcSetInputTransitionClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcSetInputTransitionClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetInputTransitionClass.type)
}

// repeated uint64 _objs = 2;
inline int SdcSetInputTransitionClass::_internal__objs_size() const {
  return _impl_._objs_.size();
}
inline int SdcSetInputTransitionClass::_objs_size() const {
  return _internal__objs_size();
}
inline void SdcSetInputTransitionClass::clear__objs() {
  _impl_._objs_.Clear();
}
inline uint64_t SdcSetInputTransitionClass::_internal__objs(int index) const {
  return _impl_._objs_.Get(index);
}
inline uint64_t SdcSetInputTransitionClass::_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetInputTransitionClass._objs)
  return _internal__objs(index);
}
inline void SdcSetInputTransitionClass::set__objs(int index, uint64_t value) {
  _impl_._objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetInputTransitionClass._objs)
}
inline void SdcSetInputTransitionClass::_internal_add__objs(uint64_t value) {
  _impl_._objs_.Add(value);
}
inline void SdcSetInputTransitionClass::add__objs(uint64_t value) {
  _internal_add__objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcSetInputTransitionClass._objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetInputTransitionClass::_internal__objs() const {
  return _impl_._objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetInputTransitionClass::_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcSetInputTransitionClass._objs)
  return _internal__objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetInputTransitionClass::_internal_mutable__objs() {
  return &_impl_._objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetInputTransitionClass::mutable__objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcSetInputTransitionClass._objs)
  return _internal_mutable__objs();
}

// required double _transition_value = 3;
inline bool SdcSetInputTransitionClass::_internal_has__transition_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcSetInputTransitionClass::has__transition_value() const {
  return _internal_has__transition_value();
}
inline void SdcSetInputTransitionClass::clear__transition_value() {
  _impl_._transition_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SdcSetInputTransitionClass::_internal__transition_value() const {
  return _impl_._transition_value_;
}
inline double SdcSetInputTransitionClass::_transition_value() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetInputTransitionClass._transition_value)
  return _internal__transition_value();
}
inline void SdcSetInputTransitionClass::_internal_set__transition_value(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._transition_value_ = value;
}
inline void SdcSetInputTransitionClass::set__transition_value(double value) {
  _internal_set__transition_value(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetInputTransitionClass._transition_value)
}

// -------------------------------------------------------------------

// SdcSetIODelayClass

// required uint32 type = 1;
inline bool SdcSetIODelayClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SdcSetIODelayClass::has_type() const {
  return _internal_has_type();
}
inline void SdcSetIODelayClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SdcSetIODelayClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcSetIODelayClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetIODelayClass.type)
  return _internal_type();
}
inline void SdcSetIODelayClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void SdcSetIODelayClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetIODelayClass.type)
}

// required string _clock_name = 2;
inline bool SdcSetIODelayClass::_internal_has__clock_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcSetIODelayClass::has__clock_name() const {
  return _internal_has__clock_name();
}
inline void SdcSetIODelayClass::clear__clock_name() {
  _impl_._clock_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SdcSetIODelayClass::_clock_name() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetIODelayClass._clock_name)
  return _internal__clock_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SdcSetIODelayClass::set__clock_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._clock_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sdc.SdcSetIODelayClass._clock_name)
}
inline std::string* SdcSetIODelayClass::mutable__clock_name() {
  std::string* _s = _internal_mutable__clock_name();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcSetIODelayClass._clock_name)
  return _s;
}
inline const std::string& SdcSetIODelayClass::_internal__clock_name() const {
  return _impl_._clock_name_.Get();
}
inline void SdcSetIODelayClass::_internal_set__clock_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._clock_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SdcSetIODelayClass::_internal_mutable__clock_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._clock_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SdcSetIODelayClass::release__clock_name() {
  // @@protoc_insertion_point(field_release:Sdc.SdcSetIODelayClass._clock_name)
  if (!_internal_has__clock_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._clock_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._clock_name_.IsDefault()) {
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SdcSetIODelayClass::set_allocated__clock_name(std::string* _clock_name) {
  if (_clock_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._clock_name_.SetAllocated(_clock_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._clock_name_.IsDefault()) {
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcSetIODelayClass._clock_name)
}

// required double _delay_value = 3;
inline bool SdcSetIODelayClass::_internal_has__delay_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcSetIODelayClass::has__delay_value() const {
  return _internal_has__delay_value();
}
inline void SdcSetIODelayClass::clear__delay_value() {
  _impl_._delay_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double SdcSetIODelayClass::_internal__delay_value() const {
  return _impl_._delay_value_;
}
inline double SdcSetIODelayClass::_delay_value() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetIODelayClass._delay_value)
  return _internal__delay_value();
}
inline void SdcSetIODelayClass::_internal_set__delay_value(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._delay_value_ = value;
}
inline void SdcSetIODelayClass::set__delay_value(double value) {
  _internal_set__delay_value(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetIODelayClass._delay_value)
}

// repeated uint64 _objs = 4;
inline int SdcSetIODelayClass::_internal__objs_size() const {
  return _impl_._objs_.size();
}
inline int SdcSetIODelayClass::_objs_size() const {
  return _internal__objs_size();
}
inline void SdcSetIODelayClass::clear__objs() {
  _impl_._objs_.Clear();
}
inline uint64_t SdcSetIODelayClass::_internal__objs(int index) const {
  return _impl_._objs_.Get(index);
}
inline uint64_t SdcSetIODelayClass::_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetIODelayClass._objs)
  return _internal__objs(index);
}
inline void SdcSetIODelayClass::set__objs(int index, uint64_t value) {
  _impl_._objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetIODelayClass._objs)
}
inline void SdcSetIODelayClass::_internal_add__objs(uint64_t value) {
  _impl_._objs_.Add(value);
}
inline void SdcSetIODelayClass::add__objs(uint64_t value) {
  _internal_add__objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcSetIODelayClass._objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetIODelayClass::_internal__objs() const {
  return _impl_._objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetIODelayClass::_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcSetIODelayClass._objs)
  return _internal__objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetIODelayClass::_internal_mutable__objs() {
  return &_impl_._objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetIODelayClass::mutable__objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcSetIODelayClass._objs)
  return _internal_mutable__objs();
}

// -------------------------------------------------------------------

// SdcSetLoadClass

// required uint32 type = 1;
inline bool SdcSetLoadClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcSetLoadClass::has_type() const {
  return _internal_has_type();
}
inline void SdcSetLoadClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcSetLoadClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcSetLoadClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetLoadClass.type)
  return _internal_type();
}
inline void SdcSetLoadClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcSetLoadClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetLoadClass.type)
}

// repeated uint64 _objs = 2;
inline int SdcSetLoadClass::_internal__objs_size() const {
  return _impl_._objs_.size();
}
inline int SdcSetLoadClass::_objs_size() const {
  return _internal__objs_size();
}
inline void SdcSetLoadClass::clear__objs() {
  _impl_._objs_.Clear();
}
inline uint64_t SdcSetLoadClass::_internal__objs(int index) const {
  return _impl_._objs_.Get(index);
}
inline uint64_t SdcSetLoadClass::_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetLoadClass._objs)
  return _internal__objs(index);
}
inline void SdcSetLoadClass::set__objs(int index, uint64_t value) {
  _impl_._objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetLoadClass._objs)
}
inline void SdcSetLoadClass::_internal_add__objs(uint64_t value) {
  _impl_._objs_.Add(value);
}
inline void SdcSetLoadClass::add__objs(uint64_t value) {
  _internal_add__objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcSetLoadClass._objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetLoadClass::_internal__objs() const {
  return _impl_._objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetLoadClass::_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcSetLoadClass._objs)
  return _internal__objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetLoadClass::_internal_mutable__objs() {
  return &_impl_._objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetLoadClass::mutable__objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcSetLoadClass._objs)
  return _internal_mutable__objs();
}

// required double _load_value = 3;
inline bool SdcSetLoadClass::_internal_has__load_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcSetLoadClass::has__load_value() const {
  return _internal_has__load_value();
}
inline void SdcSetLoadClass::clear__load_value() {
  _impl_._load_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SdcSetLoadClass::_internal__load_value() const {
  return _impl_._load_value_;
}
inline double SdcSetLoadClass::_load_value() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetLoadClass._load_value)
  return _internal__load_value();
}
inline void SdcSetLoadClass::_internal_set__load_value(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._load_value_ = value;
}
inline void SdcSetLoadClass::set__load_value(double value) {
  _internal_set__load_value(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetLoadClass._load_value)
}

// -------------------------------------------------------------------

// SdcIOConstrainSyn

// required uint32 type = 1;
inline bool SdcIOConstrainSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcIOConstrainSyn::has_type() const {
  return _internal_has_type();
}
inline void SdcIOConstrainSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcIOConstrainSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcIOConstrainSyn::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcIOConstrainSyn.type)
  return _internal_type();
}
inline void SdcIOConstrainSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcIOConstrainSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcIOConstrainSyn.type)
}

// required .Sdc.SdcIOConstrainClass parent = 2;
inline bool SdcIOConstrainSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool SdcIOConstrainSyn::has_parent() const {
  return _internal_has_parent();
}
inline void SdcIOConstrainSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Sdc::SdcIOConstrainClass& SdcIOConstrainSyn::_internal_parent() const {
  const ::Sdc::SdcIOConstrainClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcIOConstrainClass&>(
      ::Sdc::_SdcIOConstrainClass_default_instance_);
}
inline const ::Sdc::SdcIOConstrainClass& SdcIOConstrainSyn::parent() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcIOConstrainSyn.parent)
  return _internal_parent();
}
inline void SdcIOConstrainSyn::unsafe_arena_set_allocated_parent(
    ::Sdc::SdcIOConstrainClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcIOConstrainSyn.parent)
}
inline ::Sdc::SdcIOConstrainClass* SdcIOConstrainSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcIOConstrainClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcIOConstrainClass* SdcIOConstrainSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Sdc.SdcIOConstrainSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcIOConstrainClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Sdc::SdcIOConstrainClass* SdcIOConstrainSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcIOConstrainClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Sdc::SdcIOConstrainClass* SdcIOConstrainSyn::mutable_parent() {
  ::Sdc::SdcIOConstrainClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcIOConstrainSyn.parent)
  return _msg;
}
inline void SdcIOConstrainSyn::set_allocated_parent(::Sdc::SdcIOConstrainClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcIOConstrainSyn.parent)
}

// .Sdc.SdcSetInputTransitionClass ssitc = 3;
inline bool SdcIOConstrainSyn::_internal_has_ssitc() const {
  return siocs_case() == kSsitc;
}
inline bool SdcIOConstrainSyn::has_ssitc() const {
  return _internal_has_ssitc();
}
inline void SdcIOConstrainSyn::set_has_ssitc() {
  _impl_._oneof_case_[0] = kSsitc;
}
inline void SdcIOConstrainSyn::clear_ssitc() {
  if (_internal_has_ssitc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.siocs_.ssitc_;
    }
    clear_has_siocs();
  }
}
inline ::Sdc::SdcSetInputTransitionClass* SdcIOConstrainSyn::release_ssitc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcIOConstrainSyn.ssitc)
  if (_internal_has_ssitc()) {
    clear_has_siocs();
    ::Sdc::SdcSetInputTransitionClass* temp = _impl_.siocs_.ssitc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.siocs_.ssitc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcSetInputTransitionClass& SdcIOConstrainSyn::_internal_ssitc() const {
  return _internal_has_ssitc()
      ? *_impl_.siocs_.ssitc_
      : reinterpret_cast< ::Sdc::SdcSetInputTransitionClass&>(::Sdc::_SdcSetInputTransitionClass_default_instance_);
}
inline const ::Sdc::SdcSetInputTransitionClass& SdcIOConstrainSyn::ssitc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcIOConstrainSyn.ssitc)
  return _internal_ssitc();
}
inline ::Sdc::SdcSetInputTransitionClass* SdcIOConstrainSyn::unsafe_arena_release_ssitc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcIOConstrainSyn.ssitc)
  if (_internal_has_ssitc()) {
    clear_has_siocs();
    ::Sdc::SdcSetInputTransitionClass* temp = _impl_.siocs_.ssitc_;
    _impl_.siocs_.ssitc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcIOConstrainSyn::unsafe_arena_set_allocated_ssitc(::Sdc::SdcSetInputTransitionClass* ssitc) {
  clear_siocs();
  if (ssitc) {
    set_has_ssitc();
    _impl_.siocs_.ssitc_ = ssitc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcIOConstrainSyn.ssitc)
}
inline ::Sdc::SdcSetInputTransitionClass* SdcIOConstrainSyn::_internal_mutable_ssitc() {
  if (!_internal_has_ssitc()) {
    clear_siocs();
    set_has_ssitc();
    _impl_.siocs_.ssitc_ = CreateMaybeMessage< ::Sdc::SdcSetInputTransitionClass >(GetArenaForAllocation());
  }
  return _impl_.siocs_.ssitc_;
}
inline ::Sdc::SdcSetInputTransitionClass* SdcIOConstrainSyn::mutable_ssitc() {
  ::Sdc::SdcSetInputTransitionClass* _msg = _internal_mutable_ssitc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcIOConstrainSyn.ssitc)
  return _msg;
}

// .Sdc.SdcSetIODelayClass ssiodc = 4;
inline bool SdcIOConstrainSyn::_internal_has_ssiodc() const {
  return siocs_case() == kSsiodc;
}
inline bool SdcIOConstrainSyn::has_ssiodc() const {
  return _internal_has_ssiodc();
}
inline void SdcIOConstrainSyn::set_has_ssiodc() {
  _impl_._oneof_case_[0] = kSsiodc;
}
inline void SdcIOConstrainSyn::clear_ssiodc() {
  if (_internal_has_ssiodc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.siocs_.ssiodc_;
    }
    clear_has_siocs();
  }
}
inline ::Sdc::SdcSetIODelayClass* SdcIOConstrainSyn::release_ssiodc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcIOConstrainSyn.ssiodc)
  if (_internal_has_ssiodc()) {
    clear_has_siocs();
    ::Sdc::SdcSetIODelayClass* temp = _impl_.siocs_.ssiodc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.siocs_.ssiodc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcSetIODelayClass& SdcIOConstrainSyn::_internal_ssiodc() const {
  return _internal_has_ssiodc()
      ? *_impl_.siocs_.ssiodc_
      : reinterpret_cast< ::Sdc::SdcSetIODelayClass&>(::Sdc::_SdcSetIODelayClass_default_instance_);
}
inline const ::Sdc::SdcSetIODelayClass& SdcIOConstrainSyn::ssiodc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcIOConstrainSyn.ssiodc)
  return _internal_ssiodc();
}
inline ::Sdc::SdcSetIODelayClass* SdcIOConstrainSyn::unsafe_arena_release_ssiodc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcIOConstrainSyn.ssiodc)
  if (_internal_has_ssiodc()) {
    clear_has_siocs();
    ::Sdc::SdcSetIODelayClass* temp = _impl_.siocs_.ssiodc_;
    _impl_.siocs_.ssiodc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcIOConstrainSyn::unsafe_arena_set_allocated_ssiodc(::Sdc::SdcSetIODelayClass* ssiodc) {
  clear_siocs();
  if (ssiodc) {
    set_has_ssiodc();
    _impl_.siocs_.ssiodc_ = ssiodc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcIOConstrainSyn.ssiodc)
}
inline ::Sdc::SdcSetIODelayClass* SdcIOConstrainSyn::_internal_mutable_ssiodc() {
  if (!_internal_has_ssiodc()) {
    clear_siocs();
    set_has_ssiodc();
    _impl_.siocs_.ssiodc_ = CreateMaybeMessage< ::Sdc::SdcSetIODelayClass >(GetArenaForAllocation());
  }
  return _impl_.siocs_.ssiodc_;
}
inline ::Sdc::SdcSetIODelayClass* SdcIOConstrainSyn::mutable_ssiodc() {
  ::Sdc::SdcSetIODelayClass* _msg = _internal_mutable_ssiodc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcIOConstrainSyn.ssiodc)
  return _msg;
}

// .Sdc.SdcSetLoadClass sslc = 5;
inline bool SdcIOConstrainSyn::_internal_has_sslc() const {
  return siocs_case() == kSslc;
}
inline bool SdcIOConstrainSyn::has_sslc() const {
  return _internal_has_sslc();
}
inline void SdcIOConstrainSyn::set_has_sslc() {
  _impl_._oneof_case_[0] = kSslc;
}
inline void SdcIOConstrainSyn::clear_sslc() {
  if (_internal_has_sslc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.siocs_.sslc_;
    }
    clear_has_siocs();
  }
}
inline ::Sdc::SdcSetLoadClass* SdcIOConstrainSyn::release_sslc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcIOConstrainSyn.sslc)
  if (_internal_has_sslc()) {
    clear_has_siocs();
    ::Sdc::SdcSetLoadClass* temp = _impl_.siocs_.sslc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.siocs_.sslc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcSetLoadClass& SdcIOConstrainSyn::_internal_sslc() const {
  return _internal_has_sslc()
      ? *_impl_.siocs_.sslc_
      : reinterpret_cast< ::Sdc::SdcSetLoadClass&>(::Sdc::_SdcSetLoadClass_default_instance_);
}
inline const ::Sdc::SdcSetLoadClass& SdcIOConstrainSyn::sslc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcIOConstrainSyn.sslc)
  return _internal_sslc();
}
inline ::Sdc::SdcSetLoadClass* SdcIOConstrainSyn::unsafe_arena_release_sslc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcIOConstrainSyn.sslc)
  if (_internal_has_sslc()) {
    clear_has_siocs();
    ::Sdc::SdcSetLoadClass* temp = _impl_.siocs_.sslc_;
    _impl_.siocs_.sslc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcIOConstrainSyn::unsafe_arena_set_allocated_sslc(::Sdc::SdcSetLoadClass* sslc) {
  clear_siocs();
  if (sslc) {
    set_has_sslc();
    _impl_.siocs_.sslc_ = sslc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcIOConstrainSyn.sslc)
}
inline ::Sdc::SdcSetLoadClass* SdcIOConstrainSyn::_internal_mutable_sslc() {
  if (!_internal_has_sslc()) {
    clear_siocs();
    set_has_sslc();
    _impl_.siocs_.sslc_ = CreateMaybeMessage< ::Sdc::SdcSetLoadClass >(GetArenaForAllocation());
  }
  return _impl_.siocs_.sslc_;
}
inline ::Sdc::SdcSetLoadClass* SdcIOConstrainSyn::mutable_sslc() {
  ::Sdc::SdcSetLoadClass* _msg = _internal_mutable_sslc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcIOConstrainSyn.sslc)
  return _msg;
}

inline bool SdcIOConstrainSyn::has_siocs() const {
  return siocs_case() != SIOCS_NOT_SET;
}
inline void SdcIOConstrainSyn::clear_has_siocs() {
  _impl_._oneof_case_[0] = SIOCS_NOT_SET;
}
inline SdcIOConstrainSyn::SiocsCase SdcIOConstrainSyn::siocs_case() const {
  return SdcIOConstrainSyn::SiocsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SdcClockClass

// required string _clock_name = 1;
inline bool SdcClockClass::_internal_has__clock_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcClockClass::has__clock_name() const {
  return _internal_has__clock_name();
}
inline void SdcClockClass::clear__clock_name() {
  _impl_._clock_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SdcClockClass::_clock_name() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockClass._clock_name)
  return _internal__clock_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SdcClockClass::set__clock_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._clock_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sdc.SdcClockClass._clock_name)
}
inline std::string* SdcClockClass::mutable__clock_name() {
  std::string* _s = _internal_mutable__clock_name();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcClockClass._clock_name)
  return _s;
}
inline const std::string& SdcClockClass::_internal__clock_name() const {
  return _impl_._clock_name_.Get();
}
inline void SdcClockClass::_internal_set__clock_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._clock_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SdcClockClass::_internal_mutable__clock_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._clock_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SdcClockClass::release__clock_name() {
  // @@protoc_insertion_point(field_release:Sdc.SdcClockClass._clock_name)
  if (!_internal_has__clock_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._clock_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._clock_name_.IsDefault()) {
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SdcClockClass::set_allocated__clock_name(std::string* _clock_name) {
  if (_clock_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._clock_name_.SetAllocated(_clock_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._clock_name_.IsDefault()) {
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcClockClass._clock_name)
}

// required double _period = 2;
inline bool SdcClockClass::_internal_has__period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SdcClockClass::has__period() const {
  return _internal_has__period();
}
inline void SdcClockClass::clear__period() {
  _impl_._period_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double SdcClockClass::_internal__period() const {
  return _impl_._period_;
}
inline double SdcClockClass::_period() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockClass._period)
  return _internal__period();
}
inline void SdcClockClass::_internal_set__period(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_._period_ = value;
}
inline void SdcClockClass::set__period(double value) {
  _internal_set__period(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcClockClass._period)
}

// repeated uint64 _objs = 3;
inline int SdcClockClass::_internal__objs_size() const {
  return _impl_._objs_.size();
}
inline int SdcClockClass::_objs_size() const {
  return _internal__objs_size();
}
inline void SdcClockClass::clear__objs() {
  _impl_._objs_.Clear();
}
inline uint64_t SdcClockClass::_internal__objs(int index) const {
  return _impl_._objs_.Get(index);
}
inline uint64_t SdcClockClass::_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockClass._objs)
  return _internal__objs(index);
}
inline void SdcClockClass::set__objs(int index, uint64_t value) {
  _impl_._objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcClockClass._objs)
}
inline void SdcClockClass::_internal_add__objs(uint64_t value) {
  _impl_._objs_.Add(value);
}
inline void SdcClockClass::add__objs(uint64_t value) {
  _internal_add__objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcClockClass._objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcClockClass::_internal__objs() const {
  return _impl_._objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcClockClass::_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcClockClass._objs)
  return _internal__objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcClockClass::_internal_mutable__objs() {
  return &_impl_._objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcClockClass::mutable__objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcClockClass._objs)
  return _internal_mutable__objs();
}

// repeated double _edges = 4;
inline int SdcClockClass::_internal__edges_size() const {
  return _impl_._edges_.size();
}
inline int SdcClockClass::_edges_size() const {
  return _internal__edges_size();
}
inline void SdcClockClass::clear__edges() {
  _impl_._edges_.Clear();
}
inline double SdcClockClass::_internal__edges(int index) const {
  return _impl_._edges_.Get(index);
}
inline double SdcClockClass::_edges(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockClass._edges)
  return _internal__edges(index);
}
inline void SdcClockClass::set__edges(int index, double value) {
  _impl_._edges_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcClockClass._edges)
}
inline void SdcClockClass::_internal_add__edges(double value) {
  _impl_._edges_.Add(value);
}
inline void SdcClockClass::add__edges(double value) {
  _internal_add__edges(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcClockClass._edges)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SdcClockClass::_internal__edges() const {
  return _impl_._edges_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SdcClockClass::_edges() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcClockClass._edges)
  return _internal__edges();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SdcClockClass::_internal_mutable__edges() {
  return &_impl_._edges_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SdcClockClass::mutable__edges() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcClockClass._edges)
  return _internal_mutable__edges();
}

// required uint32 _is_propagated = 5;
inline bool SdcClockClass::_internal_has__is_propagated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SdcClockClass::has__is_propagated() const {
  return _internal_has__is_propagated();
}
inline void SdcClockClass::clear__is_propagated() {
  _impl_._is_propagated_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SdcClockClass::_internal__is_propagated() const {
  return _impl_._is_propagated_;
}
inline uint32_t SdcClockClass::_is_propagated() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockClass._is_propagated)
  return _internal__is_propagated();
}
inline void SdcClockClass::_internal_set__is_propagated(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._is_propagated_ = value;
}
inline void SdcClockClass::set__is_propagated(uint32_t value) {
  _internal_set__is_propagated(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcClockClass._is_propagated)
}

// required string _tracking_comment = 6;
inline bool SdcClockClass::_internal_has__tracking_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcClockClass::has__tracking_comment() const {
  return _internal_has__tracking_comment();
}
inline void SdcClockClass::clear__tracking_comment() {
  _impl_._tracking_comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SdcClockClass::_tracking_comment() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockClass._tracking_comment)
  return _internal__tracking_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SdcClockClass::set__tracking_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_._tracking_comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sdc.SdcClockClass._tracking_comment)
}
inline std::string* SdcClockClass::mutable__tracking_comment() {
  std::string* _s = _internal_mutable__tracking_comment();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcClockClass._tracking_comment)
  return _s;
}
inline const std::string& SdcClockClass::_internal__tracking_comment() const {
  return _impl_._tracking_comment_.Get();
}
inline void SdcClockClass::_internal_set__tracking_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._tracking_comment_.Set(value, GetArenaForAllocation());
}
inline std::string* SdcClockClass::_internal_mutable__tracking_comment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_._tracking_comment_.Mutable(GetArenaForAllocation());
}
inline std::string* SdcClockClass::release__tracking_comment() {
  // @@protoc_insertion_point(field_release:Sdc.SdcClockClass._tracking_comment)
  if (!_internal_has__tracking_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_._tracking_comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._tracking_comment_.IsDefault()) {
    _impl_._tracking_comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SdcClockClass::set_allocated__tracking_comment(std::string* _tracking_comment) {
  if (_tracking_comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_._tracking_comment_.SetAllocated(_tracking_comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._tracking_comment_.IsDefault()) {
    _impl_._tracking_comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcClockClass._tracking_comment)
}

// -------------------------------------------------------------------

// SdcGenrateClockClass

// required string _source_name = 1;
inline bool SdcGenrateClockClass::_internal_has__source_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcGenrateClockClass::has__source_name() const {
  return _internal_has__source_name();
}
inline void SdcGenrateClockClass::clear__source_name() {
  _impl_._source_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SdcGenrateClockClass::_source_name() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcGenrateClockClass._source_name)
  return _internal__source_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SdcGenrateClockClass::set__source_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._source_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sdc.SdcGenrateClockClass._source_name)
}
inline std::string* SdcGenrateClockClass::mutable__source_name() {
  std::string* _s = _internal_mutable__source_name();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcGenrateClockClass._source_name)
  return _s;
}
inline const std::string& SdcGenrateClockClass::_internal__source_name() const {
  return _impl_._source_name_.Get();
}
inline void SdcGenrateClockClass::_internal_set__source_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._source_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SdcGenrateClockClass::_internal_mutable__source_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._source_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SdcGenrateClockClass::release__source_name() {
  // @@protoc_insertion_point(field_release:Sdc.SdcGenrateClockClass._source_name)
  if (!_internal_has__source_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._source_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._source_name_.IsDefault()) {
    _impl_._source_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SdcGenrateClockClass::set_allocated__source_name(std::string* _source_name) {
  if (_source_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._source_name_.SetAllocated(_source_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._source_name_.IsDefault()) {
    _impl_._source_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcGenrateClockClass._source_name)
}

// -------------------------------------------------------------------

// SdcClockSyn

// required uint64 id = 1;
inline bool SdcClockSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SdcClockSyn::has_id() const {
  return _internal_has_id();
}
inline void SdcClockSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t SdcClockSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t SdcClockSyn::id() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockSyn.id)
  return _internal_id();
}
inline void SdcClockSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}
inline void SdcClockSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcClockSyn.id)
}

// required uint32 type = 2;
inline bool SdcClockSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SdcClockSyn::has_type() const {
  return _internal_has_type();
}
inline void SdcClockSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SdcClockSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcClockSyn::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockSyn.type)
  return _internal_type();
}
inline void SdcClockSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void SdcClockSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcClockSyn.type)
}

// required .Sdc.SdcClockClass parent = 3;
inline bool SdcClockSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool SdcClockSyn::has_parent() const {
  return _internal_has_parent();
}
inline void SdcClockSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Sdc::SdcClockClass& SdcClockSyn::_internal_parent() const {
  const ::Sdc::SdcClockClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcClockClass&>(
      ::Sdc::_SdcClockClass_default_instance_);
}
inline const ::Sdc::SdcClockClass& SdcClockSyn::parent() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockSyn.parent)
  return _internal_parent();
}
inline void SdcClockSyn::unsafe_arena_set_allocated_parent(
    ::Sdc::SdcClockClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcClockSyn.parent)
}
inline ::Sdc::SdcClockClass* SdcClockSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcClockClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcClockClass* SdcClockSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Sdc.SdcClockSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcClockClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Sdc::SdcClockClass* SdcClockSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcClockClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Sdc::SdcClockClass* SdcClockSyn::mutable_parent() {
  ::Sdc::SdcClockClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcClockSyn.parent)
  return _msg;
}
inline void SdcClockSyn::set_allocated_parent(::Sdc::SdcClockClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcClockSyn.parent)
}

// optional .Sdc.SdcGenrateClockClass child = 4;
inline bool SdcClockSyn::_internal_has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline bool SdcClockSyn::has_child() const {
  return _internal_has_child();
}
inline void SdcClockSyn::clear_child() {
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Sdc::SdcGenrateClockClass& SdcClockSyn::_internal_child() const {
  const ::Sdc::SdcGenrateClockClass* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcGenrateClockClass&>(
      ::Sdc::_SdcGenrateClockClass_default_instance_);
}
inline const ::Sdc::SdcGenrateClockClass& SdcClockSyn::child() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockSyn.child)
  return _internal_child();
}
inline void SdcClockSyn::unsafe_arena_set_allocated_child(
    ::Sdc::SdcGenrateClockClass* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcClockSyn.child)
}
inline ::Sdc::SdcGenrateClockClass* SdcClockSyn::release_child() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Sdc::SdcGenrateClockClass* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcGenrateClockClass* SdcClockSyn::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:Sdc.SdcClockSyn.child)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Sdc::SdcGenrateClockClass* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::Sdc::SdcGenrateClockClass* SdcClockSyn::_internal_mutable_child() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcGenrateClockClass>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::Sdc::SdcGenrateClockClass* SdcClockSyn::mutable_child() {
  ::Sdc::SdcGenrateClockClass* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcClockSyn.child)
  return _msg;
}
inline void SdcClockSyn::set_allocated_child(::Sdc::SdcGenrateClockClass* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcClockSyn.child)
}

// -------------------------------------------------------------------

// SdcAllClocksClass

// repeated uint64 _clocks = 1;
inline int SdcAllClocksClass::_internal__clocks_size() const {
  return _impl_._clocks_.size();
}
inline int SdcAllClocksClass::_clocks_size() const {
  return _internal__clocks_size();
}
inline void SdcAllClocksClass::clear__clocks() {
  _impl_._clocks_.Clear();
}
inline uint64_t SdcAllClocksClass::_internal__clocks(int index) const {
  return _impl_._clocks_.Get(index);
}
inline uint64_t SdcAllClocksClass::_clocks(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcAllClocksClass._clocks)
  return _internal__clocks(index);
}
inline void SdcAllClocksClass::set__clocks(int index, uint64_t value) {
  _impl_._clocks_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcAllClocksClass._clocks)
}
inline void SdcAllClocksClass::_internal_add__clocks(uint64_t value) {
  _impl_._clocks_.Add(value);
}
inline void SdcAllClocksClass::add__clocks(uint64_t value) {
  _internal_add__clocks(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcAllClocksClass._clocks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcAllClocksClass::_internal__clocks() const {
  return _impl_._clocks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcAllClocksClass::_clocks() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcAllClocksClass._clocks)
  return _internal__clocks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcAllClocksClass::_internal_mutable__clocks() {
  return &_impl_._clocks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcAllClocksClass::mutable__clocks() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcAllClocksClass._clocks)
  return _internal_mutable__clocks();
}

// -------------------------------------------------------------------

// SdcClockGroupClass

// repeated string _clock_group = 1;
inline int SdcClockGroupClass::_internal__clock_group_size() const {
  return _impl_._clock_group_.size();
}
inline int SdcClockGroupClass::_clock_group_size() const {
  return _internal__clock_group_size();
}
inline void SdcClockGroupClass::clear__clock_group() {
  _impl_._clock_group_.Clear();
}
inline std::string* SdcClockGroupClass::add__clock_group() {
  std::string* _s = _internal_add__clock_group();
  // @@protoc_insertion_point(field_add_mutable:Sdc.SdcClockGroupClass._clock_group)
  return _s;
}
inline const std::string& SdcClockGroupClass::_internal__clock_group(int index) const {
  return _impl_._clock_group_.Get(index);
}
inline const std::string& SdcClockGroupClass::_clock_group(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockGroupClass._clock_group)
  return _internal__clock_group(index);
}
inline std::string* SdcClockGroupClass::mutable__clock_group(int index) {
  // @@protoc_insertion_point(field_mutable:Sdc.SdcClockGroupClass._clock_group)
  return _impl_._clock_group_.Mutable(index);
}
inline void SdcClockGroupClass::set__clock_group(int index, const std::string& value) {
  _impl_._clock_group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcClockGroupClass._clock_group)
}
inline void SdcClockGroupClass::set__clock_group(int index, std::string&& value) {
  _impl_._clock_group_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Sdc.SdcClockGroupClass._clock_group)
}
inline void SdcClockGroupClass::set__clock_group(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_._clock_group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Sdc.SdcClockGroupClass._clock_group)
}
inline void SdcClockGroupClass::set__clock_group(int index, const char* value, size_t size) {
  _impl_._clock_group_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Sdc.SdcClockGroupClass._clock_group)
}
inline std::string* SdcClockGroupClass::_internal_add__clock_group() {
  return _impl_._clock_group_.Add();
}
inline void SdcClockGroupClass::add__clock_group(const std::string& value) {
  _impl_._clock_group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcClockGroupClass._clock_group)
}
inline void SdcClockGroupClass::add__clock_group(std::string&& value) {
  _impl_._clock_group_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Sdc.SdcClockGroupClass._clock_group)
}
inline void SdcClockGroupClass::add__clock_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_._clock_group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Sdc.SdcClockGroupClass._clock_group)
}
inline void SdcClockGroupClass::add__clock_group(const char* value, size_t size) {
  _impl_._clock_group_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Sdc.SdcClockGroupClass._clock_group)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SdcClockGroupClass::_clock_group() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcClockGroupClass._clock_group)
  return _impl_._clock_group_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SdcClockGroupClass::mutable__clock_group() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcClockGroupClass._clock_group)
  return &_impl_._clock_group_;
}

// -------------------------------------------------------------------

// SdcClockGroupsClass

// repeated .Sdc.SdcClockGroupClass _clock_groups = 1;
inline int SdcClockGroupsClass::_internal__clock_groups_size() const {
  return _impl_._clock_groups_.size();
}
inline int SdcClockGroupsClass::_clock_groups_size() const {
  return _internal__clock_groups_size();
}
inline void SdcClockGroupsClass::clear__clock_groups() {
  _impl_._clock_groups_.Clear();
}
inline ::Sdc::SdcClockGroupClass* SdcClockGroupsClass::mutable__clock_groups(int index) {
  // @@protoc_insertion_point(field_mutable:Sdc.SdcClockGroupsClass._clock_groups)
  return _impl_._clock_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sdc::SdcClockGroupClass >*
SdcClockGroupsClass::mutable__clock_groups() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcClockGroupsClass._clock_groups)
  return &_impl_._clock_groups_;
}
inline const ::Sdc::SdcClockGroupClass& SdcClockGroupsClass::_internal__clock_groups(int index) const {
  return _impl_._clock_groups_.Get(index);
}
inline const ::Sdc::SdcClockGroupClass& SdcClockGroupsClass::_clock_groups(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockGroupsClass._clock_groups)
  return _internal__clock_groups(index);
}
inline ::Sdc::SdcClockGroupClass* SdcClockGroupsClass::_internal_add__clock_groups() {
  return _impl_._clock_groups_.Add();
}
inline ::Sdc::SdcClockGroupClass* SdcClockGroupsClass::add__clock_groups() {
  ::Sdc::SdcClockGroupClass* _add = _internal_add__clock_groups();
  // @@protoc_insertion_point(field_add:Sdc.SdcClockGroupsClass._clock_groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Sdc::SdcClockGroupClass >&
SdcClockGroupsClass::_clock_groups() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcClockGroupsClass._clock_groups)
  return _impl_._clock_groups_;
}

// required string _group_name = 2;
inline bool SdcClockGroupsClass::_internal_has__group_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcClockGroupsClass::has__group_name() const {
  return _internal_has__group_name();
}
inline void SdcClockGroupsClass::clear__group_name() {
  _impl_._group_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SdcClockGroupsClass::_group_name() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcClockGroupsClass._group_name)
  return _internal__group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SdcClockGroupsClass::set__group_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_._group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Sdc.SdcClockGroupsClass._group_name)
}
inline std::string* SdcClockGroupsClass::mutable__group_name() {
  std::string* _s = _internal_mutable__group_name();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcClockGroupsClass._group_name)
  return _s;
}
inline const std::string& SdcClockGroupsClass::_internal__group_name() const {
  return _impl_._group_name_.Get();
}
inline void SdcClockGroupsClass::_internal_set__group_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SdcClockGroupsClass::_internal_mutable__group_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_._group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SdcClockGroupsClass::release__group_name() {
  // @@protoc_insertion_point(field_release:Sdc.SdcClockGroupsClass._group_name)
  if (!_internal_has__group_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_._group_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._group_name_.IsDefault()) {
    _impl_._group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SdcClockGroupsClass::set_allocated__group_name(std::string* _group_name) {
  if (_group_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_._group_name_.SetAllocated(_group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._group_name_.IsDefault()) {
    _impl_._group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcClockGroupsClass._group_name)
}

// -------------------------------------------------------------------

// SdcCollectionTypeEnum

// required .Sdc.SdcCollectionTypeEnum.CollectionType ct = 1;
inline bool SdcCollectionTypeEnum::_internal_has_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcCollectionTypeEnum::has_ct() const {
  return _internal_has_ct();
}
inline void SdcCollectionTypeEnum::clear_ct() {
  _impl_.ct_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::Sdc::SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::_internal_ct() const {
  return static_cast< ::Sdc::SdcCollectionTypeEnum_CollectionType >(_impl_.ct_);
}
inline ::Sdc::SdcCollectionTypeEnum_CollectionType SdcCollectionTypeEnum::ct() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCollectionTypeEnum.ct)
  return _internal_ct();
}
inline void SdcCollectionTypeEnum::_internal_set_ct(::Sdc::SdcCollectionTypeEnum_CollectionType value) {
  assert(::Sdc::SdcCollectionTypeEnum_CollectionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ct_ = value;
}
inline void SdcCollectionTypeEnum::set_ct(::Sdc::SdcCollectionTypeEnum_CollectionType value) {
  _internal_set_ct(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcCollectionTypeEnum.ct)
}

// -------------------------------------------------------------------

// SdcCollectionClass

// required .Sdc.SdcCollectionTypeEnum scte = 1;
inline bool SdcCollectionClass::_internal_has_scte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scte_ != nullptr);
  return value;
}
inline bool SdcCollectionClass::has_scte() const {
  return _internal_has_scte();
}
inline void SdcCollectionClass::clear_scte() {
  if (_impl_.scte_ != nullptr) _impl_.scte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Sdc::SdcCollectionTypeEnum& SdcCollectionClass::_internal_scte() const {
  const ::Sdc::SdcCollectionTypeEnum* p = _impl_.scte_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcCollectionTypeEnum&>(
      ::Sdc::_SdcCollectionTypeEnum_default_instance_);
}
inline const ::Sdc::SdcCollectionTypeEnum& SdcCollectionClass::scte() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCollectionClass.scte)
  return _internal_scte();
}
inline void SdcCollectionClass::unsafe_arena_set_allocated_scte(
    ::Sdc::SdcCollectionTypeEnum* scte) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scte_);
  }
  _impl_.scte_ = scte;
  if (scte) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCollectionClass.scte)
}
inline ::Sdc::SdcCollectionTypeEnum* SdcCollectionClass::release_scte() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcCollectionTypeEnum* temp = _impl_.scte_;
  _impl_.scte_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcCollectionTypeEnum* SdcCollectionClass::unsafe_arena_release_scte() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCollectionClass.scte)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcCollectionTypeEnum* temp = _impl_.scte_;
  _impl_.scte_ = nullptr;
  return temp;
}
inline ::Sdc::SdcCollectionTypeEnum* SdcCollectionClass::_internal_mutable_scte() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.scte_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcCollectionTypeEnum>(GetArenaForAllocation());
    _impl_.scte_ = p;
  }
  return _impl_.scte_;
}
inline ::Sdc::SdcCollectionTypeEnum* SdcCollectionClass::mutable_scte() {
  ::Sdc::SdcCollectionTypeEnum* _msg = _internal_mutable_scte();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCollectionClass.scte)
  return _msg;
}
inline void SdcCollectionClass::set_allocated_scte(::Sdc::SdcCollectionTypeEnum* scte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scte_;
  }
  if (scte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scte);
    if (message_arena != submessage_arena) {
      scte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scte, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.scte_ = scte;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCollectionClass.scte)
}

// repeated uint64 _collection_objs = 2;
inline int SdcCollectionClass::_internal__collection_objs_size() const {
  return _impl_._collection_objs_.size();
}
inline int SdcCollectionClass::_collection_objs_size() const {
  return _internal__collection_objs_size();
}
inline void SdcCollectionClass::clear__collection_objs() {
  _impl_._collection_objs_.Clear();
}
inline uint64_t SdcCollectionClass::_internal__collection_objs(int index) const {
  return _impl_._collection_objs_.Get(index);
}
inline uint64_t SdcCollectionClass::_collection_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCollectionClass._collection_objs)
  return _internal__collection_objs(index);
}
inline void SdcCollectionClass::set__collection_objs(int index, uint64_t value) {
  _impl_._collection_objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcCollectionClass._collection_objs)
}
inline void SdcCollectionClass::_internal_add__collection_objs(uint64_t value) {
  _impl_._collection_objs_.Add(value);
}
inline void SdcCollectionClass::add__collection_objs(uint64_t value) {
  _internal_add__collection_objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcCollectionClass._collection_objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcCollectionClass::_internal__collection_objs() const {
  return _impl_._collection_objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcCollectionClass::_collection_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcCollectionClass._collection_objs)
  return _internal__collection_objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcCollectionClass::_internal_mutable__collection_objs() {
  return &_impl_._collection_objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcCollectionClass::mutable__collection_objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcCollectionClass._collection_objs)
  return _internal_mutable__collection_objs();
}

// repeated uint32 _collection_obj_types = 3;
inline int SdcCollectionClass::_internal__collection_obj_types_size() const {
  return _impl_._collection_obj_types_.size();
}
inline int SdcCollectionClass::_collection_obj_types_size() const {
  return _internal__collection_obj_types_size();
}
inline void SdcCollectionClass::clear__collection_obj_types() {
  _impl_._collection_obj_types_.Clear();
}
inline uint32_t SdcCollectionClass::_internal__collection_obj_types(int index) const {
  return _impl_._collection_obj_types_.Get(index);
}
inline uint32_t SdcCollectionClass::_collection_obj_types(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCollectionClass._collection_obj_types)
  return _internal__collection_obj_types(index);
}
inline void SdcCollectionClass::set__collection_obj_types(int index, uint32_t value) {
  _impl_._collection_obj_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcCollectionClass._collection_obj_types)
}
inline void SdcCollectionClass::_internal_add__collection_obj_types(uint32_t value) {
  _impl_._collection_obj_types_.Add(value);
}
inline void SdcCollectionClass::add__collection_obj_types(uint32_t value) {
  _internal_add__collection_obj_types(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcCollectionClass._collection_obj_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SdcCollectionClass::_internal__collection_obj_types() const {
  return _impl_._collection_obj_types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SdcCollectionClass::_collection_obj_types() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcCollectionClass._collection_obj_types)
  return _internal__collection_obj_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SdcCollectionClass::_internal_mutable__collection_obj_types() {
  return &_impl_._collection_obj_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SdcCollectionClass::mutable__collection_obj_types() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcCollectionClass._collection_obj_types)
  return _internal_mutable__collection_obj_types();
}

// -------------------------------------------------------------------

// SdcTimingDerateClass

// required uint32 type = 1;
inline bool SdcTimingDerateClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcTimingDerateClass::has_type() const {
  return _internal_has_type();
}
inline void SdcTimingDerateClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcTimingDerateClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcTimingDerateClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDerateClass.type)
  return _internal_type();
}
inline void SdcTimingDerateClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcTimingDerateClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcTimingDerateClass.type)
}

// required double _derate_value = 2;
inline bool SdcTimingDerateClass::_internal_has__derate_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcTimingDerateClass::has__derate_value() const {
  return _internal_has__derate_value();
}
inline void SdcTimingDerateClass::clear__derate_value() {
  _impl_._derate_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SdcTimingDerateClass::_internal__derate_value() const {
  return _impl_._derate_value_;
}
inline double SdcTimingDerateClass::_derate_value() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDerateClass._derate_value)
  return _internal__derate_value();
}
inline void SdcTimingDerateClass::_internal_set__derate_value(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._derate_value_ = value;
}
inline void SdcTimingDerateClass::set__derate_value(double value) {
  _internal_set__derate_value(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcTimingDerateClass._derate_value)
}

// -------------------------------------------------------------------

// SdcTimingDRCClass

// required double _drc_val = 1;
inline bool SdcTimingDRCClass::_internal_has__drc_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcTimingDRCClass::has__drc_val() const {
  return _internal_has__drc_val();
}
inline void SdcTimingDRCClass::clear__drc_val() {
  _impl_._drc_val_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SdcTimingDRCClass::_internal__drc_val() const {
  return _impl_._drc_val_;
}
inline double SdcTimingDRCClass::_drc_val() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDRCClass._drc_val)
  return _internal__drc_val();
}
inline void SdcTimingDRCClass::_internal_set__drc_val(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._drc_val_ = value;
}
inline void SdcTimingDRCClass::set__drc_val(double value) {
  _internal_set__drc_val(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcTimingDRCClass._drc_val)
}

// repeated uint64 _objs = 2;
inline int SdcTimingDRCClass::_internal__objs_size() const {
  return _impl_._objs_.size();
}
inline int SdcTimingDRCClass::_objs_size() const {
  return _internal__objs_size();
}
inline void SdcTimingDRCClass::clear__objs() {
  _impl_._objs_.Clear();
}
inline uint64_t SdcTimingDRCClass::_internal__objs(int index) const {
  return _impl_._objs_.Get(index);
}
inline uint64_t SdcTimingDRCClass::_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDRCClass._objs)
  return _internal__objs(index);
}
inline void SdcTimingDRCClass::set__objs(int index, uint64_t value) {
  _impl_._objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcTimingDRCClass._objs)
}
inline void SdcTimingDRCClass::_internal_add__objs(uint64_t value) {
  _impl_._objs_.Add(value);
}
inline void SdcTimingDRCClass::add__objs(uint64_t value) {
  _internal_add__objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcTimingDRCClass._objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcTimingDRCClass::_internal__objs() const {
  return _impl_._objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcTimingDRCClass::_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcTimingDRCClass._objs)
  return _internal__objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcTimingDRCClass::_internal_mutable__objs() {
  return &_impl_._objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcTimingDRCClass::mutable__objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcTimingDRCClass._objs)
  return _internal_mutable__objs();
}

// repeated uint32 _obj_types = 3;
inline int SdcTimingDRCClass::_internal__obj_types_size() const {
  return _impl_._obj_types_.size();
}
inline int SdcTimingDRCClass::_obj_types_size() const {
  return _internal__obj_types_size();
}
inline void SdcTimingDRCClass::clear__obj_types() {
  _impl_._obj_types_.Clear();
}
inline uint32_t SdcTimingDRCClass::_internal__obj_types(int index) const {
  return _impl_._obj_types_.Get(index);
}
inline uint32_t SdcTimingDRCClass::_obj_types(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDRCClass._obj_types)
  return _internal__obj_types(index);
}
inline void SdcTimingDRCClass::set__obj_types(int index, uint32_t value) {
  _impl_._obj_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcTimingDRCClass._obj_types)
}
inline void SdcTimingDRCClass::_internal_add__obj_types(uint32_t value) {
  _impl_._obj_types_.Add(value);
}
inline void SdcTimingDRCClass::add__obj_types(uint32_t value) {
  _internal_add__obj_types(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcTimingDRCClass._obj_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SdcTimingDRCClass::_internal__obj_types() const {
  return _impl_._obj_types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
SdcTimingDRCClass::_obj_types() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcTimingDRCClass._obj_types)
  return _internal__obj_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SdcTimingDRCClass::_internal_mutable__obj_types() {
  return &_impl_._obj_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
SdcTimingDRCClass::mutable__obj_types() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcTimingDRCClass._obj_types)
  return _internal_mutable__obj_types();
}

// -------------------------------------------------------------------

// SdcSetMaxTransitionClass

// required uint32 type = 1;
inline bool SdcSetMaxTransitionClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcSetMaxTransitionClass::has_type() const {
  return _internal_has_type();
}
inline void SdcSetMaxTransitionClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SdcSetMaxTransitionClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcSetMaxTransitionClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetMaxTransitionClass.type)
  return _internal_type();
}
inline void SdcSetMaxTransitionClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void SdcSetMaxTransitionClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetMaxTransitionClass.type)
}

// -------------------------------------------------------------------

// SdcSetMaxCapacitanceClass

// required uint32 type = 2;
inline bool SdcSetMaxCapacitanceClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcSetMaxCapacitanceClass::has_type() const {
  return _internal_has_type();
}
inline void SdcSetMaxCapacitanceClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SdcSetMaxCapacitanceClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcSetMaxCapacitanceClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetMaxCapacitanceClass.type)
  return _internal_type();
}
inline void SdcSetMaxCapacitanceClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void SdcSetMaxCapacitanceClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetMaxCapacitanceClass.type)
}

// -------------------------------------------------------------------

// SdcTimingDRCSyn

// required uint32 type = 1;
inline bool SdcTimingDRCSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcTimingDRCSyn::has_type() const {
  return _internal_has_type();
}
inline void SdcTimingDRCSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcTimingDRCSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcTimingDRCSyn::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDRCSyn.type)
  return _internal_type();
}
inline void SdcTimingDRCSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcTimingDRCSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcTimingDRCSyn.type)
}

// required .Sdc.SdcTimingDRCClass parent = 2;
inline bool SdcTimingDRCSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool SdcTimingDRCSyn::has_parent() const {
  return _internal_has_parent();
}
inline void SdcTimingDRCSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Sdc::SdcTimingDRCClass& SdcTimingDRCSyn::_internal_parent() const {
  const ::Sdc::SdcTimingDRCClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcTimingDRCClass&>(
      ::Sdc::_SdcTimingDRCClass_default_instance_);
}
inline const ::Sdc::SdcTimingDRCClass& SdcTimingDRCSyn::parent() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDRCSyn.parent)
  return _internal_parent();
}
inline void SdcTimingDRCSyn::unsafe_arena_set_allocated_parent(
    ::Sdc::SdcTimingDRCClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcTimingDRCSyn.parent)
}
inline ::Sdc::SdcTimingDRCClass* SdcTimingDRCSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcTimingDRCClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcTimingDRCClass* SdcTimingDRCSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Sdc.SdcTimingDRCSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcTimingDRCClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Sdc::SdcTimingDRCClass* SdcTimingDRCSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcTimingDRCClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Sdc::SdcTimingDRCClass* SdcTimingDRCSyn::mutable_parent() {
  ::Sdc::SdcTimingDRCClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcTimingDRCSyn.parent)
  return _msg;
}
inline void SdcTimingDRCSyn::set_allocated_parent(::Sdc::SdcTimingDRCClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcTimingDRCSyn.parent)
}

// .Sdc.SdcSetMaxTransitionClass ssntc = 3;
inline bool SdcTimingDRCSyn::_internal_has_ssntc() const {
  return stdrcs_case() == kSsntc;
}
inline bool SdcTimingDRCSyn::has_ssntc() const {
  return _internal_has_ssntc();
}
inline void SdcTimingDRCSyn::set_has_ssntc() {
  _impl_._oneof_case_[0] = kSsntc;
}
inline void SdcTimingDRCSyn::clear_ssntc() {
  if (_internal_has_ssntc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stdrcs_.ssntc_;
    }
    clear_has_stdrcs();
  }
}
inline ::Sdc::SdcSetMaxTransitionClass* SdcTimingDRCSyn::release_ssntc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcTimingDRCSyn.ssntc)
  if (_internal_has_ssntc()) {
    clear_has_stdrcs();
    ::Sdc::SdcSetMaxTransitionClass* temp = _impl_.stdrcs_.ssntc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stdrcs_.ssntc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcSetMaxTransitionClass& SdcTimingDRCSyn::_internal_ssntc() const {
  return _internal_has_ssntc()
      ? *_impl_.stdrcs_.ssntc_
      : reinterpret_cast< ::Sdc::SdcSetMaxTransitionClass&>(::Sdc::_SdcSetMaxTransitionClass_default_instance_);
}
inline const ::Sdc::SdcSetMaxTransitionClass& SdcTimingDRCSyn::ssntc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDRCSyn.ssntc)
  return _internal_ssntc();
}
inline ::Sdc::SdcSetMaxTransitionClass* SdcTimingDRCSyn::unsafe_arena_release_ssntc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcTimingDRCSyn.ssntc)
  if (_internal_has_ssntc()) {
    clear_has_stdrcs();
    ::Sdc::SdcSetMaxTransitionClass* temp = _impl_.stdrcs_.ssntc_;
    _impl_.stdrcs_.ssntc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcTimingDRCSyn::unsafe_arena_set_allocated_ssntc(::Sdc::SdcSetMaxTransitionClass* ssntc) {
  clear_stdrcs();
  if (ssntc) {
    set_has_ssntc();
    _impl_.stdrcs_.ssntc_ = ssntc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcTimingDRCSyn.ssntc)
}
inline ::Sdc::SdcSetMaxTransitionClass* SdcTimingDRCSyn::_internal_mutable_ssntc() {
  if (!_internal_has_ssntc()) {
    clear_stdrcs();
    set_has_ssntc();
    _impl_.stdrcs_.ssntc_ = CreateMaybeMessage< ::Sdc::SdcSetMaxTransitionClass >(GetArenaForAllocation());
  }
  return _impl_.stdrcs_.ssntc_;
}
inline ::Sdc::SdcSetMaxTransitionClass* SdcTimingDRCSyn::mutable_ssntc() {
  ::Sdc::SdcSetMaxTransitionClass* _msg = _internal_mutable_ssntc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcTimingDRCSyn.ssntc)
  return _msg;
}

// .Sdc.SdcSetMaxCapacitanceClass ssncc = 4;
inline bool SdcTimingDRCSyn::_internal_has_ssncc() const {
  return stdrcs_case() == kSsncc;
}
inline bool SdcTimingDRCSyn::has_ssncc() const {
  return _internal_has_ssncc();
}
inline void SdcTimingDRCSyn::set_has_ssncc() {
  _impl_._oneof_case_[0] = kSsncc;
}
inline void SdcTimingDRCSyn::clear_ssncc() {
  if (_internal_has_ssncc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stdrcs_.ssncc_;
    }
    clear_has_stdrcs();
  }
}
inline ::Sdc::SdcSetMaxCapacitanceClass* SdcTimingDRCSyn::release_ssncc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcTimingDRCSyn.ssncc)
  if (_internal_has_ssncc()) {
    clear_has_stdrcs();
    ::Sdc::SdcSetMaxCapacitanceClass* temp = _impl_.stdrcs_.ssncc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stdrcs_.ssncc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcSetMaxCapacitanceClass& SdcTimingDRCSyn::_internal_ssncc() const {
  return _internal_has_ssncc()
      ? *_impl_.stdrcs_.ssncc_
      : reinterpret_cast< ::Sdc::SdcSetMaxCapacitanceClass&>(::Sdc::_SdcSetMaxCapacitanceClass_default_instance_);
}
inline const ::Sdc::SdcSetMaxCapacitanceClass& SdcTimingDRCSyn::ssncc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcTimingDRCSyn.ssncc)
  return _internal_ssncc();
}
inline ::Sdc::SdcSetMaxCapacitanceClass* SdcTimingDRCSyn::unsafe_arena_release_ssncc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcTimingDRCSyn.ssncc)
  if (_internal_has_ssncc()) {
    clear_has_stdrcs();
    ::Sdc::SdcSetMaxCapacitanceClass* temp = _impl_.stdrcs_.ssncc_;
    _impl_.stdrcs_.ssncc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcTimingDRCSyn::unsafe_arena_set_allocated_ssncc(::Sdc::SdcSetMaxCapacitanceClass* ssncc) {
  clear_stdrcs();
  if (ssncc) {
    set_has_ssncc();
    _impl_.stdrcs_.ssncc_ = ssncc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcTimingDRCSyn.ssncc)
}
inline ::Sdc::SdcSetMaxCapacitanceClass* SdcTimingDRCSyn::_internal_mutable_ssncc() {
  if (!_internal_has_ssncc()) {
    clear_stdrcs();
    set_has_ssncc();
    _impl_.stdrcs_.ssncc_ = CreateMaybeMessage< ::Sdc::SdcSetMaxCapacitanceClass >(GetArenaForAllocation());
  }
  return _impl_.stdrcs_.ssncc_;
}
inline ::Sdc::SdcSetMaxCapacitanceClass* SdcTimingDRCSyn::mutable_ssncc() {
  ::Sdc::SdcSetMaxCapacitanceClass* _msg = _internal_mutable_ssncc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcTimingDRCSyn.ssncc)
  return _msg;
}

inline bool SdcTimingDRCSyn::has_stdrcs() const {
  return stdrcs_case() != STDRCS_NOT_SET;
}
inline void SdcTimingDRCSyn::clear_has_stdrcs() {
  _impl_._oneof_case_[0] = STDRCS_NOT_SET;
}
inline SdcTimingDRCSyn::StdrcsCase SdcTimingDRCSyn::stdrcs_case() const {
  return SdcTimingDRCSyn::StdrcsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SdcSetClockLatencyClass

// required uint32 type = 1;
inline bool SdcSetClockLatencyClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcSetClockLatencyClass::has_type() const {
  return _internal_has_type();
}
inline void SdcSetClockLatencyClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcSetClockLatencyClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcSetClockLatencyClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetClockLatencyClass.type)
  return _internal_type();
}
inline void SdcSetClockLatencyClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcSetClockLatencyClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetClockLatencyClass.type)
}

// required double _delay_value = 2;
inline bool SdcSetClockLatencyClass::_internal_has__delay_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcSetClockLatencyClass::has__delay_value() const {
  return _internal_has__delay_value();
}
inline void SdcSetClockLatencyClass::clear__delay_value() {
  _impl_._delay_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SdcSetClockLatencyClass::_internal__delay_value() const {
  return _impl_._delay_value_;
}
inline double SdcSetClockLatencyClass::_delay_value() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetClockLatencyClass._delay_value)
  return _internal__delay_value();
}
inline void SdcSetClockLatencyClass::_internal_set__delay_value(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._delay_value_ = value;
}
inline void SdcSetClockLatencyClass::set__delay_value(double value) {
  _internal_set__delay_value(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetClockLatencyClass._delay_value)
}

// repeated uint64 _objs = 3;
inline int SdcSetClockLatencyClass::_internal__objs_size() const {
  return _impl_._objs_.size();
}
inline int SdcSetClockLatencyClass::_objs_size() const {
  return _internal__objs_size();
}
inline void SdcSetClockLatencyClass::clear__objs() {
  _impl_._objs_.Clear();
}
inline uint64_t SdcSetClockLatencyClass::_internal__objs(int index) const {
  return _impl_._objs_.Get(index);
}
inline uint64_t SdcSetClockLatencyClass::_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetClockLatencyClass._objs)
  return _internal__objs(index);
}
inline void SdcSetClockLatencyClass::set__objs(int index, uint64_t value) {
  _impl_._objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetClockLatencyClass._objs)
}
inline void SdcSetClockLatencyClass::_internal_add__objs(uint64_t value) {
  _impl_._objs_.Add(value);
}
inline void SdcSetClockLatencyClass::add__objs(uint64_t value) {
  _internal_add__objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcSetClockLatencyClass._objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetClockLatencyClass::_internal__objs() const {
  return _impl_._objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetClockLatencyClass::_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcSetClockLatencyClass._objs)
  return _internal__objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetClockLatencyClass::_internal_mutable__objs() {
  return &_impl_._objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetClockLatencyClass::mutable__objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcSetClockLatencyClass._objs)
  return _internal_mutable__objs();
}

// -------------------------------------------------------------------

// SdcSetClockUncertaintyClass

// required uint32 type = 1;
inline bool SdcSetClockUncertaintyClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcSetClockUncertaintyClass::has_type() const {
  return _internal_has_type();
}
inline void SdcSetClockUncertaintyClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcSetClockUncertaintyClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcSetClockUncertaintyClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetClockUncertaintyClass.type)
  return _internal_type();
}
inline void SdcSetClockUncertaintyClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcSetClockUncertaintyClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetClockUncertaintyClass.type)
}

// required double _uncertainty_value = 2;
inline bool SdcSetClockUncertaintyClass::_internal_has__uncertainty_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcSetClockUncertaintyClass::has__uncertainty_value() const {
  return _internal_has__uncertainty_value();
}
inline void SdcSetClockUncertaintyClass::clear__uncertainty_value() {
  _impl_._uncertainty_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SdcSetClockUncertaintyClass::_internal__uncertainty_value() const {
  return _impl_._uncertainty_value_;
}
inline double SdcSetClockUncertaintyClass::_uncertainty_value() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetClockUncertaintyClass._uncertainty_value)
  return _internal__uncertainty_value();
}
inline void SdcSetClockUncertaintyClass::_internal_set__uncertainty_value(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._uncertainty_value_ = value;
}
inline void SdcSetClockUncertaintyClass::set__uncertainty_value(double value) {
  _internal_set__uncertainty_value(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetClockUncertaintyClass._uncertainty_value)
}

// repeated uint64 _objs = 3;
inline int SdcSetClockUncertaintyClass::_internal__objs_size() const {
  return _impl_._objs_.size();
}
inline int SdcSetClockUncertaintyClass::_objs_size() const {
  return _internal__objs_size();
}
inline void SdcSetClockUncertaintyClass::clear__objs() {
  _impl_._objs_.Clear();
}
inline uint64_t SdcSetClockUncertaintyClass::_internal__objs(int index) const {
  return _impl_._objs_.Get(index);
}
inline uint64_t SdcSetClockUncertaintyClass::_objs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcSetClockUncertaintyClass._objs)
  return _internal__objs(index);
}
inline void SdcSetClockUncertaintyClass::set__objs(int index, uint64_t value) {
  _impl_._objs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcSetClockUncertaintyClass._objs)
}
inline void SdcSetClockUncertaintyClass::_internal_add__objs(uint64_t value) {
  _impl_._objs_.Add(value);
}
inline void SdcSetClockUncertaintyClass::add__objs(uint64_t value) {
  _internal_add__objs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcSetClockUncertaintyClass._objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetClockUncertaintyClass::_internal__objs() const {
  return _impl_._objs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcSetClockUncertaintyClass::_objs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcSetClockUncertaintyClass._objs)
  return _internal__objs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetClockUncertaintyClass::_internal_mutable__objs() {
  return &_impl_._objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcSetClockUncertaintyClass::mutable__objs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcSetClockUncertaintyClass._objs)
  return _internal_mutable__objs();
}

// -------------------------------------------------------------------

// SdcExceptionClass

// repeated string _prop_froms = 1;
inline int SdcExceptionClass::_internal__prop_froms_size() const {
  return _impl_._prop_froms_.size();
}
inline int SdcExceptionClass::_prop_froms_size() const {
  return _internal__prop_froms_size();
}
inline void SdcExceptionClass::clear__prop_froms() {
  _impl_._prop_froms_.Clear();
}
inline std::string* SdcExceptionClass::add__prop_froms() {
  std::string* _s = _internal_add__prop_froms();
  // @@protoc_insertion_point(field_add_mutable:Sdc.SdcExceptionClass._prop_froms)
  return _s;
}
inline const std::string& SdcExceptionClass::_internal__prop_froms(int index) const {
  return _impl_._prop_froms_.Get(index);
}
inline const std::string& SdcExceptionClass::_prop_froms(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcExceptionClass._prop_froms)
  return _internal__prop_froms(index);
}
inline std::string* SdcExceptionClass::mutable__prop_froms(int index) {
  // @@protoc_insertion_point(field_mutable:Sdc.SdcExceptionClass._prop_froms)
  return _impl_._prop_froms_.Mutable(index);
}
inline void SdcExceptionClass::set__prop_froms(int index, const std::string& value) {
  _impl_._prop_froms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcExceptionClass._prop_froms)
}
inline void SdcExceptionClass::set__prop_froms(int index, std::string&& value) {
  _impl_._prop_froms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Sdc.SdcExceptionClass._prop_froms)
}
inline void SdcExceptionClass::set__prop_froms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_._prop_froms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Sdc.SdcExceptionClass._prop_froms)
}
inline void SdcExceptionClass::set__prop_froms(int index, const char* value, size_t size) {
  _impl_._prop_froms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Sdc.SdcExceptionClass._prop_froms)
}
inline std::string* SdcExceptionClass::_internal_add__prop_froms() {
  return _impl_._prop_froms_.Add();
}
inline void SdcExceptionClass::add__prop_froms(const std::string& value) {
  _impl_._prop_froms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcExceptionClass._prop_froms)
}
inline void SdcExceptionClass::add__prop_froms(std::string&& value) {
  _impl_._prop_froms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Sdc.SdcExceptionClass._prop_froms)
}
inline void SdcExceptionClass::add__prop_froms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_._prop_froms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Sdc.SdcExceptionClass._prop_froms)
}
inline void SdcExceptionClass::add__prop_froms(const char* value, size_t size) {
  _impl_._prop_froms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Sdc.SdcExceptionClass._prop_froms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SdcExceptionClass::_prop_froms() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcExceptionClass._prop_froms)
  return _impl_._prop_froms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SdcExceptionClass::mutable__prop_froms() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcExceptionClass._prop_froms)
  return &_impl_._prop_froms_;
}

// repeated string _prop_tos = 2;
inline int SdcExceptionClass::_internal__prop_tos_size() const {
  return _impl_._prop_tos_.size();
}
inline int SdcExceptionClass::_prop_tos_size() const {
  return _internal__prop_tos_size();
}
inline void SdcExceptionClass::clear__prop_tos() {
  _impl_._prop_tos_.Clear();
}
inline std::string* SdcExceptionClass::add__prop_tos() {
  std::string* _s = _internal_add__prop_tos();
  // @@protoc_insertion_point(field_add_mutable:Sdc.SdcExceptionClass._prop_tos)
  return _s;
}
inline const std::string& SdcExceptionClass::_internal__prop_tos(int index) const {
  return _impl_._prop_tos_.Get(index);
}
inline const std::string& SdcExceptionClass::_prop_tos(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcExceptionClass._prop_tos)
  return _internal__prop_tos(index);
}
inline std::string* SdcExceptionClass::mutable__prop_tos(int index) {
  // @@protoc_insertion_point(field_mutable:Sdc.SdcExceptionClass._prop_tos)
  return _impl_._prop_tos_.Mutable(index);
}
inline void SdcExceptionClass::set__prop_tos(int index, const std::string& value) {
  _impl_._prop_tos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcExceptionClass._prop_tos)
}
inline void SdcExceptionClass::set__prop_tos(int index, std::string&& value) {
  _impl_._prop_tos_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Sdc.SdcExceptionClass._prop_tos)
}
inline void SdcExceptionClass::set__prop_tos(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_._prop_tos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Sdc.SdcExceptionClass._prop_tos)
}
inline void SdcExceptionClass::set__prop_tos(int index, const char* value, size_t size) {
  _impl_._prop_tos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Sdc.SdcExceptionClass._prop_tos)
}
inline std::string* SdcExceptionClass::_internal_add__prop_tos() {
  return _impl_._prop_tos_.Add();
}
inline void SdcExceptionClass::add__prop_tos(const std::string& value) {
  _impl_._prop_tos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcExceptionClass._prop_tos)
}
inline void SdcExceptionClass::add__prop_tos(std::string&& value) {
  _impl_._prop_tos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Sdc.SdcExceptionClass._prop_tos)
}
inline void SdcExceptionClass::add__prop_tos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_._prop_tos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Sdc.SdcExceptionClass._prop_tos)
}
inline void SdcExceptionClass::add__prop_tos(const char* value, size_t size) {
  _impl_._prop_tos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Sdc.SdcExceptionClass._prop_tos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SdcExceptionClass::_prop_tos() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcExceptionClass._prop_tos)
  return _impl_._prop_tos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SdcExceptionClass::mutable__prop_tos() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcExceptionClass._prop_tos)
  return &_impl_._prop_tos_;
}

// repeated .Common.Types.StringList _prop_throughs = 3;
inline int SdcExceptionClass::_internal__prop_throughs_size() const {
  return _impl_._prop_throughs_.size();
}
inline int SdcExceptionClass::_prop_throughs_size() const {
  return _internal__prop_throughs_size();
}
inline ::Common::Types::StringList* SdcExceptionClass::mutable__prop_throughs(int index) {
  // @@protoc_insertion_point(field_mutable:Sdc.SdcExceptionClass._prop_throughs)
  return _impl_._prop_throughs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StringList >*
SdcExceptionClass::mutable__prop_throughs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcExceptionClass._prop_throughs)
  return &_impl_._prop_throughs_;
}
inline const ::Common::Types::StringList& SdcExceptionClass::_internal__prop_throughs(int index) const {
  return _impl_._prop_throughs_.Get(index);
}
inline const ::Common::Types::StringList& SdcExceptionClass::_prop_throughs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcExceptionClass._prop_throughs)
  return _internal__prop_throughs(index);
}
inline ::Common::Types::StringList* SdcExceptionClass::_internal_add__prop_throughs() {
  return _impl_._prop_throughs_.Add();
}
inline ::Common::Types::StringList* SdcExceptionClass::add__prop_throughs() {
  ::Common::Types::StringList* _add = _internal_add__prop_throughs();
  // @@protoc_insertion_point(field_add:Sdc.SdcExceptionClass._prop_throughs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StringList >&
SdcExceptionClass::_prop_throughs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcExceptionClass._prop_throughs)
  return _impl_._prop_throughs_;
}

// -------------------------------------------------------------------

// SdcMulticyclePathClass

// required int32 _path_multiplier = 1;
inline bool SdcMulticyclePathClass::_internal_has__path_multiplier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcMulticyclePathClass::has__path_multiplier() const {
  return _internal_has__path_multiplier();
}
inline void SdcMulticyclePathClass::clear__path_multiplier() {
  _impl_._path_multiplier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t SdcMulticyclePathClass::_internal__path_multiplier() const {
  return _impl_._path_multiplier_;
}
inline int32_t SdcMulticyclePathClass::_path_multiplier() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcMulticyclePathClass._path_multiplier)
  return _internal__path_multiplier();
}
inline void SdcMulticyclePathClass::_internal_set__path_multiplier(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_._path_multiplier_ = value;
}
inline void SdcMulticyclePathClass::set__path_multiplier(int32_t value) {
  _internal_set__path_multiplier(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcMulticyclePathClass._path_multiplier)
}

// required uint32 type = 2;
inline bool SdcMulticyclePathClass::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcMulticyclePathClass::has_type() const {
  return _internal_has_type();
}
inline void SdcMulticyclePathClass::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SdcMulticyclePathClass::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcMulticyclePathClass::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcMulticyclePathClass.type)
  return _internal_type();
}
inline void SdcMulticyclePathClass::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void SdcMulticyclePathClass::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcMulticyclePathClass.type)
}

// -------------------------------------------------------------------

// SdcExceptionSyn

// required uint32 type = 1;
inline bool SdcExceptionSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SdcExceptionSyn::has_type() const {
  return _internal_has_type();
}
inline void SdcExceptionSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SdcExceptionSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcExceptionSyn::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcExceptionSyn.type)
  return _internal_type();
}
inline void SdcExceptionSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void SdcExceptionSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcExceptionSyn.type)
}

// required .Sdc.SdcExceptionClass parent = 2;
inline bool SdcExceptionSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool SdcExceptionSyn::has_parent() const {
  return _internal_has_parent();
}
inline void SdcExceptionSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Sdc::SdcExceptionClass& SdcExceptionSyn::_internal_parent() const {
  const ::Sdc::SdcExceptionClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcExceptionClass&>(
      ::Sdc::_SdcExceptionClass_default_instance_);
}
inline const ::Sdc::SdcExceptionClass& SdcExceptionSyn::parent() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcExceptionSyn.parent)
  return _internal_parent();
}
inline void SdcExceptionSyn::unsafe_arena_set_allocated_parent(
    ::Sdc::SdcExceptionClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcExceptionSyn.parent)
}
inline ::Sdc::SdcExceptionClass* SdcExceptionSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcExceptionClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcExceptionClass* SdcExceptionSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Sdc.SdcExceptionSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcExceptionClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Sdc::SdcExceptionClass* SdcExceptionSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcExceptionClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Sdc::SdcExceptionClass* SdcExceptionSyn::mutable_parent() {
  ::Sdc::SdcExceptionClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcExceptionSyn.parent)
  return _msg;
}
inline void SdcExceptionSyn::set_allocated_parent(::Sdc::SdcExceptionClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcExceptionSyn.parent)
}

// optional .Sdc.SdcMulticyclePathClass child = 3;
inline bool SdcExceptionSyn::_internal_has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline bool SdcExceptionSyn::has_child() const {
  return _internal_has_child();
}
inline void SdcExceptionSyn::clear_child() {
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Sdc::SdcMulticyclePathClass& SdcExceptionSyn::_internal_child() const {
  const ::Sdc::SdcMulticyclePathClass* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcMulticyclePathClass&>(
      ::Sdc::_SdcMulticyclePathClass_default_instance_);
}
inline const ::Sdc::SdcMulticyclePathClass& SdcExceptionSyn::child() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcExceptionSyn.child)
  return _internal_child();
}
inline void SdcExceptionSyn::unsafe_arena_set_allocated_child(
    ::Sdc::SdcMulticyclePathClass* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcExceptionSyn.child)
}
inline ::Sdc::SdcMulticyclePathClass* SdcExceptionSyn::release_child() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Sdc::SdcMulticyclePathClass* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcMulticyclePathClass* SdcExceptionSyn::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:Sdc.SdcExceptionSyn.child)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Sdc::SdcMulticyclePathClass* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::Sdc::SdcMulticyclePathClass* SdcExceptionSyn::_internal_mutable_child() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcMulticyclePathClass>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::Sdc::SdcMulticyclePathClass* SdcExceptionSyn::mutable_child() {
  ::Sdc::SdcMulticyclePathClass* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcExceptionSyn.child)
  return _msg;
}
inline void SdcExceptionSyn::set_allocated_child(::Sdc::SdcMulticyclePathClass* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcExceptionSyn.child)
}

// -------------------------------------------------------------------

// SdcCommandObjSyn

// required uint64 id = 1;
inline bool SdcCommandObjSyn::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SdcCommandObjSyn::has_id() const {
  return _internal_has_id();
}
inline void SdcCommandObjSyn::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SdcCommandObjSyn::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t SdcCommandObjSyn::id() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.id)
  return _internal_id();
}
inline void SdcCommandObjSyn::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void SdcCommandObjSyn::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcCommandObjSyn.id)
}

// required uint32 type = 2;
inline bool SdcCommandObjSyn::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SdcCommandObjSyn::has_type() const {
  return _internal_has_type();
}
inline void SdcCommandObjSyn::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SdcCommandObjSyn::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SdcCommandObjSyn::type() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.type)
  return _internal_type();
}
inline void SdcCommandObjSyn::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void SdcCommandObjSyn::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcCommandObjSyn.type)
}

// required .Sdc.SdcCommandObjClass parent = 3;
inline bool SdcCommandObjSyn::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool SdcCommandObjSyn::has_parent() const {
  return _internal_has_parent();
}
inline void SdcCommandObjSyn::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Sdc::SdcCommandObjClass& SdcCommandObjSyn::_internal_parent() const {
  const ::Sdc::SdcCommandObjClass* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Sdc::SdcCommandObjClass&>(
      ::Sdc::_SdcCommandObjClass_default_instance_);
}
inline const ::Sdc::SdcCommandObjClass& SdcCommandObjSyn::parent() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.parent)
  return _internal_parent();
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_parent(
    ::Sdc::SdcCommandObjClass* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.parent)
}
inline ::Sdc::SdcCommandObjClass* SdcCommandObjSyn::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcCommandObjClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Sdc::SdcCommandObjClass* SdcCommandObjSyn::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.parent)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Sdc::SdcCommandObjClass* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::Sdc::SdcCommandObjClass* SdcCommandObjSyn::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Sdc::SdcCommandObjClass>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::Sdc::SdcCommandObjClass* SdcCommandObjSyn::mutable_parent() {
  ::Sdc::SdcCommandObjClass* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.parent)
  return _msg;
}
inline void SdcCommandObjSyn::set_allocated_parent(::Sdc::SdcCommandObjClass* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Sdc.SdcCommandObjSyn.parent)
}

// .Sdc.SdcIOConstrainSyn siocs = 4;
inline bool SdcCommandObjSyn::_internal_has_siocs() const {
  return scos_case() == kSiocs;
}
inline bool SdcCommandObjSyn::has_siocs() const {
  return _internal_has_siocs();
}
inline void SdcCommandObjSyn::set_has_siocs() {
  _impl_._oneof_case_[0] = kSiocs;
}
inline void SdcCommandObjSyn::clear_siocs() {
  if (_internal_has_siocs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.siocs_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcIOConstrainSyn* SdcCommandObjSyn::release_siocs() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.siocs)
  if (_internal_has_siocs()) {
    clear_has_scos();
    ::Sdc::SdcIOConstrainSyn* temp = _impl_.scos_.siocs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.siocs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcIOConstrainSyn& SdcCommandObjSyn::_internal_siocs() const {
  return _internal_has_siocs()
      ? *_impl_.scos_.siocs_
      : reinterpret_cast< ::Sdc::SdcIOConstrainSyn&>(::Sdc::_SdcIOConstrainSyn_default_instance_);
}
inline const ::Sdc::SdcIOConstrainSyn& SdcCommandObjSyn::siocs() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.siocs)
  return _internal_siocs();
}
inline ::Sdc::SdcIOConstrainSyn* SdcCommandObjSyn::unsafe_arena_release_siocs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.siocs)
  if (_internal_has_siocs()) {
    clear_has_scos();
    ::Sdc::SdcIOConstrainSyn* temp = _impl_.scos_.siocs_;
    _impl_.scos_.siocs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_siocs(::Sdc::SdcIOConstrainSyn* siocs) {
  clear_scos();
  if (siocs) {
    set_has_siocs();
    _impl_.scos_.siocs_ = siocs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.siocs)
}
inline ::Sdc::SdcIOConstrainSyn* SdcCommandObjSyn::_internal_mutable_siocs() {
  if (!_internal_has_siocs()) {
    clear_scos();
    set_has_siocs();
    _impl_.scos_.siocs_ = CreateMaybeMessage< ::Sdc::SdcIOConstrainSyn >(GetArenaForAllocation());
  }
  return _impl_.scos_.siocs_;
}
inline ::Sdc::SdcIOConstrainSyn* SdcCommandObjSyn::mutable_siocs() {
  ::Sdc::SdcIOConstrainSyn* _msg = _internal_mutable_siocs();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.siocs)
  return _msg;
}

// .Sdc.SdcClockSyn scs = 5;
inline bool SdcCommandObjSyn::_internal_has_scs() const {
  return scos_case() == kScs;
}
inline bool SdcCommandObjSyn::has_scs() const {
  return _internal_has_scs();
}
inline void SdcCommandObjSyn::set_has_scs() {
  _impl_._oneof_case_[0] = kScs;
}
inline void SdcCommandObjSyn::clear_scs() {
  if (_internal_has_scs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.scs_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcClockSyn* SdcCommandObjSyn::release_scs() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.scs)
  if (_internal_has_scs()) {
    clear_has_scos();
    ::Sdc::SdcClockSyn* temp = _impl_.scos_.scs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.scs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcClockSyn& SdcCommandObjSyn::_internal_scs() const {
  return _internal_has_scs()
      ? *_impl_.scos_.scs_
      : reinterpret_cast< ::Sdc::SdcClockSyn&>(::Sdc::_SdcClockSyn_default_instance_);
}
inline const ::Sdc::SdcClockSyn& SdcCommandObjSyn::scs() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.scs)
  return _internal_scs();
}
inline ::Sdc::SdcClockSyn* SdcCommandObjSyn::unsafe_arena_release_scs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.scs)
  if (_internal_has_scs()) {
    clear_has_scos();
    ::Sdc::SdcClockSyn* temp = _impl_.scos_.scs_;
    _impl_.scos_.scs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_scs(::Sdc::SdcClockSyn* scs) {
  clear_scos();
  if (scs) {
    set_has_scs();
    _impl_.scos_.scs_ = scs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.scs)
}
inline ::Sdc::SdcClockSyn* SdcCommandObjSyn::_internal_mutable_scs() {
  if (!_internal_has_scs()) {
    clear_scos();
    set_has_scs();
    _impl_.scos_.scs_ = CreateMaybeMessage< ::Sdc::SdcClockSyn >(GetArenaForAllocation());
  }
  return _impl_.scos_.scs_;
}
inline ::Sdc::SdcClockSyn* SdcCommandObjSyn::mutable_scs() {
  ::Sdc::SdcClockSyn* _msg = _internal_mutable_scs();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.scs)
  return _msg;
}

// .Sdc.SdcAllClocksClass cacc = 6;
inline bool SdcCommandObjSyn::_internal_has_cacc() const {
  return scos_case() == kCacc;
}
inline bool SdcCommandObjSyn::has_cacc() const {
  return _internal_has_cacc();
}
inline void SdcCommandObjSyn::set_has_cacc() {
  _impl_._oneof_case_[0] = kCacc;
}
inline void SdcCommandObjSyn::clear_cacc() {
  if (_internal_has_cacc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.cacc_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcAllClocksClass* SdcCommandObjSyn::release_cacc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.cacc)
  if (_internal_has_cacc()) {
    clear_has_scos();
    ::Sdc::SdcAllClocksClass* temp = _impl_.scos_.cacc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.cacc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcAllClocksClass& SdcCommandObjSyn::_internal_cacc() const {
  return _internal_has_cacc()
      ? *_impl_.scos_.cacc_
      : reinterpret_cast< ::Sdc::SdcAllClocksClass&>(::Sdc::_SdcAllClocksClass_default_instance_);
}
inline const ::Sdc::SdcAllClocksClass& SdcCommandObjSyn::cacc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.cacc)
  return _internal_cacc();
}
inline ::Sdc::SdcAllClocksClass* SdcCommandObjSyn::unsafe_arena_release_cacc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.cacc)
  if (_internal_has_cacc()) {
    clear_has_scos();
    ::Sdc::SdcAllClocksClass* temp = _impl_.scos_.cacc_;
    _impl_.scos_.cacc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_cacc(::Sdc::SdcAllClocksClass* cacc) {
  clear_scos();
  if (cacc) {
    set_has_cacc();
    _impl_.scos_.cacc_ = cacc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.cacc)
}
inline ::Sdc::SdcAllClocksClass* SdcCommandObjSyn::_internal_mutable_cacc() {
  if (!_internal_has_cacc()) {
    clear_scos();
    set_has_cacc();
    _impl_.scos_.cacc_ = CreateMaybeMessage< ::Sdc::SdcAllClocksClass >(GetArenaForAllocation());
  }
  return _impl_.scos_.cacc_;
}
inline ::Sdc::SdcAllClocksClass* SdcCommandObjSyn::mutable_cacc() {
  ::Sdc::SdcAllClocksClass* _msg = _internal_mutable_cacc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.cacc)
  return _msg;
}

// .Sdc.SdcClockGroupsClass scgc = 7;
inline bool SdcCommandObjSyn::_internal_has_scgc() const {
  return scos_case() == kScgc;
}
inline bool SdcCommandObjSyn::has_scgc() const {
  return _internal_has_scgc();
}
inline void SdcCommandObjSyn::set_has_scgc() {
  _impl_._oneof_case_[0] = kScgc;
}
inline void SdcCommandObjSyn::clear_scgc() {
  if (_internal_has_scgc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.scgc_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcClockGroupsClass* SdcCommandObjSyn::release_scgc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.scgc)
  if (_internal_has_scgc()) {
    clear_has_scos();
    ::Sdc::SdcClockGroupsClass* temp = _impl_.scos_.scgc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.scgc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcClockGroupsClass& SdcCommandObjSyn::_internal_scgc() const {
  return _internal_has_scgc()
      ? *_impl_.scos_.scgc_
      : reinterpret_cast< ::Sdc::SdcClockGroupsClass&>(::Sdc::_SdcClockGroupsClass_default_instance_);
}
inline const ::Sdc::SdcClockGroupsClass& SdcCommandObjSyn::scgc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.scgc)
  return _internal_scgc();
}
inline ::Sdc::SdcClockGroupsClass* SdcCommandObjSyn::unsafe_arena_release_scgc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.scgc)
  if (_internal_has_scgc()) {
    clear_has_scos();
    ::Sdc::SdcClockGroupsClass* temp = _impl_.scos_.scgc_;
    _impl_.scos_.scgc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_scgc(::Sdc::SdcClockGroupsClass* scgc) {
  clear_scos();
  if (scgc) {
    set_has_scgc();
    _impl_.scos_.scgc_ = scgc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.scgc)
}
inline ::Sdc::SdcClockGroupsClass* SdcCommandObjSyn::_internal_mutable_scgc() {
  if (!_internal_has_scgc()) {
    clear_scos();
    set_has_scgc();
    _impl_.scos_.scgc_ = CreateMaybeMessage< ::Sdc::SdcClockGroupsClass >(GetArenaForAllocation());
  }
  return _impl_.scos_.scgc_;
}
inline ::Sdc::SdcClockGroupsClass* SdcCommandObjSyn::mutable_scgc() {
  ::Sdc::SdcClockGroupsClass* _msg = _internal_mutable_scgc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.scgc)
  return _msg;
}

// .Sdc.SdcCollectionClass scc = 8;
inline bool SdcCommandObjSyn::_internal_has_scc() const {
  return scos_case() == kScc;
}
inline bool SdcCommandObjSyn::has_scc() const {
  return _internal_has_scc();
}
inline void SdcCommandObjSyn::set_has_scc() {
  _impl_._oneof_case_[0] = kScc;
}
inline void SdcCommandObjSyn::clear_scc() {
  if (_internal_has_scc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.scc_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcCollectionClass* SdcCommandObjSyn::release_scc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.scc)
  if (_internal_has_scc()) {
    clear_has_scos();
    ::Sdc::SdcCollectionClass* temp = _impl_.scos_.scc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.scc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcCollectionClass& SdcCommandObjSyn::_internal_scc() const {
  return _internal_has_scc()
      ? *_impl_.scos_.scc_
      : reinterpret_cast< ::Sdc::SdcCollectionClass&>(::Sdc::_SdcCollectionClass_default_instance_);
}
inline const ::Sdc::SdcCollectionClass& SdcCommandObjSyn::scc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.scc)
  return _internal_scc();
}
inline ::Sdc::SdcCollectionClass* SdcCommandObjSyn::unsafe_arena_release_scc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.scc)
  if (_internal_has_scc()) {
    clear_has_scos();
    ::Sdc::SdcCollectionClass* temp = _impl_.scos_.scc_;
    _impl_.scos_.scc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_scc(::Sdc::SdcCollectionClass* scc) {
  clear_scos();
  if (scc) {
    set_has_scc();
    _impl_.scos_.scc_ = scc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.scc)
}
inline ::Sdc::SdcCollectionClass* SdcCommandObjSyn::_internal_mutable_scc() {
  if (!_internal_has_scc()) {
    clear_scos();
    set_has_scc();
    _impl_.scos_.scc_ = CreateMaybeMessage< ::Sdc::SdcCollectionClass >(GetArenaForAllocation());
  }
  return _impl_.scos_.scc_;
}
inline ::Sdc::SdcCollectionClass* SdcCommandObjSyn::mutable_scc() {
  ::Sdc::SdcCollectionClass* _msg = _internal_mutable_scc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.scc)
  return _msg;
}

// .Sdc.SdcTimingDerateClass stdc = 9;
inline bool SdcCommandObjSyn::_internal_has_stdc() const {
  return scos_case() == kStdc;
}
inline bool SdcCommandObjSyn::has_stdc() const {
  return _internal_has_stdc();
}
inline void SdcCommandObjSyn::set_has_stdc() {
  _impl_._oneof_case_[0] = kStdc;
}
inline void SdcCommandObjSyn::clear_stdc() {
  if (_internal_has_stdc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.stdc_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcTimingDerateClass* SdcCommandObjSyn::release_stdc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.stdc)
  if (_internal_has_stdc()) {
    clear_has_scos();
    ::Sdc::SdcTimingDerateClass* temp = _impl_.scos_.stdc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.stdc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcTimingDerateClass& SdcCommandObjSyn::_internal_stdc() const {
  return _internal_has_stdc()
      ? *_impl_.scos_.stdc_
      : reinterpret_cast< ::Sdc::SdcTimingDerateClass&>(::Sdc::_SdcTimingDerateClass_default_instance_);
}
inline const ::Sdc::SdcTimingDerateClass& SdcCommandObjSyn::stdc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.stdc)
  return _internal_stdc();
}
inline ::Sdc::SdcTimingDerateClass* SdcCommandObjSyn::unsafe_arena_release_stdc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.stdc)
  if (_internal_has_stdc()) {
    clear_has_scos();
    ::Sdc::SdcTimingDerateClass* temp = _impl_.scos_.stdc_;
    _impl_.scos_.stdc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_stdc(::Sdc::SdcTimingDerateClass* stdc) {
  clear_scos();
  if (stdc) {
    set_has_stdc();
    _impl_.scos_.stdc_ = stdc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.stdc)
}
inline ::Sdc::SdcTimingDerateClass* SdcCommandObjSyn::_internal_mutable_stdc() {
  if (!_internal_has_stdc()) {
    clear_scos();
    set_has_stdc();
    _impl_.scos_.stdc_ = CreateMaybeMessage< ::Sdc::SdcTimingDerateClass >(GetArenaForAllocation());
  }
  return _impl_.scos_.stdc_;
}
inline ::Sdc::SdcTimingDerateClass* SdcCommandObjSyn::mutable_stdc() {
  ::Sdc::SdcTimingDerateClass* _msg = _internal_mutable_stdc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.stdc)
  return _msg;
}

// .Sdc.SdcTimingDRCSyn stdrcs = 10;
inline bool SdcCommandObjSyn::_internal_has_stdrcs() const {
  return scos_case() == kStdrcs;
}
inline bool SdcCommandObjSyn::has_stdrcs() const {
  return _internal_has_stdrcs();
}
inline void SdcCommandObjSyn::set_has_stdrcs() {
  _impl_._oneof_case_[0] = kStdrcs;
}
inline void SdcCommandObjSyn::clear_stdrcs() {
  if (_internal_has_stdrcs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.stdrcs_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcTimingDRCSyn* SdcCommandObjSyn::release_stdrcs() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.stdrcs)
  if (_internal_has_stdrcs()) {
    clear_has_scos();
    ::Sdc::SdcTimingDRCSyn* temp = _impl_.scos_.stdrcs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.stdrcs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcTimingDRCSyn& SdcCommandObjSyn::_internal_stdrcs() const {
  return _internal_has_stdrcs()
      ? *_impl_.scos_.stdrcs_
      : reinterpret_cast< ::Sdc::SdcTimingDRCSyn&>(::Sdc::_SdcTimingDRCSyn_default_instance_);
}
inline const ::Sdc::SdcTimingDRCSyn& SdcCommandObjSyn::stdrcs() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.stdrcs)
  return _internal_stdrcs();
}
inline ::Sdc::SdcTimingDRCSyn* SdcCommandObjSyn::unsafe_arena_release_stdrcs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.stdrcs)
  if (_internal_has_stdrcs()) {
    clear_has_scos();
    ::Sdc::SdcTimingDRCSyn* temp = _impl_.scos_.stdrcs_;
    _impl_.scos_.stdrcs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_stdrcs(::Sdc::SdcTimingDRCSyn* stdrcs) {
  clear_scos();
  if (stdrcs) {
    set_has_stdrcs();
    _impl_.scos_.stdrcs_ = stdrcs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.stdrcs)
}
inline ::Sdc::SdcTimingDRCSyn* SdcCommandObjSyn::_internal_mutable_stdrcs() {
  if (!_internal_has_stdrcs()) {
    clear_scos();
    set_has_stdrcs();
    _impl_.scos_.stdrcs_ = CreateMaybeMessage< ::Sdc::SdcTimingDRCSyn >(GetArenaForAllocation());
  }
  return _impl_.scos_.stdrcs_;
}
inline ::Sdc::SdcTimingDRCSyn* SdcCommandObjSyn::mutable_stdrcs() {
  ::Sdc::SdcTimingDRCSyn* _msg = _internal_mutable_stdrcs();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.stdrcs)
  return _msg;
}

// .Sdc.SdcSetClockLatencyClass ssclc = 11;
inline bool SdcCommandObjSyn::_internal_has_ssclc() const {
  return scos_case() == kSsclc;
}
inline bool SdcCommandObjSyn::has_ssclc() const {
  return _internal_has_ssclc();
}
inline void SdcCommandObjSyn::set_has_ssclc() {
  _impl_._oneof_case_[0] = kSsclc;
}
inline void SdcCommandObjSyn::clear_ssclc() {
  if (_internal_has_ssclc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.ssclc_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcSetClockLatencyClass* SdcCommandObjSyn::release_ssclc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.ssclc)
  if (_internal_has_ssclc()) {
    clear_has_scos();
    ::Sdc::SdcSetClockLatencyClass* temp = _impl_.scos_.ssclc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.ssclc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcSetClockLatencyClass& SdcCommandObjSyn::_internal_ssclc() const {
  return _internal_has_ssclc()
      ? *_impl_.scos_.ssclc_
      : reinterpret_cast< ::Sdc::SdcSetClockLatencyClass&>(::Sdc::_SdcSetClockLatencyClass_default_instance_);
}
inline const ::Sdc::SdcSetClockLatencyClass& SdcCommandObjSyn::ssclc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.ssclc)
  return _internal_ssclc();
}
inline ::Sdc::SdcSetClockLatencyClass* SdcCommandObjSyn::unsafe_arena_release_ssclc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.ssclc)
  if (_internal_has_ssclc()) {
    clear_has_scos();
    ::Sdc::SdcSetClockLatencyClass* temp = _impl_.scos_.ssclc_;
    _impl_.scos_.ssclc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_ssclc(::Sdc::SdcSetClockLatencyClass* ssclc) {
  clear_scos();
  if (ssclc) {
    set_has_ssclc();
    _impl_.scos_.ssclc_ = ssclc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.ssclc)
}
inline ::Sdc::SdcSetClockLatencyClass* SdcCommandObjSyn::_internal_mutable_ssclc() {
  if (!_internal_has_ssclc()) {
    clear_scos();
    set_has_ssclc();
    _impl_.scos_.ssclc_ = CreateMaybeMessage< ::Sdc::SdcSetClockLatencyClass >(GetArenaForAllocation());
  }
  return _impl_.scos_.ssclc_;
}
inline ::Sdc::SdcSetClockLatencyClass* SdcCommandObjSyn::mutable_ssclc() {
  ::Sdc::SdcSetClockLatencyClass* _msg = _internal_mutable_ssclc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.ssclc)
  return _msg;
}

// .Sdc.SdcSetClockUncertaintyClass sscuc = 12;
inline bool SdcCommandObjSyn::_internal_has_sscuc() const {
  return scos_case() == kSscuc;
}
inline bool SdcCommandObjSyn::has_sscuc() const {
  return _internal_has_sscuc();
}
inline void SdcCommandObjSyn::set_has_sscuc() {
  _impl_._oneof_case_[0] = kSscuc;
}
inline void SdcCommandObjSyn::clear_sscuc() {
  if (_internal_has_sscuc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.sscuc_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcSetClockUncertaintyClass* SdcCommandObjSyn::release_sscuc() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.sscuc)
  if (_internal_has_sscuc()) {
    clear_has_scos();
    ::Sdc::SdcSetClockUncertaintyClass* temp = _impl_.scos_.sscuc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.sscuc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcSetClockUncertaintyClass& SdcCommandObjSyn::_internal_sscuc() const {
  return _internal_has_sscuc()
      ? *_impl_.scos_.sscuc_
      : reinterpret_cast< ::Sdc::SdcSetClockUncertaintyClass&>(::Sdc::_SdcSetClockUncertaintyClass_default_instance_);
}
inline const ::Sdc::SdcSetClockUncertaintyClass& SdcCommandObjSyn::sscuc() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.sscuc)
  return _internal_sscuc();
}
inline ::Sdc::SdcSetClockUncertaintyClass* SdcCommandObjSyn::unsafe_arena_release_sscuc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.sscuc)
  if (_internal_has_sscuc()) {
    clear_has_scos();
    ::Sdc::SdcSetClockUncertaintyClass* temp = _impl_.scos_.sscuc_;
    _impl_.scos_.sscuc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_sscuc(::Sdc::SdcSetClockUncertaintyClass* sscuc) {
  clear_scos();
  if (sscuc) {
    set_has_sscuc();
    _impl_.scos_.sscuc_ = sscuc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.sscuc)
}
inline ::Sdc::SdcSetClockUncertaintyClass* SdcCommandObjSyn::_internal_mutable_sscuc() {
  if (!_internal_has_sscuc()) {
    clear_scos();
    set_has_sscuc();
    _impl_.scos_.sscuc_ = CreateMaybeMessage< ::Sdc::SdcSetClockUncertaintyClass >(GetArenaForAllocation());
  }
  return _impl_.scos_.sscuc_;
}
inline ::Sdc::SdcSetClockUncertaintyClass* SdcCommandObjSyn::mutable_sscuc() {
  ::Sdc::SdcSetClockUncertaintyClass* _msg = _internal_mutable_sscuc();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.sscuc)
  return _msg;
}

// .Sdc.SdcExceptionSyn ses = 13;
inline bool SdcCommandObjSyn::_internal_has_ses() const {
  return scos_case() == kSes;
}
inline bool SdcCommandObjSyn::has_ses() const {
  return _internal_has_ses();
}
inline void SdcCommandObjSyn::set_has_ses() {
  _impl_._oneof_case_[0] = kSes;
}
inline void SdcCommandObjSyn::clear_ses() {
  if (_internal_has_ses()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.scos_.ses_;
    }
    clear_has_scos();
  }
}
inline ::Sdc::SdcExceptionSyn* SdcCommandObjSyn::release_ses() {
  // @@protoc_insertion_point(field_release:Sdc.SdcCommandObjSyn.ses)
  if (_internal_has_ses()) {
    clear_has_scos();
    ::Sdc::SdcExceptionSyn* temp = _impl_.scos_.ses_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scos_.ses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Sdc::SdcExceptionSyn& SdcCommandObjSyn::_internal_ses() const {
  return _internal_has_ses()
      ? *_impl_.scos_.ses_
      : reinterpret_cast< ::Sdc::SdcExceptionSyn&>(::Sdc::_SdcExceptionSyn_default_instance_);
}
inline const ::Sdc::SdcExceptionSyn& SdcCommandObjSyn::ses() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcCommandObjSyn.ses)
  return _internal_ses();
}
inline ::Sdc::SdcExceptionSyn* SdcCommandObjSyn::unsafe_arena_release_ses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Sdc.SdcCommandObjSyn.ses)
  if (_internal_has_ses()) {
    clear_has_scos();
    ::Sdc::SdcExceptionSyn* temp = _impl_.scos_.ses_;
    _impl_.scos_.ses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SdcCommandObjSyn::unsafe_arena_set_allocated_ses(::Sdc::SdcExceptionSyn* ses) {
  clear_scos();
  if (ses) {
    set_has_ses();
    _impl_.scos_.ses_ = ses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Sdc.SdcCommandObjSyn.ses)
}
inline ::Sdc::SdcExceptionSyn* SdcCommandObjSyn::_internal_mutable_ses() {
  if (!_internal_has_ses()) {
    clear_scos();
    set_has_ses();
    _impl_.scos_.ses_ = CreateMaybeMessage< ::Sdc::SdcExceptionSyn >(GetArenaForAllocation());
  }
  return _impl_.scos_.ses_;
}
inline ::Sdc::SdcExceptionSyn* SdcCommandObjSyn::mutable_ses() {
  ::Sdc::SdcExceptionSyn* _msg = _internal_mutable_ses();
  // @@protoc_insertion_point(field_mutable:Sdc.SdcCommandObjSyn.ses)
  return _msg;
}

inline bool SdcCommandObjSyn::has_scos() const {
  return scos_case() != SCOS_NOT_SET;
}
inline void SdcCommandObjSyn::clear_has_scos() {
  _impl_._oneof_case_[0] = SCOS_NOT_SET;
}
inline SdcCommandObjSyn::ScosCase SdcCommandObjSyn::scos_case() const {
  return SdcCommandObjSyn::ScosCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SdcConstrainClass

// required uint64 id = 1;
inline bool SdcConstrainClass::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdcConstrainClass::has_id() const {
  return _internal_has_id();
}
inline void SdcConstrainClass::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SdcConstrainClass::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t SdcConstrainClass::id() const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass.id)
  return _internal_id();
}
inline void SdcConstrainClass::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void SdcConstrainClass::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass.id)
}

// repeated .Common.Types.StrULongMap _sdc_clocks = 2;
inline int SdcConstrainClass::_internal__sdc_clocks_size() const {
  return _impl_._sdc_clocks_.size();
}
inline int SdcConstrainClass::_sdc_clocks_size() const {
  return _internal__sdc_clocks_size();
}
inline ::Common::Types::StrULongMap* SdcConstrainClass::mutable__sdc_clocks(int index) {
  // @@protoc_insertion_point(field_mutable:Sdc.SdcConstrainClass._sdc_clocks)
  return _impl_._sdc_clocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StrULongMap >*
SdcConstrainClass::mutable__sdc_clocks() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_clocks)
  return &_impl_._sdc_clocks_;
}
inline const ::Common::Types::StrULongMap& SdcConstrainClass::_internal__sdc_clocks(int index) const {
  return _impl_._sdc_clocks_.Get(index);
}
inline const ::Common::Types::StrULongMap& SdcConstrainClass::_sdc_clocks(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_clocks)
  return _internal__sdc_clocks(index);
}
inline ::Common::Types::StrULongMap* SdcConstrainClass::_internal_add__sdc_clocks() {
  return _impl_._sdc_clocks_.Add();
}
inline ::Common::Types::StrULongMap* SdcConstrainClass::add__sdc_clocks() {
  ::Common::Types::StrULongMap* _add = _internal_add__sdc_clocks();
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_clocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Common::Types::StrULongMap >&
SdcConstrainClass::_sdc_clocks() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_clocks)
  return _impl_._sdc_clocks_;
}

// repeated uint64 _sdc_io_constraints = 3;
inline int SdcConstrainClass::_internal__sdc_io_constraints_size() const {
  return _impl_._sdc_io_constraints_.size();
}
inline int SdcConstrainClass::_sdc_io_constraints_size() const {
  return _internal__sdc_io_constraints_size();
}
inline void SdcConstrainClass::clear__sdc_io_constraints() {
  _impl_._sdc_io_constraints_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_io_constraints(int index) const {
  return _impl_._sdc_io_constraints_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_io_constraints(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_io_constraints)
  return _internal__sdc_io_constraints(index);
}
inline void SdcConstrainClass::set__sdc_io_constraints(int index, uint64_t value) {
  _impl_._sdc_io_constraints_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_io_constraints)
}
inline void SdcConstrainClass::_internal_add__sdc_io_constraints(uint64_t value) {
  _impl_._sdc_io_constraints_.Add(value);
}
inline void SdcConstrainClass::add__sdc_io_constraints(uint64_t value) {
  _internal_add__sdc_io_constraints(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_io_constraints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_io_constraints() const {
  return _impl_._sdc_io_constraints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_io_constraints() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_io_constraints)
  return _internal__sdc_io_constraints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_io_constraints() {
  return &_impl_._sdc_io_constraints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_io_constraints() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_io_constraints)
  return _internal_mutable__sdc_io_constraints();
}

// repeated uint64 _sdc_timing_derates = 4;
inline int SdcConstrainClass::_internal__sdc_timing_derates_size() const {
  return _impl_._sdc_timing_derates_.size();
}
inline int SdcConstrainClass::_sdc_timing_derates_size() const {
  return _internal__sdc_timing_derates_size();
}
inline void SdcConstrainClass::clear__sdc_timing_derates() {
  _impl_._sdc_timing_derates_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_timing_derates(int index) const {
  return _impl_._sdc_timing_derates_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_timing_derates(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_timing_derates)
  return _internal__sdc_timing_derates(index);
}
inline void SdcConstrainClass::set__sdc_timing_derates(int index, uint64_t value) {
  _impl_._sdc_timing_derates_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_timing_derates)
}
inline void SdcConstrainClass::_internal_add__sdc_timing_derates(uint64_t value) {
  _impl_._sdc_timing_derates_.Add(value);
}
inline void SdcConstrainClass::add__sdc_timing_derates(uint64_t value) {
  _internal_add__sdc_timing_derates(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_timing_derates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_timing_derates() const {
  return _impl_._sdc_timing_derates_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_timing_derates() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_timing_derates)
  return _internal__sdc_timing_derates();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_timing_derates() {
  return &_impl_._sdc_timing_derates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_timing_derates() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_timing_derates)
  return _internal_mutable__sdc_timing_derates();
}

// repeated uint64 _sdc_timing_drcs = 5;
inline int SdcConstrainClass::_internal__sdc_timing_drcs_size() const {
  return _impl_._sdc_timing_drcs_.size();
}
inline int SdcConstrainClass::_sdc_timing_drcs_size() const {
  return _internal__sdc_timing_drcs_size();
}
inline void SdcConstrainClass::clear__sdc_timing_drcs() {
  _impl_._sdc_timing_drcs_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_timing_drcs(int index) const {
  return _impl_._sdc_timing_drcs_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_timing_drcs(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_timing_drcs)
  return _internal__sdc_timing_drcs(index);
}
inline void SdcConstrainClass::set__sdc_timing_drcs(int index, uint64_t value) {
  _impl_._sdc_timing_drcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_timing_drcs)
}
inline void SdcConstrainClass::_internal_add__sdc_timing_drcs(uint64_t value) {
  _impl_._sdc_timing_drcs_.Add(value);
}
inline void SdcConstrainClass::add__sdc_timing_drcs(uint64_t value) {
  _internal_add__sdc_timing_drcs(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_timing_drcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_timing_drcs() const {
  return _impl_._sdc_timing_drcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_timing_drcs() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_timing_drcs)
  return _internal__sdc_timing_drcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_timing_drcs() {
  return &_impl_._sdc_timing_drcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_timing_drcs() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_timing_drcs)
  return _internal_mutable__sdc_timing_drcs();
}

// repeated uint64 _sdc_clock_latencys = 6;
inline int SdcConstrainClass::_internal__sdc_clock_latencys_size() const {
  return _impl_._sdc_clock_latencys_.size();
}
inline int SdcConstrainClass::_sdc_clock_latencys_size() const {
  return _internal__sdc_clock_latencys_size();
}
inline void SdcConstrainClass::clear__sdc_clock_latencys() {
  _impl_._sdc_clock_latencys_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_clock_latencys(int index) const {
  return _impl_._sdc_clock_latencys_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_clock_latencys(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_clock_latencys)
  return _internal__sdc_clock_latencys(index);
}
inline void SdcConstrainClass::set__sdc_clock_latencys(int index, uint64_t value) {
  _impl_._sdc_clock_latencys_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_clock_latencys)
}
inline void SdcConstrainClass::_internal_add__sdc_clock_latencys(uint64_t value) {
  _impl_._sdc_clock_latencys_.Add(value);
}
inline void SdcConstrainClass::add__sdc_clock_latencys(uint64_t value) {
  _internal_add__sdc_clock_latencys(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_clock_latencys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_clock_latencys() const {
  return _impl_._sdc_clock_latencys_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_clock_latencys() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_clock_latencys)
  return _internal__sdc_clock_latencys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_clock_latencys() {
  return &_impl_._sdc_clock_latencys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_clock_latencys() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_clock_latencys)
  return _internal_mutable__sdc_clock_latencys();
}

// repeated uint64 _sdc_clock_uncertaintys = 7;
inline int SdcConstrainClass::_internal__sdc_clock_uncertaintys_size() const {
  return _impl_._sdc_clock_uncertaintys_.size();
}
inline int SdcConstrainClass::_sdc_clock_uncertaintys_size() const {
  return _internal__sdc_clock_uncertaintys_size();
}
inline void SdcConstrainClass::clear__sdc_clock_uncertaintys() {
  _impl_._sdc_clock_uncertaintys_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_clock_uncertaintys(int index) const {
  return _impl_._sdc_clock_uncertaintys_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_clock_uncertaintys(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_clock_uncertaintys)
  return _internal__sdc_clock_uncertaintys(index);
}
inline void SdcConstrainClass::set__sdc_clock_uncertaintys(int index, uint64_t value) {
  _impl_._sdc_clock_uncertaintys_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_clock_uncertaintys)
}
inline void SdcConstrainClass::_internal_add__sdc_clock_uncertaintys(uint64_t value) {
  _impl_._sdc_clock_uncertaintys_.Add(value);
}
inline void SdcConstrainClass::add__sdc_clock_uncertaintys(uint64_t value) {
  _internal_add__sdc_clock_uncertaintys(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_clock_uncertaintys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_clock_uncertaintys() const {
  return _impl_._sdc_clock_uncertaintys_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_clock_uncertaintys() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_clock_uncertaintys)
  return _internal__sdc_clock_uncertaintys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_clock_uncertaintys() {
  return &_impl_._sdc_clock_uncertaintys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_clock_uncertaintys() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_clock_uncertaintys)
  return _internal_mutable__sdc_clock_uncertaintys();
}

// repeated uint64 _sdc_clock_groups = 8;
inline int SdcConstrainClass::_internal__sdc_clock_groups_size() const {
  return _impl_._sdc_clock_groups_.size();
}
inline int SdcConstrainClass::_sdc_clock_groups_size() const {
  return _internal__sdc_clock_groups_size();
}
inline void SdcConstrainClass::clear__sdc_clock_groups() {
  _impl_._sdc_clock_groups_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_clock_groups(int index) const {
  return _impl_._sdc_clock_groups_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_clock_groups(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_clock_groups)
  return _internal__sdc_clock_groups(index);
}
inline void SdcConstrainClass::set__sdc_clock_groups(int index, uint64_t value) {
  _impl_._sdc_clock_groups_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_clock_groups)
}
inline void SdcConstrainClass::_internal_add__sdc_clock_groups(uint64_t value) {
  _impl_._sdc_clock_groups_.Add(value);
}
inline void SdcConstrainClass::add__sdc_clock_groups(uint64_t value) {
  _internal_add__sdc_clock_groups(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_clock_groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_clock_groups() const {
  return _impl_._sdc_clock_groups_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_clock_groups() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_clock_groups)
  return _internal__sdc_clock_groups();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_clock_groups() {
  return &_impl_._sdc_clock_groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_clock_groups() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_clock_groups)
  return _internal_mutable__sdc_clock_groups();
}

// repeated uint64 _sdc_exceptions = 9;
inline int SdcConstrainClass::_internal__sdc_exceptions_size() const {
  return _impl_._sdc_exceptions_.size();
}
inline int SdcConstrainClass::_sdc_exceptions_size() const {
  return _internal__sdc_exceptions_size();
}
inline void SdcConstrainClass::clear__sdc_exceptions() {
  _impl_._sdc_exceptions_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_exceptions(int index) const {
  return _impl_._sdc_exceptions_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_exceptions(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_exceptions)
  return _internal__sdc_exceptions(index);
}
inline void SdcConstrainClass::set__sdc_exceptions(int index, uint64_t value) {
  _impl_._sdc_exceptions_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_exceptions)
}
inline void SdcConstrainClass::_internal_add__sdc_exceptions(uint64_t value) {
  _impl_._sdc_exceptions_.Add(value);
}
inline void SdcConstrainClass::add__sdc_exceptions(uint64_t value) {
  _internal_add__sdc_exceptions(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_exceptions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_exceptions() const {
  return _impl_._sdc_exceptions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_exceptions() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_exceptions)
  return _internal__sdc_exceptions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_exceptions() {
  return &_impl_._sdc_exceptions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_exceptions() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_exceptions)
  return _internal_mutable__sdc_exceptions();
}

// repeated uint64 _sdc_collections = 10;
inline int SdcConstrainClass::_internal__sdc_collections_size() const {
  return _impl_._sdc_collections_.size();
}
inline int SdcConstrainClass::_sdc_collections_size() const {
  return _internal__sdc_collections_size();
}
inline void SdcConstrainClass::clear__sdc_collections() {
  _impl_._sdc_collections_.Clear();
}
inline uint64_t SdcConstrainClass::_internal__sdc_collections(int index) const {
  return _impl_._sdc_collections_.Get(index);
}
inline uint64_t SdcConstrainClass::_sdc_collections(int index) const {
  // @@protoc_insertion_point(field_get:Sdc.SdcConstrainClass._sdc_collections)
  return _internal__sdc_collections(index);
}
inline void SdcConstrainClass::set__sdc_collections(int index, uint64_t value) {
  _impl_._sdc_collections_.Set(index, value);
  // @@protoc_insertion_point(field_set:Sdc.SdcConstrainClass._sdc_collections)
}
inline void SdcConstrainClass::_internal_add__sdc_collections(uint64_t value) {
  _impl_._sdc_collections_.Add(value);
}
inline void SdcConstrainClass::add__sdc_collections(uint64_t value) {
  _internal_add__sdc_collections(value);
  // @@protoc_insertion_point(field_add:Sdc.SdcConstrainClass._sdc_collections)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_internal__sdc_collections() const {
  return _impl_._sdc_collections_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SdcConstrainClass::_sdc_collections() const {
  // @@protoc_insertion_point(field_list:Sdc.SdcConstrainClass._sdc_collections)
  return _internal__sdc_collections();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::_internal_mutable__sdc_collections() {
  return &_impl_._sdc_collections_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SdcConstrainClass::mutable__sdc_collections() {
  // @@protoc_insertion_point(field_mutable_list:Sdc.SdcConstrainClass._sdc_collections)
  return _internal_mutable__sdc_collections();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Sdc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Sdc::SdcCollectionTypeEnum_CollectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Sdc::SdcCollectionTypeEnum_CollectionType>() {
  return ::Sdc::SdcCollectionTypeEnum_CollectionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SdcConstrains_2eproto
