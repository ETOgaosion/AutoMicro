// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StaStructure.proto

#include "StaStructure.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace StaStructure {
PROTOBUF_CONSTEXPR ClockTypeEnum::ClockTypeEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ct_)*/0} {}
struct ClockTypeEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClockTypeEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClockTypeEnumDefaultTypeInternal() {}
  union {
    ClockTypeEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClockTypeEnumDefaultTypeInternal _ClockTypeEnum_default_instance_;
PROTOBUF_CONSTEXPR StaWaveFormClass::StaWaveFormClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._wave_edges_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StaWaveFormClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaWaveFormClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaWaveFormClassDefaultTypeInternal() {}
  union {
    StaWaveFormClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaWaveFormClassDefaultTypeInternal _StaWaveFormClass_default_instance_;
PROTOBUF_CONSTEXPR StaClockClass::StaClockClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._clock_vertexes_)*/{}
  , /*decltype(_impl_._clock_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._clock_type_)*/nullptr
  , /*decltype(_impl_._wave_form_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._ideal_network_latency_)*/0
  , /*decltype(_impl_._period_)*/0} {}
struct StaClockClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaClockClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaClockClassDefaultTypeInternal() {}
  union {
    StaClockClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaClockClassDefaultTypeInternal _StaClockClass_default_instance_;
PROTOBUF_CONSTEXPR StaDataClass::StaDataClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._delay_type_)*/nullptr
  , /*decltype(_impl_._trans_type_)*/nullptr
  , /*decltype(_impl_._own_vertex_)*/uint64_t{0u}
  , /*decltype(_impl_._fwd_)*/uint64_t{0u}
  , /*decltype(_impl_._bwd_)*/uint64_t{0u}} {}
struct StaDataClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaDataClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaDataClassDefaultTypeInternal() {}
  union {
    StaDataClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaDataClassDefaultTypeInternal _StaDataClass_default_instance_;
PROTOBUF_CONSTEXPR StaSlewDataClass::StaSlewDataClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._output_current_data_)*/uint64_t{0u}
  , /*decltype(_impl_._slew_)*/0} {}
struct StaSlewDataClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaSlewDataClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaSlewDataClassDefaultTypeInternal() {}
  union {
    StaSlewDataClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaSlewDataClassDefaultTypeInternal _StaSlewDataClass_default_instance_;
PROTOBUF_CONSTEXPR StaArcDelayDataClass::StaArcDelayDataClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._own_arc_)*/uint64_t{0u}
  , /*decltype(_impl_._arc_delay_)*/0} {}
struct StaArcDelayDataClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaArcDelayDataClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaArcDelayDataClassDefaultTypeInternal() {}
  union {
    StaArcDelayDataClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaArcDelayDataClassDefaultTypeInternal _StaArcDelayDataClass_default_instance_;
PROTOBUF_CONSTEXPR StaPathDelayDataClass::StaPathDelayDataClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._arrive_time_)*/int64_t{0}
  , /*decltype(_impl_._launch_clock_data_)*/uint64_t{0u}
  , /*decltype(_impl_._req_time_)*/0} {}
struct StaPathDelayDataClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaPathDelayDataClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaPathDelayDataClassDefaultTypeInternal() {}
  union {
    StaPathDelayDataClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaPathDelayDataClassDefaultTypeInternal _StaPathDelayDataClass_default_instance_;
PROTOBUF_CONSTEXPR StaClockDataClass::StaClockDataClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._clock_wave_type_)*/nullptr
  , /*decltype(_impl_._arrive_time_)*/int64_t{0}
  , /*decltype(_impl_._prop_clock_)*/uint64_t{0u}} {}
struct StaClockDataClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaClockDataClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaClockDataClassDefaultTypeInternal() {}
  union {
    StaClockDataClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaClockDataClassDefaultTypeInternal _StaClockDataClass_default_instance_;
PROTOBUF_CONSTEXPR StaDataSyn::StaDataSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.sds_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StaDataSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaDataSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaDataSynDefaultTypeInternal() {}
  union {
    StaDataSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaDataSynDefaultTypeInternal _StaDataSyn_default_instance_;
PROTOBUF_CONSTEXPR StaDataBucketClass::StaDataBucketClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._data_list_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._n_worst_)*/0u
  , /*decltype(_impl_._count_)*/0u
  , /*decltype(_impl_._next_)*/uint64_t{0u}} {}
struct StaDataBucketClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaDataBucketClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaDataBucketClassDefaultTypeInternal() {}
  union {
    StaDataBucketClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaDataBucketClassDefaultTypeInternal _StaDataBucketClass_default_instance_;
PROTOBUF_CONSTEXPR StaArcClass::StaArcClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._src_)*/uint64_t{0u}
  , /*decltype(_impl_._snk_)*/uint64_t{0u}
  , /*decltype(_impl_._arc_delay_bucket_)*/uint64_t{0u}
  , /*decltype(_impl_._is_loop_disable_)*/false} {}
struct StaArcClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaArcClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaArcClassDefaultTypeInternal() {}
  union {
    StaArcClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaArcClassDefaultTypeInternal _StaArcClass_default_instance_;
PROTOBUF_CONSTEXPR StaNetArcClass::StaNetArcClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._net_)*/uint64_t{0u}} {}
struct StaNetArcClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaNetArcClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaNetArcClassDefaultTypeInternal() {}
  union {
    StaNetArcClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaNetArcClassDefaultTypeInternal _StaNetArcClass_default_instance_;
PROTOBUF_CONSTEXPR StaInstArcClass::StaInstArcClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._arc_)*/uint64_t{0u}
  , /*decltype(_impl_._inst_)*/uint64_t{0u}} {}
struct StaInstArcClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaInstArcClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaInstArcClassDefaultTypeInternal() {}
  union {
    StaInstArcClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaInstArcClassDefaultTypeInternal _StaInstArcClass_default_instance_;
PROTOBUF_CONSTEXPR StaArcSyn::StaArcSyn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.sas_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StaArcSynDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaArcSynDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaArcSynDefaultTypeInternal() {}
  union {
    StaArcSyn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaArcSynDefaultTypeInternal _StaArcSyn_default_instance_;
PROTOBUF_CONSTEXPR StaVertexClass::StaVertexClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._src_arcs_)*/{}
  , /*decltype(_impl_._snk_arcs_)*/{}
  , /*decltype(_impl_._max_cap_)*/{}
  , /*decltype(_impl_._max_slew_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._obj_)*/uint64_t{0u}
  , /*decltype(_impl_._slew_bucket_)*/uint64_t{0u}
  , /*decltype(_impl_.control_bits_)*/0u
  , /*decltype(_impl_.type_bits_)*/0u
  , /*decltype(_impl_._clock_bucket_)*/uint64_t{0u}
  , /*decltype(_impl_._path_delay_bucket_)*/uint64_t{0u}
  , /*decltype(_impl_._max_fanout_)*/0} {}
struct StaVertexClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaVertexClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaVertexClassDefaultTypeInternal() {}
  union {
    StaVertexClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaVertexClassDefaultTypeInternal _StaVertexClass_default_instance_;
PROTOBUF_CONSTEXPR StaGraphClass::StaGraphClass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._port_vertexes_)*/{}
  , /*decltype(_impl_._start_vertexes_)*/{}
  , /*decltype(_impl_._end_vertexes_)*/{}
  , /*decltype(_impl_._vertexes_)*/{}
  , /*decltype(_impl_._arcs_)*/{}
  , /*decltype(_impl_.obj_vertex_pair_)*/{}
  , /*decltype(_impl_.main_assistant_pair_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._nl_)*/uint64_t{0u}} {}
struct StaGraphClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaGraphClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaGraphClassDefaultTypeInternal() {}
  union {
    StaGraphClass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaGraphClassDefaultTypeInternal _StaGraphClass_default_instance_;
}  // namespace StaStructure
static ::_pb::Metadata file_level_metadata_StaStructure_2eproto[16];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_StaStructure_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_StaStructure_2eproto = nullptr;

const uint32_t TableStruct_StaStructure_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::StaStructure::ClockTypeEnum, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::ClockTypeEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::ClockTypeEnum, _impl_.ct_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaWaveFormClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaWaveFormClass, _impl_._wave_edges_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_._clock_name_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_._clock_vertexes_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_._clock_type_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_._ideal_network_latency_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_._period_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockClass, _impl_._wave_form_),
  3,
  0,
  ~0u,
  1,
  4,
  5,
  2,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataClass, _impl_._delay_type_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataClass, _impl_._trans_type_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataClass, _impl_._own_vertex_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataClass, _impl_._fwd_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataClass, _impl_._bwd_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaSlewDataClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaSlewDataClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaSlewDataClass, _impl_._slew_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaSlewDataClass, _impl_._output_current_data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcDelayDataClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcDelayDataClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcDelayDataClass, _impl_._arc_delay_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcDelayDataClass, _impl_._own_arc_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaPathDelayDataClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaPathDelayDataClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaPathDelayDataClass, _impl_._arrive_time_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaPathDelayDataClass, _impl_._req_time_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaPathDelayDataClass, _impl_._launch_clock_data_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockDataClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockDataClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockDataClass, _impl_._arrive_time_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockDataClass, _impl_._prop_clock_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaClockDataClass, _impl_._clock_wave_type_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataSyn, _impl_.sds_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataBucketClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataBucketClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataBucketClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataBucketClass, _impl_._data_list_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataBucketClass, _impl_._n_worst_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataBucketClass, _impl_._count_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaDataBucketClass, _impl_._next_),
  0,
  ~0u,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcClass, _impl_._src_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcClass, _impl_._snk_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcClass, _impl_._arc_delay_bucket_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcClass, _impl_._is_loop_disable_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaNetArcClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaNetArcClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaNetArcClass, _impl_._net_),
  0,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaInstArcClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaInstArcClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaInstArcClass, _impl_._arc_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaInstArcClass, _impl_._inst_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcSyn, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcSyn, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcSyn, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcSyn, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcSyn, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcSyn, _impl_.parent_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaArcSyn, _impl_.sas_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._obj_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_.control_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._src_arcs_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._snk_arcs_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._slew_bucket_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._clock_bucket_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._path_delay_bucket_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._max_cap_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._max_slew_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_._max_fanout_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaVertexClass, _impl_.type_bits_),
  0,
  1,
  3,
  ~0u,
  ~0u,
  2,
  5,
  6,
  ~0u,
  ~0u,
  7,
  4,
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_._nl_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_._port_vertexes_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_._start_vertexes_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_._end_vertexes_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_._vertexes_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_._arcs_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_.obj_vertex_pair_),
  PROTOBUF_FIELD_OFFSET(::StaStructure::StaGraphClass, _impl_.main_assistant_pair_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::StaStructure::ClockTypeEnum)},
  { 8, -1, -1, sizeof(::StaStructure::StaWaveFormClass)},
  { 15, 28, -1, sizeof(::StaStructure::StaClockClass)},
  { 35, 46, -1, sizeof(::StaStructure::StaDataClass)},
  { 51, 59, -1, sizeof(::StaStructure::StaSlewDataClass)},
  { 61, 69, -1, sizeof(::StaStructure::StaArcDelayDataClass)},
  { 71, 80, -1, sizeof(::StaStructure::StaPathDelayDataClass)},
  { 83, 92, -1, sizeof(::StaStructure::StaClockDataClass)},
  { 95, 109, -1, sizeof(::StaStructure::StaDataSyn)},
  { 116, 127, -1, sizeof(::StaStructure::StaDataBucketClass)},
  { 132, 142, -1, sizeof(::StaStructure::StaArcClass)},
  { 146, 153, -1, sizeof(::StaStructure::StaNetArcClass)},
  { 154, 162, -1, sizeof(::StaStructure::StaInstArcClass)},
  { 164, 176, -1, sizeof(::StaStructure::StaArcSyn)},
  { 181, 199, -1, sizeof(::StaStructure::StaVertexClass)},
  { 211, 226, -1, sizeof(::StaStructure::StaGraphClass)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::StaStructure::_ClockTypeEnum_default_instance_._instance,
  &::StaStructure::_StaWaveFormClass_default_instance_._instance,
  &::StaStructure::_StaClockClass_default_instance_._instance,
  &::StaStructure::_StaDataClass_default_instance_._instance,
  &::StaStructure::_StaSlewDataClass_default_instance_._instance,
  &::StaStructure::_StaArcDelayDataClass_default_instance_._instance,
  &::StaStructure::_StaPathDelayDataClass_default_instance_._instance,
  &::StaStructure::_StaClockDataClass_default_instance_._instance,
  &::StaStructure::_StaDataSyn_default_instance_._instance,
  &::StaStructure::_StaDataBucketClass_default_instance_._instance,
  &::StaStructure::_StaArcClass_default_instance_._instance,
  &::StaStructure::_StaNetArcClass_default_instance_._instance,
  &::StaStructure::_StaInstArcClass_default_instance_._instance,
  &::StaStructure::_StaArcSyn_default_instance_._instance,
  &::StaStructure::_StaVertexClass_default_instance_._instance,
  &::StaStructure::_StaGraphClass_default_instance_._instance,
};

const char descriptor_table_protodef_StaStructure_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022StaStructure.proto\022\014StaStructure\032\021Comm"
  "onTypes.proto\"l\n\rClockTypeEnum\0221\n\002ct\030\001 \002"
  "(\0162%.StaStructure.ClockTypeEnum.ClockTyp"
  "e\"(\n\tClockType\022\n\n\006kIdeal\020\000\022\017\n\013kPropagete"
  "d\020\001\"\'\n\020StaWaveFormClass\022\023\n\013_wave_edges\030\001"
  " \003(\005\"\340\001\n\rStaClockClass\022\n\n\002id\030\001 \002(\004\022\023\n\013_c"
  "lock_name\030\002 \002(\t\022\027\n\017_clock_vertexes\030\003 \003(\004"
  "\0220\n\013_clock_type\030\004 \002(\0132\033.StaStructure.Clo"
  "ckTypeEnum\022\036\n\026_ideal_network_latency\030\005 \001"
  "(\005\022\017\n\007_period\030\006 \002(\005\0222\n\n_wave_form\030\007 \002(\0132"
  "\036.StaStructure.StaWaveFormClass\"\246\001\n\014StaD"
  "ataClass\0223\n\013_delay_type\030\001 \002(\0132\036.Common.T"
  "ypes.AnalysisModeEnum\0220\n\013_trans_type\030\002 \002"
  "(\0132\033.Common.Types.TransTypeEnum\022\023\n\013_own_"
  "vertex\030\003 \002(\004\022\014\n\004_fwd\030\004 \002(\004\022\014\n\004_bwd\030\005 \002(\004"
  "\"\?\n\020StaSlewDataClass\022\r\n\005_slew\030\001 \002(\005\022\034\n\024_"
  "output_current_data\030\002 \001(\004\"<\n\024StaArcDelay"
  "DataClass\022\022\n\n_arc_delay\030\001 \002(\005\022\020\n\010_own_ar"
  "c\030\002 \002(\004\"\\\n\025StaPathDelayDataClass\022\024\n\014_arr"
  "ive_time\030\001 \002(\003\022\021\n\t_req_time\030\002 \001(\005\022\032\n\022_la"
  "unch_clock_data\030\003 \002(\004\"u\n\021StaClockDataCla"
  "ss\022\024\n\014_arrive_time\030\001 \002(\003\022\023\n\013_prop_clock\030"
  "\002 \002(\004\0225\n\020_clock_wave_type\030\003 \002(\0132\033.Common"
  ".Types.TransTypeEnum\"\245\002\n\nStaDataSyn\022\n\n\002i"
  "d\030\001 \002(\004\022\014\n\004type\030\002 \002(\r\022*\n\006parent\030\003 \002(\0132\032."
  "StaStructure.StaDataClass\022.\n\004ssdc\030\004 \001(\0132"
  "\036.StaStructure.StaSlewDataClassH\000\0223\n\005sad"
  "dc\030\005 \001(\0132\".StaStructure.StaArcDelayDataC"
  "lassH\000\0224\n\005spddc\030\006 \001(\0132#.StaStructure.Sta"
  "PathDelayDataClassH\000\022/\n\004scdc\030\007 \001(\0132\037.Sta"
  "Structure.StaClockDataClassH\000B\005\n\003sds\"e\n\022"
  "StaDataBucketClass\022\n\n\002id\030\001 \002(\004\022\022\n\n_data_"
  "list\030\002 \003(\004\022\020\n\010_n_worst\030\003 \002(\r\022\016\n\006_count\030\004"
  " \002(\r\022\r\n\005_next\030\005 \002(\004\"^\n\013StaArcClass\022\014\n\004_s"
  "rc\030\001 \002(\004\022\014\n\004_snk\030\002 \002(\004\022\031\n\021_arc_delay_buc"
  "ket\030\003 \001(\004\022\030\n\020_is_loop_disable\030\004 \002(\010\"\036\n\016S"
  "taNetArcClass\022\014\n\004_net\030\001 \002(\004\".\n\017StaInstAr"
  "cClass\022\014\n\004_arc\030\001 \002(\004\022\r\n\005_inst\030\002 \002(\004\"\264\001\n\t"
  "StaArcSyn\022\n\n\002id\030\001 \002(\004\022\014\n\004type\030\002 \002(\r\022)\n\006p"
  "arent\030\003 \002(\0132\031.StaStructure.StaArcClass\022,"
  "\n\004snac\030\004 \001(\0132\034.StaStructure.StaNetArcCla"
  "ssH\000\022-\n\004siac\030\005 \001(\0132\035.StaStructure.StaIns"
  "tArcClassH\000B\005\n\003sas\"\270\002\n\016StaVertexClass\022\n\n"
  "\002id\030\001 \002(\004\022\014\n\004_obj\030\002 \002(\004\022\024\n\014control_bits\030"
  "\003 \002(\r\022\021\n\t_src_arcs\030\007 \003(\004\022\021\n\t_snk_arcs\030\010 "
  "\003(\004\022\024\n\014_slew_bucket\030\t \001(\004\022\025\n\r_clock_buck"
  "et\030\n \001(\004\022\032\n\022_path_delay_bucket\030\013 \001(\004\022.\n\010"
  "_max_cap\030\014 \003(\0132\034.Common.Types.OptionalDo"
  "uble\022/\n\t_max_slew\030\r \003(\0132\034.Common.Types.O"
  "ptionalDouble\022\023\n\013_max_fanout\030\016 \001(\001\022\021\n\tty"
  "pe_bits\030\017 \002(\r\"\372\001\n\rStaGraphClass\022\n\n\002id\030\001 "
  "\002(\004\022\013\n\003_nl\030\002 \002(\004\022\026\n\016_port_vertexes\030\003 \003(\004"
  "\022\027\n\017_start_vertexes\030\004 \003(\004\022\025\n\r_end_vertex"
  "es\030\005 \003(\004\022\021\n\t_vertexes\030\006 \003(\004\022\r\n\005_arcs\030\007 \003"
  "(\004\0220\n\017obj_vertex_pair\030\010 \003(\0132\027.Common.Typ"
  "es.ULongPair\0224\n\023main_assistant_pair\030\t \003("
  "\0132\027.Common.Types.ULongPair2\\\n\023StaStructu"
  "reService\022E\n\021generateSpefGraph\022\030.Common."
  "Types.StrIntPair\032\026.Common.Types.ULongMsg"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_StaStructure_2eproto_deps[1] = {
  &::descriptor_table_CommonTypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_StaStructure_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_StaStructure_2eproto = {
    false, false, 2360, descriptor_table_protodef_StaStructure_2eproto,
    "StaStructure.proto",
    &descriptor_table_StaStructure_2eproto_once, descriptor_table_StaStructure_2eproto_deps, 1, 16,
    schemas, file_default_instances, TableStruct_StaStructure_2eproto::offsets,
    file_level_metadata_StaStructure_2eproto, file_level_enum_descriptors_StaStructure_2eproto,
    file_level_service_descriptors_StaStructure_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_StaStructure_2eproto_getter() {
  return &descriptor_table_StaStructure_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_StaStructure_2eproto(&descriptor_table_StaStructure_2eproto);
namespace StaStructure {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClockTypeEnum_ClockType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_StaStructure_2eproto);
  return file_level_enum_descriptors_StaStructure_2eproto[0];
}
bool ClockTypeEnum_ClockType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClockTypeEnum_ClockType ClockTypeEnum::kIdeal;
constexpr ClockTypeEnum_ClockType ClockTypeEnum::kPropageted;
constexpr ClockTypeEnum_ClockType ClockTypeEnum::ClockType_MIN;
constexpr ClockTypeEnum_ClockType ClockTypeEnum::ClockType_MAX;
constexpr int ClockTypeEnum::ClockType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ClockTypeEnum::_Internal {
 public:
  using HasBits = decltype(std::declval<ClockTypeEnum>()._impl_._has_bits_);
  static void set_has_ct(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ClockTypeEnum::ClockTypeEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.ClockTypeEnum)
}
ClockTypeEnum::ClockTypeEnum(const ClockTypeEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClockTypeEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ct_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ct_ = from._impl_.ct_;
  // @@protoc_insertion_point(copy_constructor:StaStructure.ClockTypeEnum)
}

inline void ClockTypeEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ct_){0}
  };
}

ClockTypeEnum::~ClockTypeEnum() {
  // @@protoc_insertion_point(destructor:StaStructure.ClockTypeEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClockTypeEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClockTypeEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClockTypeEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.ClockTypeEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ct_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClockTypeEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .StaStructure.ClockTypeEnum.ClockType ct = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::StaStructure::ClockTypeEnum_ClockType_IsValid(val))) {
            _internal_set_ct(static_cast<::StaStructure::ClockTypeEnum_ClockType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClockTypeEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.ClockTypeEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .StaStructure.ClockTypeEnum.ClockType ct = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ct(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.ClockTypeEnum)
  return target;
}

size_t ClockTypeEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.ClockTypeEnum)
  size_t total_size = 0;

  // required .StaStructure.ClockTypeEnum.ClockType ct = 1;
  if (_internal_has_ct()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_ct());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClockTypeEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClockTypeEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClockTypeEnum::GetClassData() const { return &_class_data_; }


void ClockTypeEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClockTypeEnum*>(&to_msg);
  auto& from = static_cast<const ClockTypeEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.ClockTypeEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ct()) {
    _this->_internal_set_ct(from._internal_ct());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClockTypeEnum::CopyFrom(const ClockTypeEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.ClockTypeEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClockTypeEnum::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClockTypeEnum::InternalSwap(ClockTypeEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ct_, other->_impl_.ct_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClockTypeEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[0]);
}

// ===================================================================

class StaWaveFormClass::_Internal {
 public:
};

StaWaveFormClass::StaWaveFormClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaWaveFormClass)
}
StaWaveFormClass::StaWaveFormClass(const StaWaveFormClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaWaveFormClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._wave_edges_){from._impl_._wave_edges_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaWaveFormClass)
}

inline void StaWaveFormClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._wave_edges_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StaWaveFormClass::~StaWaveFormClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaWaveFormClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaWaveFormClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._wave_edges_.~RepeatedField();
}

void StaWaveFormClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaWaveFormClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaWaveFormClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._wave_edges_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaWaveFormClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 _wave_edges = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__wave_edges(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable__wave_edges(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaWaveFormClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaWaveFormClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 _wave_edges = 1;
  for (int i = 0, n = this->_internal__wave_edges_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal__wave_edges(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaWaveFormClass)
  return target;
}

size_t StaWaveFormClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaWaveFormClass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 _wave_edges = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_._wave_edges_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__wave_edges_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaWaveFormClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaWaveFormClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaWaveFormClass::GetClassData() const { return &_class_data_; }


void StaWaveFormClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaWaveFormClass*>(&to_msg);
  auto& from = static_cast<const StaWaveFormClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaWaveFormClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._wave_edges_.MergeFrom(from._impl_._wave_edges_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaWaveFormClass::CopyFrom(const StaWaveFormClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaWaveFormClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaWaveFormClass::IsInitialized() const {
  return true;
}

void StaWaveFormClass::InternalSwap(StaWaveFormClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_._wave_edges_.InternalSwap(&other->_impl_._wave_edges_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaWaveFormClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[1]);
}

// ===================================================================

class StaClockClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaClockClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__clock_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::StaStructure::ClockTypeEnum& _clock_type(const StaClockClass* msg);
  static void set_has__clock_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__ideal_network_latency(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has__period(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::StaStructure::StaWaveFormClass& _wave_form(const StaClockClass* msg);
  static void set_has__wave_form(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000002f) ^ 0x0000002f) != 0;
  }
};

const ::StaStructure::ClockTypeEnum&
StaClockClass::_Internal::_clock_type(const StaClockClass* msg) {
  return *msg->_impl_._clock_type_;
}
const ::StaStructure::StaWaveFormClass&
StaClockClass::_Internal::_wave_form(const StaClockClass* msg) {
  return *msg->_impl_._wave_form_;
}
StaClockClass::StaClockClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaClockClass)
}
StaClockClass::StaClockClass(const StaClockClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaClockClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._clock_vertexes_){from._impl_._clock_vertexes_}
    , decltype(_impl_._clock_name_){}
    , decltype(_impl_._clock_type_){nullptr}
    , decltype(_impl_._wave_form_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_._ideal_network_latency_){}
    , decltype(_impl_._period_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._clock_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has__clock_name()) {
    _this->_impl_._clock_name_.Set(from._internal__clock_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has__clock_type()) {
    _this->_impl_._clock_type_ = new ::StaStructure::ClockTypeEnum(*from._impl_._clock_type_);
  }
  if (from._internal_has__wave_form()) {
    _this->_impl_._wave_form_ = new ::StaStructure::StaWaveFormClass(*from._impl_._wave_form_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._period_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._period_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaClockClass)
}

inline void StaClockClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._clock_vertexes_){arena}
    , decltype(_impl_._clock_name_){}
    , decltype(_impl_._clock_type_){nullptr}
    , decltype(_impl_._wave_form_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._ideal_network_latency_){0}
    , decltype(_impl_._period_){0}
  };
  _impl_._clock_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_._clock_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StaClockClass::~StaClockClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaClockClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaClockClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._clock_vertexes_.~RepeatedField();
  _impl_._clock_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_._clock_type_;
  if (this != internal_default_instance()) delete _impl_._wave_form_;
}

void StaClockClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaClockClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaClockClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._clock_vertexes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_._clock_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_._clock_type_ != nullptr);
      _impl_._clock_type_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_._wave_form_ != nullptr);
      _impl_._wave_form_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._period_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._period_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaClockClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string _clock_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable__clock_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "StaStructure.StaClockClass._clock_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _clock_vertexes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__clock_vertexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__clock_vertexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .StaStructure.ClockTypeEnum _clock_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable__clock_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 _ideal_network_latency = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__ideal_network_latency(&has_bits);
          _impl_._ideal_network_latency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 _period = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has__period(&has_bits);
          _impl_._period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .StaStructure.StaWaveFormClass _wave_form = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable__wave_form(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaClockClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaClockClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required string _clock_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal__clock_name().data(), static_cast<int>(this->_internal__clock_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StaStructure.StaClockClass._clock_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal__clock_name(), target);
  }

  // repeated uint64 _clock_vertexes = 3;
  for (int i = 0, n = this->_internal__clock_vertexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__clock_vertexes(i), target);
  }

  // required .StaStructure.ClockTypeEnum _clock_type = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::_clock_type(this),
        _Internal::_clock_type(this).GetCachedSize(), target, stream);
  }

  // optional int32 _ideal_network_latency = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal__ideal_network_latency(), target);
  }

  // required int32 _period = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal__period(), target);
  }

  // required .StaStructure.StaWaveFormClass _wave_form = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::_wave_form(this),
        _Internal::_wave_form(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaClockClass)
  return target;
}

size_t StaClockClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaClockClass)
  size_t total_size = 0;

  if (_internal_has__clock_name()) {
    // required string _clock_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__clock_name());
  }

  if (_internal_has__clock_type()) {
    // required .StaStructure.ClockTypeEnum _clock_type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._clock_type_);
  }

  if (_internal_has__wave_form()) {
    // required .StaStructure.StaWaveFormClass _wave_form = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._wave_form_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has__period()) {
    // required int32 _period = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__period());
  }

  return total_size;
}
size_t StaClockClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaClockClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000002f) ^ 0x0000002f) == 0) {  // All required fields are present.
    // required string _clock_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal__clock_name());

    // required .StaStructure.ClockTypeEnum _clock_type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._clock_type_);

    // required .StaStructure.StaWaveFormClass _wave_form = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._wave_form_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required int32 _period = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__period());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _clock_vertexes = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._clock_vertexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__clock_vertexes_size());
    total_size += data_size;
  }

  // optional int32 _ideal_network_latency = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__ideal_network_latency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaClockClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaClockClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaClockClass::GetClassData() const { return &_class_data_; }


void StaClockClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaClockClass*>(&to_msg);
  auto& from = static_cast<const StaClockClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaClockClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._clock_vertexes_.MergeFrom(from._impl_._clock_vertexes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set__clock_name(from._internal__clock_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable__clock_type()->::StaStructure::ClockTypeEnum::MergeFrom(
          from._internal__clock_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable__wave_form()->::StaStructure::StaWaveFormClass::MergeFrom(
          from._internal__wave_form());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_._ideal_network_latency_ = from._impl_._ideal_network_latency_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_._period_ = from._impl_._period_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaClockClass::CopyFrom(const StaClockClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaClockClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaClockClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__clock_type()) {
    if (!_impl_._clock_type_->IsInitialized()) return false;
  }
  return true;
}

void StaClockClass::InternalSwap(StaClockClass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._clock_vertexes_.InternalSwap(&other->_impl_._clock_vertexes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_._clock_name_, lhs_arena,
      &other->_impl_._clock_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaClockClass, _impl_._period_)
      + sizeof(StaClockClass::_impl_._period_)
      - PROTOBUF_FIELD_OFFSET(StaClockClass, _impl_._clock_type_)>(
          reinterpret_cast<char*>(&_impl_._clock_type_),
          reinterpret_cast<char*>(&other->_impl_._clock_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaClockClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[2]);
}

// ===================================================================

class StaDataClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaDataClass>()._impl_._has_bits_);
  static const ::Common::Types::AnalysisModeEnum& _delay_type(const StaDataClass* msg);
  static void set_has__delay_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Common::Types::TransTypeEnum& _trans_type(const StaDataClass* msg);
  static void set_has__trans_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__own_vertex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__fwd(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__bwd(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::Common::Types::AnalysisModeEnum&
StaDataClass::_Internal::_delay_type(const StaDataClass* msg) {
  return *msg->_impl_._delay_type_;
}
const ::Common::Types::TransTypeEnum&
StaDataClass::_Internal::_trans_type(const StaDataClass* msg) {
  return *msg->_impl_._trans_type_;
}
void StaDataClass::clear__delay_type() {
  if (_impl_._delay_type_ != nullptr) _impl_._delay_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void StaDataClass::clear__trans_type() {
  if (_impl_._trans_type_ != nullptr) _impl_._trans_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
StaDataClass::StaDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaDataClass)
}
StaDataClass::StaDataClass(const StaDataClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaDataClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._delay_type_){nullptr}
    , decltype(_impl_._trans_type_){nullptr}
    , decltype(_impl_._own_vertex_){}
    , decltype(_impl_._fwd_){}
    , decltype(_impl_._bwd_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has__delay_type()) {
    _this->_impl_._delay_type_ = new ::Common::Types::AnalysisModeEnum(*from._impl_._delay_type_);
  }
  if (from._internal_has__trans_type()) {
    _this->_impl_._trans_type_ = new ::Common::Types::TransTypeEnum(*from._impl_._trans_type_);
  }
  ::memcpy(&_impl_._own_vertex_, &from._impl_._own_vertex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._bwd_) -
    reinterpret_cast<char*>(&_impl_._own_vertex_)) + sizeof(_impl_._bwd_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaDataClass)
}

inline void StaDataClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._delay_type_){nullptr}
    , decltype(_impl_._trans_type_){nullptr}
    , decltype(_impl_._own_vertex_){uint64_t{0u}}
    , decltype(_impl_._fwd_){uint64_t{0u}}
    , decltype(_impl_._bwd_){uint64_t{0u}}
  };
}

StaDataClass::~StaDataClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaDataClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaDataClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_._delay_type_;
  if (this != internal_default_instance()) delete _impl_._trans_type_;
}

void StaDataClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaDataClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaDataClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_._delay_type_ != nullptr);
      _impl_._delay_type_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_._trans_type_ != nullptr);
      _impl_._trans_type_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_._own_vertex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._bwd_) -
        reinterpret_cast<char*>(&_impl_._own_vertex_)) + sizeof(_impl_._bwd_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaDataClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Common.Types.AnalysisModeEnum _delay_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable__delay_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Common.Types.TransTypeEnum _trans_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable__trans_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _own_vertex = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__own_vertex(&has_bits);
          _impl_._own_vertex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _fwd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__fwd(&has_bits);
          _impl_._fwd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _bwd = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__bwd(&has_bits);
          _impl_._bwd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaDataClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaDataClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Common.Types.AnalysisModeEnum _delay_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::_delay_type(this),
        _Internal::_delay_type(this).GetCachedSize(), target, stream);
  }

  // required .Common.Types.TransTypeEnum _trans_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::_trans_type(this),
        _Internal::_trans_type(this).GetCachedSize(), target, stream);
  }

  // required uint64 _own_vertex = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__own_vertex(), target);
  }

  // required uint64 _fwd = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__fwd(), target);
  }

  // required uint64 _bwd = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__bwd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaDataClass)
  return target;
}

size_t StaDataClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaDataClass)
  size_t total_size = 0;

  if (_internal_has__delay_type()) {
    // required .Common.Types.AnalysisModeEnum _delay_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._delay_type_);
  }

  if (_internal_has__trans_type()) {
    // required .Common.Types.TransTypeEnum _trans_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._trans_type_);
  }

  if (_internal_has__own_vertex()) {
    // required uint64 _own_vertex = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__own_vertex());
  }

  if (_internal_has__fwd()) {
    // required uint64 _fwd = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__fwd());
  }

  if (_internal_has__bwd()) {
    // required uint64 _bwd = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__bwd());
  }

  return total_size;
}
size_t StaDataClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaDataClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .Common.Types.AnalysisModeEnum _delay_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._delay_type_);

    // required .Common.Types.TransTypeEnum _trans_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._trans_type_);

    // required uint64 _own_vertex = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__own_vertex());

    // required uint64 _fwd = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__fwd());

    // required uint64 _bwd = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__bwd());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaDataClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaDataClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaDataClass::GetClassData() const { return &_class_data_; }


void StaDataClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaDataClass*>(&to_msg);
  auto& from = static_cast<const StaDataClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaDataClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable__delay_type()->::Common::Types::AnalysisModeEnum::MergeFrom(
          from._internal__delay_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable__trans_type()->::Common::Types::TransTypeEnum::MergeFrom(
          from._internal__trans_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._own_vertex_ = from._impl_._own_vertex_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._fwd_ = from._impl_._fwd_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_._bwd_ = from._impl_._bwd_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaDataClass::CopyFrom(const StaDataClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaDataClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaDataClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__delay_type()) {
    if (!_impl_._delay_type_->IsInitialized()) return false;
  }
  if (_internal_has__trans_type()) {
    if (!_impl_._trans_type_->IsInitialized()) return false;
  }
  return true;
}

void StaDataClass::InternalSwap(StaDataClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaDataClass, _impl_._bwd_)
      + sizeof(StaDataClass::_impl_._bwd_)
      - PROTOBUF_FIELD_OFFSET(StaDataClass, _impl_._delay_type_)>(
          reinterpret_cast<char*>(&_impl_._delay_type_),
          reinterpret_cast<char*>(&other->_impl_._delay_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaDataClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[3]);
}

// ===================================================================

class StaSlewDataClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaSlewDataClass>()._impl_._has_bits_);
  static void set_has__slew(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__output_current_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

StaSlewDataClass::StaSlewDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaSlewDataClass)
}
StaSlewDataClass::StaSlewDataClass(const StaSlewDataClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaSlewDataClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._output_current_data_){}
    , decltype(_impl_._slew_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._output_current_data_, &from._impl_._output_current_data_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._slew_) -
    reinterpret_cast<char*>(&_impl_._output_current_data_)) + sizeof(_impl_._slew_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaSlewDataClass)
}

inline void StaSlewDataClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._output_current_data_){uint64_t{0u}}
    , decltype(_impl_._slew_){0}
  };
}

StaSlewDataClass::~StaSlewDataClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaSlewDataClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaSlewDataClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaSlewDataClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaSlewDataClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaSlewDataClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._output_current_data_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._slew_) -
        reinterpret_cast<char*>(&_impl_._output_current_data_)) + sizeof(_impl_._slew_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaSlewDataClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _slew = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__slew(&has_bits);
          _impl_._slew_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _output_current_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__output_current_data(&has_bits);
          _impl_._output_current_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaSlewDataClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaSlewDataClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _slew = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal__slew(), target);
  }

  // optional uint64 _output_current_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__output_current_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaSlewDataClass)
  return target;
}

size_t StaSlewDataClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaSlewDataClass)
  size_t total_size = 0;

  // required int32 _slew = 1;
  if (_internal_has__slew()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__slew());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 _output_current_data = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__output_current_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaSlewDataClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaSlewDataClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaSlewDataClass::GetClassData() const { return &_class_data_; }


void StaSlewDataClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaSlewDataClass*>(&to_msg);
  auto& from = static_cast<const StaSlewDataClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaSlewDataClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._output_current_data_ = from._impl_._output_current_data_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._slew_ = from._impl_._slew_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaSlewDataClass::CopyFrom(const StaSlewDataClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaSlewDataClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaSlewDataClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaSlewDataClass::InternalSwap(StaSlewDataClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaSlewDataClass, _impl_._slew_)
      + sizeof(StaSlewDataClass::_impl_._slew_)
      - PROTOBUF_FIELD_OFFSET(StaSlewDataClass, _impl_._output_current_data_)>(
          reinterpret_cast<char*>(&_impl_._output_current_data_),
          reinterpret_cast<char*>(&other->_impl_._output_current_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaSlewDataClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[4]);
}

// ===================================================================

class StaArcDelayDataClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaArcDelayDataClass>()._impl_._has_bits_);
  static void set_has__arc_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__own_arc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

StaArcDelayDataClass::StaArcDelayDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaArcDelayDataClass)
}
StaArcDelayDataClass::StaArcDelayDataClass(const StaArcDelayDataClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaArcDelayDataClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._own_arc_){}
    , decltype(_impl_._arc_delay_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._own_arc_, &from._impl_._own_arc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._arc_delay_) -
    reinterpret_cast<char*>(&_impl_._own_arc_)) + sizeof(_impl_._arc_delay_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaArcDelayDataClass)
}

inline void StaArcDelayDataClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._own_arc_){uint64_t{0u}}
    , decltype(_impl_._arc_delay_){0}
  };
}

StaArcDelayDataClass::~StaArcDelayDataClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaArcDelayDataClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaArcDelayDataClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaArcDelayDataClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaArcDelayDataClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaArcDelayDataClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._own_arc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._arc_delay_) -
        reinterpret_cast<char*>(&_impl_._own_arc_)) + sizeof(_impl_._arc_delay_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaArcDelayDataClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 _arc_delay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__arc_delay(&has_bits);
          _impl_._arc_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _own_arc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__own_arc(&has_bits);
          _impl_._own_arc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaArcDelayDataClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaArcDelayDataClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 _arc_delay = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal__arc_delay(), target);
  }

  // required uint64 _own_arc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__own_arc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaArcDelayDataClass)
  return target;
}

size_t StaArcDelayDataClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaArcDelayDataClass)
  size_t total_size = 0;

  if (_internal_has__own_arc()) {
    // required uint64 _own_arc = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__own_arc());
  }

  if (_internal_has__arc_delay()) {
    // required int32 _arc_delay = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__arc_delay());
  }

  return total_size;
}
size_t StaArcDelayDataClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaArcDelayDataClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 _own_arc = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__own_arc());

    // required int32 _arc_delay = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__arc_delay());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaArcDelayDataClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaArcDelayDataClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaArcDelayDataClass::GetClassData() const { return &_class_data_; }


void StaArcDelayDataClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaArcDelayDataClass*>(&to_msg);
  auto& from = static_cast<const StaArcDelayDataClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaArcDelayDataClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._own_arc_ = from._impl_._own_arc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._arc_delay_ = from._impl_._arc_delay_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaArcDelayDataClass::CopyFrom(const StaArcDelayDataClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaArcDelayDataClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaArcDelayDataClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaArcDelayDataClass::InternalSwap(StaArcDelayDataClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaArcDelayDataClass, _impl_._arc_delay_)
      + sizeof(StaArcDelayDataClass::_impl_._arc_delay_)
      - PROTOBUF_FIELD_OFFSET(StaArcDelayDataClass, _impl_._own_arc_)>(
          reinterpret_cast<char*>(&_impl_._own_arc_),
          reinterpret_cast<char*>(&other->_impl_._own_arc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaArcDelayDataClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[5]);
}

// ===================================================================

class StaPathDelayDataClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaPathDelayDataClass>()._impl_._has_bits_);
  static void set_has__arrive_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__req_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__launch_clock_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

StaPathDelayDataClass::StaPathDelayDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaPathDelayDataClass)
}
StaPathDelayDataClass::StaPathDelayDataClass(const StaPathDelayDataClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaPathDelayDataClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._arrive_time_){}
    , decltype(_impl_._launch_clock_data_){}
    , decltype(_impl_._req_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._arrive_time_, &from._impl_._arrive_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._req_time_) -
    reinterpret_cast<char*>(&_impl_._arrive_time_)) + sizeof(_impl_._req_time_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaPathDelayDataClass)
}

inline void StaPathDelayDataClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._arrive_time_){int64_t{0}}
    , decltype(_impl_._launch_clock_data_){uint64_t{0u}}
    , decltype(_impl_._req_time_){0}
  };
}

StaPathDelayDataClass::~StaPathDelayDataClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaPathDelayDataClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaPathDelayDataClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaPathDelayDataClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaPathDelayDataClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaPathDelayDataClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_._arrive_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._req_time_) -
        reinterpret_cast<char*>(&_impl_._arrive_time_)) + sizeof(_impl_._req_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaPathDelayDataClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 _arrive_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__arrive_time(&has_bits);
          _impl_._arrive_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 _req_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__req_time(&has_bits);
          _impl_._req_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _launch_clock_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__launch_clock_data(&has_bits);
          _impl_._launch_clock_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaPathDelayDataClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaPathDelayDataClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 _arrive_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal__arrive_time(), target);
  }

  // optional int32 _req_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal__req_time(), target);
  }

  // required uint64 _launch_clock_data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__launch_clock_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaPathDelayDataClass)
  return target;
}

size_t StaPathDelayDataClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaPathDelayDataClass)
  size_t total_size = 0;

  if (_internal_has__arrive_time()) {
    // required int64 _arrive_time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal__arrive_time());
  }

  if (_internal_has__launch_clock_data()) {
    // required uint64 _launch_clock_data = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__launch_clock_data());
  }

  return total_size;
}
size_t StaPathDelayDataClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaPathDelayDataClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 _arrive_time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal__arrive_time());

    // required uint64 _launch_clock_data = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__launch_clock_data());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 _req_time = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal__req_time());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaPathDelayDataClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaPathDelayDataClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaPathDelayDataClass::GetClassData() const { return &_class_data_; }


void StaPathDelayDataClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaPathDelayDataClass*>(&to_msg);
  auto& from = static_cast<const StaPathDelayDataClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaPathDelayDataClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._arrive_time_ = from._impl_._arrive_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._launch_clock_data_ = from._impl_._launch_clock_data_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._req_time_ = from._impl_._req_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaPathDelayDataClass::CopyFrom(const StaPathDelayDataClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaPathDelayDataClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaPathDelayDataClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaPathDelayDataClass::InternalSwap(StaPathDelayDataClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaPathDelayDataClass, _impl_._req_time_)
      + sizeof(StaPathDelayDataClass::_impl_._req_time_)
      - PROTOBUF_FIELD_OFFSET(StaPathDelayDataClass, _impl_._arrive_time_)>(
          reinterpret_cast<char*>(&_impl_._arrive_time_),
          reinterpret_cast<char*>(&other->_impl_._arrive_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaPathDelayDataClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[6]);
}

// ===================================================================

class StaClockDataClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaClockDataClass>()._impl_._has_bits_);
  static void set_has__arrive_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__prop_clock(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Common::Types::TransTypeEnum& _clock_wave_type(const StaClockDataClass* msg);
  static void set_has__clock_wave_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::Common::Types::TransTypeEnum&
StaClockDataClass::_Internal::_clock_wave_type(const StaClockDataClass* msg) {
  return *msg->_impl_._clock_wave_type_;
}
void StaClockDataClass::clear__clock_wave_type() {
  if (_impl_._clock_wave_type_ != nullptr) _impl_._clock_wave_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StaClockDataClass::StaClockDataClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaClockDataClass)
}
StaClockDataClass::StaClockDataClass(const StaClockDataClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaClockDataClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._clock_wave_type_){nullptr}
    , decltype(_impl_._arrive_time_){}
    , decltype(_impl_._prop_clock_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has__clock_wave_type()) {
    _this->_impl_._clock_wave_type_ = new ::Common::Types::TransTypeEnum(*from._impl_._clock_wave_type_);
  }
  ::memcpy(&_impl_._arrive_time_, &from._impl_._arrive_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._prop_clock_) -
    reinterpret_cast<char*>(&_impl_._arrive_time_)) + sizeof(_impl_._prop_clock_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaClockDataClass)
}

inline void StaClockDataClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._clock_wave_type_){nullptr}
    , decltype(_impl_._arrive_time_){int64_t{0}}
    , decltype(_impl_._prop_clock_){uint64_t{0u}}
  };
}

StaClockDataClass::~StaClockDataClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaClockDataClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaClockDataClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_._clock_wave_type_;
}

void StaClockDataClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaClockDataClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaClockDataClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_._clock_wave_type_ != nullptr);
    _impl_._clock_wave_type_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_._arrive_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._prop_clock_) -
        reinterpret_cast<char*>(&_impl_._arrive_time_)) + sizeof(_impl_._prop_clock_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaClockDataClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 _arrive_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__arrive_time(&has_bits);
          _impl_._arrive_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _prop_clock = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__prop_clock(&has_bits);
          _impl_._prop_clock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Common.Types.TransTypeEnum _clock_wave_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable__clock_wave_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaClockDataClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaClockDataClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 _arrive_time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal__arrive_time(), target);
  }

  // required uint64 _prop_clock = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__prop_clock(), target);
  }

  // required .Common.Types.TransTypeEnum _clock_wave_type = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::_clock_wave_type(this),
        _Internal::_clock_wave_type(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaClockDataClass)
  return target;
}

size_t StaClockDataClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaClockDataClass)
  size_t total_size = 0;

  if (_internal_has__clock_wave_type()) {
    // required .Common.Types.TransTypeEnum _clock_wave_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._clock_wave_type_);
  }

  if (_internal_has__arrive_time()) {
    // required int64 _arrive_time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal__arrive_time());
  }

  if (_internal_has__prop_clock()) {
    // required uint64 _prop_clock = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__prop_clock());
  }

  return total_size;
}
size_t StaClockDataClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaClockDataClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Common.Types.TransTypeEnum _clock_wave_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_._clock_wave_type_);

    // required int64 _arrive_time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal__arrive_time());

    // required uint64 _prop_clock = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__prop_clock());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaClockDataClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaClockDataClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaClockDataClass::GetClassData() const { return &_class_data_; }


void StaClockDataClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaClockDataClass*>(&to_msg);
  auto& from = static_cast<const StaClockDataClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaClockDataClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable__clock_wave_type()->::Common::Types::TransTypeEnum::MergeFrom(
          from._internal__clock_wave_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._arrive_time_ = from._impl_._arrive_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._prop_clock_ = from._impl_._prop_clock_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaClockDataClass::CopyFrom(const StaClockDataClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaClockDataClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaClockDataClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has__clock_wave_type()) {
    if (!_impl_._clock_wave_type_->IsInitialized()) return false;
  }
  return true;
}

void StaClockDataClass::InternalSwap(StaClockDataClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaClockDataClass, _impl_._prop_clock_)
      + sizeof(StaClockDataClass::_impl_._prop_clock_)
      - PROTOBUF_FIELD_OFFSET(StaClockDataClass, _impl_._clock_wave_type_)>(
          reinterpret_cast<char*>(&_impl_._clock_wave_type_),
          reinterpret_cast<char*>(&other->_impl_._clock_wave_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaClockDataClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[7]);
}

// ===================================================================

class StaDataSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<StaDataSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::StaStructure::StaDataClass& parent(const StaDataSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::StaStructure::StaSlewDataClass& ssdc(const StaDataSyn* msg);
  static const ::StaStructure::StaArcDelayDataClass& saddc(const StaDataSyn* msg);
  static const ::StaStructure::StaPathDelayDataClass& spddc(const StaDataSyn* msg);
  static const ::StaStructure::StaClockDataClass& scdc(const StaDataSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::StaStructure::StaDataClass&
StaDataSyn::_Internal::parent(const StaDataSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::StaStructure::StaSlewDataClass&
StaDataSyn::_Internal::ssdc(const StaDataSyn* msg) {
  return *msg->_impl_.sds_.ssdc_;
}
const ::StaStructure::StaArcDelayDataClass&
StaDataSyn::_Internal::saddc(const StaDataSyn* msg) {
  return *msg->_impl_.sds_.saddc_;
}
const ::StaStructure::StaPathDelayDataClass&
StaDataSyn::_Internal::spddc(const StaDataSyn* msg) {
  return *msg->_impl_.sds_.spddc_;
}
const ::StaStructure::StaClockDataClass&
StaDataSyn::_Internal::scdc(const StaDataSyn* msg) {
  return *msg->_impl_.sds_.scdc_;
}
void StaDataSyn::set_allocated_ssdc(::StaStructure::StaSlewDataClass* ssdc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sds();
  if (ssdc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssdc);
    if (message_arena != submessage_arena) {
      ssdc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssdc, submessage_arena);
    }
    set_has_ssdc();
    _impl_.sds_.ssdc_ = ssdc;
  }
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaDataSyn.ssdc)
}
void StaDataSyn::set_allocated_saddc(::StaStructure::StaArcDelayDataClass* saddc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sds();
  if (saddc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saddc);
    if (message_arena != submessage_arena) {
      saddc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saddc, submessage_arena);
    }
    set_has_saddc();
    _impl_.sds_.saddc_ = saddc;
  }
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaDataSyn.saddc)
}
void StaDataSyn::set_allocated_spddc(::StaStructure::StaPathDelayDataClass* spddc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sds();
  if (spddc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spddc);
    if (message_arena != submessage_arena) {
      spddc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spddc, submessage_arena);
    }
    set_has_spddc();
    _impl_.sds_.spddc_ = spddc;
  }
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaDataSyn.spddc)
}
void StaDataSyn::set_allocated_scdc(::StaStructure::StaClockDataClass* scdc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sds();
  if (scdc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scdc);
    if (message_arena != submessage_arena) {
      scdc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scdc, submessage_arena);
    }
    set_has_scdc();
    _impl_.sds_.scdc_ = scdc;
  }
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaDataSyn.scdc)
}
StaDataSyn::StaDataSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaDataSyn)
}
StaDataSyn::StaDataSyn(const StaDataSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaDataSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.sds_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::StaStructure::StaDataClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  clear_has_sds();
  switch (from.sds_case()) {
    case kSsdc: {
      _this->_internal_mutable_ssdc()->::StaStructure::StaSlewDataClass::MergeFrom(
          from._internal_ssdc());
      break;
    }
    case kSaddc: {
      _this->_internal_mutable_saddc()->::StaStructure::StaArcDelayDataClass::MergeFrom(
          from._internal_saddc());
      break;
    }
    case kSpddc: {
      _this->_internal_mutable_spddc()->::StaStructure::StaPathDelayDataClass::MergeFrom(
          from._internal_spddc());
      break;
    }
    case kScdc: {
      _this->_internal_mutable_scdc()->::StaStructure::StaClockDataClass::MergeFrom(
          from._internal_scdc());
      break;
    }
    case SDS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaDataSyn)
}

inline void StaDataSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.sds_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_sds();
}

StaDataSyn::~StaDataSyn() {
  // @@protoc_insertion_point(destructor:StaStructure.StaDataSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaDataSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_sds()) {
    clear_sds();
  }
}

void StaDataSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaDataSyn::clear_sds() {
// @@protoc_insertion_point(one_of_clear_start:StaStructure.StaDataSyn)
  switch (sds_case()) {
    case kSsdc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sds_.ssdc_;
      }
      break;
    }
    case kSaddc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sds_.saddc_;
      }
      break;
    }
    case kSpddc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sds_.spddc_;
      }
      break;
    }
    case kScdc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sds_.scdc_;
      }
      break;
    }
    case SDS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SDS_NOT_SET;
}


void StaDataSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaDataSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  clear_sds();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaDataSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .StaStructure.StaDataClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StaStructure.StaSlewDataClass ssdc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ssdc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StaStructure.StaArcDelayDataClass saddc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_saddc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StaStructure.StaPathDelayDataClass spddc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_spddc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StaStructure.StaClockDataClass scdc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_scdc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaDataSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaDataSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  // required .StaStructure.StaDataClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (sds_case()) {
    case kSsdc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::ssdc(this),
          _Internal::ssdc(this).GetCachedSize(), target, stream);
      break;
    }
    case kSaddc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::saddc(this),
          _Internal::saddc(this).GetCachedSize(), target, stream);
      break;
    }
    case kSpddc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::spddc(this),
          _Internal::spddc(this).GetCachedSize(), target, stream);
      break;
    }
    case kScdc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::scdc(this),
          _Internal::scdc(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaDataSyn)
  return target;
}

size_t StaDataSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaDataSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .StaStructure.StaDataClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_type()) {
    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t StaDataSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaDataSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .StaStructure.StaDataClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (sds_case()) {
    // .StaStructure.StaSlewDataClass ssdc = 4;
    case kSsdc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sds_.ssdc_);
      break;
    }
    // .StaStructure.StaArcDelayDataClass saddc = 5;
    case kSaddc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sds_.saddc_);
      break;
    }
    // .StaStructure.StaPathDelayDataClass spddc = 6;
    case kSpddc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sds_.spddc_);
      break;
    }
    // .StaStructure.StaClockDataClass scdc = 7;
    case kScdc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sds_.scdc_);
      break;
    }
    case SDS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaDataSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaDataSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaDataSyn::GetClassData() const { return &_class_data_; }


void StaDataSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaDataSyn*>(&to_msg);
  auto& from = static_cast<const StaDataSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaDataSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::StaStructure::StaDataClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.sds_case()) {
    case kSsdc: {
      _this->_internal_mutable_ssdc()->::StaStructure::StaSlewDataClass::MergeFrom(
          from._internal_ssdc());
      break;
    }
    case kSaddc: {
      _this->_internal_mutable_saddc()->::StaStructure::StaArcDelayDataClass::MergeFrom(
          from._internal_saddc());
      break;
    }
    case kSpddc: {
      _this->_internal_mutable_spddc()->::StaStructure::StaPathDelayDataClass::MergeFrom(
          from._internal_spddc());
      break;
    }
    case kScdc: {
      _this->_internal_mutable_scdc()->::StaStructure::StaClockDataClass::MergeFrom(
          from._internal_scdc());
      break;
    }
    case SDS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaDataSyn::CopyFrom(const StaDataSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaDataSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaDataSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (sds_case()) {
    case kSsdc: {
      if (_internal_has_ssdc()) {
        if (!_impl_.sds_.ssdc_->IsInitialized()) return false;
      }
      break;
    }
    case kSaddc: {
      if (_internal_has_saddc()) {
        if (!_impl_.sds_.saddc_->IsInitialized()) return false;
      }
      break;
    }
    case kSpddc: {
      if (_internal_has_spddc()) {
        if (!_impl_.sds_.spddc_->IsInitialized()) return false;
      }
      break;
    }
    case kScdc: {
      if (_internal_has_scdc()) {
        if (!_impl_.sds_.scdc_->IsInitialized()) return false;
      }
      break;
    }
    case SDS_NOT_SET: {
      break;
    }
  }
  return true;
}

void StaDataSyn::InternalSwap(StaDataSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaDataSyn, _impl_.type_)
      + sizeof(StaDataSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(StaDataSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.sds_, other->_impl_.sds_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaDataSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[8]);
}

// ===================================================================

class StaDataBucketClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaDataBucketClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__n_worst(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__next(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

StaDataBucketClass::StaDataBucketClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaDataBucketClass)
}
StaDataBucketClass::StaDataBucketClass(const StaDataBucketClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaDataBucketClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._data_list_){from._impl_._data_list_}
    , decltype(_impl_.id_){}
    , decltype(_impl_._n_worst_){}
    , decltype(_impl_._count_){}
    , decltype(_impl_._next_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._next_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._next_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaDataBucketClass)
}

inline void StaDataBucketClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._data_list_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._n_worst_){0u}
    , decltype(_impl_._count_){0u}
    , decltype(_impl_._next_){uint64_t{0u}}
  };
}

StaDataBucketClass::~StaDataBucketClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaDataBucketClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaDataBucketClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._data_list_.~RepeatedField();
}

void StaDataBucketClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaDataBucketClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaDataBucketClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._data_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._next_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._next_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaDataBucketClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _data_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__data_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__data_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _n_worst = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__n_worst(&has_bits);
          _impl_._n_worst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 _count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__count(&has_bits);
          _impl_._count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _next = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__next(&has_bits);
          _impl_._next_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaDataBucketClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaDataBucketClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // repeated uint64 _data_list = 2;
  for (int i = 0, n = this->_internal__data_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__data_list(i), target);
  }

  // required uint32 _n_worst = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal__n_worst(), target);
  }

  // required uint32 _count = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal__count(), target);
  }

  // required uint64 _next = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__next(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaDataBucketClass)
  return target;
}

size_t StaDataBucketClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaDataBucketClass)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has__n_worst()) {
    // required uint32 _n_worst = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__n_worst());
  }

  if (_internal_has__count()) {
    // required uint32 _count = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__count());
  }

  if (_internal_has__next()) {
    // required uint64 _next = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__next());
  }

  return total_size;
}
size_t StaDataBucketClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaDataBucketClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 _n_worst = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__n_worst());

    // required uint32 _count = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__count());

    // required uint64 _next = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__next());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _data_list = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._data_list_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__data_list_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaDataBucketClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaDataBucketClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaDataBucketClass::GetClassData() const { return &_class_data_; }


void StaDataBucketClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaDataBucketClass*>(&to_msg);
  auto& from = static_cast<const StaDataBucketClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaDataBucketClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._data_list_.MergeFrom(from._impl_._data_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._n_worst_ = from._impl_._n_worst_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._count_ = from._impl_._count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._next_ = from._impl_._next_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaDataBucketClass::CopyFrom(const StaDataBucketClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaDataBucketClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaDataBucketClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaDataBucketClass::InternalSwap(StaDataBucketClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._data_list_.InternalSwap(&other->_impl_._data_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaDataBucketClass, _impl_._next_)
      + sizeof(StaDataBucketClass::_impl_._next_)
      - PROTOBUF_FIELD_OFFSET(StaDataBucketClass, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaDataBucketClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[9]);
}

// ===================================================================

class StaArcClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaArcClass>()._impl_._has_bits_);
  static void set_has__src(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__snk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has__arc_delay_bucket(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__is_loop_disable(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

StaArcClass::StaArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaArcClass)
}
StaArcClass::StaArcClass(const StaArcClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaArcClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_){}
    , decltype(_impl_._snk_){}
    , decltype(_impl_._arc_delay_bucket_){}
    , decltype(_impl_._is_loop_disable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._src_, &from._impl_._src_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._is_loop_disable_) -
    reinterpret_cast<char*>(&_impl_._src_)) + sizeof(_impl_._is_loop_disable_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaArcClass)
}

inline void StaArcClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_){uint64_t{0u}}
    , decltype(_impl_._snk_){uint64_t{0u}}
    , decltype(_impl_._arc_delay_bucket_){uint64_t{0u}}
    , decltype(_impl_._is_loop_disable_){false}
  };
}

StaArcClass::~StaArcClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaArcClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaArcClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaArcClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaArcClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaArcClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_._src_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._is_loop_disable_) -
        reinterpret_cast<char*>(&_impl_._src_)) + sizeof(_impl_._is_loop_disable_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaArcClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 _src = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__src(&has_bits);
          _impl_._src_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _snk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__snk(&has_bits);
          _impl_._snk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _arc_delay_bucket = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has__arc_delay_bucket(&has_bits);
          _impl_._arc_delay_bucket_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool _is_loop_disable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has__is_loop_disable(&has_bits);
          _impl_._is_loop_disable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaArcClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaArcClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 _src = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__src(), target);
  }

  // required uint64 _snk = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__snk(), target);
  }

  // optional uint64 _arc_delay_bucket = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__arc_delay_bucket(), target);
  }

  // required bool _is_loop_disable = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal__is_loop_disable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaArcClass)
  return target;
}

size_t StaArcClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaArcClass)
  size_t total_size = 0;

  if (_internal_has__src()) {
    // required uint64 _src = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__src());
  }

  if (_internal_has__snk()) {
    // required uint64 _snk = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__snk());
  }

  if (_internal_has__is_loop_disable()) {
    // required bool _is_loop_disable = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t StaArcClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaArcClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required uint64 _src = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__src());

    // required uint64 _snk = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__snk());

    // required bool _is_loop_disable = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 _arc_delay_bucket = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__arc_delay_bucket());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaArcClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaArcClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaArcClass::GetClassData() const { return &_class_data_; }


void StaArcClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaArcClass*>(&to_msg);
  auto& from = static_cast<const StaArcClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaArcClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._src_ = from._impl_._src_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._snk_ = from._impl_._snk_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._arc_delay_bucket_ = from._impl_._arc_delay_bucket_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._is_loop_disable_ = from._impl_._is_loop_disable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaArcClass::CopyFrom(const StaArcClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaArcClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaArcClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaArcClass::InternalSwap(StaArcClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaArcClass, _impl_._is_loop_disable_)
      + sizeof(StaArcClass::_impl_._is_loop_disable_)
      - PROTOBUF_FIELD_OFFSET(StaArcClass, _impl_._src_)>(
          reinterpret_cast<char*>(&_impl_._src_),
          reinterpret_cast<char*>(&other->_impl_._src_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaArcClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[10]);
}

// ===================================================================

class StaNetArcClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaNetArcClass>()._impl_._has_bits_);
  static void set_has__net(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

StaNetArcClass::StaNetArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaNetArcClass)
}
StaNetArcClass::StaNetArcClass(const StaNetArcClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaNetArcClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._net_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_._net_ = from._impl_._net_;
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaNetArcClass)
}

inline void StaNetArcClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._net_){uint64_t{0u}}
  };
}

StaNetArcClass::~StaNetArcClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaNetArcClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaNetArcClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaNetArcClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaNetArcClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaNetArcClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._net_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaNetArcClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 _net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__net(&has_bits);
          _impl_._net_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaNetArcClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaNetArcClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 _net = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__net(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaNetArcClass)
  return target;
}

size_t StaNetArcClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaNetArcClass)
  size_t total_size = 0;

  // required uint64 _net = 1;
  if (_internal_has__net()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__net());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaNetArcClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaNetArcClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaNetArcClass::GetClassData() const { return &_class_data_; }


void StaNetArcClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaNetArcClass*>(&to_msg);
  auto& from = static_cast<const StaNetArcClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaNetArcClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has__net()) {
    _this->_internal_set__net(from._internal__net());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaNetArcClass::CopyFrom(const StaNetArcClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaNetArcClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaNetArcClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaNetArcClass::InternalSwap(StaNetArcClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._net_, other->_impl_._net_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaNetArcClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[11]);
}

// ===================================================================

class StaInstArcClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaInstArcClass>()._impl_._has_bits_);
  static void set_has__arc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__inst(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

StaInstArcClass::StaInstArcClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaInstArcClass)
}
StaInstArcClass::StaInstArcClass(const StaInstArcClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaInstArcClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._arc_){}
    , decltype(_impl_._inst_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_._arc_, &from._impl_._arc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._inst_) -
    reinterpret_cast<char*>(&_impl_._arc_)) + sizeof(_impl_._inst_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaInstArcClass)
}

inline void StaInstArcClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._arc_){uint64_t{0u}}
    , decltype(_impl_._inst_){uint64_t{0u}}
  };
}

StaInstArcClass::~StaInstArcClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaInstArcClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaInstArcClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StaInstArcClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaInstArcClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaInstArcClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_._arc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._inst_) -
        reinterpret_cast<char*>(&_impl_._arc_)) + sizeof(_impl_._inst_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaInstArcClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 _arc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has__arc(&has_bits);
          _impl_._arc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _inst = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__inst(&has_bits);
          _impl_._inst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaInstArcClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaInstArcClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 _arc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal__arc(), target);
  }

  // required uint64 _inst = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__inst(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaInstArcClass)
  return target;
}

size_t StaInstArcClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaInstArcClass)
  size_t total_size = 0;

  if (_internal_has__arc()) {
    // required uint64 _arc = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__arc());
  }

  if (_internal_has__inst()) {
    // required uint64 _inst = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__inst());
  }

  return total_size;
}
size_t StaInstArcClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaInstArcClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 _arc = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__arc());

    // required uint64 _inst = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__inst());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaInstArcClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaInstArcClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaInstArcClass::GetClassData() const { return &_class_data_; }


void StaInstArcClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaInstArcClass*>(&to_msg);
  auto& from = static_cast<const StaInstArcClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaInstArcClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_._arc_ = from._impl_._arc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._inst_ = from._impl_._inst_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaInstArcClass::CopyFrom(const StaInstArcClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaInstArcClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaInstArcClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaInstArcClass::InternalSwap(StaInstArcClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaInstArcClass, _impl_._inst_)
      + sizeof(StaInstArcClass::_impl_._inst_)
      - PROTOBUF_FIELD_OFFSET(StaInstArcClass, _impl_._arc_)>(
          reinterpret_cast<char*>(&_impl_._arc_),
          reinterpret_cast<char*>(&other->_impl_._arc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaInstArcClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[12]);
}

// ===================================================================

class StaArcSyn::_Internal {
 public:
  using HasBits = decltype(std::declval<StaArcSyn>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::StaStructure::StaArcClass& parent(const StaArcSyn* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::StaStructure::StaNetArcClass& snac(const StaArcSyn* msg);
  static const ::StaStructure::StaInstArcClass& siac(const StaArcSyn* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::StaStructure::StaArcClass&
StaArcSyn::_Internal::parent(const StaArcSyn* msg) {
  return *msg->_impl_.parent_;
}
const ::StaStructure::StaNetArcClass&
StaArcSyn::_Internal::snac(const StaArcSyn* msg) {
  return *msg->_impl_.sas_.snac_;
}
const ::StaStructure::StaInstArcClass&
StaArcSyn::_Internal::siac(const StaArcSyn* msg) {
  return *msg->_impl_.sas_.siac_;
}
void StaArcSyn::set_allocated_snac(::StaStructure::StaNetArcClass* snac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sas();
  if (snac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snac);
    if (message_arena != submessage_arena) {
      snac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snac, submessage_arena);
    }
    set_has_snac();
    _impl_.sas_.snac_ = snac;
  }
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaArcSyn.snac)
}
void StaArcSyn::set_allocated_siac(::StaStructure::StaInstArcClass* siac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sas();
  if (siac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(siac);
    if (message_arena != submessage_arena) {
      siac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, siac, submessage_arena);
    }
    set_has_siac();
    _impl_.sas_.siac_ = siac;
  }
  // @@protoc_insertion_point(field_set_allocated:StaStructure.StaArcSyn.siac)
}
StaArcSyn::StaArcSyn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaArcSyn)
}
StaArcSyn::StaArcSyn(const StaArcSyn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaArcSyn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.sas_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::StaStructure::StaArcClass(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  clear_has_sas();
  switch (from.sas_case()) {
    case kSnac: {
      _this->_internal_mutable_snac()->::StaStructure::StaNetArcClass::MergeFrom(
          from._internal_snac());
      break;
    }
    case kSiac: {
      _this->_internal_mutable_siac()->::StaStructure::StaInstArcClass::MergeFrom(
          from._internal_siac());
      break;
    }
    case SAS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaArcSyn)
}

inline void StaArcSyn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.sas_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_sas();
}

StaArcSyn::~StaArcSyn() {
  // @@protoc_insertion_point(destructor:StaStructure.StaArcSyn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaArcSyn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (has_sas()) {
    clear_sas();
  }
}

void StaArcSyn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaArcSyn::clear_sas() {
// @@protoc_insertion_point(one_of_clear_start:StaStructure.StaArcSyn)
  switch (sas_case()) {
    case kSnac: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sas_.snac_;
      }
      break;
    }
    case kSiac: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sas_.siac_;
      }
      break;
    }
    case SAS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SAS_NOT_SET;
}


void StaArcSyn::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaArcSyn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.parent_ != nullptr);
    _impl_.parent_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  clear_sas();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaArcSyn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .StaStructure.StaArcClass parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StaStructure.StaNetArcClass snac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_snac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .StaStructure.StaInstArcClass siac = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_siac(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaArcSyn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaArcSyn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint32 type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  // required .StaStructure.StaArcClass parent = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  switch (sas_case()) {
    case kSnac: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::snac(this),
          _Internal::snac(this).GetCachedSize(), target, stream);
      break;
    }
    case kSiac: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::siac(this),
          _Internal::siac(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaArcSyn)
  return target;
}

size_t StaArcSyn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaArcSyn)
  size_t total_size = 0;

  if (_internal_has_parent()) {
    // required .StaStructure.StaArcClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_type()) {
    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return total_size;
}
size_t StaArcSyn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaArcSyn)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .StaStructure.StaArcClass parent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);

    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint32 type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (sas_case()) {
    // .StaStructure.StaNetArcClass snac = 4;
    case kSnac: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sas_.snac_);
      break;
    }
    // .StaStructure.StaInstArcClass siac = 5;
    case kSiac: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sas_.siac_);
      break;
    }
    case SAS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaArcSyn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaArcSyn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaArcSyn::GetClassData() const { return &_class_data_; }


void StaArcSyn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaArcSyn*>(&to_msg);
  auto& from = static_cast<const StaArcSyn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaArcSyn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_parent()->::StaStructure::StaArcClass::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.sas_case()) {
    case kSnac: {
      _this->_internal_mutable_snac()->::StaStructure::StaNetArcClass::MergeFrom(
          from._internal_snac());
      break;
    }
    case kSiac: {
      _this->_internal_mutable_siac()->::StaStructure::StaInstArcClass::MergeFrom(
          from._internal_siac());
      break;
    }
    case SAS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaArcSyn::CopyFrom(const StaArcSyn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaArcSyn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaArcSyn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  switch (sas_case()) {
    case kSnac: {
      if (_internal_has_snac()) {
        if (!_impl_.sas_.snac_->IsInitialized()) return false;
      }
      break;
    }
    case kSiac: {
      if (_internal_has_siac()) {
        if (!_impl_.sas_.siac_->IsInitialized()) return false;
      }
      break;
    }
    case SAS_NOT_SET: {
      break;
    }
  }
  return true;
}

void StaArcSyn::InternalSwap(StaArcSyn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaArcSyn, _impl_.type_)
      + sizeof(StaArcSyn::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(StaArcSyn, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.sas_, other->_impl_.sas_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaArcSyn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[13]);
}

// ===================================================================

class StaVertexClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaVertexClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__obj(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_control_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has__slew_bucket(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__clock_bucket(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has__path_delay_bucket(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has__max_fanout(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_type_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001b) ^ 0x0000001b) != 0;
  }
};

void StaVertexClass::clear__max_cap() {
  _impl_._max_cap_.Clear();
}
void StaVertexClass::clear__max_slew() {
  _impl_._max_slew_.Clear();
}
StaVertexClass::StaVertexClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaVertexClass)
}
StaVertexClass::StaVertexClass(const StaVertexClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaVertexClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_arcs_){from._impl_._src_arcs_}
    , decltype(_impl_._snk_arcs_){from._impl_._snk_arcs_}
    , decltype(_impl_._max_cap_){from._impl_._max_cap_}
    , decltype(_impl_._max_slew_){from._impl_._max_slew_}
    , decltype(_impl_.id_){}
    , decltype(_impl_._obj_){}
    , decltype(_impl_._slew_bucket_){}
    , decltype(_impl_.control_bits_){}
    , decltype(_impl_.type_bits_){}
    , decltype(_impl_._clock_bucket_){}
    , decltype(_impl_._path_delay_bucket_){}
    , decltype(_impl_._max_fanout_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._max_fanout_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._max_fanout_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaVertexClass)
}

inline void StaVertexClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._src_arcs_){arena}
    , decltype(_impl_._snk_arcs_){arena}
    , decltype(_impl_._max_cap_){arena}
    , decltype(_impl_._max_slew_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._obj_){uint64_t{0u}}
    , decltype(_impl_._slew_bucket_){uint64_t{0u}}
    , decltype(_impl_.control_bits_){0u}
    , decltype(_impl_.type_bits_){0u}
    , decltype(_impl_._clock_bucket_){uint64_t{0u}}
    , decltype(_impl_._path_delay_bucket_){uint64_t{0u}}
    , decltype(_impl_._max_fanout_){0}
  };
}

StaVertexClass::~StaVertexClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaVertexClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaVertexClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._src_arcs_.~RepeatedField();
  _impl_._snk_arcs_.~RepeatedField();
  _impl_._max_cap_.~RepeatedPtrField();
  _impl_._max_slew_.~RepeatedPtrField();
}

void StaVertexClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaVertexClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaVertexClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._src_arcs_.Clear();
  _impl_._snk_arcs_.Clear();
  _impl_._max_cap_.Clear();
  _impl_._max_slew_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._max_fanout_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._max_fanout_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaVertexClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _obj = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__obj(&has_bits);
          _impl_._obj_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 control_bits = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_control_bits(&has_bits);
          _impl_.control_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _src_arcs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__src_arcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__src_arcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _snk_arcs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__snk_arcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__snk_arcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _slew_bucket = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has__slew_bucket(&has_bits);
          _impl_._slew_bucket_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _clock_bucket = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has__clock_bucket(&has_bits);
          _impl_._clock_bucket_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 _path_delay_bucket = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has__path_delay_bucket(&has_bits);
          _impl_._path_delay_bucket_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.OptionalDouble _max_cap = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__max_cap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.OptionalDouble _max_slew = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add__max_slew(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double _max_fanout = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has__max_fanout(&has_bits);
          _impl_._max_fanout_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 type_bits = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_type_bits(&has_bits);
          _impl_.type_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaVertexClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaVertexClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint64 _obj = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__obj(), target);
  }

  // required uint32 control_bits = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_control_bits(), target);
  }

  // repeated uint64 _src_arcs = 7;
  for (int i = 0, n = this->_internal__src_arcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal__src_arcs(i), target);
  }

  // repeated uint64 _snk_arcs = 8;
  for (int i = 0, n = this->_internal__snk_arcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal__snk_arcs(i), target);
  }

  // optional uint64 _slew_bucket = 9;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal__slew_bucket(), target);
  }

  // optional uint64 _clock_bucket = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal__clock_bucket(), target);
  }

  // optional uint64 _path_delay_bucket = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal__path_delay_bucket(), target);
  }

  // repeated .Common.Types.OptionalDouble _max_cap = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__max_cap_size()); i < n; i++) {
    const auto& repfield = this->_internal__max_cap(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Common.Types.OptionalDouble _max_slew = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal__max_slew_size()); i < n; i++) {
    const auto& repfield = this->_internal__max_slew(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double _max_fanout = 14;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal__max_fanout(), target);
  }

  // required uint32 type_bits = 15;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_type_bits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaVertexClass)
  return target;
}

size_t StaVertexClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaVertexClass)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has__obj()) {
    // required uint64 _obj = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__obj());
  }

  if (_internal_has_control_bits()) {
    // required uint32 control_bits = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_control_bits());
  }

  if (_internal_has_type_bits()) {
    // required uint32 type_bits = 15;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type_bits());
  }

  return total_size;
}
size_t StaVertexClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaVertexClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001b) ^ 0x0000001b) == 0) {  // All required fields are present.
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint64 _obj = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__obj());

    // required uint32 control_bits = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_control_bits());

    // required uint32 type_bits = 15;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type_bits());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _src_arcs = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._src_arcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__src_arcs_size());
    total_size += data_size;
  }

  // repeated uint64 _snk_arcs = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._snk_arcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__snk_arcs_size());
    total_size += data_size;
  }

  // repeated .Common.Types.OptionalDouble _max_cap = 12;
  total_size += 1UL * this->_internal__max_cap_size();
  for (const auto& msg : this->_impl_._max_cap_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Common.Types.OptionalDouble _max_slew = 13;
  total_size += 1UL * this->_internal__max_slew_size();
  for (const auto& msg : this->_impl_._max_slew_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 _slew_bucket = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__slew_bucket());
  }

  if (cached_has_bits & 0x000000e0u) {
    // optional uint64 _clock_bucket = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__clock_bucket());
    }

    // optional uint64 _path_delay_bucket = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__path_delay_bucket());
    }

    // optional double _max_fanout = 14;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaVertexClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaVertexClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaVertexClass::GetClassData() const { return &_class_data_; }


void StaVertexClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaVertexClass*>(&to_msg);
  auto& from = static_cast<const StaVertexClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaVertexClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._src_arcs_.MergeFrom(from._impl_._src_arcs_);
  _this->_impl_._snk_arcs_.MergeFrom(from._impl_._snk_arcs_);
  _this->_impl_._max_cap_.MergeFrom(from._impl_._max_cap_);
  _this->_impl_._max_slew_.MergeFrom(from._impl_._max_slew_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._obj_ = from._impl_._obj_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_._slew_bucket_ = from._impl_._slew_bucket_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.control_bits_ = from._impl_.control_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_bits_ = from._impl_.type_bits_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_._clock_bucket_ = from._impl_._clock_bucket_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_._path_delay_bucket_ = from._impl_._path_delay_bucket_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_._max_fanout_ = from._impl_._max_fanout_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaVertexClass::CopyFrom(const StaVertexClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaVertexClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaVertexClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void StaVertexClass::InternalSwap(StaVertexClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._src_arcs_.InternalSwap(&other->_impl_._src_arcs_);
  _impl_._snk_arcs_.InternalSwap(&other->_impl_._snk_arcs_);
  _impl_._max_cap_.InternalSwap(&other->_impl_._max_cap_);
  _impl_._max_slew_.InternalSwap(&other->_impl_._max_slew_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaVertexClass, _impl_._max_fanout_)
      + sizeof(StaVertexClass::_impl_._max_fanout_)
      - PROTOBUF_FIELD_OFFSET(StaVertexClass, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaVertexClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[14]);
}

// ===================================================================

class StaGraphClass::_Internal {
 public:
  using HasBits = decltype(std::declval<StaGraphClass>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__nl(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

void StaGraphClass::clear_obj_vertex_pair() {
  _impl_.obj_vertex_pair_.Clear();
}
void StaGraphClass::clear_main_assistant_pair() {
  _impl_.main_assistant_pair_.Clear();
}
StaGraphClass::StaGraphClass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StaStructure.StaGraphClass)
}
StaGraphClass::StaGraphClass(const StaGraphClass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaGraphClass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_vertexes_){from._impl_._port_vertexes_}
    , decltype(_impl_._start_vertexes_){from._impl_._start_vertexes_}
    , decltype(_impl_._end_vertexes_){from._impl_._end_vertexes_}
    , decltype(_impl_._vertexes_){from._impl_._vertexes_}
    , decltype(_impl_._arcs_){from._impl_._arcs_}
    , decltype(_impl_.obj_vertex_pair_){from._impl_.obj_vertex_pair_}
    , decltype(_impl_.main_assistant_pair_){from._impl_.main_assistant_pair_}
    , decltype(_impl_.id_){}
    , decltype(_impl_._nl_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_._nl_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._nl_));
  // @@protoc_insertion_point(copy_constructor:StaStructure.StaGraphClass)
}

inline void StaGraphClass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_._port_vertexes_){arena}
    , decltype(_impl_._start_vertexes_){arena}
    , decltype(_impl_._end_vertexes_){arena}
    , decltype(_impl_._vertexes_){arena}
    , decltype(_impl_._arcs_){arena}
    , decltype(_impl_.obj_vertex_pair_){arena}
    , decltype(_impl_.main_assistant_pair_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_._nl_){uint64_t{0u}}
  };
}

StaGraphClass::~StaGraphClass() {
  // @@protoc_insertion_point(destructor:StaStructure.StaGraphClass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaGraphClass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._port_vertexes_.~RepeatedField();
  _impl_._start_vertexes_.~RepeatedField();
  _impl_._end_vertexes_.~RepeatedField();
  _impl_._vertexes_.~RepeatedField();
  _impl_._arcs_.~RepeatedField();
  _impl_.obj_vertex_pair_.~RepeatedPtrField();
  _impl_.main_assistant_pair_.~RepeatedPtrField();
}

void StaGraphClass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaGraphClass::Clear() {
// @@protoc_insertion_point(message_clear_start:StaStructure.StaGraphClass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._port_vertexes_.Clear();
  _impl_._start_vertexes_.Clear();
  _impl_._end_vertexes_.Clear();
  _impl_._vertexes_.Clear();
  _impl_._arcs_.Clear();
  _impl_.obj_vertex_pair_.Clear();
  _impl_.main_assistant_pair_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_._nl_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_._nl_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaGraphClass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 _nl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__nl(&has_bits);
          _impl_._nl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _port_vertexes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__port_vertexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__port_vertexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _start_vertexes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__start_vertexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__start_vertexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _end_vertexes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__end_vertexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__end_vertexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _vertexes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__vertexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__vertexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 _arcs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add__arcs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable__arcs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.ULongPair obj_vertex_pair = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_obj_vertex_pair(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Common.Types.ULongPair main_assistant_pair = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_main_assistant_pair(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaGraphClass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StaStructure.StaGraphClass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // required uint64 _nl = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal__nl(), target);
  }

  // repeated uint64 _port_vertexes = 3;
  for (int i = 0, n = this->_internal__port_vertexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal__port_vertexes(i), target);
  }

  // repeated uint64 _start_vertexes = 4;
  for (int i = 0, n = this->_internal__start_vertexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal__start_vertexes(i), target);
  }

  // repeated uint64 _end_vertexes = 5;
  for (int i = 0, n = this->_internal__end_vertexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal__end_vertexes(i), target);
  }

  // repeated uint64 _vertexes = 6;
  for (int i = 0, n = this->_internal__vertexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal__vertexes(i), target);
  }

  // repeated uint64 _arcs = 7;
  for (int i = 0, n = this->_internal__arcs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal__arcs(i), target);
  }

  // repeated .Common.Types.ULongPair obj_vertex_pair = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_obj_vertex_pair_size()); i < n; i++) {
    const auto& repfield = this->_internal_obj_vertex_pair(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Common.Types.ULongPair main_assistant_pair = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_main_assistant_pair_size()); i < n; i++) {
    const auto& repfield = this->_internal_main_assistant_pair(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StaStructure.StaGraphClass)
  return target;
}

size_t StaGraphClass::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StaStructure.StaGraphClass)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  if (_internal_has__nl()) {
    // required uint64 _nl = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__nl());
  }

  return total_size;
}
size_t StaGraphClass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StaStructure.StaGraphClass)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 id = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());

    // required uint64 _nl = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal__nl());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 _port_vertexes = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._port_vertexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__port_vertexes_size());
    total_size += data_size;
  }

  // repeated uint64 _start_vertexes = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._start_vertexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__start_vertexes_size());
    total_size += data_size;
  }

  // repeated uint64 _end_vertexes = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._end_vertexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__end_vertexes_size());
    total_size += data_size;
  }

  // repeated uint64 _vertexes = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._vertexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__vertexes_size());
    total_size += data_size;
  }

  // repeated uint64 _arcs = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_._arcs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal__arcs_size());
    total_size += data_size;
  }

  // repeated .Common.Types.ULongPair obj_vertex_pair = 8;
  total_size += 1UL * this->_internal_obj_vertex_pair_size();
  for (const auto& msg : this->_impl_.obj_vertex_pair_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Common.Types.ULongPair main_assistant_pair = 9;
  total_size += 1UL * this->_internal_main_assistant_pair_size();
  for (const auto& msg : this->_impl_.main_assistant_pair_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaGraphClass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaGraphClass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaGraphClass::GetClassData() const { return &_class_data_; }


void StaGraphClass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaGraphClass*>(&to_msg);
  auto& from = static_cast<const StaGraphClass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StaStructure.StaGraphClass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._port_vertexes_.MergeFrom(from._impl_._port_vertexes_);
  _this->_impl_._start_vertexes_.MergeFrom(from._impl_._start_vertexes_);
  _this->_impl_._end_vertexes_.MergeFrom(from._impl_._end_vertexes_);
  _this->_impl_._vertexes_.MergeFrom(from._impl_._vertexes_);
  _this->_impl_._arcs_.MergeFrom(from._impl_._arcs_);
  _this->_impl_.obj_vertex_pair_.MergeFrom(from._impl_.obj_vertex_pair_);
  _this->_impl_.main_assistant_pair_.MergeFrom(from._impl_.main_assistant_pair_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._nl_ = from._impl_._nl_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaGraphClass::CopyFrom(const StaGraphClass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StaStructure.StaGraphClass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaGraphClass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.obj_vertex_pair_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.main_assistant_pair_))
    return false;
  return true;
}

void StaGraphClass::InternalSwap(StaGraphClass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_._port_vertexes_.InternalSwap(&other->_impl_._port_vertexes_);
  _impl_._start_vertexes_.InternalSwap(&other->_impl_._start_vertexes_);
  _impl_._end_vertexes_.InternalSwap(&other->_impl_._end_vertexes_);
  _impl_._vertexes_.InternalSwap(&other->_impl_._vertexes_);
  _impl_._arcs_.InternalSwap(&other->_impl_._arcs_);
  _impl_.obj_vertex_pair_.InternalSwap(&other->_impl_.obj_vertex_pair_);
  _impl_.main_assistant_pair_.InternalSwap(&other->_impl_.main_assistant_pair_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaGraphClass, _impl_._nl_)
      + sizeof(StaGraphClass::_impl_._nl_)
      - PROTOBUF_FIELD_OFFSET(StaGraphClass, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaGraphClass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_StaStructure_2eproto_getter, &descriptor_table_StaStructure_2eproto_once,
      file_level_metadata_StaStructure_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace StaStructure
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::StaStructure::ClockTypeEnum*
Arena::CreateMaybeMessage< ::StaStructure::ClockTypeEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::ClockTypeEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaWaveFormClass*
Arena::CreateMaybeMessage< ::StaStructure::StaWaveFormClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaWaveFormClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaClockClass*
Arena::CreateMaybeMessage< ::StaStructure::StaClockClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaClockClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaDataClass*
Arena::CreateMaybeMessage< ::StaStructure::StaDataClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaDataClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaSlewDataClass*
Arena::CreateMaybeMessage< ::StaStructure::StaSlewDataClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaSlewDataClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaArcDelayDataClass*
Arena::CreateMaybeMessage< ::StaStructure::StaArcDelayDataClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaArcDelayDataClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaPathDelayDataClass*
Arena::CreateMaybeMessage< ::StaStructure::StaPathDelayDataClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaPathDelayDataClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaClockDataClass*
Arena::CreateMaybeMessage< ::StaStructure::StaClockDataClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaClockDataClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaDataSyn*
Arena::CreateMaybeMessage< ::StaStructure::StaDataSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaDataSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaDataBucketClass*
Arena::CreateMaybeMessage< ::StaStructure::StaDataBucketClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaDataBucketClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaArcClass*
Arena::CreateMaybeMessage< ::StaStructure::StaArcClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaArcClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaNetArcClass*
Arena::CreateMaybeMessage< ::StaStructure::StaNetArcClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaNetArcClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaInstArcClass*
Arena::CreateMaybeMessage< ::StaStructure::StaInstArcClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaInstArcClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaArcSyn*
Arena::CreateMaybeMessage< ::StaStructure::StaArcSyn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaArcSyn >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaVertexClass*
Arena::CreateMaybeMessage< ::StaStructure::StaVertexClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaVertexClass >(arena);
}
template<> PROTOBUF_NOINLINE ::StaStructure::StaGraphClass*
Arena::CreateMaybeMessage< ::StaStructure::StaGraphClass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StaStructure::StaGraphClass >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
